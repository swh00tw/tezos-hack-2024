"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@taquito";
exports.ids = ["vendor-chunks/@taquito"];
exports.modules = {

/***/ "(ssr)/./node_modules/@taquito/beacon-wallet/dist/taquito-beacon-wallet.es6.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@taquito/beacon-wallet/dist/taquito-beacon-wallet.es6.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BeaconWallet: () => (/* binding */ BeaconWallet),\n/* harmony export */   BeaconWalletNotInitialized: () => (/* binding */ BeaconWalletNotInitialized),\n/* harmony export */   MissingRequiredScopes: () => (/* binding */ MissingRequiredScopes),\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\n/* harmony import */ var _airgap_beacon_dapp__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @airgap/beacon-dapp */ \"(ssr)/./node_modules/@airgap/beacon-dapp/dist/esm/index.js\");\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n/* harmony import */ var typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! typedarray-to-buffer */ \"(ssr)/./node_modules/typedarray-to-buffer/index.js\");\n/* harmony import */ var typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _taquito_taquito__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @taquito/taquito */ \"(ssr)/./node_modules/@taquito/taquito/dist/taquito.es6.js\");\n/* harmony import */ var _taquito_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @taquito/utils */ \"(ssr)/./node_modules/@taquito/utils/dist/taquito-utils.es6.js\");\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n *  @category Error\n *  @description Error that indicates the Beacon wallet not being initialized\n */ class BeaconWalletNotInitialized extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.PermissionDeniedError {\n    constructor(){\n        super();\n        this.name = \"BeaconWalletNotInitialized\";\n        this.message = 'BeaconWallet needs to be initialized by calling `await BeaconWallet.requestPermissions({network: {type: \"chosen_network\"}})` first.';\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates missing required persmission scopes\n */ class MissingRequiredScopes extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.PermissionDeniedError {\n    constructor(requiredScopes){\n        super();\n        this.requiredScopes = requiredScopes;\n        this.name = \"MissingRequiredScopes\";\n        this.message = `Required permissions scopes: ${requiredScopes.join(\",\")} were not granted.`;\n    }\n}\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\n/**\n * @packageDocumentation\n * @module @taquito/beacon-wallet\n */ class BeaconWallet {\n    constructor(options){\n        this.client = (0,_airgap_beacon_dapp__WEBPACK_IMPORTED_MODULE_0__.getDAppClientInstance)(options);\n    }\n    validateRequiredScopesOrFail(permissionScopes, requiredScopes) {\n        const mandatoryScope = new Set(requiredScopes);\n        for (const scope of permissionScopes){\n            if (mandatoryScope.has(scope)) {\n                mandatoryScope.delete(scope);\n            }\n        }\n        if (mandatoryScope.size > 0) {\n            throw new MissingRequiredScopes(Array.from(mandatoryScope));\n        }\n    }\n    requestPermissions(request) {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.requestPermissions(request);\n        });\n    }\n    getPKH() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const account = yield this.client.getActiveAccount();\n            if (!account) {\n                throw new BeaconWalletNotInitialized();\n            }\n            return account.address;\n        });\n    }\n    getPK() {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const account = yield this.client.getActiveAccount();\n            if (!account) {\n                throw new BeaconWalletNotInitialized();\n            }\n            return (_a = account.publicKey) !== null && _a !== void 0 ? _a : \"\";\n        });\n    }\n    mapTransferParamsToWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let walletParams;\n            yield this.client.showPrepare();\n            try {\n                walletParams = yield params();\n            } catch (err) {\n                yield this.client.hideUI([\n                    \"alert\"\n                ]);\n                throw err;\n            }\n            return this.removeDefaultParams(walletParams, (yield (0,_taquito_taquito__WEBPACK_IMPORTED_MODULE_3__.createTransferOperation)(this.formatParameters(walletParams))));\n        });\n    }\n    mapIncreasePaidStorageWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let walletParams;\n            yield this.client.showPrepare();\n            try {\n                walletParams = yield params();\n            } catch (err) {\n                yield this.client.hideUI([\n                    \"alert\"\n                ]);\n                throw err;\n            }\n            return this.removeDefaultParams(walletParams, (yield (0,_taquito_taquito__WEBPACK_IMPORTED_MODULE_3__.createIncreasePaidStorageOperation)(this.formatParameters(walletParams))));\n        });\n    }\n    mapOriginateParamsToWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let walletParams;\n            yield this.client.showPrepare();\n            try {\n                walletParams = yield params();\n            } catch (err) {\n                yield this.client.hideUI([\n                    \"alert\"\n                ]);\n                throw err;\n            }\n            return this.removeDefaultParams(walletParams, (yield (0,_taquito_taquito__WEBPACK_IMPORTED_MODULE_3__.createOriginationOperation)(this.formatParameters(walletParams))));\n        });\n    }\n    mapDelegateParamsToWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let walletParams;\n            yield this.client.showPrepare();\n            try {\n                walletParams = yield params();\n            } catch (err) {\n                yield this.client.hideUI([\n                    \"alert\"\n                ]);\n                throw err;\n            }\n            return this.removeDefaultParams(walletParams, (yield (0,_taquito_taquito__WEBPACK_IMPORTED_MODULE_3__.createSetDelegateOperation)(this.formatParameters(walletParams))));\n        });\n    }\n    formatParameters(params) {\n        if (params.fee) {\n            params.fee = params.fee.toString();\n        }\n        if (params.storageLimit) {\n            params.storageLimit = params.storageLimit.toString();\n        }\n        if (params.gasLimit) {\n            params.gasLimit = params.gasLimit.toString();\n        }\n        return params;\n    }\n    removeDefaultParams(params, operatedParams) {\n        // If fee, storageLimit or gasLimit is undefined by user\n        // in case of beacon wallet, dont override it by\n        // defaults.\n        if (!params.fee) {\n            delete operatedParams.fee;\n        }\n        if (!params.storageLimit) {\n            delete operatedParams.storage_limit;\n        }\n        if (!params.gasLimit) {\n            delete operatedParams.gas_limit;\n        }\n        return operatedParams;\n    }\n    sendOperations(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const account = yield this.client.getActiveAccount();\n            if (!account) {\n                throw new BeaconWalletNotInitialized();\n            }\n            const permissions = account.scopes;\n            this.validateRequiredScopesOrFail(permissions, [\n                _airgap_beacon_dapp__WEBPACK_IMPORTED_MODULE_0__.PermissionScope.OPERATION_REQUEST\n            ]);\n            const { transactionHash } = yield this.client.requestOperation({\n                operationDetails: params\n            });\n            return transactionHash;\n        });\n    }\n    /**\n     *\n     * @description Removes all beacon values from the storage. After using this method, this instance is no longer usable.\n     * You will have to instantiate a new BeaconWallet.\n     */ disconnect() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.destroy();\n        });\n    }\n    /**\n     *\n     * @description This method removes the active account from local storage by setting it to undefined.\n     */ clearActiveAccount() {\n        return __awaiter(this, void 0, void 0, function*() {\n            yield this.client.setActiveAccount();\n        });\n    }\n    sign(bytes, watermark) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let bb = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.hex2buf)(bytes);\n            if (typeof watermark !== \"undefined\") {\n                bb = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.mergebuf)(watermark, bb);\n            }\n            const watermarkedBytes = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.buf2hex)(typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_2___default()(bb));\n            const signingType = this.getSigningType(watermark);\n            if (signingType !== _airgap_beacon_dapp__WEBPACK_IMPORTED_MODULE_0__.SigningType.OPERATION) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.UnsupportedActionError(`Taquito Beacon Wallet currently only supports signing operations, not ${signingType}`);\n            }\n            const { signature } = yield this.client.requestSignPayload({\n                payload: watermarkedBytes,\n                signingType\n            });\n            return signature;\n        });\n    }\n    getSigningType(watermark) {\n        if (!watermark || watermark.length === 0) {\n            return _airgap_beacon_dapp__WEBPACK_IMPORTED_MODULE_0__.SigningType.RAW;\n        }\n        if (watermark.length === 1) {\n            if (watermark[0] === 5) {\n                return _airgap_beacon_dapp__WEBPACK_IMPORTED_MODULE_0__.SigningType.MICHELINE;\n            }\n            if (watermark[0] === 3) {\n                return _airgap_beacon_dapp__WEBPACK_IMPORTED_MODULE_0__.SigningType.OPERATION;\n            }\n        }\n        throw new Error(`Invalid watermark ${JSON.stringify(watermark)}`);\n    }\n}\n //# sourceMappingURL=taquito-beacon-wallet.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vYmVhY29uLXdhbGxldC9kaXN0L3RhcXVpdG8tYmVhY29uLXdhbGxldC5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUEwRjtBQUNaO0FBQ2xDO0FBQzJHO0FBQzNGO0FBRTVEOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSxvREFBb0QsR0FHcEQsU0FBU2EsVUFBVUMsT0FBTyxFQUFFQyxVQUFVLEVBQUVDLENBQUMsRUFBRUMsU0FBUztJQUNoRCxTQUFTQyxNQUFNQyxLQUFLO1FBQUksT0FBT0EsaUJBQWlCSCxJQUFJRyxRQUFRLElBQUlILEVBQUUsU0FBVUksT0FBTztZQUFJQSxRQUFRRDtRQUFRO0lBQUk7SUFDM0csT0FBTyxJQUFLSCxDQUFBQSxLQUFNQSxDQUFBQSxJQUFJSyxPQUFNLENBQUMsRUFBRyxTQUFVRCxPQUFPLEVBQUVFLE1BQU07UUFDckQsU0FBU0MsVUFBVUosS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFVBQVVRLElBQUksQ0FBQ047WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUMxRixTQUFTQyxTQUFTUixLQUFLO1lBQUksSUFBSTtnQkFBRUssS0FBS1AsU0FBUyxDQUFDLFFBQVEsQ0FBQ0U7WUFBUyxFQUFFLE9BQU9PLEdBQUc7Z0JBQUVKLE9BQU9JO1lBQUk7UUFBRTtRQUM3RixTQUFTRixLQUFLSSxNQUFNO1lBQUlBLE9BQU9DLElBQUksR0FBR1QsUUFBUVEsT0FBT1QsS0FBSyxJQUFJRCxNQUFNVSxPQUFPVCxLQUFLLEVBQUVXLElBQUksQ0FBQ1AsV0FBV0k7UUFBVztRQUM3R0gsS0FBSyxDQUFDUCxZQUFZQSxVQUFVYyxLQUFLLENBQUNqQixTQUFTQyxjQUFjLEVBQUUsR0FBR1UsSUFBSTtJQUN0RTtBQUNKO0FBRUEsT0FBT08sb0JBQW9CLGFBQWFBLGtCQUFrQixTQUFVQyxLQUFLLEVBQUVDLFVBQVUsRUFBRUMsT0FBTztJQUMxRixJQUFJVCxJQUFJLElBQUlVLE1BQU1EO0lBQ2xCLE9BQU9ULEVBQUVXLElBQUksR0FBRyxtQkFBbUJYLEVBQUVPLEtBQUssR0FBR0EsT0FBT1AsRUFBRVEsVUFBVSxHQUFHQSxZQUFZUjtBQUNuRjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1ZLG1DQUFtQ25DLGdFQUFxQkE7SUFDMURvQyxhQUFjO1FBQ1YsS0FBSztRQUNMLElBQUksQ0FBQ0YsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRixPQUFPLEdBQ1I7SUFDUjtBQUNKO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUssOEJBQThCckMsZ0VBQXFCQTtJQUNyRG9DLFlBQVlFLGNBQWMsQ0FBRTtRQUN4QixLQUFLO1FBQ0wsSUFBSSxDQUFDQSxjQUFjLEdBQUdBO1FBQ3RCLElBQUksQ0FBQ0osSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDRixPQUFPLEdBQUcsQ0FBQyw2QkFBNkIsRUFBRU0sZUFBZUMsSUFBSSxDQUFDLEtBQUssa0JBQWtCLENBQUM7SUFDL0Y7QUFDSjtBQUVBLDJFQUEyRTtBQUMzRSxNQUFNQyxVQUFVO0lBQ1osY0FBYztJQUNkLFdBQVc7QUFDZjtBQUVBOzs7Q0FHQyxHQUNELE1BQU1DO0lBQ0ZMLFlBQVlNLE9BQU8sQ0FBRTtRQUNqQixJQUFJLENBQUNDLE1BQU0sR0FBRzlDLDBFQUFxQkEsQ0FBQzZDO0lBQ3hDO0lBQ0FFLDZCQUE2QkMsZ0JBQWdCLEVBQUVQLGNBQWMsRUFBRTtRQUMzRCxNQUFNUSxpQkFBaUIsSUFBSUMsSUFBSVQ7UUFDL0IsS0FBSyxNQUFNVSxTQUFTSCxpQkFBa0I7WUFDbEMsSUFBSUMsZUFBZUcsR0FBRyxDQUFDRCxRQUFRO2dCQUMzQkYsZUFBZUksTUFBTSxDQUFDRjtZQUMxQjtRQUNKO1FBQ0EsSUFBSUYsZUFBZUssSUFBSSxHQUFHLEdBQUc7WUFDekIsTUFBTSxJQUFJZCxzQkFBc0JlLE1BQU1DLElBQUksQ0FBQ1A7UUFDL0M7SUFDSjtJQUNBUSxtQkFBbUJDLE9BQU8sRUFBRTtRQUN4QixPQUFPN0MsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQ1csa0JBQWtCLENBQUNDO1FBQ3pDO0lBQ0o7SUFDQUMsU0FBUztRQUNMLE9BQU85QyxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE1BQU0rQyxVQUFVLE1BQU0sSUFBSSxDQUFDZCxNQUFNLENBQUNlLGdCQUFnQjtZQUNsRCxJQUFJLENBQUNELFNBQVM7Z0JBQ1YsTUFBTSxJQUFJdEI7WUFDZDtZQUNBLE9BQU9zQixRQUFRRSxPQUFPO1FBQzFCO0lBQ0o7SUFDQUMsUUFBUTtRQUNKLElBQUlDO1FBQ0osT0FBT25ELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsTUFBTStDLFVBQVUsTUFBTSxJQUFJLENBQUNkLE1BQU0sQ0FBQ2UsZ0JBQWdCO1lBQ2xELElBQUksQ0FBQ0QsU0FBUztnQkFDVixNQUFNLElBQUl0QjtZQUNkO1lBQ0EsT0FBTyxDQUFDMEIsS0FBS0osUUFBUUssU0FBUyxNQUFNLFFBQVFELE9BQU8sS0FBSyxJQUFJQSxLQUFLO1FBQ3JFO0lBQ0o7SUFDQUUsZ0NBQWdDQyxNQUFNLEVBQUU7UUFDcEMsT0FBT3RELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXVEO1lBQ0osTUFBTSxJQUFJLENBQUN0QixNQUFNLENBQUN1QixXQUFXO1lBQzdCLElBQUk7Z0JBQ0FELGVBQWUsTUFBTUQ7WUFDekIsRUFDQSxPQUFPRyxLQUFLO2dCQUNSLE1BQU0sSUFBSSxDQUFDeEIsTUFBTSxDQUFDeUIsTUFBTSxDQUFDO29CQUFDO2lCQUFRO2dCQUNsQyxNQUFNRDtZQUNWO1lBQ0EsT0FBTyxJQUFJLENBQUNFLG1CQUFtQixDQUFDSixjQUFjLE9BQU05RCx5RUFBdUJBLENBQUMsSUFBSSxDQUFDbUUsZ0JBQWdCLENBQUNMLGNBQWE7UUFDbkg7SUFDSjtJQUNBTSxtQ0FBbUNQLE1BQU0sRUFBRTtRQUN2QyxPQUFPdEQsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJdUQ7WUFDSixNQUFNLElBQUksQ0FBQ3RCLE1BQU0sQ0FBQ3VCLFdBQVc7WUFDN0IsSUFBSTtnQkFDQUQsZUFBZSxNQUFNRDtZQUN6QixFQUNBLE9BQU9HLEtBQUs7Z0JBQ1IsTUFBTSxJQUFJLENBQUN4QixNQUFNLENBQUN5QixNQUFNLENBQUM7b0JBQUM7aUJBQVE7Z0JBQ2xDLE1BQU1EO1lBQ1Y7WUFDQSxPQUFPLElBQUksQ0FBQ0UsbUJBQW1CLENBQUNKLGNBQWMsT0FBTTdELG9GQUFrQ0EsQ0FBQyxJQUFJLENBQUNrRSxnQkFBZ0IsQ0FBQ0wsY0FBYTtRQUM5SDtJQUNKO0lBQ0FPLGlDQUFpQ1IsTUFBTSxFQUFFO1FBQ3JDLE9BQU90RCxVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLElBQUl1RDtZQUNKLE1BQU0sSUFBSSxDQUFDdEIsTUFBTSxDQUFDdUIsV0FBVztZQUM3QixJQUFJO2dCQUNBRCxlQUFlLE1BQU1EO1lBQ3pCLEVBQ0EsT0FBT0csS0FBSztnQkFDUixNQUFNLElBQUksQ0FBQ3hCLE1BQU0sQ0FBQ3lCLE1BQU0sQ0FBQztvQkFBQztpQkFBUTtnQkFDbEMsTUFBTUQ7WUFDVjtZQUNBLE9BQU8sSUFBSSxDQUFDRSxtQkFBbUIsQ0FBQ0osY0FBYyxPQUFNNUQsNEVBQTBCQSxDQUFDLElBQUksQ0FBQ2lFLGdCQUFnQixDQUFDTCxjQUFhO1FBQ3RIO0lBQ0o7SUFDQVEsZ0NBQWdDVCxNQUFNLEVBQUU7UUFDcEMsT0FBT3RELFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsSUFBSXVEO1lBQ0osTUFBTSxJQUFJLENBQUN0QixNQUFNLENBQUN1QixXQUFXO1lBQzdCLElBQUk7Z0JBQ0FELGVBQWUsTUFBTUQ7WUFDekIsRUFDQSxPQUFPRyxLQUFLO2dCQUNSLE1BQU0sSUFBSSxDQUFDeEIsTUFBTSxDQUFDeUIsTUFBTSxDQUFDO29CQUFDO2lCQUFRO2dCQUNsQyxNQUFNRDtZQUNWO1lBQ0EsT0FBTyxJQUFJLENBQUNFLG1CQUFtQixDQUFDSixjQUFjLE9BQU0zRCw0RUFBMEJBLENBQUMsSUFBSSxDQUFDZ0UsZ0JBQWdCLENBQUNMLGNBQWE7UUFDdEg7SUFDSjtJQUNBSyxpQkFBaUJOLE1BQU0sRUFBRTtRQUNyQixJQUFJQSxPQUFPVSxHQUFHLEVBQUU7WUFDWlYsT0FBT1UsR0FBRyxHQUFHVixPQUFPVSxHQUFHLENBQUNDLFFBQVE7UUFDcEM7UUFDQSxJQUFJWCxPQUFPWSxZQUFZLEVBQUU7WUFDckJaLE9BQU9ZLFlBQVksR0FBR1osT0FBT1ksWUFBWSxDQUFDRCxRQUFRO1FBQ3REO1FBQ0EsSUFBSVgsT0FBT2EsUUFBUSxFQUFFO1lBQ2pCYixPQUFPYSxRQUFRLEdBQUdiLE9BQU9hLFFBQVEsQ0FBQ0YsUUFBUTtRQUM5QztRQUNBLE9BQU9YO0lBQ1g7SUFDQUssb0JBQW9CTCxNQUFNLEVBQUVjLGNBQWMsRUFBRTtRQUN4Qyx3REFBd0Q7UUFDeEQsZ0RBQWdEO1FBQ2hELFlBQVk7UUFDWixJQUFJLENBQUNkLE9BQU9VLEdBQUcsRUFBRTtZQUNiLE9BQU9JLGVBQWVKLEdBQUc7UUFDN0I7UUFDQSxJQUFJLENBQUNWLE9BQU9ZLFlBQVksRUFBRTtZQUN0QixPQUFPRSxlQUFlQyxhQUFhO1FBQ3ZDO1FBQ0EsSUFBSSxDQUFDZixPQUFPYSxRQUFRLEVBQUU7WUFDbEIsT0FBT0MsZUFBZUUsU0FBUztRQUNuQztRQUNBLE9BQU9GO0lBQ1g7SUFDQUcsZUFBZWpCLE1BQU0sRUFBRTtRQUNuQixPQUFPdEQsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNK0MsVUFBVSxNQUFNLElBQUksQ0FBQ2QsTUFBTSxDQUFDZSxnQkFBZ0I7WUFDbEQsSUFBSSxDQUFDRCxTQUFTO2dCQUNWLE1BQU0sSUFBSXRCO1lBQ2Q7WUFDQSxNQUFNK0MsY0FBY3pCLFFBQVEwQixNQUFNO1lBQ2xDLElBQUksQ0FBQ3ZDLDRCQUE0QixDQUFDc0MsYUFBYTtnQkFBQ25GLGdFQUFlQSxDQUFDcUYsaUJBQWlCO2FBQUM7WUFDbEYsTUFBTSxFQUFFQyxlQUFlLEVBQUUsR0FBRyxNQUFNLElBQUksQ0FBQzFDLE1BQU0sQ0FBQzJDLGdCQUFnQixDQUFDO2dCQUFFQyxrQkFBa0J2QjtZQUFPO1lBQzFGLE9BQU9xQjtRQUNYO0lBQ0o7SUFDQTs7OztLQUlDLEdBQ0RHLGFBQWE7UUFDVCxPQUFPOUUsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxNQUFNLElBQUksQ0FBQ2lDLE1BQU0sQ0FBQzhDLE9BQU87UUFDN0I7SUFDSjtJQUNBOzs7S0FHQyxHQUNEQyxxQkFBcUI7UUFDakIsT0FBT2hGLFVBQVUsSUFBSSxFQUFFLEtBQUssR0FBRyxLQUFLLEdBQUc7WUFDbkMsTUFBTSxJQUFJLENBQUNpQyxNQUFNLENBQUNnRCxnQkFBZ0I7UUFDdEM7SUFDSjtJQUNBQyxLQUFLQyxLQUFLLEVBQUVDLFNBQVMsRUFBRTtRQUNuQixPQUFPcEYsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxJQUFJcUYsS0FBS3hGLHVEQUFPQSxDQUFDc0Y7WUFDakIsSUFBSSxPQUFPQyxjQUFjLGFBQWE7Z0JBQ2xDQyxLQUFLdkYsd0RBQVFBLENBQUNzRixXQUFXQztZQUM3QjtZQUNBLE1BQU1DLG1CQUFtQnZGLHVEQUFPQSxDQUFDUCwyREFBUUEsQ0FBQzZGO1lBQzFDLE1BQU1FLGNBQWMsSUFBSSxDQUFDQyxjQUFjLENBQUNKO1lBQ3hDLElBQUlHLGdCQUFnQm5HLDREQUFXQSxDQUFDcUcsU0FBUyxFQUFFO2dCQUN2QyxNQUFNLElBQUlsRyxpRUFBc0JBLENBQUMsQ0FBQyxzRUFBc0UsRUFBRWdHLFlBQVksQ0FBQztZQUMzSDtZQUNBLE1BQU0sRUFBRUcsU0FBUyxFQUFFLEdBQUcsTUFBTSxJQUFJLENBQUN6RCxNQUFNLENBQUMwRCxrQkFBa0IsQ0FBQztnQkFDdkRDLFNBQVNOO2dCQUNUQztZQUNKO1lBQ0EsT0FBT0c7UUFDWDtJQUNKO0lBQ0FGLGVBQWVKLFNBQVMsRUFBRTtRQUN0QixJQUFJLENBQUNBLGFBQWFBLFVBQVVTLE1BQU0sS0FBSyxHQUFHO1lBQ3RDLE9BQU96Ryw0REFBV0EsQ0FBQzBHLEdBQUc7UUFDMUI7UUFDQSxJQUFJVixVQUFVUyxNQUFNLEtBQUssR0FBRztZQUN4QixJQUFJVCxTQUFTLENBQUMsRUFBRSxLQUFLLEdBQUc7Z0JBQ3BCLE9BQU9oRyw0REFBV0EsQ0FBQzJHLFNBQVM7WUFDaEM7WUFDQSxJQUFJWCxTQUFTLENBQUMsRUFBRSxLQUFLLEdBQUc7Z0JBQ3BCLE9BQU9oRyw0REFBV0EsQ0FBQ3FHLFNBQVM7WUFDaEM7UUFDSjtRQUNBLE1BQU0sSUFBSWxFLE1BQU0sQ0FBQyxrQkFBa0IsRUFBRXlFLEtBQUtDLFNBQVMsQ0FBQ2IsV0FBVyxDQUFDO0lBQ3BFO0FBQ0o7QUFFb0YsQ0FDcEYscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdycGVya3MvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vYmVhY29uLXdhbGxldC9kaXN0L3RhcXVpdG8tYmVhY29uLXdhbGxldC5lczYuanM/NGRhYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXREQXBwQ2xpZW50SW5zdGFuY2UsIFNpZ25pbmdUeXBlLCBQZXJtaXNzaW9uU2NvcGUgfSBmcm9tICdAYWlyZ2FwL2JlYWNvbi1kYXBwJztcbmltcG9ydCB7IFBlcm1pc3Npb25EZW5pZWRFcnJvciwgVW5zdXBwb3J0ZWRBY3Rpb25FcnJvciB9IGZyb20gJ0B0YXF1aXRvL2NvcmUnO1xuaW1wb3J0IHRvQnVmZmVyIGZyb20gJ3R5cGVkYXJyYXktdG8tYnVmZmVyJztcbmltcG9ydCB7IGNyZWF0ZVRyYW5zZmVyT3BlcmF0aW9uLCBjcmVhdGVJbmNyZWFzZVBhaWRTdG9yYWdlT3BlcmF0aW9uLCBjcmVhdGVPcmlnaW5hdGlvbk9wZXJhdGlvbiwgY3JlYXRlU2V0RGVsZWdhdGVPcGVyYXRpb24gfSBmcm9tICdAdGFxdWl0by90YXF1aXRvJztcbmltcG9ydCB7IGhleDJidWYsIG1lcmdlYnVmLCBidWYyaGV4IH0gZnJvbSAnQHRhcXVpdG8vdXRpbHMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyB0aGUgQmVhY29uIHdhbGxldCBub3QgYmVpbmcgaW5pdGlhbGl6ZWRcbiAqL1xuY2xhc3MgQmVhY29uV2FsbGV0Tm90SW5pdGlhbGl6ZWQgZXh0ZW5kcyBQZXJtaXNzaW9uRGVuaWVkRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmVhY29uV2FsbGV0Tm90SW5pdGlhbGl6ZWQnO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPVxuICAgICAgICAgICAgJ0JlYWNvbldhbGxldCBuZWVkcyB0byBiZSBpbml0aWFsaXplZCBieSBjYWxsaW5nIGBhd2FpdCBCZWFjb25XYWxsZXQucmVxdWVzdFBlcm1pc3Npb25zKHtuZXR3b3JrOiB7dHlwZTogXCJjaG9zZW5fbmV0d29ya1wifX0pYCBmaXJzdC4nO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBtaXNzaW5nIHJlcXVpcmVkIHBlcnNtaXNzaW9uIHNjb3Blc1xuICovXG5jbGFzcyBNaXNzaW5nUmVxdWlyZWRTY29wZXMgZXh0ZW5kcyBQZXJtaXNzaW9uRGVuaWVkRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlcXVpcmVkU2NvcGVzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVxdWlyZWRTY29wZXMgPSByZXF1aXJlZFNjb3BlcztcbiAgICAgICAgdGhpcy5uYW1lID0gJ01pc3NpbmdSZXF1aXJlZFNjb3Blcyc7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBSZXF1aXJlZCBwZXJtaXNzaW9ucyBzY29wZXM6ICR7cmVxdWlyZWRTY29wZXMuam9pbignLCcpfSB3ZXJlIG5vdCBncmFudGVkLmA7XG4gICAgfVxufVxuXG4vLyBJTVBPUlRBTlQ6IFRISVMgRklMRSBJUyBBVVRPIEdFTkVSQVRFRCEgRE8gTk9UIE1BTlVBTExZIEVESVQgT1IgQ0hFQ0tJTiFcbmNvbnN0IFZFUlNJT04gPSB7XG4gICAgXCJjb21taXRIYXNoXCI6IFwiMTNhMTJhYjdjZjQ0MjA0MzUyNjc0NWRiMmJiZjRlZjNiMDg5YzM0YVwiLFxuICAgIFwidmVyc2lvblwiOiBcIjE5LjAuMlwiXG59O1xuXG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBAdGFxdWl0by9iZWFjb24td2FsbGV0XG4gKi9cbmNsYXNzIEJlYWNvbldhbGxldCB7XG4gICAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGdldERBcHBDbGllbnRJbnN0YW5jZShvcHRpb25zKTtcbiAgICB9XG4gICAgdmFsaWRhdGVSZXF1aXJlZFNjb3Blc09yRmFpbChwZXJtaXNzaW9uU2NvcGVzLCByZXF1aXJlZFNjb3Blcykge1xuICAgICAgICBjb25zdCBtYW5kYXRvcnlTY29wZSA9IG5ldyBTZXQocmVxdWlyZWRTY29wZXMpO1xuICAgICAgICBmb3IgKGNvbnN0IHNjb3BlIG9mIHBlcm1pc3Npb25TY29wZXMpIHtcbiAgICAgICAgICAgIGlmIChtYW5kYXRvcnlTY29wZS5oYXMoc2NvcGUpKSB7XG4gICAgICAgICAgICAgICAgbWFuZGF0b3J5U2NvcGUuZGVsZXRlKHNjb3BlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWFuZGF0b3J5U2NvcGUuc2l6ZSA+IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNaXNzaW5nUmVxdWlyZWRTY29wZXMoQXJyYXkuZnJvbShtYW5kYXRvcnlTY29wZSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlcXVlc3RQZXJtaXNzaW9ucyhyZXF1ZXN0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5yZXF1ZXN0UGVybWlzc2lvbnMocmVxdWVzdCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRQS0goKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhY2NvdW50ID0geWllbGQgdGhpcy5jbGllbnQuZ2V0QWN0aXZlQWNjb3VudCgpO1xuICAgICAgICAgICAgaWYgKCFhY2NvdW50KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEJlYWNvbldhbGxldE5vdEluaXRpYWxpemVkKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjb3VudC5hZGRyZXNzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UEsoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB5aWVsZCB0aGlzLmNsaWVudC5nZXRBY3RpdmVBY2NvdW50KCk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQmVhY29uV2FsbGV0Tm90SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAoX2EgPSBhY2NvdW50LnB1YmxpY0tleSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJyc7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBUcmFuc2ZlclBhcmFtc1RvV2FsbGV0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHdhbGxldFBhcmFtcztcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnNob3dQcmVwYXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdhbGxldFBhcmFtcyA9IHlpZWxkIHBhcmFtcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LmhpZGVVSShbJ2FsZXJ0J10pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZURlZmF1bHRQYXJhbXMod2FsbGV0UGFyYW1zLCB5aWVsZCBjcmVhdGVUcmFuc2Zlck9wZXJhdGlvbih0aGlzLmZvcm1hdFBhcmFtZXRlcnMod2FsbGV0UGFyYW1zKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFwSW5jcmVhc2VQYWlkU3RvcmFnZVdhbGxldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCB3YWxsZXRQYXJhbXM7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5zaG93UHJlcGFyZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB3YWxsZXRQYXJhbXMgPSB5aWVsZCBwYXJhbXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNsaWVudC5oaWRlVUkoWydhbGVydCddKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVEZWZhdWx0UGFyYW1zKHdhbGxldFBhcmFtcywgeWllbGQgY3JlYXRlSW5jcmVhc2VQYWlkU3RvcmFnZU9wZXJhdGlvbih0aGlzLmZvcm1hdFBhcmFtZXRlcnMod2FsbGV0UGFyYW1zKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFwT3JpZ2luYXRlUGFyYW1zVG9XYWxsZXRQYXJhbXMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgd2FsbGV0UGFyYW1zO1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQuc2hvd1ByZXBhcmUoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2FsbGV0UGFyYW1zID0geWllbGQgcGFyYW1zKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQuaGlkZVVJKFsnYWxlcnQnXSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlRGVmYXVsdFBhcmFtcyh3YWxsZXRQYXJhbXMsIHlpZWxkIGNyZWF0ZU9yaWdpbmF0aW9uT3BlcmF0aW9uKHRoaXMuZm9ybWF0UGFyYW1ldGVycyh3YWxsZXRQYXJhbXMpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBEZWxlZ2F0ZVBhcmFtc1RvV2FsbGV0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IHdhbGxldFBhcmFtcztcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnNob3dQcmVwYXJlKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHdhbGxldFBhcmFtcyA9IHlpZWxkIHBhcmFtcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LmhpZGVVSShbJ2FsZXJ0J10pO1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJlbW92ZURlZmF1bHRQYXJhbXMod2FsbGV0UGFyYW1zLCB5aWVsZCBjcmVhdGVTZXREZWxlZ2F0ZU9wZXJhdGlvbih0aGlzLmZvcm1hdFBhcmFtZXRlcnMod2FsbGV0UGFyYW1zKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9ybWF0UGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHBhcmFtcy5mZWUpIHtcbiAgICAgICAgICAgIHBhcmFtcy5mZWUgPSBwYXJhbXMuZmVlLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5zdG9yYWdlTGltaXQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zdG9yYWdlTGltaXQgPSBwYXJhbXMuc3RvcmFnZUxpbWl0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcy5nYXNMaW1pdCkge1xuICAgICAgICAgICAgcGFyYW1zLmdhc0xpbWl0ID0gcGFyYW1zLmdhc0xpbWl0LnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgcmVtb3ZlRGVmYXVsdFBhcmFtcyhwYXJhbXMsIG9wZXJhdGVkUGFyYW1zKSB7XG4gICAgICAgIC8vIElmIGZlZSwgc3RvcmFnZUxpbWl0IG9yIGdhc0xpbWl0IGlzIHVuZGVmaW5lZCBieSB1c2VyXG4gICAgICAgIC8vIGluIGNhc2Ugb2YgYmVhY29uIHdhbGxldCwgZG9udCBvdmVycmlkZSBpdCBieVxuICAgICAgICAvLyBkZWZhdWx0cy5cbiAgICAgICAgaWYgKCFwYXJhbXMuZmVlKSB7XG4gICAgICAgICAgICBkZWxldGUgb3BlcmF0ZWRQYXJhbXMuZmVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcGFyYW1zLnN0b3JhZ2VMaW1pdCkge1xuICAgICAgICAgICAgZGVsZXRlIG9wZXJhdGVkUGFyYW1zLnN0b3JhZ2VfbGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwYXJhbXMuZ2FzTGltaXQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcGVyYXRlZFBhcmFtcy5nYXNfbGltaXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9wZXJhdGVkUGFyYW1zO1xuICAgIH1cbiAgICBzZW5kT3BlcmF0aW9ucyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFjY291bnQgPSB5aWVsZCB0aGlzLmNsaWVudC5nZXRBY3RpdmVBY2NvdW50KCk7XG4gICAgICAgICAgICBpZiAoIWFjY291bnQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQmVhY29uV2FsbGV0Tm90SW5pdGlhbGl6ZWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gYWNjb3VudC5zY29wZXM7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlUmVxdWlyZWRTY29wZXNPckZhaWwocGVybWlzc2lvbnMsIFtQZXJtaXNzaW9uU2NvcGUuT1BFUkFUSU9OX1JFUVVFU1RdKTtcbiAgICAgICAgICAgIGNvbnN0IHsgdHJhbnNhY3Rpb25IYXNoIH0gPSB5aWVsZCB0aGlzLmNsaWVudC5yZXF1ZXN0T3BlcmF0aW9uKHsgb3BlcmF0aW9uRGV0YWlsczogcGFyYW1zIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRyYW5zYWN0aW9uSGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFJlbW92ZXMgYWxsIGJlYWNvbiB2YWx1ZXMgZnJvbSB0aGUgc3RvcmFnZS4gQWZ0ZXIgdXNpbmcgdGhpcyBtZXRob2QsIHRoaXMgaW5zdGFuY2UgaXMgbm8gbG9uZ2VyIHVzYWJsZS5cbiAgICAgKiBZb3Ugd2lsbCBoYXZlIHRvIGluc3RhbnRpYXRlIGEgbmV3IEJlYWNvbldhbGxldC5cbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5jbGllbnQuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhpcyBtZXRob2QgcmVtb3ZlcyB0aGUgYWN0aXZlIGFjY291bnQgZnJvbSBsb2NhbCBzdG9yYWdlIGJ5IHNldHRpbmcgaXQgdG8gdW5kZWZpbmVkLlxuICAgICAqL1xuICAgIGNsZWFyQWN0aXZlQWNjb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xpZW50LnNldEFjdGl2ZUFjY291bnQoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ24oYnl0ZXMsIHdhdGVybWFyaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbGV0IGJiID0gaGV4MmJ1ZihieXRlcyk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdhdGVybWFyayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICBiYiA9IG1lcmdlYnVmKHdhdGVybWFyaywgYmIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgd2F0ZXJtYXJrZWRCeXRlcyA9IGJ1ZjJoZXgodG9CdWZmZXIoYmIpKTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25pbmdUeXBlID0gdGhpcy5nZXRTaWduaW5nVHlwZSh3YXRlcm1hcmspO1xuICAgICAgICAgICAgaWYgKHNpZ25pbmdUeXBlICE9PSBTaWduaW5nVHlwZS5PUEVSQVRJT04pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRBY3Rpb25FcnJvcihgVGFxdWl0byBCZWFjb24gV2FsbGV0IGN1cnJlbnRseSBvbmx5IHN1cHBvcnRzIHNpZ25pbmcgb3BlcmF0aW9ucywgbm90ICR7c2lnbmluZ1R5cGV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IHNpZ25hdHVyZSB9ID0geWllbGQgdGhpcy5jbGllbnQucmVxdWVzdFNpZ25QYXlsb2FkKHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiB3YXRlcm1hcmtlZEJ5dGVzLFxuICAgICAgICAgICAgICAgIHNpZ25pbmdUeXBlLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gc2lnbmF0dXJlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U2lnbmluZ1R5cGUod2F0ZXJtYXJrKSB7XG4gICAgICAgIGlmICghd2F0ZXJtYXJrIHx8IHdhdGVybWFyay5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBTaWduaW5nVHlwZS5SQVc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdhdGVybWFyay5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGlmICh3YXRlcm1hcmtbMF0gPT09IDUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU2lnbmluZ1R5cGUuTUlDSEVMSU5FO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdhdGVybWFya1swXSA9PT0gMykge1xuICAgICAgICAgICAgICAgIHJldHVybiBTaWduaW5nVHlwZS5PUEVSQVRJT047XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHdhdGVybWFyayAke0pTT04uc3RyaW5naWZ5KHdhdGVybWFyayl9YCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCZWFjb25XYWxsZXQsIEJlYWNvbldhbGxldE5vdEluaXRpYWxpemVkLCBNaXNzaW5nUmVxdWlyZWRTY29wZXMsIFZFUlNJT04gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcXVpdG8tYmVhY29uLXdhbGxldC5lczYuanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0REFwcENsaWVudEluc3RhbmNlIiwiU2lnbmluZ1R5cGUiLCJQZXJtaXNzaW9uU2NvcGUiLCJQZXJtaXNzaW9uRGVuaWVkRXJyb3IiLCJVbnN1cHBvcnRlZEFjdGlvbkVycm9yIiwidG9CdWZmZXIiLCJjcmVhdGVUcmFuc2Zlck9wZXJhdGlvbiIsImNyZWF0ZUluY3JlYXNlUGFpZFN0b3JhZ2VPcGVyYXRpb24iLCJjcmVhdGVPcmlnaW5hdGlvbk9wZXJhdGlvbiIsImNyZWF0ZVNldERlbGVnYXRlT3BlcmF0aW9uIiwiaGV4MmJ1ZiIsIm1lcmdlYnVmIiwiYnVmMmhleCIsIl9fYXdhaXRlciIsInRoaXNBcmciLCJfYXJndW1lbnRzIiwiUCIsImdlbmVyYXRvciIsImFkb3B0IiwidmFsdWUiLCJyZXNvbHZlIiwiUHJvbWlzZSIsInJlamVjdCIsImZ1bGZpbGxlZCIsInN0ZXAiLCJuZXh0IiwiZSIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIlN1cHByZXNzZWRFcnJvciIsImVycm9yIiwic3VwcHJlc3NlZCIsIm1lc3NhZ2UiLCJFcnJvciIsIm5hbWUiLCJCZWFjb25XYWxsZXROb3RJbml0aWFsaXplZCIsImNvbnN0cnVjdG9yIiwiTWlzc2luZ1JlcXVpcmVkU2NvcGVzIiwicmVxdWlyZWRTY29wZXMiLCJqb2luIiwiVkVSU0lPTiIsIkJlYWNvbldhbGxldCIsIm9wdGlvbnMiLCJjbGllbnQiLCJ2YWxpZGF0ZVJlcXVpcmVkU2NvcGVzT3JGYWlsIiwicGVybWlzc2lvblNjb3BlcyIsIm1hbmRhdG9yeVNjb3BlIiwiU2V0Iiwic2NvcGUiLCJoYXMiLCJkZWxldGUiLCJzaXplIiwiQXJyYXkiLCJmcm9tIiwicmVxdWVzdFBlcm1pc3Npb25zIiwicmVxdWVzdCIsImdldFBLSCIsImFjY291bnQiLCJnZXRBY3RpdmVBY2NvdW50IiwiYWRkcmVzcyIsImdldFBLIiwiX2EiLCJwdWJsaWNLZXkiLCJtYXBUcmFuc2ZlclBhcmFtc1RvV2FsbGV0UGFyYW1zIiwicGFyYW1zIiwid2FsbGV0UGFyYW1zIiwic2hvd1ByZXBhcmUiLCJlcnIiLCJoaWRlVUkiLCJyZW1vdmVEZWZhdWx0UGFyYW1zIiwiZm9ybWF0UGFyYW1ldGVycyIsIm1hcEluY3JlYXNlUGFpZFN0b3JhZ2VXYWxsZXRQYXJhbXMiLCJtYXBPcmlnaW5hdGVQYXJhbXNUb1dhbGxldFBhcmFtcyIsIm1hcERlbGVnYXRlUGFyYW1zVG9XYWxsZXRQYXJhbXMiLCJmZWUiLCJ0b1N0cmluZyIsInN0b3JhZ2VMaW1pdCIsImdhc0xpbWl0Iiwib3BlcmF0ZWRQYXJhbXMiLCJzdG9yYWdlX2xpbWl0IiwiZ2FzX2xpbWl0Iiwic2VuZE9wZXJhdGlvbnMiLCJwZXJtaXNzaW9ucyIsInNjb3BlcyIsIk9QRVJBVElPTl9SRVFVRVNUIiwidHJhbnNhY3Rpb25IYXNoIiwicmVxdWVzdE9wZXJhdGlvbiIsIm9wZXJhdGlvbkRldGFpbHMiLCJkaXNjb25uZWN0IiwiZGVzdHJveSIsImNsZWFyQWN0aXZlQWNjb3VudCIsInNldEFjdGl2ZUFjY291bnQiLCJzaWduIiwiYnl0ZXMiLCJ3YXRlcm1hcmsiLCJiYiIsIndhdGVybWFya2VkQnl0ZXMiLCJzaWduaW5nVHlwZSIsImdldFNpZ25pbmdUeXBlIiwiT1BFUkFUSU9OIiwic2lnbmF0dXJlIiwicmVxdWVzdFNpZ25QYXlsb2FkIiwicGF5bG9hZCIsImxlbmd0aCIsIlJBVyIsIk1JQ0hFTElORSIsIkpTT04iLCJzdHJpbmdpZnkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/beacon-wallet/dist/taquito-beacon-wallet.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js":
/*!*************************************************************!*\
  !*** ./node_modules/@taquito/core/dist/taquito-core.es6.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeprecationError: () => (/* binding */ DeprecationError),\n/* harmony export */   InvalidAddressError: () => (/* binding */ InvalidAddressError),\n/* harmony export */   InvalidAmountError: () => (/* binding */ InvalidAmountError),\n/* harmony export */   InvalidBlockHashError: () => (/* binding */ InvalidBlockHashError),\n/* harmony export */   InvalidChainIdError: () => (/* binding */ InvalidChainIdError),\n/* harmony export */   InvalidContractAddressError: () => (/* binding */ InvalidContractAddressError),\n/* harmony export */   InvalidDerivationPathError: () => (/* binding */ InvalidDerivationPathError),\n/* harmony export */   InvalidHexStringError: () => (/* binding */ InvalidHexStringError),\n/* harmony export */   InvalidKeyError: () => (/* binding */ InvalidKeyError),\n/* harmony export */   InvalidKeyHashError: () => (/* binding */ InvalidKeyHashError),\n/* harmony export */   InvalidMessageError: () => (/* binding */ InvalidMessageError),\n/* harmony export */   InvalidOperationHashError: () => (/* binding */ InvalidOperationHashError),\n/* harmony export */   InvalidOperationKindError: () => (/* binding */ InvalidOperationKindError),\n/* harmony export */   InvalidPublicKeyError: () => (/* binding */ InvalidPublicKeyError),\n/* harmony export */   InvalidSignatureError: () => (/* binding */ InvalidSignatureError),\n/* harmony export */   InvalidViewParameterError: () => (/* binding */ InvalidViewParameterError),\n/* harmony export */   NetworkError: () => (/* binding */ NetworkError),\n/* harmony export */   ParameterValidationError: () => (/* binding */ ParameterValidationError),\n/* harmony export */   PermissionDeniedError: () => (/* binding */ PermissionDeniedError),\n/* harmony export */   ProhibitedActionError: () => (/* binding */ ProhibitedActionError),\n/* harmony export */   PublicKeyNotFoundError: () => (/* binding */ PublicKeyNotFoundError),\n/* harmony export */   RpcError: () => (/* binding */ RpcError),\n/* harmony export */   TaquitoError: () => (/* binding */ TaquitoError),\n/* harmony export */   TezosToolkitConfigError: () => (/* binding */ TezosToolkitConfigError),\n/* harmony export */   UnsupportedActionError: () => (/* binding */ UnsupportedActionError)\n/* harmony export */ });\n// ==========================================================================================\n// parent error classes for Taquito\n// ==========================================================================================\n/**\n *  @category Error\n *  @description Parent error class all taquito errors to extend from\n */ class TaquitoError extends Error {\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid user inputs\n */ class ParameterValidationError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error returned by RPC node\n */ class RpcError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error that indicates TezosToolKit has not been configured appropriately\n */ class TezosToolkitConfigError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error that indicates a requested action is not supported by Taquito\n */ class UnsupportedActionError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error during a network operation\n */ class NetworkError extends TaquitoError {\n}\n/**\n *  @category Error\n *  @description Error that indicates user attempts an action without necessary permissions\n */ class PermissionDeniedError extends TaquitoError {\n}\n// ==========================================================================================\n// common error classes for Taquito\n// ==========================================================================================\n/**\n *  @category Error\n *  @description Error that indicates an invalid originated or implicit address being passed or used\n */ class InvalidAddressError extends ParameterValidationError {\n    constructor(address, errorDetail){\n        super();\n        this.address = address;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidAddressError\";\n        this.message = `Invalid address \"${address}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid block hash being passed or used\n */ class InvalidBlockHashError extends ParameterValidationError {\n    constructor(blockHash, errorDetail){\n        super();\n        this.blockHash = blockHash;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidBlockHashError\";\n        this.message = `Invalid block hash \"${blockHash}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n * @category Error\n * @description Error that indicates an invalid amount of tez being passed as a parameter\n */ class InvalidAmountError extends ParameterValidationError {\n    constructor(amount){\n        super();\n        this.amount = amount;\n        this.name = \"InvalidAmountError\";\n        this.message = `Invalid amount \"${amount}\"`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid derivation path being passed or used\n */ class InvalidDerivationPathError extends ParameterValidationError {\n    constructor(derivationPath, errorDetail){\n        super();\n        this.derivationPath = derivationPath;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidDerivationPathError\";\n        this.message = `Invalid derivation path \"${derivationPath}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid hex string have been passed or used\n */ class InvalidHexStringError extends ParameterValidationError {\n    constructor(hexString, errorDetail){\n        super();\n        this.hexString = hexString;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidHexStringError\";\n        this.message = `Invalid hex string \"${hexString}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid message being passed or used\n */ class InvalidMessageError extends ParameterValidationError {\n    constructor(msg, errorDetail){\n        super();\n        this.msg = msg;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidMessageError\";\n        this.message = `Invalid message \"${msg}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid view parameter of a smart contract\n */ class InvalidViewParameterError extends ParameterValidationError {\n    constructor(viewName, sigs, args, cause){\n        super();\n        this.viewName = viewName;\n        this.sigs = sigs;\n        this.args = args;\n        this.cause = cause;\n        this.name = \"InvalidViewParameterError\";\n        this.message = `Invalid view arguments ${JSON.stringify(args)} received for name \"${viewName}\" expecting one of the following signatures ${JSON.stringify(sigs)}.`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid private key being passed or used\n */ class InvalidKeyError extends ParameterValidationError {\n    constructor(errorDetail){\n        super();\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidKeyError\";\n        this.message = `Invalid private key`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an Invalid Public Key being passed or used\n */ class InvalidPublicKeyError extends ParameterValidationError {\n    constructor(publicKey, errorDetail){\n        super();\n        this.publicKey = publicKey;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidPublicKeyError\";\n        this.message = `Invalid public key \"${publicKey}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid signature being passed or used\n */ class InvalidSignatureError extends ParameterValidationError {\n    constructor(signature, errorDetail){\n        super();\n        this.signature = signature;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidSignatureError\";\n        this.message = `Invalid signature \"${signature}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract address being passed or used\n */ class InvalidContractAddressError extends ParameterValidationError {\n    constructor(contractAddress, errorDetail){\n        super();\n        this.contractAddress = contractAddress;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidContractAddressError\";\n        this.message = `Invalid contract address \"${contractAddress}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid chain id being passed or used\n */ class InvalidChainIdError extends ParameterValidationError {\n    constructor(chainId, errorDetail){\n        super();\n        this.chainId = chainId;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidChainIdError\";\n        this.message = `Invalid chain id \"${chainId}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid public key hash being passed or used\n */ class InvalidKeyHashError extends ParameterValidationError {\n    constructor(keyHash, errorDetail){\n        super();\n        this.keyHash = keyHash;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidKeyHashError\";\n        this.message = `Invalid public key hash \"${keyHash}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation hash being passed or used\n */ class InvalidOperationHashError extends ParameterValidationError {\n    constructor(operationHash, errorDetail){\n        super();\n        this.operationHash = operationHash;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidOperationHashError\";\n        this.message = `Invalid operation hash \"${operationHash}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation kind being passed or used\n */ class InvalidOperationKindError extends ParameterValidationError {\n    constructor(operationKind, errorDetail){\n        super();\n        this.operationKind = operationKind;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidOperationKindError\";\n        this.message = `Invalid operation kind \"${operationKind}\"`;\n        this.message += errorDetail ? ` ${errorDetail}.` : \".\";\n    }\n}\n/**\n *  @category Error\n *  @description General error that indicates something is no longer supported and/or deprecated\n */ class DeprecationError extends UnsupportedActionError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"DeprecationError\";\n    }\n}\n/**\n *  @category Error\n *  @description General error that indicates an action is prohibited or not allowed\n */ class ProhibitedActionError extends UnsupportedActionError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"ProhibitedActionError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure in grabbing the public key\n */ class PublicKeyNotFoundError extends TaquitoError {\n    constructor(pkh, cause){\n        super();\n        this.pkh = pkh;\n        this.cause = cause;\n        this.name = \"PublicKeyNotFoundError\";\n        this.message = `Public key not found of this address \"${pkh}\" in either wallet or contract API.`;\n    }\n}\n //# sourceMappingURL=taquito-core.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vY29yZS9kaXN0L3RhcXVpdG8tY29yZS5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLDZGQUE2RjtBQUM3RixtQ0FBbUM7QUFDbkMsNkZBQTZGO0FBQzdGOzs7Q0FHQyxHQUNELE1BQU1BLHFCQUFxQkM7QUFDM0I7QUFDQTs7O0NBR0MsR0FDRCxNQUFNQyxpQ0FBaUNGO0FBQ3ZDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTUcsaUJBQWlCSDtBQUN2QjtBQUNBOzs7Q0FHQyxHQUNELE1BQU1JLGdDQUFnQ0o7QUFDdEM7QUFDQTs7O0NBR0MsR0FDRCxNQUFNSywrQkFBK0JMO0FBQ3JDO0FBQ0E7OztDQUdDLEdBQ0QsTUFBTU0scUJBQXFCTjtBQUMzQjtBQUNBOzs7Q0FHQyxHQUNELE1BQU1PLDhCQUE4QlA7QUFDcEM7QUFDQSw2RkFBNkY7QUFDN0YsbUNBQW1DO0FBQ25DLDZGQUE2RjtBQUM3Rjs7O0NBR0MsR0FDRCxNQUFNUSw0QkFBNEJOO0lBQzlCTyxZQUFZQyxPQUFPLEVBQUVDLFdBQVcsQ0FBRTtRQUM5QixLQUFLO1FBQ0wsSUFBSSxDQUFDRCxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ0MsSUFBSSxHQUFHO1FBQ1osSUFBSSxDQUFDQyxPQUFPLEdBQUcsQ0FBQyxpQkFBaUIsRUFBRUgsUUFBUSxDQUFDLENBQUM7UUFDN0MsSUFBSSxDQUFDRyxPQUFPLElBQUlGLGNBQWMsQ0FBQyxDQUFDLEVBQUVBLFlBQVksQ0FBQyxDQUFDLEdBQUc7SUFDdkQ7QUFDSjtBQUNBOzs7Q0FHQyxHQUNELE1BQU1HLDhCQUE4Qlo7SUFDaENPLFlBQVlNLFNBQVMsRUFBRUosV0FBVyxDQUFFO1FBQ2hDLEtBQUs7UUFDTCxJQUFJLENBQUNJLFNBQVMsR0FBR0E7UUFDakIsSUFBSSxDQUFDSixXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FB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NENBQTRDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdycGVya3MvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vY29yZS9kaXN0L3RhcXVpdG8tY29yZS5lczYuanM/NTZlNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8vIHBhcmVudCBlcnJvciBjbGFzc2VzIGZvciBUYXF1aXRvXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBQYXJlbnQgZXJyb3IgY2xhc3MgYWxsIHRhcXVpdG8gZXJyb3JzIHRvIGV4dGVuZCBmcm9tXG4gKi9cbmNsYXNzIFRhcXVpdG9FcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBpbnZhbGlkIHVzZXIgaW5wdXRzXG4gKi9cbmNsYXNzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgcmV0dXJuZWQgYnkgUlBDIG5vZGVcbiAqL1xuY2xhc3MgUnBjRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIFRlem9zVG9vbEtpdCBoYXMgbm90IGJlZW4gY29uZmlndXJlZCBhcHByb3ByaWF0ZWx5XG4gKi9cbmNsYXNzIFRlem9zVG9vbGtpdENvbmZpZ0Vycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIHJlcXVlc3RlZCBhY3Rpb24gaXMgbm90IHN1cHBvcnRlZCBieSBUYXF1aXRvXG4gKi9cbmNsYXNzIFVuc3VwcG9ydGVkQWN0aW9uRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIGR1cmluZyBhIG5ldHdvcmsgb3BlcmF0aW9uXG4gKi9cbmNsYXNzIE5ldHdvcmtFcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgdXNlciBhdHRlbXB0cyBhbiBhY3Rpb24gd2l0aG91dCBuZWNlc3NhcnkgcGVybWlzc2lvbnNcbiAqL1xuY2xhc3MgUGVybWlzc2lvbkRlbmllZEVycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbn1cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gY29tbW9uIGVycm9yIGNsYXNzZXMgZm9yIFRhcXVpdG9cbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgb3JpZ2luYXRlZCBvciBpbXBsaWNpdCBhZGRyZXNzIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRBZGRyZXNzRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWwgPSBlcnJvckRldGFpbDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRBZGRyZXNzRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBhZGRyZXNzIFwiJHthZGRyZXNzfVwiYDtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IGVycm9yRGV0YWlsID8gYCAke2Vycm9yRGV0YWlsfS5gIDogJy4nO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIGJsb2NrIGhhc2ggYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZEJsb2NrSGFzaEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0hhc2gsIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoO1xuICAgICAgICB0aGlzLmVycm9yRGV0YWlsID0gZXJyb3JEZXRhaWw7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkQmxvY2tIYXNoRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBibG9jayBoYXNoIFwiJHtibG9ja0hhc2h9XCJgO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gZXJyb3JEZXRhaWwgPyBgICR7ZXJyb3JEZXRhaWx9LmAgOiAnLic7XG4gICAgfVxufVxuLyoqXG4gKiBAY2F0ZWdvcnkgRXJyb3JcbiAqIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIGFtb3VudCBvZiB0ZXogYmVpbmcgcGFzc2VkIGFzIGEgcGFyYW1ldGVyXG4gKi9cbmNsYXNzIEludmFsaWRBbW91bnRFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoYW1vdW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYW1vdW50ID0gYW1vdW50O1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEFtb3VudEVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYEludmFsaWQgYW1vdW50IFwiJHthbW91bnR9XCJgO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIGRlcml2YXRpb24gcGF0aCBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkRGVyaXZhdGlvblBhdGhFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoZGVyaXZhdGlvblBhdGgsIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGVyaXZhdGlvblBhdGggPSBkZXJpdmF0aW9uUGF0aDtcbiAgICAgICAgdGhpcy5lcnJvckRldGFpbCA9IGVycm9yRGV0YWlsO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZERlcml2YXRpb25QYXRoRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBkZXJpdmF0aW9uIHBhdGggXCIke2Rlcml2YXRpb25QYXRofVwiYDtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IGVycm9yRGV0YWlsID8gYCAke2Vycm9yRGV0YWlsfS5gIDogJy4nO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIGhleCBzdHJpbmcgaGF2ZSBiZWVuIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRIZXhTdHJpbmdFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoaGV4U3RyaW5nLCBlcnJvckRldGFpbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmhleFN0cmluZyA9IGhleFN0cmluZztcbiAgICAgICAgdGhpcy5lcnJvckRldGFpbCA9IGVycm9yRGV0YWlsO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEhleFN0cmluZ0Vycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYEludmFsaWQgaGV4IHN0cmluZyBcIiR7aGV4U3RyaW5nfVwiYDtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IGVycm9yRGV0YWlsID8gYCAke2Vycm9yRGV0YWlsfS5gIDogJy4nO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIG1lc3NhZ2UgYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZE1lc3NhZ2VFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobXNnLCBlcnJvckRldGFpbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1zZyA9IG1zZztcbiAgICAgICAgdGhpcy5lcnJvckRldGFpbCA9IGVycm9yRGV0YWlsO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZE1lc3NhZ2VFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIG1lc3NhZ2UgXCIke21zZ31cImA7XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSBlcnJvckRldGFpbCA/IGAgJHtlcnJvckRldGFpbH0uYCA6ICcuJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgaW52YWxpZCB2aWV3IHBhcmFtZXRlciBvZiBhIHNtYXJ0IGNvbnRyYWN0XG4gKi9cbmNsYXNzIEludmFsaWRWaWV3UGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZpZXdOYW1lLCBzaWdzLCBhcmdzLCBjYXVzZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZpZXdOYW1lID0gdmlld05hbWU7XG4gICAgICAgIHRoaXMuc2lncyA9IHNpZ3M7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRWaWV3UGFyYW1ldGVyRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCB2aWV3IGFyZ3VtZW50cyAke0pTT04uc3RyaW5naWZ5KGFyZ3MpfSByZWNlaXZlZCBmb3IgbmFtZSBcIiR7dmlld05hbWV9XCIgZXhwZWN0aW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIHNpZ25hdHVyZXMgJHtKU09OLnN0cmluZ2lmeShzaWdzKX0uYDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBwcml2YXRlIGtleSBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkS2V5RXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWwgPSBlcnJvckRldGFpbDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRLZXlFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIHByaXZhdGUga2V5YDtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IGVycm9yRGV0YWlsID8gYCAke2Vycm9yRGV0YWlsfS5gIDogJy4nO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBJbnZhbGlkIFB1YmxpYyBLZXkgYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZFB1YmxpY0tleUVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWNLZXksIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucHVibGljS2V5ID0gcHVibGljS2V5O1xuICAgICAgICB0aGlzLmVycm9yRGV0YWlsID0gZXJyb3JEZXRhaWw7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkUHVibGljS2V5RXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBwdWJsaWMga2V5IFwiJHtwdWJsaWNLZXl9XCJgO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gZXJyb3JEZXRhaWwgPyBgICR7ZXJyb3JEZXRhaWx9LmAgOiAnLic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgc2lnbmF0dXJlIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRTaWduYXR1cmVFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc2lnbmF0dXJlLCBlcnJvckRldGFpbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNpZ25hdHVyZSA9IHNpZ25hdHVyZTtcbiAgICAgICAgdGhpcy5lcnJvckRldGFpbCA9IGVycm9yRGV0YWlsO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFNpZ25hdHVyZUVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYEludmFsaWQgc2lnbmF0dXJlIFwiJHtzaWduYXR1cmV9XCJgO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gZXJyb3JEZXRhaWwgPyBgICR7ZXJyb3JEZXRhaWx9LmAgOiAnLic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgY29udHJhY3QgYWRkcmVzcyBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0QWRkcmVzcywgZXJyb3JEZXRhaWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jb250cmFjdEFkZHJlc3MgPSBjb250cmFjdEFkZHJlc3M7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWwgPSBlcnJvckRldGFpbDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIGNvbnRyYWN0IGFkZHJlc3MgXCIke2NvbnRyYWN0QWRkcmVzc31cImA7XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSBlcnJvckRldGFpbCA/IGAgJHtlcnJvckRldGFpbH0uYCA6ICcuJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBjaGFpbiBpZCBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkQ2hhaW5JZEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihjaGFpbklkLCBlcnJvckRldGFpbCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNoYWluSWQgPSBjaGFpbklkO1xuICAgICAgICB0aGlzLmVycm9yRGV0YWlsID0gZXJyb3JEZXRhaWw7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkQ2hhaW5JZEVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYEludmFsaWQgY2hhaW4gaWQgXCIke2NoYWluSWR9XCJgO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gZXJyb3JEZXRhaWwgPyBgICR7ZXJyb3JEZXRhaWx9LmAgOiAnLic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgcHVibGljIGtleSBoYXNoIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRLZXlIYXNoRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGtleUhhc2gsIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMua2V5SGFzaCA9IGtleUhhc2g7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWwgPSBlcnJvckRldGFpbDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRLZXlIYXNoRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBwdWJsaWMga2V5IGhhc2ggXCIke2tleUhhc2h9XCJgO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgKz0gZXJyb3JEZXRhaWwgPyBgICR7ZXJyb3JEZXRhaWx9LmAgOiAnLic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgb3BlcmF0aW9uIGhhc2ggYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZE9wZXJhdGlvbkhhc2hFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3BlcmF0aW9uSGFzaCwgZXJyb3JEZXRhaWwpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25IYXNoID0gb3BlcmF0aW9uSGFzaDtcbiAgICAgICAgdGhpcy5lcnJvckRldGFpbCA9IGVycm9yRGV0YWlsO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZE9wZXJhdGlvbkhhc2hFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIG9wZXJhdGlvbiBoYXNoIFwiJHtvcGVyYXRpb25IYXNofVwiYDtcbiAgICAgICAgdGhpcy5tZXNzYWdlICs9IGVycm9yRGV0YWlsID8gYCAke2Vycm9yRGV0YWlsfS5gIDogJy4nO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIG9wZXJhdGlvbiBraW5kIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRPcGVyYXRpb25LaW5kRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9wZXJhdGlvbktpbmQsIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uS2luZCA9IG9wZXJhdGlvbktpbmQ7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWwgPSBlcnJvckRldGFpbDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRPcGVyYXRpb25LaW5kRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBvcGVyYXRpb24ga2luZCBcIiR7b3BlcmF0aW9uS2luZH1cImA7XG4gICAgICAgIHRoaXMubWVzc2FnZSArPSBlcnJvckRldGFpbCA/IGAgJHtlcnJvckRldGFpbH0uYCA6ICcuJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gR2VuZXJhbCBlcnJvciB0aGF0IGluZGljYXRlcyBzb21ldGhpbmcgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCBhbmQvb3IgZGVwcmVjYXRlZFxuICovXG5jbGFzcyBEZXByZWNhdGlvbkVycm9yIGV4dGVuZHMgVW5zdXBwb3J0ZWRBY3Rpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRGVwcmVjYXRpb25FcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEdlbmVyYWwgZXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gYWN0aW9uIGlzIHByb2hpYml0ZWQgb3Igbm90IGFsbG93ZWRcbiAqL1xuY2xhc3MgUHJvaGliaXRlZEFjdGlvbkVycm9yIGV4dGVuZHMgVW5zdXBwb3J0ZWRBY3Rpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnUHJvaGliaXRlZEFjdGlvbkVycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGluIGdyYWJiaW5nIHRoZSBwdWJsaWMga2V5XG4gKi9cbmNsYXNzIFB1YmxpY0tleU5vdEZvdW5kRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHBraCwgY2F1c2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wa2ggPSBwa2g7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1B1YmxpY0tleU5vdEZvdW5kRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgUHVibGljIGtleSBub3QgZm91bmQgb2YgdGhpcyBhZGRyZXNzIFwiJHtwa2h9XCIgaW4gZWl0aGVyIHdhbGxldCBvciBjb250cmFjdCBBUEkuYDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IERlcHJlY2F0aW9uRXJyb3IsIEludmFsaWRBZGRyZXNzRXJyb3IsIEludmFsaWRBbW91bnRFcnJvciwgSW52YWxpZEJsb2NrSGFzaEVycm9yLCBJbnZhbGlkQ2hhaW5JZEVycm9yLCBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IsIEludmFsaWREZXJpdmF0aW9uUGF0aEVycm9yLCBJbnZhbGlkSGV4U3RyaW5nRXJyb3IsIEludmFsaWRLZXlFcnJvciwgSW52YWxpZEtleUhhc2hFcnJvciwgSW52YWxpZE1lc3NhZ2VFcnJvciwgSW52YWxpZE9wZXJhdGlvbkhhc2hFcnJvciwgSW52YWxpZE9wZXJhdGlvbktpbmRFcnJvciwgSW52YWxpZFB1YmxpY0tleUVycm9yLCBJbnZhbGlkU2lnbmF0dXJlRXJyb3IsIEludmFsaWRWaWV3UGFyYW1ldGVyRXJyb3IsIE5ldHdvcmtFcnJvciwgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yLCBQZXJtaXNzaW9uRGVuaWVkRXJyb3IsIFByb2hpYml0ZWRBY3Rpb25FcnJvciwgUHVibGljS2V5Tm90Rm91bmRFcnJvciwgUnBjRXJyb3IsIFRhcXVpdG9FcnJvciwgVGV6b3NUb29sa2l0Q29uZmlnRXJyb3IsIFVuc3VwcG9ydGVkQWN0aW9uRXJyb3IgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcXVpdG8tY29yZS5lczYuanMubWFwXG4iXSwibmFtZXMiOlsiVGFxdWl0b0Vycm9yIiwiRXJyb3IiLCJQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3IiLCJScGNFcnJvciIsIlRlem9zVG9vbGtpdENvbmZpZ0Vycm9yIiwiVW5zdXBwb3J0ZWRBY3Rpb25FcnJvciIsIk5ldHdvcmtFcnJvciIsIlBlcm1pc3Npb25EZW5pZWRFcnJvciIsIkludmFsaWRBZGRyZXNzRXJyb3IiLCJjb25zdHJ1Y3RvciIsImFkZHJlc3MiLCJlcnJvckRldGFpbCIsIm5hbWUiLCJtZXNzYWdlIiwiSW52YWxpZEJsb2NrSGFzaEVycm9yIiwiYmxvY2tIYXNoIiwiSW52YWxpZEFtb3VudEVycm9yIiwiYW1vdW50IiwiSW52YWxpZERlcml2YXRpb25QYXRoRXJyb3IiLCJkZXJpdmF0aW9uUGF0aCIsIkludmFsaWRIZXhTdHJpbmdFcnJvciIsImhleFN0cmluZyIsIkludmFsaWRNZXNzYWdlRXJyb3IiLCJtc2ciLCJJbnZhbGlkVmlld1BhcmFtZXRlckVycm9yIiwidmlld05hbWUiLCJzaWdzIiwiYXJncyIsImNhdXNlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkludmFsaWRLZXlFcnJvciIsIkludmFsaWRQdWJsaWNLZXlFcnJvciIsInB1YmxpY0tleSIsIkludmFsaWRTaWduYXR1cmVFcnJvciIsInNpZ25hdHVyZSIsIkludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvciIsImNvbnRyYWN0QWRkcmVzcyIsIkludmFsaWRDaGFpbklkRXJyb3IiLCJjaGFpbklkIiwiSW52YWxpZEtleUhhc2hFcnJvciIsImtleUhhc2giLCJJbnZhbGlkT3BlcmF0aW9uSGFzaEVycm9yIiwib3BlcmF0aW9uSGFzaCIsIkludmFsaWRPcGVyYXRpb25LaW5kRXJyb3IiLCJvcGVyYXRpb25LaW5kIiwiRGVwcmVjYXRpb25FcnJvciIsIlByb2hpYml0ZWRBY3Rpb25FcnJvciIsIlB1YmxpY0tleU5vdEZvdW5kRXJyb3IiLCJwa2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/http-utils/dist/taquito-http-utils.es6.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@taquito/http-utils/dist/taquito-http-utils.es6.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   HttpBackend: () => (/* binding */ HttpBackend),\n/* harmony export */   HttpRequestFailed: () => (/* binding */ HttpRequestFailed),\n/* harmony export */   HttpResponseError: () => (/* binding */ HttpResponseError),\n/* harmony export */   HttpTimeoutError: () => (/* binding */ HttpTimeoutError),\n/* harmony export */   STATUS_CODE: () => (/* binding */ STATUS_CODE),\n/* harmony export */   VERSION: () => (/* binding */ VERSION)\n/* harmony export */ });\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n/**\n *  @category Error\n *  @description Error that indicates a general failure in making the HTTP request\n */ class HttpRequestFailed extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.NetworkError {\n    constructor(method, url, cause){\n        super();\n        this.method = method;\n        this.url = url;\n        this.cause = cause;\n        this.name = \"HttpRequestFailed\";\n        this.message = `${method} ${url} ${String(cause)}`;\n    }\n}\n/**\n *  @category Error\n *  @description Error thrown when the endpoint returns an HTTP error to the client\n */ class HttpResponseError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.NetworkError {\n    constructor(message, status, statusText, body, url){\n        super();\n        this.message = message;\n        this.status = status;\n        this.statusText = statusText;\n        this.body = body;\n        this.url = url;\n        this.name = \"HttpResponseError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error\n */ class HttpTimeoutError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.NetworkError {\n    constructor(timeout, url){\n        super();\n        this.timeout = timeout;\n        this.url = url;\n        this.name = \"HttpTimeoutError\";\n        this.message = `HTTP request timeout of ${timeout}ms exceeded`;\n    }\n}\n/**\n * Hypertext Transfer Protocol (HTTP) response status codes.\n * @see {@link https://en.wikipedia.org/wiki/List_of_HTTP_status_codes}\n */ var STATUS_CODE;\n(function(STATUS_CODE) {\n    /**\n     * The server has received the request headers and the client should proceed to send the request body\n     * (in the case of a request for which a body needs to be sent; for example, a POST request).\n     * Sending a large request body to a server after a request has been rejected for inappropriate headers would be inefficient.\n     * To have a server check the request's headers, a client must send Expect: 100-continue as a header in its initial request\n     * and receive a 100 Continue status code in response before sending the body. The response 417 Expectation Failed indicates the request should not be continued.\n     */ STATUS_CODE[STATUS_CODE[\"CONTINUE\"] = 100] = \"CONTINUE\";\n    /**\n     * The requester has asked the server to switch protocols and the server has agreed to do so.\n     */ STATUS_CODE[STATUS_CODE[\"SWITCHING_PROTOCOLS\"] = 101] = \"SWITCHING_PROTOCOLS\";\n    /**\n     * A WebDAV request may contain many sub-requests involving file operations, requiring a long time to complete the request.\n     * This code indicates that the server has received and is processing the request, but no response is available yet.\n     * This prevents the client from timing out and assuming the request was lost.\n     */ STATUS_CODE[STATUS_CODE[\"PROCESSING\"] = 102] = \"PROCESSING\";\n    /**\n     * Standard response for successful HTTP requests.\n     * The actual response will depend on the request method used.\n     * In a GET request, the response will contain an entity corresponding to the requested resource.\n     * In a POST request, the response will contain an entity describing or containing the result of the action.\n     */ STATUS_CODE[STATUS_CODE[\"OK\"] = 200] = \"OK\";\n    /**\n     * The request has been fulfilled, resulting in the creation of a new resource.\n     */ STATUS_CODE[STATUS_CODE[\"CREATED\"] = 201] = \"CREATED\";\n    /**\n     * The request has been accepted for processing, but the processing has not been completed.\n     * The request might or might not be eventually acted upon, and may be disallowed when processing occurs.\n     */ STATUS_CODE[STATUS_CODE[\"ACCEPTED\"] = 202] = \"ACCEPTED\";\n    /**\n     * SINCE HTTP/1.1\n     * The server is a transforming proxy that received a 200 OK from its origin,\n     * but is returning a modified version of the origin's response.\n     */ STATUS_CODE[STATUS_CODE[\"NON_AUTHORITATIVE_INFORMATION\"] = 203] = \"NON_AUTHORITATIVE_INFORMATION\";\n    /**\n     * The server successfully processed the request and is not returning any content.\n     */ STATUS_CODE[STATUS_CODE[\"NO_CONTENT\"] = 204] = \"NO_CONTENT\";\n    /**\n     * The server successfully processed the request, but is not returning any content.\n     * Unlike a 204 response, this response requires that the requester reset the document view.\n     */ STATUS_CODE[STATUS_CODE[\"RESET_CONTENT\"] = 205] = \"RESET_CONTENT\";\n    /**\n     * The server is delivering only part of the resource (byte serving) due to a range header sent by the client.\n     * The range header is used by HTTP clients to enable resuming of interrupted downloads,\n     * or split a download into multiple simultaneous streams.\n     */ STATUS_CODE[STATUS_CODE[\"PARTIAL_CONTENT\"] = 206] = \"PARTIAL_CONTENT\";\n    /**\n     * The message body that follows is an XML message and can contain a number of separate response codes,\n     * depending on how many sub-requests were made.\n     */ STATUS_CODE[STATUS_CODE[\"MULTI_STATUS\"] = 207] = \"MULTI_STATUS\";\n    /**\n     * The members of a DAV binding have already been enumerated in a preceding part of the (multistatus) response,\n     * and are not being included again.\n     */ STATUS_CODE[STATUS_CODE[\"ALREADY_REPORTED\"] = 208] = \"ALREADY_REPORTED\";\n    /**\n     * The server has fulfilled a request for the resource,\n     * and the response is a representation of the result of one or more instance-manipulations applied to the current instance.\n     */ STATUS_CODE[STATUS_CODE[\"IM_USED\"] = 226] = \"IM_USED\";\n    /**\n     * Indicates multiple options for the resource from which the client may choose (via agent-driven content negotiation).\n     * For example, this code could be used to present multiple video format options,\n     * to list files with different filename extensions, or to suggest word-sense disambiguation.\n     */ STATUS_CODE[STATUS_CODE[\"MULTIPLE_CHOICES\"] = 300] = \"MULTIPLE_CHOICES\";\n    /**\n     * This and all future requests should be directed to the given URI.\n     */ STATUS_CODE[STATUS_CODE[\"MOVED_PERMANENTLY\"] = 301] = \"MOVED_PERMANENTLY\";\n    /**\n     * This is an example of industry practice contradicting the standard.\n     * The HTTP/1.0 specification (RFC 1945) required the client to perform a temporary redirect\n     * (the original describing phrase was \"Moved Temporarily\"), but popular browsers implemented 302\n     * with the functionality of a 303 See Other. Therefore, HTTP/1.1 added status codes 303 and 307\n     * to distinguish between the two behaviours. However, some Web applications and frameworks\n     * use the 302 status code as if it were the 303.\n     */ STATUS_CODE[STATUS_CODE[\"FOUND\"] = 302] = \"FOUND\";\n    /**\n     * SINCE HTTP/1.1\n     * The response to the request can be found under another URI using a GET method.\n     * When received in response to a POST (or PUT/DELETE), the client should presume that\n     * the server has received the data and should issue a redirect with a separate GET message.\n     */ STATUS_CODE[STATUS_CODE[\"SEE_OTHER\"] = 303] = \"SEE_OTHER\";\n    /**\n     * Indicates that the resource has not been modified since the version specified by the request headers If-Modified-Since or If-None-Match.\n     * In such case, there is no need to retransmit the resource since the client still has a previously-downloaded copy.\n     */ STATUS_CODE[STATUS_CODE[\"NOT_MODIFIED\"] = 304] = \"NOT_MODIFIED\";\n    /**\n     * SINCE HTTP/1.1\n     * The requested resource is available only through a proxy, the address for which is provided in the response.\n     * Many HTTP clients (such as Mozilla and Internet Explorer) do not correctly handle responses with this status code, primarily for security reasons.\n     */ STATUS_CODE[STATUS_CODE[\"USE_PROXY\"] = 305] = \"USE_PROXY\";\n    /**\n     * No longer used. Originally meant \"Subsequent requests should use the specified proxy.\"\n     */ STATUS_CODE[STATUS_CODE[\"SWITCH_PROXY\"] = 306] = \"SWITCH_PROXY\";\n    /**\n     * SINCE HTTP/1.1\n     * In this case, the request should be repeated with another URI; however, future requests should still use the original URI.\n     * In contrast to how 302 was historically implemented, the request method is not allowed to be changed when reissuing the original request.\n     * For example, a POST request should be repeated using another POST request.\n     */ STATUS_CODE[STATUS_CODE[\"TEMPORARY_REDIRECT\"] = 307] = \"TEMPORARY_REDIRECT\";\n    /**\n     * The request and all future requests should be repeated using another URI.\n     * 307 and 308 parallel the behaviors of 302 and 301, but do not allow the HTTP method to change.\n     * So, for example, submitting a form to a permanently redirected resource may continue smoothly.\n     */ STATUS_CODE[STATUS_CODE[\"PERMANENT_REDIRECT\"] = 308] = \"PERMANENT_REDIRECT\";\n    /**\n     * The server cannot or will not process the request due to an apparent client error\n     * (e.g., malformed request syntax, too large size, invalid request message framing, or deceptive request routing).\n     */ STATUS_CODE[STATUS_CODE[\"BAD_REQUEST\"] = 400] = \"BAD_REQUEST\";\n    /**\n     * Similar to 403 Forbidden, but specifically for use when authentication is required and has failed or has not yet\n     * been provided. The response must include a WWW-Authenticate header field containing a challenge applicable to the\n     * requested resource. See Basic access authentication and Digest access authentication. 401 semantically means\n     * \"unauthenticated\",i.e. the user does not have the necessary credentials.\n     */ STATUS_CODE[STATUS_CODE[\"UNAUTHORIZED\"] = 401] = \"UNAUTHORIZED\";\n    /**\n     * Reserved for future use. The original intention was that this code might be used as part of some form of digital\n     * cash or micro payment scheme, but that has not happened, and this code is not usually used.\n     * Google Developers API uses this status if a particular developer has exceeded the daily limit on requests.\n     */ STATUS_CODE[STATUS_CODE[\"PAYMENT_REQUIRED\"] = 402] = \"PAYMENT_REQUIRED\";\n    /**\n     * The request was valid, but the server is refusing action.\n     * The user might not have the necessary permissions for a resource.\n     */ STATUS_CODE[STATUS_CODE[\"FORBIDDEN\"] = 403] = \"FORBIDDEN\";\n    /**\n     * The requested resource could not be found but may be available in the future.\n     * Subsequent requests by the client are permissible.\n     */ STATUS_CODE[STATUS_CODE[\"NOT_FOUND\"] = 404] = \"NOT_FOUND\";\n    /**\n     * A request method is not supported for the requested resource;\n     * for example, a GET request on a form that requires data to be presented via POST, or a PUT request on a read-only resource.\n     */ STATUS_CODE[STATUS_CODE[\"METHOD_NOT_ALLOWED\"] = 405] = \"METHOD_NOT_ALLOWED\";\n    /**\n     * The requested resource is capable of generating only content not acceptable according to the Accept headers sent in the request.\n     */ STATUS_CODE[STATUS_CODE[\"NOT_ACCEPTABLE\"] = 406] = \"NOT_ACCEPTABLE\";\n    /**\n     * The client must first authenticate itself with the proxy.\n     */ STATUS_CODE[STATUS_CODE[\"PROXY_AUTHENTICATION_REQUIRED\"] = 407] = \"PROXY_AUTHENTICATION_REQUIRED\";\n    /**\n     * The server timed out waiting for the request.\n     * According to HTTP specifications:\n     * \"The client did not produce a request within the time that the server was prepared to wait. The client MAY repeat the request without modifications at any later time.\"\n     */ STATUS_CODE[STATUS_CODE[\"REQUEST_TIMEOUT\"] = 408] = \"REQUEST_TIMEOUT\";\n    /**\n     * Indicates that the request could not be processed because of conflict in the request,\n     * such as an edit conflict between multiple simultaneous updates.\n     */ STATUS_CODE[STATUS_CODE[\"CONFLICT\"] = 409] = \"CONFLICT\";\n    /**\n     * Indicates that the resource requested is no longer available and will not be available again.\n     * This should be used when a resource has been intentionally removed and the resource should be purged.\n     * Upon receiving a 410 status code, the client should not request the resource in the future.\n     * Clients such as search engines should remove the resource from their indices.\n     * Most use cases do not require clients and search engines to purge the resource, and a \"404 Not Found\" may be used instead.\n     */ STATUS_CODE[STATUS_CODE[\"GONE\"] = 410] = \"GONE\";\n    /**\n     * The request did not specify the length of its content, which is required by the requested resource.\n     */ STATUS_CODE[STATUS_CODE[\"LENGTH_REQUIRED\"] = 411] = \"LENGTH_REQUIRED\";\n    /**\n     * The server does not meet one of the preconditions that the requester put on the request.\n     */ STATUS_CODE[STATUS_CODE[\"PRECONDITION_FAILED\"] = 412] = \"PRECONDITION_FAILED\";\n    /**\n     * The request is larger than the server is willing or able to process. Previously called \"Request Entity Too Large\".\n     */ STATUS_CODE[STATUS_CODE[\"PAYLOAD_TOO_LARGE\"] = 413] = \"PAYLOAD_TOO_LARGE\";\n    /**\n     * The URI provided was too long for the server to process. Often the result of too much data being encoded as a query-string of a GET request,\n     * in which case it should be converted to a POST request.\n     * Called \"Request-URI Too Long\" previously.\n     */ STATUS_CODE[STATUS_CODE[\"URI_TOO_LONG\"] = 414] = \"URI_TOO_LONG\";\n    /**\n     * The request entity has a media type which the server or resource does not support.\n     * For example, the client uploads an image as image/svg+xml, but the server requires that images use a different format.\n     */ STATUS_CODE[STATUS_CODE[\"UNSUPPORTED_MEDIA_TYPE\"] = 415] = \"UNSUPPORTED_MEDIA_TYPE\";\n    /**\n     * The client has asked for a portion of the file (byte serving), but the server cannot supply that portion.\n     * For example, if the client asked for a part of the file that lies beyond the end of the file.\n     * Called \"Requested Range Not Satisfiable\" previously.\n     */ STATUS_CODE[STATUS_CODE[\"RANGE_NOT_SATISFIABLE\"] = 416] = \"RANGE_NOT_SATISFIABLE\";\n    /**\n     * The server cannot meet the requirements of the Expect request-header field.\n     */ STATUS_CODE[STATUS_CODE[\"EXPECTATION_FAILED\"] = 417] = \"EXPECTATION_FAILED\";\n    /**\n     * This code was defined in 1998 as one of the traditional IETF April Fools' jokes, in RFC 2324, Hyper Text Coffee Pot Control Protocol,\n     * and is not expected to be implemented by actual HTTP servers. The RFC specifies this code should be returned by\n     * teapots requested to brew coffee. This HTTP status is used as an Easter egg in some websites, including Google.com.\n     */ STATUS_CODE[STATUS_CODE[\"I_AM_A_TEAPOT\"] = 418] = \"I_AM_A_TEAPOT\";\n    /**\n     * The request was directed at a server that is not able to produce a response (for example because a connection reuse).\n     */ STATUS_CODE[STATUS_CODE[\"MISDIRECTED_REQUEST\"] = 421] = \"MISDIRECTED_REQUEST\";\n    /**\n     * The request was well-formed but was unable to be followed due to semantic errors.\n     */ STATUS_CODE[STATUS_CODE[\"UNPROCESSABLE_ENTITY\"] = 422] = \"UNPROCESSABLE_ENTITY\";\n    /**\n     * The resource that is being accessed is locked.\n     */ STATUS_CODE[STATUS_CODE[\"LOCKED\"] = 423] = \"LOCKED\";\n    /**\n     * The request failed due to failure of a previous request (e.g., a PROPPATCH).\n     */ STATUS_CODE[STATUS_CODE[\"FAILED_DEPENDENCY\"] = 424] = \"FAILED_DEPENDENCY\";\n    /**\n     * The client should switch to a different protocol such as TLS/1.0, given in the Upgrade header field.\n     */ STATUS_CODE[STATUS_CODE[\"UPGRADE_REQUIRED\"] = 426] = \"UPGRADE_REQUIRED\";\n    /**\n     * The origin server requires the request to be conditional.\n     * Intended to prevent \"the 'lost update' problem, where a client\n     * GETs a resource's state, modifies it, and PUTs it back to the server,\n     * when meanwhile a third party has modified the state on the server, leading to a conflict.\"\n     */ STATUS_CODE[STATUS_CODE[\"PRECONDITION_REQUIRED\"] = 428] = \"PRECONDITION_REQUIRED\";\n    /**\n     * The user has sent too many requests in a given amount of time. Intended for use with rate-limiting schemes.\n     */ STATUS_CODE[STATUS_CODE[\"TOO_MANY_REQUESTS\"] = 429] = \"TOO_MANY_REQUESTS\";\n    /**\n     * The server is unwilling to process the request because either an individual header field,\n     * or all the header fields collectively, are too large.\n     */ STATUS_CODE[STATUS_CODE[\"REQUEST_HEADER_FIELDS_TOO_LARGE\"] = 431] = \"REQUEST_HEADER_FIELDS_TOO_LARGE\";\n    /**\n     * A server operator has received a legal demand to deny access to a resource or to a set of resources\n     * that includes the requested resource. The code 451 was chosen as a reference to the novel Fahrenheit 451.\n     */ STATUS_CODE[STATUS_CODE[\"UNAVAILABLE_FOR_LEGAL_REASONS\"] = 451] = \"UNAVAILABLE_FOR_LEGAL_REASONS\";\n    /**\n     * A generic error message, given when an unexpected condition was encountered and no more specific message is suitable.\n     */ STATUS_CODE[STATUS_CODE[\"INTERNAL_SERVER_ERROR\"] = 500] = \"INTERNAL_SERVER_ERROR\";\n    /**\n     * The server either does not recognize the request method, or it lacks the ability to fulfill the request.\n     * Usually this implies future availability (e.g., a new feature of a web-service API).\n     */ STATUS_CODE[STATUS_CODE[\"NOT_IMPLEMENTED\"] = 501] = \"NOT_IMPLEMENTED\";\n    /**\n     * The server was acting as a gateway or proxy and received an invalid response from the upstream server.\n     */ STATUS_CODE[STATUS_CODE[\"BAD_GATEWAY\"] = 502] = \"BAD_GATEWAY\";\n    /**\n     * The server is currently unavailable (because it is overloaded or down for maintenance).\n     * Generally, this is a temporary state.\n     */ STATUS_CODE[STATUS_CODE[\"SERVICE_UNAVAILABLE\"] = 503] = \"SERVICE_UNAVAILABLE\";\n    /**\n     * The server was acting as a gateway or proxy and did not receive a timely response from the upstream server.\n     */ STATUS_CODE[STATUS_CODE[\"GATEWAY_TIMEOUT\"] = 504] = \"GATEWAY_TIMEOUT\";\n    /**\n     * The server does not support the HTTP protocol version used in the request\n     */ STATUS_CODE[STATUS_CODE[\"HTTP_VERSION_NOT_SUPPORTED\"] = 505] = \"HTTP_VERSION_NOT_SUPPORTED\";\n    /**\n     * Transparent content negotiation for the request results in a circular reference.\n     */ STATUS_CODE[STATUS_CODE[\"VARIANT_ALSO_NEGOTIATES\"] = 506] = \"VARIANT_ALSO_NEGOTIATES\";\n    /**\n     * The server is unable to store the representation needed to complete the request.\n     */ STATUS_CODE[STATUS_CODE[\"INSUFFICIENT_STORAGE\"] = 507] = \"INSUFFICIENT_STORAGE\";\n    /**\n     * The server detected an infinite loop while processing the request.\n     */ STATUS_CODE[STATUS_CODE[\"LOOP_DETECTED\"] = 508] = \"LOOP_DETECTED\";\n    /**\n     * Further extensions to the request are required for the server to fulfill it.\n     */ STATUS_CODE[STATUS_CODE[\"NOT_EXTENDED\"] = 510] = \"NOT_EXTENDED\";\n    /**\n     * The client needs to authenticate to gain network access.\n     * Intended for use by intercepting proxies used to control access to the network (e.g., \"captive portals\" used\n     * to require agreement to Terms of Service before granting full Internet access via a Wi-Fi hotspot).\n     */ STATUS_CODE[STATUS_CODE[\"NETWORK_AUTHENTICATION_REQUIRED\"] = 511] = \"NETWORK_AUTHENTICATION_REQUIRED\";\n})(STATUS_CODE || (STATUS_CODE = {}));\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\n/**\n * @packageDocumentation\n * @module @taquito/http-utils\n */ var _a;\nlet fetch = globalThis === null || globalThis === void 0 ? void 0 : globalThis.fetch;\n// Will only use browser fetch if we are in a browser environment,\n// default to the more stable node-fetch otherwise\nconst isNode = typeof process !== \"undefined\" && !!((_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node);\nif (isNode) {\n    fetch = __webpack_require__(/*! node-fetch */ \"(ssr)/./node_modules/node-fetch/lib/index.mjs\");\n}\nclass HttpBackend {\n    constructor(timeout = 30000){\n        this.timeout = timeout;\n    }\n    serialize(obj) {\n        if (!obj) {\n            return \"\";\n        }\n        const str = [];\n        for(const p in obj){\n            // eslint-disable-next-line no-prototype-builtins\n            if (obj.hasOwnProperty(p) && typeof obj[p] !== \"undefined\") {\n                const prop = typeof obj[p].toJSON === \"function\" ? obj[p].toJSON() : obj[p];\n                // query arguments can have no value so we need some way of handling that\n                // example https://domain.com/query?all\n                if (prop === null) {\n                    str.push(encodeURIComponent(p));\n                    continue;\n                }\n                // another use case is multiple arguments with the same name\n                // they are passed as array\n                if (Array.isArray(prop)) {\n                    prop.forEach((item)=>{\n                        str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(item));\n                    });\n                    continue;\n                }\n                str.push(encodeURIComponent(p) + \"=\" + encodeURIComponent(prop));\n            }\n        }\n        const serialized = str.join(\"&\");\n        if (serialized) {\n            return `?${serialized}`;\n        } else {\n            return \"\";\n        }\n    }\n    /**\n     *\n     * @param options contains options to be passed for the HTTP request (url, method and timeout)\n     * @throws {@link HttpRequestFailed} | {@link HttpResponseError} | {@link HttpTimeoutError}\n     */ createRequest({ url, method, timeout = this.timeout, query, headers = {}, json = true }, data) {\n        return __awaiter(this, void 0, void 0, function*() {\n            // Serializes query params\n            const urlWithQuery = url + this.serialize(query);\n            // Adds default header entry if there aren't any Content-Type header\n            if (!headers[\"Content-Type\"]) {\n                headers[\"Content-Type\"] = \"application/json\";\n            }\n            // Creates a new AbortController instance to handle timeouts\n            const controller = new AbortController();\n            const t = setTimeout(()=>controller.abort(), timeout);\n            try {\n                const response = yield fetch(urlWithQuery, {\n                    method,\n                    headers,\n                    body: JSON.stringify(data),\n                    signal: controller.signal\n                });\n                if (typeof response === \"undefined\") {\n                    throw new Error(\"Response is undefined\");\n                }\n                // Handle responses with status code >= 400\n                if (response.status >= 400) {\n                    const errorData = yield response.text();\n                    throw new HttpResponseError(`Http error response: (${response.status}) ${errorData}`, response.status, response.statusText, errorData, urlWithQuery);\n                }\n                if (json) {\n                    return response.json();\n                } else {\n                    return response.text();\n                }\n            } catch (e) {\n                if (e instanceof Error && e.name === \"AbortError\") {\n                    throw new HttpTimeoutError(timeout, urlWithQuery);\n                } else if (e instanceof HttpResponseError) {\n                    throw e;\n                } else {\n                    throw new HttpRequestFailed(String(method), urlWithQuery, e);\n                }\n            } finally{\n                clearTimeout(t);\n            }\n        });\n    }\n}\n //# sourceMappingURL=taquito-http-utils.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vaHR0cC11dGlscy9kaXN0L3RhcXVpdG8taHR0cC11dGlscy5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUE2QztBQUU3Qzs7Ozs7Ozs7Ozs7Ozs4RUFhOEUsR0FDOUUsb0RBQW9ELEdBR3BELFNBQVNDLFVBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDaEQsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFBS0gsQ0FBQUEsS0FBTUEsQ0FBQUEsSUFBSUssT0FBTSxDQUFDLEVBQUcsU0FBVUQsT0FBTyxFQUFFRSxNQUFNO1FBQ3JELFNBQVNDLFVBQVVKLEtBQUs7WUFBSSxJQUFJO2dCQUFFSyxLQUFLUCxVQUFVUSxJQUFJLENBQUNOO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDMUYsU0FBU0MsU0FBU1IsS0FBSztZQUFJLElBQUk7Z0JBQUVLLEtBQUtQLFNBQVMsQ0FBQyxRQUFRLENBQUNFO1lBQVMsRUFBRSxPQUFPTyxHQUFHO2dCQUFFSixPQUFPSTtZQUFJO1FBQUU7UUFDN0YsU0FBU0YsS0FBS0ksTUFBTTtZQUFJQSxPQUFPQyxJQUFJLEdBQUdULFFBQVFRLE9BQU9ULEtBQUssSUFBSUQsTUFBTVUsT0FBT1QsS0FBSyxFQUFFVyxJQUFJLENBQUNQLFdBQVdJO1FBQVc7UUFDN0dILEtBQUssQ0FBQ1AsWUFBWUEsVUFBVWMsS0FBSyxDQUFDakIsU0FBU0MsY0FBYyxFQUFFLEdBQUdVLElBQUk7SUFDdEU7QUFDSjtBQUVBLE9BQU9PLG9CQUFvQixhQUFhQSxrQkFBa0IsU0FBVUMsS0FBSyxFQUFFQyxVQUFVLEVBQUVDLE9BQU87SUFDMUYsSUFBSVQsSUFBSSxJQUFJVSxNQUFNRDtJQUNs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LFdBQVdJLEtBQUssSUFBSXJDO1lBQy9DLElBQUk7Z0JBQ0EsTUFBTXNDLFdBQVcsTUFBTWxDLE1BQU00QixjQUFjO29CQUN2Q3pDO29CQUNBc0M7b0JBQ0EvQixNQUFNeUMsS0FBS0MsU0FBUyxDQUFDVDtvQkFDckJVLFFBQVFSLFdBQVdRLE1BQU07Z0JBQzdCO2dCQUNBLElBQUksT0FBT0gsYUFBYSxhQUFhO29CQUNqQyxNQUFNLElBQUluRCxNQUFNO2dCQUNwQjtnQkFDQSwyQ0FBMkM7Z0JBQzNDLElBQUltRCxTQUFTMUMsTUFBTSxJQUFJLEtBQUs7b0JBQ3hCLE1BQU04QyxZQUFZLE1BQU1KLFNBQVNLLElBQUk7b0JBQ3JDLE1BQU0sSUFBSWhELGtCQUFrQixDQUFDLHNCQUFzQixFQUFFMkMsU0FBUzFDLE1BQU0sQ0FBQyxFQUFFLEVBQUU4QyxVQUFVLENBQUMsRUFBRUosU0FBUzFDLE1BQU0sRUFBRTBDLFNBQVN6QyxVQUFVLEVBQUU2QyxXQUFXVjtnQkFDM0k7Z0JBQ0EsSUFBSUYsTUFBTTtvQkFDTixPQUFPUSxTQUFTUixJQUFJO2dCQUN4QixPQUNLO29CQUNELE9BQU9RLFNBQVNLLElBQUk7Z0JBQ3hCO1lBQ0osRUFDQSxPQUFPbEUsR0FBRztnQkFDTixJQUFJQSxhQUFhVSxTQUFTVixFQUFFVyxJQUFJLEtBQUssY0FBYztvQkFDL0MsTUFBTSxJQUFJVyxpQkFBaUJDLFNBQVNnQztnQkFDeEMsT0FDSyxJQUFJdkQsYUFBYWtCLG1CQUFtQjtvQkFDckMsTUFBTWxCO2dCQUNWLE9BQ0s7b0JBQ0QsTUFBTSxJQUFJWSxrQkFBa0JLLE9BQU9ILFNBQVN5QyxjQUFjdkQ7Z0JBQzlEO1lBQ0osU0FDUTtnQkFDSm1FLGFBQWFUO1lBQ2pCO1FBQ0o7SUFDSjtBQUNKO0FBRXFHLENBQ3JHLGtEQUFrRCIsInNvdXJjZXMiOlsid2VicGFjazovL3B3cnBlcmtzLy4vbm9kZV9tb2R1bGVzL0B0YXF1aXRvL2h0dHAtdXRpbHMvZGlzdC90YXF1aXRvLWh0dHAtdXRpbHMuZXM2LmpzP2Y5NTQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV0d29ya0Vycm9yIH0gZnJvbSAnQHRhcXVpdG8vY29yZSc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG50eXBlb2YgU3VwcHJlc3NlZEVycm9yID09PSBcImZ1bmN0aW9uXCIgPyBTdXBwcmVzc2VkRXJyb3IgOiBmdW5jdGlvbiAoZXJyb3IsIHN1cHByZXNzZWQsIG1lc3NhZ2UpIHtcclxuICAgIHZhciBlID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xyXG4gICAgcmV0dXJuIGUubmFtZSA9IFwiU3VwcHJlc3NlZEVycm9yXCIsIGUuZXJyb3IgPSBlcnJvciwgZS5zdXBwcmVzc2VkID0gc3VwcHJlc3NlZCwgZTtcclxufTtcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZ2VuZXJhbCBmYWlsdXJlIGluIG1ha2luZyB0aGUgSFRUUCByZXF1ZXN0XG4gKi9cbmNsYXNzIEh0dHBSZXF1ZXN0RmFpbGVkIGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXRob2QsIHVybCwgY2F1c2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdIdHRwUmVxdWVzdEZhaWxlZCc7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGAke21ldGhvZH0gJHt1cmx9ICR7U3RyaW5nKGNhdXNlKX1gO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aHJvd24gd2hlbiB0aGUgZW5kcG9pbnQgcmV0dXJucyBhbiBIVFRQIGVycm9yIHRvIHRoZSBjbGllbnRcbiAqL1xuY2xhc3MgSHR0cFJlc3BvbnNlRXJyb3IgZXh0ZW5kcyBOZXR3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIHN0YXR1cywgc3RhdHVzVGV4dCwgYm9keSwgdXJsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuICAgICAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICAgICAgICB0aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICB0aGlzLnVybCA9IHVybDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0h0dHBSZXNwb25zZUVycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3JcbiAqL1xuY2xhc3MgSHR0cFRpbWVvdXRFcnJvciBleHRlbmRzIE5ldHdvcmtFcnJvciB7XG4gICAgY29uc3RydWN0b3IodGltZW91dCwgdXJsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHRoaXMudXJsID0gdXJsO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSHR0cFRpbWVvdXRFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBIVFRQIHJlcXVlc3QgdGltZW91dCBvZiAke3RpbWVvdXR9bXMgZXhjZWVkZWRgO1xuICAgIH1cbn1cblxuLyoqXG4gKiBIeXBlcnRleHQgVHJhbnNmZXIgUHJvdG9jb2wgKEhUVFApIHJlc3BvbnNlIHN0YXR1cyBjb2Rlcy5cbiAqIEBzZWUge0BsaW5rIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xpc3Rfb2ZfSFRUUF9zdGF0dXNfY29kZXN9XG4gKi9cbnZhciBTVEFUVVNfQ09ERTtcbihmdW5jdGlvbiAoU1RBVFVTX0NPREUpIHtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGhhcyByZWNlaXZlZCB0aGUgcmVxdWVzdCBoZWFkZXJzIGFuZCB0aGUgY2xpZW50IHNob3VsZCBwcm9jZWVkIHRvIHNlbmQgdGhlIHJlcXVlc3QgYm9keVxuICAgICAqIChpbiB0aGUgY2FzZSBvZiBhIHJlcXVlc3QgZm9yIHdoaWNoIGEgYm9keSBuZWVkcyB0byBiZSBzZW50OyBmb3IgZXhhbXBsZSwgYSBQT1NUIHJlcXVlc3QpLlxuICAgICAqIFNlbmRpbmcgYSBsYXJnZSByZXF1ZXN0IGJvZHkgdG8gYSBzZXJ2ZXIgYWZ0ZXIgYSByZXF1ZXN0IGhhcyBiZWVuIHJlamVjdGVkIGZvciBpbmFwcHJvcHJpYXRlIGhlYWRlcnMgd291bGQgYmUgaW5lZmZpY2llbnQuXG4gICAgICogVG8gaGF2ZSBhIHNlcnZlciBjaGVjayB0aGUgcmVxdWVzdCdzIGhlYWRlcnMsIGEgY2xpZW50IG11c3Qgc2VuZCBFeHBlY3Q6IDEwMC1jb250aW51ZSBhcyBhIGhlYWRlciBpbiBpdHMgaW5pdGlhbCByZXF1ZXN0XG4gICAgICogYW5kIHJlY2VpdmUgYSAxMDAgQ29udGludWUgc3RhdHVzIGNvZGUgaW4gcmVzcG9uc2UgYmVmb3JlIHNlbmRpbmcgdGhlIGJvZHkuIFRoZSByZXNwb25zZSA0MTcgRXhwZWN0YXRpb24gRmFpbGVkIGluZGljYXRlcyB0aGUgcmVxdWVzdCBzaG91bGQgbm90IGJlIGNvbnRpbnVlZC5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkNPTlRJTlVFXCJdID0gMTAwXSA9IFwiQ09OVElOVUVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdGVyIGhhcyBhc2tlZCB0aGUgc2VydmVyIHRvIHN3aXRjaCBwcm90b2NvbHMgYW5kIHRoZSBzZXJ2ZXIgaGFzIGFncmVlZCB0byBkbyBzby5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlNXSVRDSElOR19QUk9UT0NPTFNcIl0gPSAxMDFdID0gXCJTV0lUQ0hJTkdfUFJPVE9DT0xTXCI7XG4gICAgLyoqXG4gICAgICogQSBXZWJEQVYgcmVxdWVzdCBtYXkgY29udGFpbiBtYW55IHN1Yi1yZXF1ZXN0cyBpbnZvbHZpbmcgZmlsZSBvcGVyYXRpb25zLCByZXF1aXJpbmcgYSBsb25nIHRpbWUgdG8gY29tcGxldGUgdGhlIHJlcXVlc3QuXG4gICAgICogVGhpcyBjb2RlIGluZGljYXRlcyB0aGF0IHRoZSBzZXJ2ZXIgaGFzIHJlY2VpdmVkIGFuZCBpcyBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0LCBidXQgbm8gcmVzcG9uc2UgaXMgYXZhaWxhYmxlIHlldC5cbiAgICAgKiBUaGlzIHByZXZlbnRzIHRoZSBjbGllbnQgZnJvbSB0aW1pbmcgb3V0IGFuZCBhc3N1bWluZyB0aGUgcmVxdWVzdCB3YXMgbG9zdC5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlBST0NFU1NJTkdcIl0gPSAxMDJdID0gXCJQUk9DRVNTSU5HXCI7XG4gICAgLyoqXG4gICAgICogU3RhbmRhcmQgcmVzcG9uc2UgZm9yIHN1Y2Nlc3NmdWwgSFRUUCByZXF1ZXN0cy5cbiAgICAgKiBUaGUgYWN0dWFsIHJlc3BvbnNlIHdpbGwgZGVwZW5kIG9uIHRoZSByZXF1ZXN0IG1ldGhvZCB1c2VkLlxuICAgICAqIEluIGEgR0VUIHJlcXVlc3QsIHRoZSByZXNwb25zZSB3aWxsIGNvbnRhaW4gYW4gZW50aXR5IGNvcnJlc3BvbmRpbmcgdG8gdGhlIHJlcXVlc3RlZCByZXNvdXJjZS5cbiAgICAgKiBJbiBhIFBPU1QgcmVxdWVzdCwgdGhlIHJlc3BvbnNlIHdpbGwgY29udGFpbiBhbiBlbnRpdHkgZGVzY3JpYmluZyBvciBjb250YWluaW5nIHRoZSByZXN1bHQgb2YgdGhlIGFjdGlvbi5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIk9LXCJdID0gMjAwXSA9IFwiT0tcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBoYXMgYmVlbiBmdWxmaWxsZWQsIHJlc3VsdGluZyBpbiB0aGUgY3JlYXRpb24gb2YgYSBuZXcgcmVzb3VyY2UuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJDUkVBVEVEXCJdID0gMjAxXSA9IFwiQ1JFQVRFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IGhhcyBiZWVuIGFjY2VwdGVkIGZvciBwcm9jZXNzaW5nLCBidXQgdGhlIHByb2Nlc3NpbmcgaGFzIG5vdCBiZWVuIGNvbXBsZXRlZC5cbiAgICAgKiBUaGUgcmVxdWVzdCBtaWdodCBvciBtaWdodCBub3QgYmUgZXZlbnR1YWxseSBhY3RlZCB1cG9uLCBhbmQgbWF5IGJlIGRpc2FsbG93ZWQgd2hlbiBwcm9jZXNzaW5nIG9jY3Vycy5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkFDQ0VQVEVEXCJdID0gMjAyXSA9IFwiQUNDRVBURURcIjtcbiAgICAvKipcbiAgICAgKiBTSU5DRSBIVFRQLzEuMVxuICAgICAqIFRoZSBzZXJ2ZXIgaXMgYSB0cmFuc2Zvcm1pbmcgcHJveHkgdGhhdCByZWNlaXZlZCBhIDIwMCBPSyBmcm9tIGl0cyBvcmlnaW4sXG4gICAgICogYnV0IGlzIHJldHVybmluZyBhIG1vZGlmaWVkIHZlcnNpb24gb2YgdGhlIG9yaWdpbidzIHJlc3BvbnNlLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiTk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT05cIl0gPSAyMDNdID0gXCJOT05fQVVUSE9SSVRBVElWRV9JTkZPUk1BVElPTlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgc3VjY2Vzc2Z1bGx5IHByb2Nlc3NlZCB0aGUgcmVxdWVzdCBhbmQgaXMgbm90IHJldHVybmluZyBhbnkgY29udGVudC5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIk5PX0NPTlRFTlRcIl0gPSAyMDRdID0gXCJOT19DT05URU5UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBzdWNjZXNzZnVsbHkgcHJvY2Vzc2VkIHRoZSByZXF1ZXN0LCBidXQgaXMgbm90IHJldHVybmluZyBhbnkgY29udGVudC5cbiAgICAgKiBVbmxpa2UgYSAyMDQgcmVzcG9uc2UsIHRoaXMgcmVzcG9uc2UgcmVxdWlyZXMgdGhhdCB0aGUgcmVxdWVzdGVyIHJlc2V0IHRoZSBkb2N1bWVudCB2aWV3LlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiUkVTRVRfQ09OVEVOVFwiXSA9IDIwNV0gPSBcIlJFU0VUX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGlzIGRlbGl2ZXJpbmcgb25seSBwYXJ0IG9mIHRoZSByZXNvdXJjZSAoYnl0ZSBzZXJ2aW5nKSBkdWUgdG8gYSByYW5nZSBoZWFkZXIgc2VudCBieSB0aGUgY2xpZW50LlxuICAgICAqIFRoZSByYW5nZSBoZWFkZXIgaXMgdXNlZCBieSBIVFRQIGNsaWVudHMgdG8gZW5hYmxlIHJlc3VtaW5nIG9mIGludGVycnVwdGVkIGRvd25sb2FkcyxcbiAgICAgKiBvciBzcGxpdCBhIGRvd25sb2FkIGludG8gbXVsdGlwbGUgc2ltdWx0YW5lb3VzIHN0cmVhbXMuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJQQVJUSUFMX0NPTlRFTlRcIl0gPSAyMDZdID0gXCJQQVJUSUFMX0NPTlRFTlRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVzc2FnZSBib2R5IHRoYXQgZm9sbG93cyBpcyBhbiBYTUwgbWVzc2FnZSBhbmQgY2FuIGNvbnRhaW4gYSBudW1iZXIgb2Ygc2VwYXJhdGUgcmVzcG9uc2UgY29kZXMsXG4gICAgICogZGVwZW5kaW5nIG9uIGhvdyBtYW55IHN1Yi1yZXF1ZXN0cyB3ZXJlIG1hZGUuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJNVUxUSV9TVEFUVVNcIl0gPSAyMDddID0gXCJNVUxUSV9TVEFUVVNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgbWVtYmVycyBvZiBhIERBViBiaW5kaW5nIGhhdmUgYWxyZWFkeSBiZWVuIGVudW1lcmF0ZWQgaW4gYSBwcmVjZWRpbmcgcGFydCBvZiB0aGUgKG11bHRpc3RhdHVzKSByZXNwb25zZSxcbiAgICAgKiBhbmQgYXJlIG5vdCBiZWluZyBpbmNsdWRlZCBhZ2Fpbi5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkFMUkVBRFlfUkVQT1JURURcIl0gPSAyMDhdID0gXCJBTFJFQURZX1JFUE9SVEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBoYXMgZnVsZmlsbGVkIGEgcmVxdWVzdCBmb3IgdGhlIHJlc291cmNlLFxuICAgICAqIGFuZCB0aGUgcmVzcG9uc2UgaXMgYSByZXByZXNlbnRhdGlvbiBvZiB0aGUgcmVzdWx0IG9mIG9uZSBvciBtb3JlIGluc3RhbmNlLW1hbmlwdWxhdGlvbnMgYXBwbGllZCB0byB0aGUgY3VycmVudCBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIklNX1VTRURcIl0gPSAyMjZdID0gXCJJTV9VU0VEXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIG11bHRpcGxlIG9wdGlvbnMgZm9yIHRoZSByZXNvdXJjZSBmcm9tIHdoaWNoIHRoZSBjbGllbnQgbWF5IGNob29zZSAodmlhIGFnZW50LWRyaXZlbiBjb250ZW50IG5lZ290aWF0aW9uKS5cbiAgICAgKiBGb3IgZXhhbXBsZSwgdGhpcyBjb2RlIGNvdWxkIGJlIHVzZWQgdG8gcHJlc2VudCBtdWx0aXBsZSB2aWRlbyBmb3JtYXQgb3B0aW9ucyxcbiAgICAgKiB0byBsaXN0IGZpbGVzIHdpdGggZGlmZmVyZW50IGZpbGVuYW1lIGV4dGVuc2lvbnMsIG9yIHRvIHN1Z2dlc3Qgd29yZC1zZW5zZSBkaXNhbWJpZ3VhdGlvbi5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIk1VTFRJUExFX0NIT0lDRVNcIl0gPSAzMDBdID0gXCJNVUxUSVBMRV9DSE9JQ0VTXCI7XG4gICAgLyoqXG4gICAgICogVGhpcyBhbmQgYWxsIGZ1dHVyZSByZXF1ZXN0cyBzaG91bGQgYmUgZGlyZWN0ZWQgdG8gdGhlIGdpdmVuIFVSSS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIk1PVkVEX1BFUk1BTkVOVExZXCJdID0gMzAxXSA9IFwiTU9WRURfUEVSTUFORU5UTFlcIjtcbiAgICAvKipcbiAgICAgKiBUaGlzIGlzIGFuIGV4YW1wbGUgb2YgaW5kdXN0cnkgcHJhY3RpY2UgY29udHJhZGljdGluZyB0aGUgc3RhbmRhcmQuXG4gICAgICogVGhlIEhUVFAvMS4wIHNwZWNpZmljYXRpb24gKFJGQyAxOTQ1KSByZXF1aXJlZCB0aGUgY2xpZW50IHRvIHBlcmZvcm0gYSB0ZW1wb3JhcnkgcmVkaXJlY3RcbiAgICAgKiAodGhlIG9yaWdpbmFsIGRlc2NyaWJpbmcgcGhyYXNlIHdhcyBcIk1vdmVkIFRlbXBvcmFyaWx5XCIpLCBidXQgcG9wdWxhciBicm93c2VycyBpbXBsZW1lbnRlZCAzMDJcbiAgICAgKiB3aXRoIHRoZSBmdW5jdGlvbmFsaXR5IG9mIGEgMzAzIFNlZSBPdGhlci4gVGhlcmVmb3JlLCBIVFRQLzEuMSBhZGRlZCBzdGF0dXMgY29kZXMgMzAzIGFuZCAzMDdcbiAgICAgKiB0byBkaXN0aW5ndWlzaCBiZXR3ZWVuIHRoZSB0d28gYmVoYXZpb3Vycy4gSG93ZXZlciwgc29tZSBXZWIgYXBwbGljYXRpb25zIGFuZCBmcmFtZXdvcmtzXG4gICAgICogdXNlIHRoZSAzMDIgc3RhdHVzIGNvZGUgYXMgaWYgaXQgd2VyZSB0aGUgMzAzLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiRk9VTkRcIl0gPSAzMDJdID0gXCJGT1VORFwiO1xuICAgIC8qKlxuICAgICAqIFNJTkNFIEhUVFAvMS4xXG4gICAgICogVGhlIHJlc3BvbnNlIHRvIHRoZSByZXF1ZXN0IGNhbiBiZSBmb3VuZCB1bmRlciBhbm90aGVyIFVSSSB1c2luZyBhIEdFVCBtZXRob2QuXG4gICAgICogV2hlbiByZWNlaXZlZCBpbiByZXNwb25zZSB0byBhIFBPU1QgKG9yIFBVVC9ERUxFVEUpLCB0aGUgY2xpZW50IHNob3VsZCBwcmVzdW1lIHRoYXRcbiAgICAgKiB0aGUgc2VydmVyIGhhcyByZWNlaXZlZCB0aGUgZGF0YSBhbmQgc2hvdWxkIGlzc3VlIGEgcmVkaXJlY3Qgd2l0aCBhIHNlcGFyYXRlIEdFVCBtZXNzYWdlLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiU0VFX09USEVSXCJdID0gMzAzXSA9IFwiU0VFX09USEVSXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHJlc291cmNlIGhhcyBub3QgYmVlbiBtb2RpZmllZCBzaW5jZSB0aGUgdmVyc2lvbiBzcGVjaWZpZWQgYnkgdGhlIHJlcXVlc3QgaGVhZGVycyBJZi1Nb2RpZmllZC1TaW5jZSBvciBJZi1Ob25lLU1hdGNoLlxuICAgICAqIEluIHN1Y2ggY2FzZSwgdGhlcmUgaXMgbm8gbmVlZCB0byByZXRyYW5zbWl0IHRoZSByZXNvdXJjZSBzaW5jZSB0aGUgY2xpZW50IHN0aWxsIGhhcyBhIHByZXZpb3VzbHktZG93bmxvYWRlZCBjb3B5LlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiTk9UX01PRElGSUVEXCJdID0gMzA0XSA9IFwiTk9UX01PRElGSUVEXCI7XG4gICAgLyoqXG4gICAgICogU0lOQ0UgSFRUUC8xLjFcbiAgICAgKiBUaGUgcmVxdWVzdGVkIHJlc291cmNlIGlzIGF2YWlsYWJsZSBvbmx5IHRocm91Z2ggYSBwcm94eSwgdGhlIGFkZHJlc3MgZm9yIHdoaWNoIGlzIHByb3ZpZGVkIGluIHRoZSByZXNwb25zZS5cbiAgICAgKiBNYW55IEhUVFAgY2xpZW50cyAoc3VjaCBhcyBNb3ppbGxhIGFuZCBJbnRlcm5ldCBFeHBsb3JlcikgZG8gbm90IGNvcnJlY3RseSBoYW5kbGUgcmVzcG9uc2VzIHdpdGggdGhpcyBzdGF0dXMgY29kZSwgcHJpbWFyaWx5IGZvciBzZWN1cml0eSByZWFzb25zLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiVVNFX1BST1hZXCJdID0gMzA1XSA9IFwiVVNFX1BST1hZXCI7XG4gICAgLyoqXG4gICAgICogTm8gbG9uZ2VyIHVzZWQuIE9yaWdpbmFsbHkgbWVhbnQgXCJTdWJzZXF1ZW50IHJlcXVlc3RzIHNob3VsZCB1c2UgdGhlIHNwZWNpZmllZCBwcm94eS5cIlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiU1dJVENIX1BST1hZXCJdID0gMzA2XSA9IFwiU1dJVENIX1BST1hZXCI7XG4gICAgLyoqXG4gICAgICogU0lOQ0UgSFRUUC8xLjFcbiAgICAgKiBJbiB0aGlzIGNhc2UsIHRoZSByZXF1ZXN0IHNob3VsZCBiZSByZXBlYXRlZCB3aXRoIGFub3RoZXIgVVJJOyBob3dldmVyLCBmdXR1cmUgcmVxdWVzdHMgc2hvdWxkIHN0aWxsIHVzZSB0aGUgb3JpZ2luYWwgVVJJLlxuICAgICAqIEluIGNvbnRyYXN0IHRvIGhvdyAzMDIgd2FzIGhpc3RvcmljYWxseSBpbXBsZW1lbnRlZCwgdGhlIHJlcXVlc3QgbWV0aG9kIGlzIG5vdCBhbGxvd2VkIHRvIGJlIGNoYW5nZWQgd2hlbiByZWlzc3VpbmcgdGhlIG9yaWdpbmFsIHJlcXVlc3QuXG4gICAgICogRm9yIGV4YW1wbGUsIGEgUE9TVCByZXF1ZXN0IHNob3VsZCBiZSByZXBlYXRlZCB1c2luZyBhbm90aGVyIFBPU1QgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlRFTVBPUkFSWV9SRURJUkVDVFwiXSA9IDMwN10gPSBcIlRFTVBPUkFSWV9SRURJUkVDVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IGFuZCBhbGwgZnV0dXJlIHJlcXVlc3RzIHNob3VsZCBiZSByZXBlYXRlZCB1c2luZyBhbm90aGVyIFVSSS5cbiAgICAgKiAzMDcgYW5kIDMwOCBwYXJhbGxlbCB0aGUgYmVoYXZpb3JzIG9mIDMwMiBhbmQgMzAxLCBidXQgZG8gbm90IGFsbG93IHRoZSBIVFRQIG1ldGhvZCB0byBjaGFuZ2UuXG4gICAgICogU28sIGZvciBleGFtcGxlLCBzdWJtaXR0aW5nIGEgZm9ybSB0byBhIHBlcm1hbmVudGx5IHJlZGlyZWN0ZWQgcmVzb3VyY2UgbWF5IGNvbnRpbnVlIHNtb290aGx5LlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiUEVSTUFORU5UX1JFRElSRUNUXCJdID0gMzA4XSA9IFwiUEVSTUFORU5UX1JFRElSRUNUXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBjYW5ub3Qgb3Igd2lsbCBub3QgcHJvY2VzcyB0aGUgcmVxdWVzdCBkdWUgdG8gYW4gYXBwYXJlbnQgY2xpZW50IGVycm9yXG4gICAgICogKGUuZy4sIG1hbGZvcm1lZCByZXF1ZXN0IHN5bnRheCwgdG9vIGxhcmdlIHNpemUsIGludmFsaWQgcmVxdWVzdCBtZXNzYWdlIGZyYW1pbmcsIG9yIGRlY2VwdGl2ZSByZXF1ZXN0IHJvdXRpbmcpLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiQkFEX1JFUVVFU1RcIl0gPSA0MDBdID0gXCJCQURfUkVRVUVTVFwiO1xuICAgIC8qKlxuICAgICAqIFNpbWlsYXIgdG8gNDAzIEZvcmJpZGRlbiwgYnV0IHNwZWNpZmljYWxseSBmb3IgdXNlIHdoZW4gYXV0aGVudGljYXRpb24gaXMgcmVxdWlyZWQgYW5kIGhhcyBmYWlsZWQgb3IgaGFzIG5vdCB5ZXRcbiAgICAgKiBiZWVuIHByb3ZpZGVkLiBUaGUgcmVzcG9uc2UgbXVzdCBpbmNsdWRlIGEgV1dXLUF1dGhlbnRpY2F0ZSBoZWFkZXIgZmllbGQgY29udGFpbmluZyBhIGNoYWxsZW5nZSBhcHBsaWNhYmxlIHRvIHRoZVxuICAgICAqIHJlcXVlc3RlZCByZXNvdXJjZS4gU2VlIEJhc2ljIGFjY2VzcyBhdXRoZW50aWNhdGlvbiBhbmQgRGlnZXN0IGFjY2VzcyBhdXRoZW50aWNhdGlvbi4gNDAxIHNlbWFudGljYWxseSBtZWFuc1xuICAgICAqIFwidW5hdXRoZW50aWNhdGVkXCIsaS5lLiB0aGUgdXNlciBkb2VzIG5vdCBoYXZlIHRoZSBuZWNlc3NhcnkgY3JlZGVudGlhbHMuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJVTkFVVEhPUklaRURcIl0gPSA0MDFdID0gXCJVTkFVVEhPUklaRURcIjtcbiAgICAvKipcbiAgICAgKiBSZXNlcnZlZCBmb3IgZnV0dXJlIHVzZS4gVGhlIG9yaWdpbmFsIGludGVudGlvbiB3YXMgdGhhdCB0aGlzIGNvZGUgbWlnaHQgYmUgdXNlZCBhcyBwYXJ0IG9mIHNvbWUgZm9ybSBvZiBkaWdpdGFsXG4gICAgICogY2FzaCBvciBtaWNybyBwYXltZW50IHNjaGVtZSwgYnV0IHRoYXQgaGFzIG5vdCBoYXBwZW5lZCwgYW5kIHRoaXMgY29kZSBpcyBub3QgdXN1YWxseSB1c2VkLlxuICAgICAqIEdvb2dsZSBEZXZlbG9wZXJzIEFQSSB1c2VzIHRoaXMgc3RhdHVzIGlmIGEgcGFydGljdWxhciBkZXZlbG9wZXIgaGFzIGV4Y2VlZGVkIHRoZSBkYWlseSBsaW1pdCBvbiByZXF1ZXN0cy5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlBBWU1FTlRfUkVRVUlSRURcIl0gPSA0MDJdID0gXCJQQVlNRU5UX1JFUVVJUkVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3Qgd2FzIHZhbGlkLCBidXQgdGhlIHNlcnZlciBpcyByZWZ1c2luZyBhY3Rpb24uXG4gICAgICogVGhlIHVzZXIgbWlnaHQgbm90IGhhdmUgdGhlIG5lY2Vzc2FyeSBwZXJtaXNzaW9ucyBmb3IgYSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkZPUkJJRERFTlwiXSA9IDQwM10gPSBcIkZPUkJJRERFTlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgY291bGQgbm90IGJlIGZvdW5kIGJ1dCBtYXkgYmUgYXZhaWxhYmxlIGluIHRoZSBmdXR1cmUuXG4gICAgICogU3Vic2VxdWVudCByZXF1ZXN0cyBieSB0aGUgY2xpZW50IGFyZSBwZXJtaXNzaWJsZS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIk5PVF9GT1VORFwiXSA9IDQwNF0gPSBcIk5PVF9GT1VORFwiO1xuICAgIC8qKlxuICAgICAqIEEgcmVxdWVzdCBtZXRob2QgaXMgbm90IHN1cHBvcnRlZCBmb3IgdGhlIHJlcXVlc3RlZCByZXNvdXJjZTtcbiAgICAgKiBmb3IgZXhhbXBsZSwgYSBHRVQgcmVxdWVzdCBvbiBhIGZvcm0gdGhhdCByZXF1aXJlcyBkYXRhIHRvIGJlIHByZXNlbnRlZCB2aWEgUE9TVCwgb3IgYSBQVVQgcmVxdWVzdCBvbiBhIHJlYWQtb25seSByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIk1FVEhPRF9OT1RfQUxMT1dFRFwiXSA9IDQwNV0gPSBcIk1FVEhPRF9OT1RfQUxMT1dFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UgaXMgY2FwYWJsZSBvZiBnZW5lcmF0aW5nIG9ubHkgY29udGVudCBub3QgYWNjZXB0YWJsZSBhY2NvcmRpbmcgdG8gdGhlIEFjY2VwdCBoZWFkZXJzIHNlbnQgaW4gdGhlIHJlcXVlc3QuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJOT1RfQUNDRVBUQUJMRVwiXSA9IDQwNl0gPSBcIk5PVF9BQ0NFUFRBQkxFXCI7XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBtdXN0IGZpcnN0IGF1dGhlbnRpY2F0ZSBpdHNlbGYgd2l0aCB0aGUgcHJveHkuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRFwiXSA9IDQwN10gPSBcIlBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciB0aW1lZCBvdXQgd2FpdGluZyBmb3IgdGhlIHJlcXVlc3QuXG4gICAgICogQWNjb3JkaW5nIHRvIEhUVFAgc3BlY2lmaWNhdGlvbnM6XG4gICAgICogXCJUaGUgY2xpZW50IGRpZCBub3QgcHJvZHVjZSBhIHJlcXVlc3Qgd2l0aGluIHRoZSB0aW1lIHRoYXQgdGhlIHNlcnZlciB3YXMgcHJlcGFyZWQgdG8gd2FpdC4gVGhlIGNsaWVudCBNQVkgcmVwZWF0IHRoZSByZXF1ZXN0IHdpdGhvdXQgbW9kaWZpY2F0aW9ucyBhdCBhbnkgbGF0ZXIgdGltZS5cIlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiUkVRVUVTVF9USU1FT1VUXCJdID0gNDA4XSA9IFwiUkVRVUVTVF9USU1FT1VUXCI7XG4gICAgLyoqXG4gICAgICogSW5kaWNhdGVzIHRoYXQgdGhlIHJlcXVlc3QgY291bGQgbm90IGJlIHByb2Nlc3NlZCBiZWNhdXNlIG9mIGNvbmZsaWN0IGluIHRoZSByZXF1ZXN0LFxuICAgICAqIHN1Y2ggYXMgYW4gZWRpdCBjb25mbGljdCBiZXR3ZWVuIG11bHRpcGxlIHNpbXVsdGFuZW91cyB1cGRhdGVzLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiQ09ORkxJQ1RcIl0gPSA0MDldID0gXCJDT05GTElDVFwiO1xuICAgIC8qKlxuICAgICAqIEluZGljYXRlcyB0aGF0IHRoZSByZXNvdXJjZSByZXF1ZXN0ZWQgaXMgbm8gbG9uZ2VyIGF2YWlsYWJsZSBhbmQgd2lsbCBub3QgYmUgYXZhaWxhYmxlIGFnYWluLlxuICAgICAqIFRoaXMgc2hvdWxkIGJlIHVzZWQgd2hlbiBhIHJlc291cmNlIGhhcyBiZWVuIGludGVudGlvbmFsbHkgcmVtb3ZlZCBhbmQgdGhlIHJlc291cmNlIHNob3VsZCBiZSBwdXJnZWQuXG4gICAgICogVXBvbiByZWNlaXZpbmcgYSA0MTAgc3RhdHVzIGNvZGUsIHRoZSBjbGllbnQgc2hvdWxkIG5vdCByZXF1ZXN0IHRoZSByZXNvdXJjZSBpbiB0aGUgZnV0dXJlLlxuICAgICAqIENsaWVudHMgc3VjaCBhcyBzZWFyY2ggZW5naW5lcyBzaG91bGQgcmVtb3ZlIHRoZSByZXNvdXJjZSBmcm9tIHRoZWlyIGluZGljZXMuXG4gICAgICogTW9zdCB1c2UgY2FzZXMgZG8gbm90IHJlcXVpcmUgY2xpZW50cyBhbmQgc2VhcmNoIGVuZ2luZXMgdG8gcHVyZ2UgdGhlIHJlc291cmNlLCBhbmQgYSBcIjQwNCBOb3QgRm91bmRcIiBtYXkgYmUgdXNlZCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiR09ORVwiXSA9IDQxMF0gPSBcIkdPTkVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBkaWQgbm90IHNwZWNpZnkgdGhlIGxlbmd0aCBvZiBpdHMgY29udGVudCwgd2hpY2ggaXMgcmVxdWlyZWQgYnkgdGhlIHJlcXVlc3RlZCByZXNvdXJjZS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkxFTkdUSF9SRVFVSVJFRFwiXSA9IDQxMV0gPSBcIkxFTkdUSF9SRVFVSVJFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgZG9lcyBub3QgbWVldCBvbmUgb2YgdGhlIHByZWNvbmRpdGlvbnMgdGhhdCB0aGUgcmVxdWVzdGVyIHB1dCBvbiB0aGUgcmVxdWVzdC5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlBSRUNPTkRJVElPTl9GQUlMRURcIl0gPSA0MTJdID0gXCJQUkVDT05ESVRJT05fRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3QgaXMgbGFyZ2VyIHRoYW4gdGhlIHNlcnZlciBpcyB3aWxsaW5nIG9yIGFibGUgdG8gcHJvY2Vzcy4gUHJldmlvdXNseSBjYWxsZWQgXCJSZXF1ZXN0IEVudGl0eSBUb28gTGFyZ2VcIi5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlBBWUxPQURfVE9PX0xBUkdFXCJdID0gNDEzXSA9IFwiUEFZTE9BRF9UT09fTEFSR0VcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgVVJJIHByb3ZpZGVkIHdhcyB0b28gbG9uZyBmb3IgdGhlIHNlcnZlciB0byBwcm9jZXNzLiBPZnRlbiB0aGUgcmVzdWx0IG9mIHRvbyBtdWNoIGRhdGEgYmVpbmcgZW5jb2RlZCBhcyBhIHF1ZXJ5LXN0cmluZyBvZiBhIEdFVCByZXF1ZXN0LFxuICAgICAqIGluIHdoaWNoIGNhc2UgaXQgc2hvdWxkIGJlIGNvbnZlcnRlZCB0byBhIFBPU1QgcmVxdWVzdC5cbiAgICAgKiBDYWxsZWQgXCJSZXF1ZXN0LVVSSSBUb28gTG9uZ1wiIHByZXZpb3VzbHkuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJVUklfVE9PX0xPTkdcIl0gPSA0MTRdID0gXCJVUklfVE9PX0xPTkdcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVxdWVzdCBlbnRpdHkgaGFzIGEgbWVkaWEgdHlwZSB3aGljaCB0aGUgc2VydmVyIG9yIHJlc291cmNlIGRvZXMgbm90IHN1cHBvcnQuXG4gICAgICogRm9yIGV4YW1wbGUsIHRoZSBjbGllbnQgdXBsb2FkcyBhbiBpbWFnZSBhcyBpbWFnZS9zdmcreG1sLCBidXQgdGhlIHNlcnZlciByZXF1aXJlcyB0aGF0IGltYWdlcyB1c2UgYSBkaWZmZXJlbnQgZm9ybWF0LlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiXSA9IDQxNV0gPSBcIlVOU1VQUE9SVEVEX01FRElBX1RZUEVcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IGhhcyBhc2tlZCBmb3IgYSBwb3J0aW9uIG9mIHRoZSBmaWxlIChieXRlIHNlcnZpbmcpLCBidXQgdGhlIHNlcnZlciBjYW5ub3Qgc3VwcGx5IHRoYXQgcG9ydGlvbi5cbiAgICAgKiBGb3IgZXhhbXBsZSwgaWYgdGhlIGNsaWVudCBhc2tlZCBmb3IgYSBwYXJ0IG9mIHRoZSBmaWxlIHRoYXQgbGllcyBiZXlvbmQgdGhlIGVuZCBvZiB0aGUgZmlsZS5cbiAgICAgKiBDYWxsZWQgXCJSZXF1ZXN0ZWQgUmFuZ2UgTm90IFNhdGlzZmlhYmxlXCIgcHJldmlvdXNseS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlJBTkdFX05PVF9TQVRJU0ZJQUJMRVwiXSA9IDQxNl0gPSBcIlJBTkdFX05PVF9TQVRJU0ZJQUJMRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgY2Fubm90IG1lZXQgdGhlIHJlcXVpcmVtZW50cyBvZiB0aGUgRXhwZWN0IHJlcXVlc3QtaGVhZGVyIGZpZWxkLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiRVhQRUNUQVRJT05fRkFJTEVEXCJdID0gNDE3XSA9IFwiRVhQRUNUQVRJT05fRkFJTEVEXCI7XG4gICAgLyoqXG4gICAgICogVGhpcyBjb2RlIHdhcyBkZWZpbmVkIGluIDE5OTggYXMgb25lIG9mIHRoZSB0cmFkaXRpb25hbCBJRVRGIEFwcmlsIEZvb2xzJyBqb2tlcywgaW4gUkZDIDIzMjQsIEh5cGVyIFRleHQgQ29mZmVlIFBvdCBDb250cm9sIFByb3RvY29sLFxuICAgICAqIGFuZCBpcyBub3QgZXhwZWN0ZWQgdG8gYmUgaW1wbGVtZW50ZWQgYnkgYWN0dWFsIEhUVFAgc2VydmVycy4gVGhlIFJGQyBzcGVjaWZpZXMgdGhpcyBjb2RlIHNob3VsZCBiZSByZXR1cm5lZCBieVxuICAgICAqIHRlYXBvdHMgcmVxdWVzdGVkIHRvIGJyZXcgY29mZmVlLiBUaGlzIEhUVFAgc3RhdHVzIGlzIHVzZWQgYXMgYW4gRWFzdGVyIGVnZyBpbiBzb21lIHdlYnNpdGVzLCBpbmNsdWRpbmcgR29vZ2xlLmNvbS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIklfQU1fQV9URUFQT1RcIl0gPSA0MThdID0gXCJJX0FNX0FfVEVBUE9UXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHJlcXVlc3Qgd2FzIGRpcmVjdGVkIGF0IGEgc2VydmVyIHRoYXQgaXMgbm90IGFibGUgdG8gcHJvZHVjZSBhIHJlc3BvbnNlIChmb3IgZXhhbXBsZSBiZWNhdXNlIGEgY29ubmVjdGlvbiByZXVzZSkuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJNSVNESVJFQ1RFRF9SRVFVRVNUXCJdID0gNDIxXSA9IFwiTUlTRElSRUNURURfUkVRVUVTVFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IHdhcyB3ZWxsLWZvcm1lZCBidXQgd2FzIHVuYWJsZSB0byBiZSBmb2xsb3dlZCBkdWUgdG8gc2VtYW50aWMgZXJyb3JzLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiVU5QUk9DRVNTQUJMRV9FTlRJVFlcIl0gPSA0MjJdID0gXCJVTlBST0NFU1NBQkxFX0VOVElUWVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXNvdXJjZSB0aGF0IGlzIGJlaW5nIGFjY2Vzc2VkIGlzIGxvY2tlZC5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkxPQ0tFRFwiXSA9IDQyM10gPSBcIkxPQ0tFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSByZXF1ZXN0IGZhaWxlZCBkdWUgdG8gZmFpbHVyZSBvZiBhIHByZXZpb3VzIHJlcXVlc3QgKGUuZy4sIGEgUFJPUFBBVENIKS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkZBSUxFRF9ERVBFTkRFTkNZXCJdID0gNDI0XSA9IFwiRkFJTEVEX0RFUEVOREVOQ1lcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNob3VsZCBzd2l0Y2ggdG8gYSBkaWZmZXJlbnQgcHJvdG9jb2wgc3VjaCBhcyBUTFMvMS4wLCBnaXZlbiBpbiB0aGUgVXBncmFkZSBoZWFkZXIgZmllbGQuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJVUEdSQURFX1JFUVVJUkVEXCJdID0gNDI2XSA9IFwiVVBHUkFERV9SRVFVSVJFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBvcmlnaW4gc2VydmVyIHJlcXVpcmVzIHRoZSByZXF1ZXN0IHRvIGJlIGNvbmRpdGlvbmFsLlxuICAgICAqIEludGVuZGVkIHRvIHByZXZlbnQgXCJ0aGUgJ2xvc3QgdXBkYXRlJyBwcm9ibGVtLCB3aGVyZSBhIGNsaWVudFxuICAgICAqIEdFVHMgYSByZXNvdXJjZSdzIHN0YXRlLCBtb2RpZmllcyBpdCwgYW5kIFBVVHMgaXQgYmFjayB0byB0aGUgc2VydmVyLFxuICAgICAqIHdoZW4gbWVhbndoaWxlIGEgdGhpcmQgcGFydHkgaGFzIG1vZGlmaWVkIHRoZSBzdGF0ZSBvbiB0aGUgc2VydmVyLCBsZWFkaW5nIHRvIGEgY29uZmxpY3QuXCJcbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlBSRUNPTkRJVElPTl9SRVFVSVJFRFwiXSA9IDQyOF0gPSBcIlBSRUNPTkRJVElPTl9SRVFVSVJFRFwiO1xuICAgIC8qKlxuICAgICAqIFRoZSB1c2VyIGhhcyBzZW50IHRvbyBtYW55IHJlcXVlc3RzIGluIGEgZ2l2ZW4gYW1vdW50IG9mIHRpbWUuIEludGVuZGVkIGZvciB1c2Ugd2l0aCByYXRlLWxpbWl0aW5nIHNjaGVtZXMuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJUT09fTUFOWV9SRVFVRVNUU1wiXSA9IDQyOV0gPSBcIlRPT19NQU5ZX1JFUVVFU1RTXCI7XG4gICAgLyoqXG4gICAgICogVGhlIHNlcnZlciBpcyB1bndpbGxpbmcgdG8gcHJvY2VzcyB0aGUgcmVxdWVzdCBiZWNhdXNlIGVpdGhlciBhbiBpbmRpdmlkdWFsIGhlYWRlciBmaWVsZCxcbiAgICAgKiBvciBhbGwgdGhlIGhlYWRlciBmaWVsZHMgY29sbGVjdGl2ZWx5LCBhcmUgdG9vIGxhcmdlLlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiUkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRVwiXSA9IDQzMV0gPSBcIlJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VcIjtcbiAgICAvKipcbiAgICAgKiBBIHNlcnZlciBvcGVyYXRvciBoYXMgcmVjZWl2ZWQgYSBsZWdhbCBkZW1hbmQgdG8gZGVueSBhY2Nlc3MgdG8gYSByZXNvdXJjZSBvciB0byBhIHNldCBvZiByZXNvdXJjZXNcbiAgICAgKiB0aGF0IGluY2x1ZGVzIHRoZSByZXF1ZXN0ZWQgcmVzb3VyY2UuIFRoZSBjb2RlIDQ1MSB3YXMgY2hvc2VuIGFzIGEgcmVmZXJlbmNlIHRvIHRoZSBub3ZlbCBGYWhyZW5oZWl0IDQ1MS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TXCJdID0gNDUxXSA9IFwiVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlNcIjtcbiAgICAvKipcbiAgICAgKiBBIGdlbmVyaWMgZXJyb3IgbWVzc2FnZSwgZ2l2ZW4gd2hlbiBhbiB1bmV4cGVjdGVkIGNvbmRpdGlvbiB3YXMgZW5jb3VudGVyZWQgYW5kIG5vIG1vcmUgc3BlY2lmaWMgbWVzc2FnZSBpcyBzdWl0YWJsZS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiXSA9IDUwMF0gPSBcIklOVEVSTkFMX1NFUlZFUl9FUlJPUlwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgZWl0aGVyIGRvZXMgbm90IHJlY29nbml6ZSB0aGUgcmVxdWVzdCBtZXRob2QsIG9yIGl0IGxhY2tzIHRoZSBhYmlsaXR5IHRvIGZ1bGZpbGwgdGhlIHJlcXVlc3QuXG4gICAgICogVXN1YWxseSB0aGlzIGltcGxpZXMgZnV0dXJlIGF2YWlsYWJpbGl0eSAoZS5nLiwgYSBuZXcgZmVhdHVyZSBvZiBhIHdlYi1zZXJ2aWNlIEFQSSkuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSA1MDFdID0gXCJOT1RfSU1QTEVNRU5URURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIHdhcyBhY3RpbmcgYXMgYSBnYXRld2F5IG9yIHByb3h5IGFuZCByZWNlaXZlZCBhbiBpbnZhbGlkIHJlc3BvbnNlIGZyb20gdGhlIHVwc3RyZWFtIHNlcnZlci5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIkJBRF9HQVRFV0FZXCJdID0gNTAyXSA9IFwiQkFEX0dBVEVXQVlcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGlzIGN1cnJlbnRseSB1bmF2YWlsYWJsZSAoYmVjYXVzZSBpdCBpcyBvdmVybG9hZGVkIG9yIGRvd24gZm9yIG1haW50ZW5hbmNlKS5cbiAgICAgKiBHZW5lcmFsbHksIHRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3RhdGUuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJTRVJWSUNFX1VOQVZBSUxBQkxFXCJdID0gNTAzXSA9IFwiU0VSVklDRV9VTkFWQUlMQUJMRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgd2FzIGFjdGluZyBhcyBhIGdhdGV3YXkgb3IgcHJveHkgYW5kIGRpZCBub3QgcmVjZWl2ZSBhIHRpbWVseSByZXNwb25zZSBmcm9tIHRoZSB1cHN0cmVhbSBzZXJ2ZXIuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJHQVRFV0FZX1RJTUVPVVRcIl0gPSA1MDRdID0gXCJHQVRFV0FZX1RJTUVPVVRcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGRvZXMgbm90IHN1cHBvcnQgdGhlIEhUVFAgcHJvdG9jb2wgdmVyc2lvbiB1c2VkIGluIHRoZSByZXF1ZXN0XG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRFwiXSA9IDUwNV0gPSBcIkhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEXCI7XG4gICAgLyoqXG4gICAgICogVHJhbnNwYXJlbnQgY29udGVudCBuZWdvdGlhdGlvbiBmb3IgdGhlIHJlcXVlc3QgcmVzdWx0cyBpbiBhIGNpcmN1bGFyIHJlZmVyZW5jZS5cbiAgICAgKi9cbiAgICBTVEFUVVNfQ09ERVtTVEFUVVNfQ09ERVtcIlZBUklBTlRfQUxTT19ORUdPVElBVEVTXCJdID0gNTA2XSA9IFwiVkFSSUFOVF9BTFNPX05FR09USUFURVNcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgc2VydmVyIGlzIHVuYWJsZSB0byBzdG9yZSB0aGUgcmVwcmVzZW50YXRpb24gbmVlZGVkIHRvIGNvbXBsZXRlIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiSU5TVUZGSUNJRU5UX1NUT1JBR0VcIl0gPSA1MDddID0gXCJJTlNVRkZJQ0lFTlRfU1RPUkFHRVwiO1xuICAgIC8qKlxuICAgICAqIFRoZSBzZXJ2ZXIgZGV0ZWN0ZWQgYW4gaW5maW5pdGUgbG9vcCB3aGlsZSBwcm9jZXNzaW5nIHRoZSByZXF1ZXN0LlxuICAgICAqL1xuICAgIFNUQVRVU19DT0RFW1NUQVRVU19DT0RFW1wiTE9PUF9ERVRFQ1RFRFwiXSA9IDUwOF0gPSBcIkxPT1BfREVURUNURURcIjtcbiAgICAvKipcbiAgICAgKiBGdXJ0aGVyIGV4dGVuc2lvbnMgdG8gdGhlIHJlcXVlc3QgYXJlIHJlcXVpcmVkIGZvciB0aGUgc2VydmVyIHRvIGZ1bGZpbGwgaXQuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJOT1RfRVhURU5ERURcIl0gPSA1MTBdID0gXCJOT1RfRVhURU5ERURcIjtcbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IG5lZWRzIHRvIGF1dGhlbnRpY2F0ZSB0byBnYWluIG5ldHdvcmsgYWNjZXNzLlxuICAgICAqIEludGVuZGVkIGZvciB1c2UgYnkgaW50ZXJjZXB0aW5nIHByb3hpZXMgdXNlZCB0byBjb250cm9sIGFjY2VzcyB0byB0aGUgbmV0d29yayAoZS5nLiwgXCJjYXB0aXZlIHBvcnRhbHNcIiB1c2VkXG4gICAgICogdG8gcmVxdWlyZSBhZ3JlZW1lbnQgdG8gVGVybXMgb2YgU2VydmljZSBiZWZvcmUgZ3JhbnRpbmcgZnVsbCBJbnRlcm5ldCBhY2Nlc3MgdmlhIGEgV2ktRmkgaG90c3BvdCkuXG4gICAgICovXG4gICAgU1RBVFVTX0NPREVbU1RBVFVTX0NPREVbXCJORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEXCJdID0gNTExXSA9IFwiTkVUV09SS19BVVRIRU5USUNBVElPTl9SRVFVSVJFRFwiO1xufSkoU1RBVFVTX0NPREUgfHwgKFNUQVRVU19DT0RFID0ge30pKTtcblxuLy8gSU1QT1JUQU5UOiBUSElTIEZJTEUgSVMgQVVUTyBHRU5FUkFURUQhIERPIE5PVCBNQU5VQUxMWSBFRElUIE9SIENIRUNLSU4hXG5jb25zdCBWRVJTSU9OID0ge1xuICAgIFwiY29tbWl0SGFzaFwiOiBcIjEzYTEyYWI3Y2Y0NDIwNDM1MjY3NDVkYjJiYmY0ZWYzYjA4OWMzNGFcIixcbiAgICBcInZlcnNpb25cIjogXCIxOS4wLjJcIlxufTtcblxuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQHRhcXVpdG8vaHR0cC11dGlsc1xuICovXG52YXIgX2E7XG5sZXQgZmV0Y2ggPSBnbG9iYWxUaGlzID09PSBudWxsIHx8IGdsb2JhbFRoaXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGdsb2JhbFRoaXMuZmV0Y2g7XG4vLyBXaWxsIG9ubHkgdXNlIGJyb3dzZXIgZmV0Y2ggaWYgd2UgYXJlIGluIGEgYnJvd3NlciBlbnZpcm9ubWVudCxcbi8vIGRlZmF1bHQgdG8gdGhlIG1vcmUgc3RhYmxlIG5vZGUtZmV0Y2ggb3RoZXJ3aXNlXG5jb25zdCBpc05vZGUgPSB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgISEoKF9hID0gcHJvY2VzcyA9PT0gbnVsbCB8fCBwcm9jZXNzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwcm9jZXNzLnZlcnNpb25zKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Eubm9kZSk7XG5pZiAoaXNOb2RlKSB7XG4gICAgZmV0Y2ggPSByZXF1aXJlKCdub2RlLWZldGNoJyk7XG59XG5jbGFzcyBIdHRwQmFja2VuZCB7XG4gICAgY29uc3RydWN0b3IodGltZW91dCA9IDMwMDAwKSB7XG4gICAgICAgIHRoaXMudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgfVxuICAgIHNlcmlhbGl6ZShvYmopIHtcbiAgICAgICAgaWYgKCFvYmopIHtcbiAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHIgPSBbXTtcbiAgICAgICAgZm9yIChjb25zdCBwIGluIG9iaikge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXByb3RvdHlwZS1idWlsdGluc1xuICAgICAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShwKSAmJiB0eXBlb2Ygb2JqW3BdICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb3AgPSB0eXBlb2Ygb2JqW3BdLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJyA/IG9ialtwXS50b0pTT04oKSA6IG9ialtwXTtcbiAgICAgICAgICAgICAgICAvLyBxdWVyeSBhcmd1bWVudHMgY2FuIGhhdmUgbm8gdmFsdWUgc28gd2UgbmVlZCBzb21lIHdheSBvZiBoYW5kbGluZyB0aGF0XG4gICAgICAgICAgICAgICAgLy8gZXhhbXBsZSBodHRwczovL2RvbWFpbi5jb20vcXVlcnk/YWxsXG4gICAgICAgICAgICAgICAgaWYgKHByb3AgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHApKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGFub3RoZXIgdXNlIGNhc2UgaXMgbXVsdGlwbGUgYXJndW1lbnRzIHdpdGggdGhlIHNhbWUgbmFtZVxuICAgICAgICAgICAgICAgIC8vIHRoZXkgYXJlIHBhc3NlZCBhcyBhcnJheVxuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHByb3ApKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3AuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyLnB1c2goZW5jb2RlVVJJQ29tcG9uZW50KHApICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGl0ZW0pKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdHIucHVzaChlbmNvZGVVUklDb21wb25lbnQocCkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQocHJvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBzdHIuam9pbignJicpO1xuICAgICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICAgICAgcmV0dXJuIGA/JHtzZXJpYWxpemVkfWA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBvcHRpb25zIHRvIGJlIHBhc3NlZCBmb3IgdGhlIEhUVFAgcmVxdWVzdCAodXJsLCBtZXRob2QgYW5kIHRpbWVvdXQpXG4gICAgICogQHRocm93cyB7QGxpbmsgSHR0cFJlcXVlc3RGYWlsZWR9IHwge0BsaW5rIEh0dHBSZXNwb25zZUVycm9yfSB8IHtAbGluayBIdHRwVGltZW91dEVycm9yfVxuICAgICAqL1xuICAgIGNyZWF0ZVJlcXVlc3QoeyB1cmwsIG1ldGhvZCwgdGltZW91dCA9IHRoaXMudGltZW91dCwgcXVlcnksIGhlYWRlcnMgPSB7fSwganNvbiA9IHRydWUgfSwgZGF0YSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gU2VyaWFsaXplcyBxdWVyeSBwYXJhbXNcbiAgICAgICAgICAgIGNvbnN0IHVybFdpdGhRdWVyeSA9IHVybCArIHRoaXMuc2VyaWFsaXplKHF1ZXJ5KTtcbiAgICAgICAgICAgIC8vIEFkZHMgZGVmYXVsdCBoZWFkZXIgZW50cnkgaWYgdGhlcmUgYXJlbid0IGFueSBDb250ZW50LVR5cGUgaGVhZGVyXG4gICAgICAgICAgICBpZiAoIWhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDcmVhdGVzIGEgbmV3IEFib3J0Q29udHJvbGxlciBpbnN0YW5jZSB0byBoYW5kbGUgdGltZW91dHNcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgICAgICBjb25zdCB0ID0gc2V0VGltZW91dCgoKSA9PiBjb250cm9sbGVyLmFib3J0KCksIHRpbWVvdXQpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIGZldGNoKHVybFdpdGhRdWVyeSwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2QsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgICAgICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2UgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVzcG9uc2UgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSByZXNwb25zZXMgd2l0aCBzdGF0dXMgY29kZSA+PSA0MDBcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDQwMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvckRhdGEgPSB5aWVsZCByZXNwb25zZS50ZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBIdHRwUmVzcG9uc2VFcnJvcihgSHR0cCBlcnJvciByZXNwb25zZTogKCR7cmVzcG9uc2Uuc3RhdHVzfSkgJHtlcnJvckRhdGF9YCwgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS5zdGF0dXNUZXh0LCBlcnJvckRhdGEsIHVybFdpdGhRdWVyeSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UudGV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSHR0cFRpbWVvdXRFcnJvcih0aW1lb3V0LCB1cmxXaXRoUXVlcnkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlIGluc3RhbmNlb2YgSHR0cFJlc3BvbnNlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBIdHRwUmVxdWVzdEZhaWxlZChTdHJpbmcobWV0aG9kKSwgdXJsV2l0aFF1ZXJ5LCBlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgSHR0cEJhY2tlbmQsIEh0dHBSZXF1ZXN0RmFpbGVkLCBIdHRwUmVzcG9uc2VFcnJvciwgSHR0cFRpbWVvdXRFcnJvciwgU1RBVFVTX0NPREUsIFZFUlNJT04gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcXVpdG8taHR0cC11dGlscy5lczYuanMubWFwXG4iXSwibmFtZXMiOlsiTmV0d29ya0Vycm9yIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJlIiwicmVqZWN0ZWQiLCJyZXN1bHQiLCJkb25lIiwidGhlbiIsImFwcGx5IiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwibmFtZSIsIkh0dHBSZXF1ZXN0RmFpbGVkIiwiY29uc3RydWN0b3IiLCJtZXRob2QiLCJ1cmwiLCJjYXVzZSIsIlN0cmluZyIsIkh0dHBSZXNwb25zZUVycm9yIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsImJvZHkiLCJIdHRwVGltZW91dEVycm9yIiwidGltZW91dCIsIlNUQVRVU19DT0RFIiwiVkVSU0lPTiIsIl9hIiwiZmV0Y2giLCJnbG9iYWxUaGlzIiwiaXNOb2RlIiwicHJvY2VzcyIsInZlcnNpb25zIiwibm9kZSIsInJlcXVpcmUiLCJIdHRwQmFja2VuZCIsInNlcmlhbGl6ZSIsIm9iaiIsInN0ciIsInAiLCJoYXNPd25Qcm9wZXJ0eSIsInByb3AiLCJ0b0pTT04iLCJwdXNoIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiQXJyYXkiLCJpc0FycmF5IiwiZm9yRWFjaCIsIml0ZW0iLCJzZXJpYWxpemVkIiwiam9pbiIsImNyZWF0ZVJlcXVlc3QiLCJxdWVyeSIsImhlYWRlcnMiLCJqc29uIiwiZGF0YSIsInVybFdpdGhRdWVyeSIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0Iiwic2V0VGltZW91dCIsImFib3J0IiwicmVzcG9uc2UiLCJKU09OIiwic3RyaW5naWZ5Iiwic2lnbmFsIiwiZXJyb3JEYXRhIiwidGV4dCIsImNsZWFyVGltZW91dCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/http-utils/dist/taquito-http-utils.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/local-forging/dist/taquito-local-forging.es6.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/@taquito/local-forging/dist/taquito-local-forging.es6.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   CODEC: () => (/* binding */ CODEC),\n/* harmony export */   LocalForger: () => (/* binding */ LocalForger),\n/* harmony export */   ProtocolsHash: () => (/* binding */ ProtocolsHash),\n/* harmony export */   Uint8ArrayConsumer: () => (/* binding */ Uint8ArrayConsumer),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   decoders: () => (/* binding */ decoders),\n/* harmony export */   encoders: () => (/* binding */ encoders),\n/* harmony export */   getCodec: () => (/* binding */ getCodec),\n/* harmony export */   localForger: () => (/* binding */ localForger),\n/* harmony export */   opMapping: () => (/* binding */ opMapping),\n/* harmony export */   opMappingReverse: () => (/* binding */ opMappingReverse)\n/* harmony export */ });\n/* harmony import */ var _taquito_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @taquito/utils */ \"(ssr)/./node_modules/@taquito/utils/dist/taquito-utils.es6.js\");\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n\n\n\nconst toHexString = (bytes)=>bytes.reduce((str, byte)=>str + byte.toString(16).padStart(2, \"0\"), \"\");\nconst pad = (num, paddingLen = 8)=>{\n    return num.toString(16).padStart(paddingLen, \"0\");\n};\n/*\n * Some code in this file is originally from sotez\n * Copyright (c) 2018 Andrew Kishino\n */ // See: https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint\nconst ENTRYPOINT_MAX_LENGTH = 31;\nvar CODEC;\n(function(CODEC) {\n    CODEC[\"SECRET\"] = \"secret\";\n    CODEC[\"RAW\"] = \"raw\";\n    CODEC[\"TZ1\"] = \"tz1\";\n    CODEC[\"BRANCH\"] = \"branch\";\n    CODEC[\"ZARITH\"] = \"zarith\";\n    CODEC[\"PUBLIC_KEY\"] = \"public_key\";\n    CODEC[\"PKH\"] = \"pkh\";\n    CODEC[\"PKH_ARR\"] = \"pkhArr\";\n    CODEC[\"DELEGATE\"] = \"delegate\";\n    CODEC[\"SCRIPT\"] = \"script\";\n    CODEC[\"BALLOT_STATEMENT\"] = \"ballotStmt\";\n    CODEC[\"PROPOSAL\"] = \"proposal\";\n    CODEC[\"PROPOSAL_ARR\"] = \"proposalArr\";\n    CODEC[\"INT32\"] = \"int32\";\n    CODEC[\"INT16\"] = \"int16\";\n    CODEC[\"PARAMETERS\"] = \"parameters\";\n    CODEC[\"ADDRESS\"] = \"address\";\n    CODEC[\"SMART_CONTRACT_ADDRESS\"] = \"smart_contract_address\";\n    CODEC[\"SMART_ROLLUP_ADDRESS\"] = \"smart_rollup_address\";\n    CODEC[\"SMART_ROLLUP_COMMITMENT_HASH\"] = \"smart_rollup_commitment_hash\";\n    CODEC[\"VALUE\"] = \"value\";\n    CODEC[\"PADDED_BYTES\"] = \"padded_bytes\";\n    CODEC[\"SMART_ROLLUP_MESSAGE\"] = \"smart_rollup_message\";\n    CODEC[\"MANAGER\"] = \"manager\";\n    CODEC[\"BLOCK_PAYLOAD_HASH\"] = \"blockPayloadHash\";\n    CODEC[\"ENTRYPOINT\"] = \"entrypoint\";\n    CODEC[\"OPERATION\"] = \"operation\";\n    CODEC[\"OP_ACTIVATE_ACCOUNT\"] = \"activate_account\";\n    CODEC[\"OP_DELEGATION\"] = \"delegation\";\n    CODEC[\"OP_TRANSACTION\"] = \"transaction\";\n    CODEC[\"OP_ORIGINATION\"] = \"origination\";\n    CODEC[\"OP_BALLOT\"] = \"ballot\";\n    CODEC[\"OP_FAILING_NOOP\"] = \"failing_noop\";\n    CODEC[\"OP_ATTESTATION\"] = \"attestation\";\n    CODEC[\"OP_ENDORSEMENT\"] = \"endorsement\";\n    CODEC[\"OP_SEED_NONCE_REVELATION\"] = \"seed_nonce_revelation\";\n    CODEC[\"OP_REVEAL\"] = \"reveal\";\n    CODEC[\"OP_PROPOSALS\"] = \"proposals\";\n    CODEC[\"OP_REGISTER_GLOBAL_CONSTANT\"] = \"register_global_constant\";\n    CODEC[\"OP_TRANSFER_TICKET\"] = \"transfer_ticket\";\n    CODEC[\"BURN_LIMIT\"] = \"burn_limit\";\n    CODEC[\"OP_INCREASE_PAID_STORAGE\"] = \"increase_paid_storage\";\n    CODEC[\"OP_UPDATE_CONSENSUS_KEY\"] = \"update_consensus_key\";\n    CODEC[\"OP_DRAIN_DELEGATE\"] = \"drain_delegate\";\n    CODEC[\"DEPOSITS_LIMIT\"] = \"deposits_limit\";\n    CODEC[\"OP_SET_DEPOSITS_LIMIT\"] = \"set_deposits_limit\";\n    CODEC[\"OP_SMART_ROLLUP_ORIGINATE\"] = \"smart_rollup_originate\";\n    CODEC[\"PVM_KIND\"] = \"pvm_kind\";\n    CODEC[\"OP_SMART_ROLLUP_ADD_MESSAGES\"] = \"smart_rollup_add_messages\";\n    CODEC[\"OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE\"] = \"smart_rollup_execute_outbox_message\";\n})(CODEC || (CODEC = {}));\n// See https://tezos.gitlab.io/whitedoc/michelson.html#full-grammar\nconst opMapping = {\n    \"00\": \"parameter\",\n    \"01\": \"storage\",\n    \"02\": \"code\",\n    \"03\": \"False\",\n    \"04\": \"Elt\",\n    \"05\": \"Left\",\n    \"06\": \"None\",\n    \"07\": \"Pair\",\n    \"08\": \"Right\",\n    \"09\": \"Some\",\n    \"0a\": \"True\",\n    \"0b\": \"Unit\",\n    \"0c\": \"PACK\",\n    \"0d\": \"UNPACK\",\n    \"0e\": \"BLAKE2B\",\n    \"0f\": \"SHA256\",\n    \"10\": \"SHA512\",\n    \"11\": \"ABS\",\n    \"12\": \"ADD\",\n    \"13\": \"AMOUNT\",\n    \"14\": \"AND\",\n    \"15\": \"BALANCE\",\n    \"16\": \"CAR\",\n    \"17\": \"CDR\",\n    \"18\": \"CHECK_SIGNATURE\",\n    \"19\": \"COMPARE\",\n    \"1a\": \"CONCAT\",\n    \"1b\": \"CONS\",\n    \"1c\": \"CREATE_ACCOUNT\",\n    \"1d\": \"CREATE_CONTRACT\",\n    \"1e\": \"IMPLICIT_ACCOUNT\",\n    \"1f\": \"DIP\",\n    \"20\": \"DROP\",\n    \"21\": \"DUP\",\n    \"22\": \"EDIV\",\n    \"23\": \"EMPTY_MAP\",\n    \"24\": \"EMPTY_SET\",\n    \"25\": \"EQ\",\n    \"26\": \"EXEC\",\n    \"27\": \"FAILWITH\",\n    \"28\": \"GE\",\n    \"29\": \"GET\",\n    \"2a\": \"GT\",\n    \"2b\": \"HASH_KEY\",\n    \"2c\": \"IF\",\n    \"2d\": \"IF_CONS\",\n    \"2e\": \"IF_LEFT\",\n    \"2f\": \"IF_NONE\",\n    \"30\": \"INT\",\n    \"31\": \"LAMBDA\",\n    \"32\": \"LE\",\n    \"33\": \"LEFT\",\n    \"34\": \"LOOP\",\n    \"35\": \"LSL\",\n    \"36\": \"LSR\",\n    \"37\": \"LT\",\n    \"38\": \"MAP\",\n    \"39\": \"MEM\",\n    \"3a\": \"MUL\",\n    \"3b\": \"NEG\",\n    \"3c\": \"NEQ\",\n    \"3d\": \"NIL\",\n    \"3e\": \"NONE\",\n    \"3f\": \"NOT\",\n    \"40\": \"NOW\",\n    \"41\": \"OR\",\n    \"42\": \"PAIR\",\n    \"43\": \"PUSH\",\n    \"44\": \"RIGHT\",\n    \"45\": \"SIZE\",\n    \"46\": \"SOME\",\n    \"47\": \"SOURCE\",\n    \"48\": \"SENDER\",\n    \"49\": \"SELF\",\n    \"4a\": \"STEPS_TO_QUOTA\",\n    \"4b\": \"SUB\",\n    \"4c\": \"SWAP\",\n    \"4d\": \"TRANSFER_TOKENS\",\n    \"4e\": \"SET_DELEGATE\",\n    \"4f\": \"UNIT\",\n    \"50\": \"UPDATE\",\n    \"51\": \"XOR\",\n    \"52\": \"ITER\",\n    \"53\": \"LOOP_LEFT\",\n    \"54\": \"ADDRESS\",\n    \"55\": \"CONTRACT\",\n    \"56\": \"ISNAT\",\n    \"57\": \"CAST\",\n    \"58\": \"RENAME\",\n    \"59\": \"bool\",\n    \"5a\": \"contract\",\n    \"5b\": \"int\",\n    \"5c\": \"key\",\n    \"5d\": \"key_hash\",\n    \"5e\": \"lambda\",\n    \"5f\": \"list\",\n    \"60\": \"map\",\n    \"61\": \"big_map\",\n    \"62\": \"nat\",\n    \"63\": \"option\",\n    \"64\": \"or\",\n    \"65\": \"pair\",\n    \"66\": \"set\",\n    \"67\": \"signature\",\n    \"68\": \"string\",\n    \"69\": \"bytes\",\n    \"6a\": \"mutez\",\n    \"6b\": \"timestamp\",\n    \"6c\": \"unit\",\n    \"6d\": \"operation\",\n    \"6e\": \"address\",\n    \"6f\": \"SLICE\",\n    \"70\": \"DIG\",\n    \"71\": \"DUG\",\n    \"72\": \"EMPTY_BIG_MAP\",\n    \"73\": \"APPLY\",\n    \"74\": \"chain_id\",\n    \"75\": \"CHAIN_ID\",\n    \"76\": \"LEVEL\",\n    \"77\": \"SELF_ADDRESS\",\n    \"78\": \"never\",\n    \"79\": \"NEVER\",\n    \"7a\": \"UNPAIR\",\n    \"7b\": \"VOTING_POWER\",\n    \"7c\": \"TOTAL_VOTING_POWER\",\n    \"7d\": \"KECCAK\",\n    \"7e\": \"SHA3\",\n    \"7f\": \"PAIRING_CHECK\",\n    \"80\": \"bls12_381_g1\",\n    \"81\": \"bls12_381_g2\",\n    \"82\": \"bls12_381_fr\",\n    \"83\": \"sapling_state\",\n    \"84\": \"sapling_transaction_deprecated\",\n    \"85\": \"SAPLING_EMPTY_STATE\",\n    \"86\": \"SAPLING_VERIFY_UPDATE\",\n    \"87\": \"ticket\",\n    \"88\": \"TICKET_DEPRECATED\",\n    \"89\": \"READ_TICKET\",\n    \"8a\": \"SPLIT_TICKET\",\n    \"8b\": \"JOIN_TICKETS\",\n    \"8c\": \"GET_AND_UPDATE\",\n    \"8d\": \"chest\",\n    \"8e\": \"chest_key\",\n    \"8f\": \"OPEN_CHEST\",\n    \"90\": \"VIEW\",\n    \"91\": \"view\",\n    \"92\": \"constant\",\n    \"93\": \"SUB_MUTEZ\",\n    \"94\": \"tx_rollup_l2_address\",\n    \"95\": \"MIN_BLOCK_TIME\",\n    \"96\": \"sapling_transaction\",\n    \"97\": \"EMIT\",\n    \"98\": \"Lambda_rec\",\n    \"99\": \"LAMBDA_REC\",\n    \"9a\": \"TICKET\",\n    \"9b\": \"BYTES\",\n    \"9c\": \"NAT\"\n};\nconst opMappingReverse = (()=>{\n    const result = {};\n    Object.keys(opMapping).forEach((key)=>{\n        result[opMapping[key]] = key;\n    });\n    return result;\n})();\n// See https://tezos.gitlab.io/shell/p2p_api.html?highlight=p2p\nconst kindMapping = {\n    0x04: \"activate_account\",\n    0x6b: \"reveal\",\n    0x6e: \"delegation\",\n    0x6c: \"transaction\",\n    0x6d: \"origination\",\n    0x06: \"ballot\",\n    0x15: \"attestation\",\n    0x01: \"seed_nonce_revelation\",\n    0x05: \"proposals\",\n    0x6f: \"register_global_constant\",\n    0x9e: \"transfer_ticket\",\n    0x70: \"set_deposits_limit\",\n    0x71: \"increase_paid_storage\",\n    0x72: \"update_consensus_key\",\n    0x09: \"drain_delegate\",\n    0xc8: \"smart_rollup_originate\",\n    0xc9: \"smart_rollup_add_messages\",\n    0xce: \"smart_rollup_execute_outbox_message\",\n    0x11: \"failing_noop\"\n};\nconst kindMappingReverse = (()=>{\n    const result = {};\n    Object.keys(kindMapping).forEach((key)=>{\n        const keyNum = typeof key === \"string\" ? parseInt(key, 10) : key;\n        result[kindMapping[keyNum]] = pad(keyNum, 2);\n    });\n    return result;\n})();\n// See https://tezos.gitlab.io/protocols/005_babylon.html#transactions-now-have-an-entrypoint\nconst entrypointMapping = {\n    \"00\": \"default\",\n    \"01\": \"root\",\n    \"02\": \"do\",\n    \"03\": \"set_delegate\",\n    \"04\": \"remove_delegate\",\n    \"05\": \"deposit\",\n    \"06\": \"stake\",\n    \"07\": \"unstake\",\n    \"08\": \"finalize_unstake\",\n    \"09\": \"set_delegate_parameters\"\n};\nconst entrypointMappingReverse = (()=>{\n    const result = {};\n    Object.keys(entrypointMapping).forEach((key)=>{\n        result[entrypointMapping[key]] = key;\n    });\n    return result;\n})();\n/**\n *  @category Error\n *  @description Error that indicates an invalid operation content being passed or used\n */ class InvalidOperationSchemaError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(operation, errorDetail){\n        super();\n        this.operation = operation;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidOperationSchemaError\";\n        this.message = `Invalid operation content recevied`;\n        errorDetail ? this.message += ` ${errorDetail}.` : \"\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an entrypoint name exceeding maximum length\n */ class OversizedEntryPointError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(entrypoint){\n        super();\n        this.entrypoint = entrypoint;\n        this.name = \"OversizedEntryPointError\";\n        this.message = `Invalid entrypoint length \"${entrypoint.length}\", maximum length is \"${ENTRYPOINT_MAX_LENGTH}\".`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid ballot value being used\n */ class InvalidBallotValueError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(ballotValue){\n        super();\n        this.ballotValue = ballotValue;\n        this.name = \"InvalidBallotValueError\";\n        this.message = `Invalid ballot value \"${ballotValue}\" expecting one of the following: \"yay\", \"nay\", \"pass\".`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to decode ballot value\n */ class DecodeBallotValueError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(ballotValue){\n        super();\n        this.ballotValue = ballotValue;\n        this.name = \"DecodeBallotValueError\";\n        this.message = `Invalid ballot value \"${ballotValue}\", cannot be decoded.`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates unexpected Michelson Value being passed or used\n */ class UnexpectedMichelsonValueError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(value){\n        super();\n        this.value = value;\n        this.name = \"UnexpectedMichelsonValueError\";\n        this.message = `Invalid Michelson value \"${value}\", unalbe to encode.`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to decode an operation\n */ class OperationDecodingError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"OperationDecodingError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode an operation\n */ class OperationEncodingError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"OperationEncodingError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an unsupported operation being passed or used\n */ class UnsupportedOperationError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(op){\n        super();\n        this.op = op;\n        this.name = \"UnsupportedOperationError\";\n        this.message = `Unsupported operation \"${op}\", can submit an issue on our github for feature request.`;\n    }\n}\n/**\n * @cateogry Error\n * @description Error that indicates an unsupported pvm being passed or used\n */ class UnsupportedPvmKindError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(pvm){\n        super();\n        this.pvm = pvm;\n        this.name = \"UnsupportedPvmKindError\";\n        this.message = `Invalid Pvm kind \"${pvm}\" expecting either \"arith\" or \"wasm_2_0_0\".`;\n    }\n}\n/**\n * @category Error\n * @description Error that indicates an unsupported pvm to decode\n */ class DecodePvmKindError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(pvm){\n        super();\n        this.pvm = pvm;\n        this.name = \"DecodePvmKindError\";\n        this.message = `Invalid Pvm kind \"${pvm}\", cannot be decoded.`;\n    }\n}\n/**\n * @category Error\n * @description Error that indicates an invalid Smart Rollup Address (sr1)\n */ class InvalidSmartRollupAddressError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(address, errorDetail){\n        super();\n        this.address = address;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidSmartRollupAddress\";\n        this.message = `Invalid smart rollup address \"${address}\"`;\n        errorDetail ? this.message += ` ${errorDetail}.` : \"\";\n    }\n}\n/**\n * @category Error\n * @description Error that indicates an invalid Smart Rollup commitment hash (src1)\n */ class InvalidSmartRollupCommitmentHashError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.ParameterValidationError {\n    constructor(hash, errorDetail){\n        super();\n        this.hash = hash;\n        this.errorDetail = errorDetail;\n        this.name = \"InvalidSmartRollupCommitmentHashError\";\n        this.message = `Invalid smart rollup commitment hash \"${hash}\"`;\n        errorDetail ? this.message += ` ${errorDetail}.` : \"\";\n    }\n}\nclass Uint8ArrayConsumer {\n    static fromHexString(hex) {\n        const lowHex = hex.toLowerCase();\n        if (/^(([a-f]|\\d){2})*$/.test(lowHex)) {\n            const arr = new Uint8Array((lowHex.match(/([a-z]|\\d){2}/g) || []).map((byte)=>parseInt(byte, 16)));\n            return new Uint8ArrayConsumer(arr);\n        } else {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidHexStringError(lowHex);\n        }\n    }\n    constructor(arr, offset = 0){\n        this.arr = arr;\n        this.offset = offset;\n    }\n    consume(count) {\n        const subArr = this.arr.subarray(this.offset, this.offset + count);\n        this.offset += count;\n        return subArr;\n    }\n    get(idx) {\n        return this.arr[this.offset + idx];\n    }\n    length() {\n        return this.arr.length - this.offset;\n    }\n    slice(start, end) {\n        return new Uint8ArrayConsumer(this.arr.slice(start, end));\n    }\n}\nconst isPrim = (value)=>{\n    return \"prim\" in value;\n};\nconst isBytes = (value)=>{\n    return \"bytes\" in value && typeof value.bytes === \"string\";\n};\nconst isString = (value)=>{\n    return \"string\" in value && typeof value.string === \"string\";\n};\nconst isInt = (value)=>{\n    return \"int\" in value && typeof value.int === \"string\";\n};\nconst scriptEncoder = (script)=>{\n    const code = valueEncoder(script.code);\n    const storage = valueEncoder(script.storage);\n    return `${pad(code.length / 2, 8)}${code}${pad(storage.length / 2, 8)}${storage}`;\n};\nconst scriptDecoder = (value)=>{\n    const code = extractRequiredLen(value);\n    const storage = extractRequiredLen(value);\n    return {\n        code: valueDecoder(new Uint8ArrayConsumer(code)),\n        storage: valueDecoder(new Uint8ArrayConsumer(storage))\n    };\n};\nconst valueEncoder = (value)=>{\n    if (Array.isArray(value)) {\n        const encoded = value.map((x)=>valueEncoder(x)).join(\"\");\n        const len = encoded.length / 2;\n        return `02${pad(len)}${encoded}`;\n    } else if (isPrim(value)) {\n        return primEncoder(value);\n    } else if (isBytes(value)) {\n        return bytesEncoder(value);\n    } else if (isString(value)) {\n        return stringEncoder(value);\n    } else if (isInt(value)) {\n        return intEncoder(value);\n    }\n    throw new UnexpectedMichelsonValueError(JSON.stringify(value));\n};\nconst valueDecoder = (value)=>{\n    const preamble = value.consume(1);\n    switch(preamble[0]){\n        case 0x0a:\n            return bytesDecoder(value);\n        case 0x01:\n            return stringDecoder(value);\n        case 0x00:\n            return intDecoder(value);\n        case 0x02:\n            {\n                const val = new Uint8ArrayConsumer(extractRequiredLen(value));\n                const results = [];\n                while(val.length() > 0){\n                    results.push(valueDecoder(val));\n                }\n                return results;\n            }\n        default:\n            return primDecoder(value, preamble);\n    }\n};\nconst extractRequiredLen = (value, bytesLength = 4)=>{\n    const len = value.consume(bytesLength);\n    const valueLen = parseInt(Buffer.from(len).toString(\"hex\"), 16);\n    return value.consume(valueLen);\n};\n/**\n * @description parse bytes into multiple items of an array\n * @param value Uint8ArrayConsumer class of forged segment to parse\n * @param bytesLength default 4 bytes for length of variable bytes\n * @returns array of Uint8Array values for each array item\n */ const stripLengthPrefixFromBytes = (value, bytesLength = 4)=>{\n    const ret = [];\n    let values = value;\n    while(values.length()){\n        const len = values.consume(bytesLength);\n        const valueLen = parseInt(Buffer.from(len).toString(\"hex\"), 16);\n        ret.push(values.consume(valueLen));\n        values = values.slice(valueLen + bytesLength);\n    }\n    return ret;\n};\nconst bytesEncoder = (value)=>{\n    if (!/^([A-Fa-f0-9]{2})*$/.test(value.bytes)) {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidHexStringError(value.bytes);\n    }\n    const len = value.bytes.length / 2;\n    return `0a${pad(len)}${value.bytes}`;\n};\nconst bytesDecoder = (value)=>{\n    const bytes = extractRequiredLen(value);\n    return {\n        bytes: Buffer.from(bytes).toString(\"hex\")\n    };\n};\nconst stringEncoder = (value)=>{\n    const str = Buffer.from(value.string, \"utf8\").toString(\"hex\");\n    const hexLength = str.length / 2;\n    return `01${pad(hexLength)}${str}`;\n};\nconst stringDecoder = (value)=>{\n    const str = extractRequiredLen(value);\n    return {\n        string: Buffer.from(str).toString(\"utf8\")\n    };\n};\nconst intEncoder = ({ int })=>{\n    const num = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__.BigNumber(int, 10);\n    const positiveMark = num.toString(2)[0] === \"-\" ? \"1\" : \"0\";\n    const binary = num.toString(2).replace(/-/g, \"\");\n    const pad = binary.length <= 6 ? 6 : (binary.length - 6) % 7 ? binary.length + 7 - (binary.length - 6) % 7 : binary.length;\n    const splitted = binary.padStart(pad, \"0\").match(/\\d{6,7}/g);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const reversed = splitted.reverse();\n    reversed[0] = positiveMark + reversed[0];\n    const numHex = reversed.map((x, i)=>// Add one to the last chunk\n        parseInt((i === reversed.length - 1 ? \"0\" : \"1\") + x, 2).toString(16).padStart(2, \"0\"));\n    return `00${numHex.join(\"\")}`;\n};\nconst intDecoder = (value)=>{\n    let c = value.consume(1)[0];\n    const hexNumber = [];\n    const isNotLastChunkMask = 1 << 7;\n    while(c & isNotLastChunkMask){\n        hexNumber.push(c);\n        c = value.consume(1)[0];\n    }\n    hexNumber.push(c);\n    const isNegative = !!(1 << 6 & hexNumber[0]);\n    hexNumber[0] = hexNumber[0] & 127;\n    const numBin = hexNumber.map((x, i)=>x.toString(2).slice(i === 0 ? -6 : -7).padStart(i === 0 ? 6 : 7, \"0\")).reverse();\n    let num = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__.BigNumber(numBin.join(\"\"), 2);\n    if (isNegative) {\n        num = num.times(-1);\n    }\n    return {\n        int: num.toFixed()\n    };\n};\nconst primEncoder = (value)=>{\n    const hasAnnot = +Array.isArray(value.annots);\n    const argsCount = Array.isArray(value.args) ? value.args.length : 0;\n    // Specify the number of args max is 3 without annotation\n    const preamble = pad(Math.min(2 * argsCount + hasAnnot + 0x03, 9), 2);\n    const op = opMappingReverse[value.prim];\n    let encodedArgs = (value.args || []).map((arg)=>valueEncoder(arg)).join(\"\");\n    const encodedAnnots = Array.isArray(value.annots) ? encodeAnnots(value.annots) : \"\";\n    if ((value.prim === \"LAMBDA\" || value.prim === \"LAMBDA_REC\") && argsCount) {\n        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);\n    }\n    if ((value.prim === \"pair\" || value.prim === \"Pair\") && argsCount > 2) {\n        encodedArgs = encodedAnnots === \"\" ? pad(encodedArgs.length / 2) + encodedArgs + pad(0) : pad(encodedArgs.length / 2) + encodedArgs;\n    }\n    if (value.prim === \"view\" && value.args) {\n        encodedArgs = pad(encodedArgs.length / 2) + encodedArgs + pad(0);\n    }\n    return `${preamble}${op}${encodedArgs}${encodedAnnots}`;\n};\nconst primDecoder = (value, preamble)=>{\n    const hasAnnot = (preamble[0] - 0x03) % 2 === 1;\n    let argsCount = Math.floor((preamble[0] - 0x03) / 2);\n    const op = value.consume(1)[0].toString(16).padStart(2, \"0\");\n    const result = {\n        prim: opMapping[op]\n    };\n    if (opMapping[op] === \"LAMBDA\" || opMapping[op] === \"LAMBDA_REC\") {\n        value.consume(4);\n    }\n    if (opMapping[op] === \"view\") {\n        if (argsCount != 0) {\n            return primViewDecoder(value, result);\n        } else {\n            return result;\n        }\n    }\n    let combPairArgs;\n    let combPairAnnots;\n    if ((opMapping[op] === \"pair\" || opMapping[op] === \"Pair\") && argsCount > 2) {\n        combPairArgs = decodeCombPair(value);\n        argsCount = 0;\n        combPairAnnots = decodeAnnots(value);\n    }\n    const args = new Array(argsCount).fill(0).map(()=>valueDecoder(value));\n    if (opMapping[op] === \"LAMBDA\" || opMapping[op] === \"LAMBDA_REC\") {\n        value.consume(4);\n    }\n    if (combPairArgs) {\n        result[\"args\"] = combPairArgs;\n    } else if (args.length) {\n        result[\"args\"] = args;\n    }\n    if (combPairAnnots && combPairAnnots[0] !== \"\") {\n        result[\"annots\"] = combPairAnnots;\n    } else if (hasAnnot) {\n        result[\"annots\"] = decodeAnnots(value);\n    }\n    return result;\n};\nconst primViewDecoder = (value, result)=>{\n    value.consume(4);\n    result[\"args\"] = new Array(4).fill(0).map(()=>valueDecoder(value));\n    value.consume(4);\n    return result;\n};\nconst decodeCombPair = (val)=>{\n    const array = new Uint8ArrayConsumer(extractRequiredLen(val));\n    const args = [];\n    while(array.length() > 0){\n        args.push(valueDecoder(array));\n    }\n    return args;\n};\nconst encodeAnnots = (value)=>{\n    const mergedAnnot = value.map((x)=>{\n        return Buffer.from(x, \"utf8\").toString(\"hex\");\n    }).join(\"20\");\n    const len = mergedAnnot.length / 2;\n    return `${pad(len)}${mergedAnnot}`;\n};\nconst decodeAnnots = (val)=>{\n    const len = val.consume(4);\n    const annotLen = parseInt(Buffer.from(len).toString(\"hex\"), 16);\n    const restOfAnnot = val.consume(annotLen);\n    const restOfAnnotHex = Buffer.from(restOfAnnot).toString(\"hex\");\n    return restOfAnnotHex.split(\"20\").map((x)=>Buffer.from(x, \"hex\").toString(\"utf8\"));\n};\n// https://tezos.gitlab.io/shell/p2p_api.html specifies data types and structure for forging\nconst prefixEncoder = (prefix$1)=>(str)=>{\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.buf2hex)(Buffer.from((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.b58cdecode)(str, _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.prefix[prefix$1])));\n    };\nconst prefixDecoder = (pre)=>(str)=>{\n        const val = str.consume(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.prefixLength[pre]);\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.b58cencode)(val, _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.prefix[pre]);\n    };\nconst tz1Decoder = prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1);\nconst branchDecoder = prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.B);\nconst publicKeyHashDecoder = (val)=>{\n    const prefix = val.consume(1);\n    if (prefix[0] === 0x00) {\n        return prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1)(val);\n    } else if (prefix[0] === 0x01) {\n        return prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ2)(val);\n    } else if (prefix[0] === 0x02) {\n        return prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ3)(val);\n    }\n};\nconst publicKeyHashesDecoder = (val)=>{\n    if (!boolDecoder(val)) {\n        return undefined;\n    }\n    const publicKeyHashes = [];\n    val.consume(4);\n    while(val.length() > 0){\n        publicKeyHashes.push(publicKeyHashDecoder(val));\n    }\n    return publicKeyHashes;\n};\nconst branchEncoder = prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.B);\nconst tz1Encoder = prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1);\nconst boolEncoder = (bool)=>bool ? \"ff\" : \"00\";\nconst proposalEncoder = (proposal)=>{\n    return prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.P)(proposal);\n};\nconst proposalDecoder = (proposal)=>{\n    return prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.P)(proposal);\n};\nconst proposalsDecoder = (proposal)=>{\n    const proposals = [];\n    proposal.consume(4);\n    while(proposal.length() > 0){\n        proposals.push(proposalDecoder(proposal));\n    }\n    return proposals;\n};\nconst proposalsEncoder = (proposals)=>{\n    return pad(32 * proposals.length) + proposals.map((x)=>proposalEncoder(x)).join(\"\");\n};\nconst ballotEncoder = (ballot)=>{\n    switch(ballot){\n        case \"yay\":\n            return \"00\";\n        case \"nay\":\n            return \"01\";\n        case \"pass\":\n            return \"02\";\n        default:\n            throw new InvalidBallotValueError(ballot);\n    }\n};\nconst ballotDecoder = (ballot)=>{\n    const value = ballot.consume(1);\n    switch(value[0]){\n        case 0x00:\n            return \"yay\";\n        case 0x01:\n            return \"nay\";\n        case 0x02:\n            return \"pass\";\n        default:\n            throw new DecodeBallotValueError(value[0].toString());\n    }\n};\nconst pvmKindEncoder = (pvm)=>{\n    switch(pvm){\n        case \"arith\":\n            return \"00\";\n        case \"wasm_2_0_0\":\n            return \"01\";\n        case \"riscv\":\n            return \"02\";\n        default:\n            throw new UnsupportedPvmKindError(pvm);\n    }\n};\nconst pvmKindDecoder = (pvm)=>{\n    const value = pvm.consume(1);\n    switch(value[0]){\n        case 0x00:\n            return \"arith\";\n        case 0x01:\n            return \"wasm_2_0_0\";\n        case 0x02:\n            return \"riscv\";\n        default:\n            throw new DecodePvmKindError(value[0].toString());\n    }\n};\nconst delegateEncoder = (val)=>{\n    if (val) {\n        return boolEncoder(true) + publicKeyHashEncoder(val);\n    } else {\n        return boolEncoder(false);\n    }\n};\nconst int32Encoder = (val)=>{\n    const num = parseInt(String(val), 10);\n    const byte = [];\n    for(let i = 0; i < 4; i++){\n        const shiftBy = (4 - (i + 1)) * 8;\n        byte.push((num & 0xff << shiftBy) >> shiftBy);\n    }\n    return Buffer.from(byte).toString(\"hex\");\n};\nconst int32Decoder = (val)=>{\n    const num = val.consume(4);\n    let finalNum = 0;\n    for(let i = 0; i < num.length; i++){\n        finalNum = finalNum | num[i] << (num.length - (i + 1)) * 8;\n    }\n    return finalNum;\n};\nconst int16Encoder = (val)=>{\n    const num = parseInt(String(val), 10);\n    const byte = [];\n    for(let i = 0; i < 2; i++){\n        const shiftBy = (2 - (i + 1)) * 8;\n        byte.push((num & 0xff << shiftBy) >> shiftBy);\n    }\n    return Buffer.from(byte).toString(\"hex\");\n};\nconst int16Decoder = (val)=>{\n    const num = val.consume(2);\n    let finalNum = 0;\n    for(let i = 0; i < num.length; i++){\n        finalNum = finalNum | num[i] << (num.length - (i + 1)) * 8;\n    }\n    return finalNum;\n};\nconst boolDecoder = (val)=>{\n    const bool = val.consume(1);\n    return bool[0] === 0xff;\n};\nconst delegateDecoder = (val)=>{\n    const hasDelegate = boolDecoder(val);\n    if (hasDelegate) {\n        return publicKeyHashDecoder(val);\n    }\n};\nconst publicKeyHashEncoder = (val)=>{\n    const pubkeyPrefix = val.substring(0, 3);\n    switch(pubkeyPrefix){\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1:\n            return \"00\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1)(val);\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ2:\n            return \"01\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ2)(val);\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ3:\n            return \"02\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ3)(val);\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ4:\n            return \"03\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ4)(val);\n        default:\n            throw new _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.InvalidKeyHashError(val, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting one for the following \"${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1}\", \"${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ2}\", \"${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ3}\" or \"${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ4}\".`);\n    }\n};\nconst publicKeyHashesEncoder = (val)=>{\n    if (!val) {\n        return boolEncoder(false);\n    }\n    if (val.length === 0) {\n        return boolEncoder(true) + pad(0);\n    }\n    const publicKeyHashes = val.reduce((prev, curr)=>{\n        return prev + publicKeyHashEncoder(curr);\n    }, \"\");\n    return boolEncoder(true) + pad(publicKeyHashes.length / 2) + publicKeyHashes;\n};\nconst publicKeyEncoder = (val)=>{\n    const pubkeyPrefix = val.substring(0, 4);\n    switch(pubkeyPrefix){\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.EDPK:\n            return \"00\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.EDPK)(val);\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SPPK:\n            return \"01\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SPPK)(val);\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.P2PK:\n            return \"02\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.P2PK)(val);\n        default:\n            throw new _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.InvalidPublicKeyError(val, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting one of the following '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.EDPK}', '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SPPK}', '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.P2PK}' or '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.BLPK}'.`);\n    }\n};\nconst addressEncoder = (val)=>{\n    const pubkeyPrefix = val.substring(0, 3);\n    switch(pubkeyPrefix){\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1:\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ2:\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ3:\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ4:\n            return \"00\" + publicKeyHashEncoder(val);\n        case _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1:\n            return \"01\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1)(val) + \"00\";\n        default:\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidAddressError(val, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting one of the following prefix '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ1}', ${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ2}', '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ3}', '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.TZ4}' or '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1}'.`);\n    }\n};\nconst smartRollupAddressEncoder = (val)=>{\n    if (val.substring(0, 3) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SR1) {\n        throw new InvalidSmartRollupAddressError(val, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SR1}'.`);\n    }\n    return prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SR1)(val);\n};\nconst smartContractAddressEncoder = (val)=>{\n    const prefix = val.substring(0, 3);\n    if (prefix === _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1) {\n        return \"01\" + prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1)(val) + \"00\";\n    }\n    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidContractAddressError(val, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1}'.`);\n};\nconst publicKeyDecoder = (val)=>{\n    const preamble = val.consume(1);\n    switch(preamble[0]){\n        case 0x00:\n            return prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.EDPK)(val);\n        case 0x01:\n            return prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SPPK)(val);\n        case 0x02:\n            return prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.P2PK)(val);\n        default:\n            throw new _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.InvalidPublicKeyError(val.toString(), (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED));\n    }\n};\nconst smartRollupCommitmentHashEncoder = (val)=>{\n    const prefix = val.substring(0, 4);\n    if (prefix === _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SRC1) {\n        return prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SRC1)(val);\n    }\n    throw new InvalidSmartRollupCommitmentHashError(val, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SRC1}'`);\n};\nconst addressDecoder = (val)=>{\n    const preamble = val.consume(1);\n    switch(preamble[0]){\n        case 0x00:\n            return publicKeyHashDecoder(val);\n        case 0x01:\n            {\n                const address = prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1)(val);\n                val.consume(1);\n                return address;\n            }\n        default:\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidAddressError(val.toString(), \": Unable to decode.\");\n    }\n};\nconst smartRollupAddressDecoder = (val)=>{\n    const address = prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SR1)(val);\n    if (address.substring(0, 3) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SR1) {\n        throw new InvalidSmartRollupAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SR1}'.`);\n    }\n    return address;\n};\nconst smartContractAddressDecoder = (val)=>{\n    const preamble = val.consume(1);\n    if (preamble[0] === 0x01) {\n        const scAddress = prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.KT1)(val);\n        val.consume(1);\n        return scAddress;\n    }\n    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidContractAddressError(val.toString(), (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED));\n};\nconst smartRollupCommitmentHashDecoder = (val)=>{\n    const address = prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SRC1)(val);\n    if (address.substring(0, 4) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SRC1) {\n        throw new InvalidSmartRollupCommitmentHashError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.NO_PREFIX_MATCHED) + ` expecting prefix '${_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.SRC1}'`);\n    }\n    return address;\n};\nconst zarithEncoder = (n)=>{\n    const fn = [];\n    let nn = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](n, 10);\n    if (nn.isNaN()) {\n        throw new TypeError(`Invalid zarith number ${n}`);\n    }\n    // eslint-disable-next-line no-constant-condition\n    while(true){\n        if (nn.lt(128)) {\n            if (nn.lt(16)) fn.push(\"0\");\n            fn.push(nn.toString(16));\n            break;\n        } else {\n            let b = nn.mod(128);\n            nn = nn.minus(b);\n            nn = nn.dividedBy(128);\n            b = b.plus(128);\n            fn.push(b.toString(16));\n        }\n    }\n    return fn.join(\"\");\n};\nconst zarithDecoder = (n)=>{\n    let mostSignificantByte = 0;\n    while(mostSignificantByte < n.length() && (n.get(mostSignificantByte) & 128) !== 0){\n        mostSignificantByte += 1;\n    }\n    let num = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](0);\n    for(let i = mostSignificantByte; i >= 0; i -= 1){\n        const tmp = n.get(i) & 0x7f;\n        num = num.multipliedBy(128);\n        num = num.plus(tmp);\n    }\n    n.consume(mostSignificantByte + 1);\n    return new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](num).toString();\n};\nconst entrypointDecoder = (value)=>{\n    const preamble = pad(value.consume(1)[0], 2);\n    if (preamble in entrypointMapping) {\n        return entrypointMapping[preamble];\n    } else {\n        const entry = extractRequiredLen(value, 1);\n        const entrypoint = Buffer.from(entry).toString(\"utf8\");\n        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {\n            throw new OversizedEntryPointError(entrypoint);\n        }\n        return entrypoint;\n    }\n};\nconst parametersDecoder = (val)=>{\n    const preamble = val.consume(1);\n    if (preamble[0] === 0x00) {\n        return;\n    } else {\n        const encodedEntrypoint = entrypointDecoder(val);\n        const params = extractRequiredLen(val);\n        const parameters = valueDecoder(new Uint8ArrayConsumer(params));\n        return {\n            entrypoint: encodedEntrypoint,\n            value: parameters\n        };\n    }\n};\nconst entrypointEncoder = (entrypoint)=>{\n    if (entrypoint in entrypointMappingReverse) {\n        return `${entrypointMappingReverse[entrypoint]}`;\n    } else {\n        if (entrypoint.length > ENTRYPOINT_MAX_LENGTH) {\n            throw new OversizedEntryPointError(entrypoint);\n        }\n        const value = {\n            string: entrypoint\n        };\n        return `ff${valueEncoder(value).slice(8)}`;\n    }\n};\nconst parametersEncoder = (val)=>{\n    if (!val || val.entrypoint === \"default\" && \"prim\" in val.value && val.value.prim === \"Unit\") {\n        return \"00\";\n    }\n    const encodedEntrypoint = entrypointEncoder(val.entrypoint);\n    const parameters = valueEncoder(val.value);\n    const length = (parameters.length / 2).toString(16).padStart(8, \"0\");\n    return `ff${encodedEntrypoint}${length}${parameters}`;\n};\nconst valueParameterEncoder = (value)=>{\n    const valueEncoded = valueEncoder(value);\n    return `${pad(valueEncoded.length / 2)}${valueEncoded}`;\n};\nconst valueParameterDecoder = (val)=>{\n    const value = extractRequiredLen(val);\n    return valueDecoder(new Uint8ArrayConsumer(value));\n};\nconst blockPayloadHashEncoder = prefixEncoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.VH);\nconst blockPayloadHashDecoder = prefixDecoder(_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.Prefix.VH);\nconst entrypointNameEncoder = (entrypoint)=>{\n    const value = {\n        string: entrypoint\n    };\n    return `${valueEncoder(value).slice(2)}`;\n};\nconst entrypointNameDecoder = (val)=>{\n    const entry = extractRequiredLen(val);\n    return Buffer.from(entry).toString(\"utf8\");\n};\nconst burnLimitEncoder = (val)=>{\n    return !val ? \"00\" : `ff${zarithEncoder(val)}`;\n};\nconst burnLimitDecoder = (value)=>{\n    const prefix = value.consume(1);\n    if (Buffer.from(prefix).toString(\"hex\") !== \"00\") {\n        return zarithDecoder(value);\n    }\n};\nconst depositsLimitEncoder = (val)=>{\n    return !val ? \"00\" : `ff${zarithEncoder(val)}`;\n};\nconst depositsLimitDecoder = (value)=>{\n    const prefix = value.consume(1);\n    if (Buffer.from(prefix).toString(\"hex\") !== \"00\") {\n        return zarithDecoder(value);\n    }\n};\nconst paddedBytesEncoder = (val, paddingLength = 8)=>{\n    return `${pad(val.length / 2, paddingLength)}${val}`;\n};\nconst paddedBytesDecoder = (val)=>{\n    const value = extractRequiredLen(val);\n    return Buffer.from(value).toString(\"hex\");\n};\nconst smartRollupMessageEncoder = (val)=>{\n    const message = val.reduce((prev, curr)=>{\n        return prev + `${pad(curr.length / 2)}${curr}`;\n    }, \"\");\n    return `${pad(message.length / 2)}${message}`;\n};\nconst smartRollupMessageDecoder = (val)=>{\n    const valueArray = extractRequiredLen(val);\n    const ret = stripLengthPrefixFromBytes(new Uint8ArrayConsumer(valueArray));\n    return ret.map((value)=>Buffer.from(value).toString(\"hex\"));\n};\nconst ManagerOperationSchema = {\n    branch: CODEC.BRANCH,\n    contents: [\n        CODEC.OPERATION\n    ]\n};\nconst ActivationSchema = {\n    pkh: CODEC.TZ1,\n    secret: CODEC.SECRET\n};\nconst RevealSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    public_key: CODEC.PUBLIC_KEY\n};\nconst DelegationSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    delegate: CODEC.DELEGATE\n};\nconst TransactionSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    amount: CODEC.ZARITH,\n    destination: CODEC.ADDRESS,\n    parameters: CODEC.PARAMETERS\n};\nconst OriginationSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    balance: CODEC.ZARITH,\n    delegate: CODEC.DELEGATE,\n    script: CODEC.SCRIPT\n};\nconst BallotSchema = {\n    source: CODEC.PKH,\n    period: CODEC.INT32,\n    proposal: CODEC.PROPOSAL,\n    ballot: CODEC.BALLOT_STATEMENT\n};\nconst AttestationSchema = {\n    slot: CODEC.INT16,\n    level: CODEC.INT32,\n    round: CODEC.INT32,\n    block_payload_hash: CODEC.BLOCK_PAYLOAD_HASH\n};\nconst EndorsementSchema = {\n    slot: CODEC.INT16,\n    level: CODEC.INT32,\n    round: CODEC.INT32,\n    block_payload_hash: CODEC.BLOCK_PAYLOAD_HASH\n};\nconst SeedNonceRevelationSchema = {\n    level: CODEC.INT32,\n    nonce: CODEC.RAW\n};\nconst ProposalsSchema = {\n    source: CODEC.PKH,\n    period: CODEC.INT32,\n    proposals: CODEC.PROPOSAL_ARR\n};\nconst RegisterGlobalConstantSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    value: CODEC.VALUE\n};\nconst TransferTicketSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    ticket_contents: CODEC.VALUE,\n    ticket_ty: CODEC.VALUE,\n    ticket_ticketer: CODEC.ADDRESS,\n    ticket_amount: CODEC.ZARITH,\n    destination: CODEC.ADDRESS,\n    entrypoint: CODEC.ENTRYPOINT\n};\nconst IncreasePaidStorageSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    amount: CODEC.ZARITH,\n    destination: CODEC.SMART_CONTRACT_ADDRESS\n};\nconst UpdateConsensusKeySchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    pk: CODEC.PUBLIC_KEY\n};\nconst DrainDelegateSchema = {\n    consensus_key: CODEC.PKH,\n    delegate: CODEC.PKH,\n    destination: CODEC.PKH\n};\nconst SetDepositsLimitSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    limit: CODEC.DEPOSITS_LIMIT\n};\nconst SmartRollupOriginateSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    pvm_kind: CODEC.PVM_KIND,\n    kernel: CODEC.PADDED_BYTES,\n    parameters_ty: CODEC.VALUE,\n    whitelist: CODEC.PKH_ARR\n};\nconst SmartRollupAddMessagesSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    message: CODEC.SMART_ROLLUP_MESSAGE\n};\nconst SmartRollupExecuteOutboxMessageSchema = {\n    source: CODEC.PKH,\n    fee: CODEC.ZARITH,\n    counter: CODEC.ZARITH,\n    gas_limit: CODEC.ZARITH,\n    storage_limit: CODEC.ZARITH,\n    rollup: CODEC.SMART_ROLLUP_ADDRESS,\n    cemented_commitment: CODEC.SMART_ROLLUP_COMMITMENT_HASH,\n    output_proof: CODEC.PADDED_BYTES\n};\nconst FailingNoopSchema = {\n    arbitrary: CODEC.PADDED_BYTES\n};\nconst operationEncoder = (encoders)=>(operation)=>{\n        if (!(operation.kind in encoders) || !(operation.kind in kindMappingReverse)) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidOperationKindError(operation.kind);\n        }\n        return kindMappingReverse[operation.kind] + encoders[operation.kind](operation);\n    };\nconst operationDecoder = (decoders)=>(value)=>{\n        const op = value.consume(1);\n        const operationName = kindMapping[op[0]];\n        if (operationName === undefined) {\n            throw new UnsupportedOperationError(op[0].toString());\n        }\n        const decodedObj = decoders[operationName](value);\n        if (typeof decodedObj !== \"object\") {\n            throw new OperationDecodingError(\"Invalid operation, cannot be decoded.\");\n        }\n        return Object.assign({\n            kind: operationName\n        }, decodedObj);\n    };\nconst schemaEncoder = (encoders)=>(schema)=>(value)=>{\n            const keys = Object.keys(schema);\n            return keys.reduce((prev, key)=>{\n                const valueToEncode = schema[key];\n                if (value && Array.isArray(valueToEncode)) {\n                    const encoder = encoders[valueToEncode[0]];\n                    const values = value[key];\n                    if (!Array.isArray(values)) {\n                        throw new OperationEncodingError(`Invalid operation value \"${JSON.stringify(values)}\" of key \"${key}, expected value to be Array.`);\n                    }\n                    return prev + values.reduce((prevBytes, current)=>prevBytes + encoder(current), \"\");\n                } else {\n                    const encoder = encoders[valueToEncode];\n                    return prev + encoder(value[key]);\n                }\n            }, \"\");\n        };\nconst schemaDecoder = (decoders)=>(schema)=>(value)=>{\n            const keys = Object.keys(schema);\n            return keys.reduce((prev, key)=>{\n                const valueToEncode = schema[key];\n                if (Array.isArray(valueToEncode)) {\n                    const decoder = decoders[valueToEncode[0]];\n                    const decoded = [];\n                    const lastLength = value.length();\n                    while(value.length() > 0){\n                        decoded.push(decoder(value));\n                        if (lastLength === value.length()) {\n                            throw new OperationDecodingError(\"Unable to decode value\");\n                        }\n                    }\n                    return Object.assign(Object.assign({}, prev), {\n                        [key]: decoded\n                    });\n                } else {\n                    const decoder = decoders[valueToEncode];\n                    const result = decoder(value);\n                    if (typeof result !== \"undefined\") {\n                        return Object.assign(Object.assign({}, prev), {\n                            [key]: result\n                        });\n                    } else {\n                        return Object.assign({}, prev);\n                    }\n                }\n            }, {});\n        };\nconst decoders = {\n    [CODEC.SECRET]: (val)=>toHexString(val.consume(20)),\n    [CODEC.RAW]: (val)=>toHexString(val.consume(32)),\n    [CODEC.TZ1]: tz1Decoder,\n    [CODEC.BRANCH]: branchDecoder,\n    [CODEC.ZARITH]: zarithDecoder,\n    [CODEC.PUBLIC_KEY]: publicKeyDecoder,\n    [CODEC.PKH]: publicKeyHashDecoder,\n    [CODEC.PKH_ARR]: publicKeyHashesDecoder,\n    [CODEC.DELEGATE]: delegateDecoder,\n    [CODEC.INT32]: int32Decoder,\n    [CODEC.SCRIPT]: scriptDecoder,\n    [CODEC.BALLOT_STATEMENT]: ballotDecoder,\n    [CODEC.PROPOSAL]: proposalDecoder,\n    [CODEC.PROPOSAL_ARR]: proposalsDecoder,\n    [CODEC.PARAMETERS]: parametersDecoder,\n    [CODEC.ADDRESS]: addressDecoder,\n    [CODEC.SMART_ROLLUP_ADDRESS]: smartRollupAddressDecoder,\n    [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressDecoder,\n    [CODEC.SMART_ROLLUP_COMMITMENT_HASH]: smartRollupCommitmentHashDecoder,\n    [CODEC.VALUE]: valueParameterDecoder,\n    [CODEC.INT16]: int16Decoder,\n    [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashDecoder,\n    [CODEC.ENTRYPOINT]: entrypointNameDecoder,\n    [CODEC.BURN_LIMIT]: burnLimitDecoder,\n    [CODEC.DEPOSITS_LIMIT]: depositsLimitDecoder,\n    [CODEC.PVM_KIND]: pvmKindDecoder,\n    [CODEC.PADDED_BYTES]: paddedBytesDecoder,\n    [CODEC.SMART_ROLLUP_MESSAGE]: smartRollupMessageDecoder\n};\ndecoders[CODEC.OPERATION] = operationDecoder(decoders);\ndecoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val)=>schemaDecoder(decoders)(ActivationSchema)(val);\ndecoders[CODEC.OP_FAILING_NOOP] = (val)=>schemaDecoder(decoders)(FailingNoopSchema)(val);\ndecoders[CODEC.OP_DELEGATION] = (val)=>schemaDecoder(decoders)(DelegationSchema)(val);\ndecoders[CODEC.OP_TRANSACTION] = (val)=>schemaDecoder(decoders)(TransactionSchema)(val);\ndecoders[CODEC.OP_ORIGINATION] = (val)=>schemaDecoder(decoders)(OriginationSchema)(val);\ndecoders[CODEC.OP_BALLOT] = (val)=>schemaDecoder(decoders)(BallotSchema)(val);\ndecoders[CODEC.OP_ATTESTATION] = (val)=>schemaDecoder(decoders)(AttestationSchema)(val);\ndecoders[CODEC.OP_ENDORSEMENT] = (val)=>schemaDecoder(decoders)(EndorsementSchema)(val);\ndecoders[CODEC.OP_SEED_NONCE_REVELATION] = (val)=>schemaDecoder(decoders)(SeedNonceRevelationSchema)(val);\ndecoders[CODEC.OP_PROPOSALS] = (val)=>schemaDecoder(decoders)(ProposalsSchema)(val);\ndecoders[CODEC.OP_REVEAL] = (val)=>schemaDecoder(decoders)(RevealSchema)(val);\ndecoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val)=>schemaDecoder(decoders)(RegisterGlobalConstantSchema)(val);\ndecoders[CODEC.OP_TRANSFER_TICKET] = (val)=>schemaDecoder(decoders)(TransferTicketSchema)(val);\ndecoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val)=>schemaDecoder(decoders)(IncreasePaidStorageSchema)(val);\ndecoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val)=>schemaDecoder(decoders)(UpdateConsensusKeySchema)(val);\ndecoders[CODEC.OP_DRAIN_DELEGATE] = (val)=>schemaDecoder(decoders)(DrainDelegateSchema)(val);\ndecoders[CODEC.OP_SMART_ROLLUP_ORIGINATE] = (val)=>schemaDecoder(decoders)(SmartRollupOriginateSchema)(val);\ndecoders[CODEC.OP_SMART_ROLLUP_ADD_MESSAGES] = (val)=>schemaDecoder(decoders)(SmartRollupAddMessagesSchema)(val);\ndecoders[CODEC.OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE] = (val)=>schemaDecoder(decoders)(SmartRollupExecuteOutboxMessageSchema)(val);\ndecoders[CODEC.MANAGER] = schemaDecoder(decoders)(ManagerOperationSchema);\ndecoders[CODEC.OP_SET_DEPOSITS_LIMIT] = (val)=>schemaDecoder(decoders)(SetDepositsLimitSchema)(val);\nconst encoders = {\n    [CODEC.SECRET]: (val)=>val,\n    [CODEC.RAW]: (val)=>val,\n    [CODEC.TZ1]: tz1Encoder,\n    [CODEC.BRANCH]: branchEncoder,\n    [CODEC.ZARITH]: zarithEncoder,\n    [CODEC.PUBLIC_KEY]: publicKeyEncoder,\n    [CODEC.PKH]: publicKeyHashEncoder,\n    [CODEC.PKH_ARR]: publicKeyHashesEncoder,\n    [CODEC.DELEGATE]: delegateEncoder,\n    [CODEC.SCRIPT]: scriptEncoder,\n    [CODEC.BALLOT_STATEMENT]: ballotEncoder,\n    [CODEC.PROPOSAL]: proposalEncoder,\n    [CODEC.PROPOSAL_ARR]: proposalsEncoder,\n    [CODEC.INT32]: int32Encoder,\n    [CODEC.PARAMETERS]: parametersEncoder,\n    [CODEC.ADDRESS]: addressEncoder,\n    [CODEC.SMART_ROLLUP_ADDRESS]: smartRollupAddressEncoder,\n    [CODEC.SMART_CONTRACT_ADDRESS]: smartContractAddressEncoder,\n    [CODEC.SMART_ROLLUP_COMMITMENT_HASH]: smartRollupCommitmentHashEncoder,\n    [CODEC.VALUE]: valueParameterEncoder,\n    [CODEC.INT16]: int16Encoder,\n    [CODEC.BLOCK_PAYLOAD_HASH]: blockPayloadHashEncoder,\n    [CODEC.ENTRYPOINT]: entrypointNameEncoder,\n    [CODEC.BURN_LIMIT]: burnLimitEncoder,\n    [CODEC.DEPOSITS_LIMIT]: depositsLimitEncoder,\n    [CODEC.PVM_KIND]: pvmKindEncoder,\n    [CODEC.PADDED_BYTES]: paddedBytesEncoder,\n    [CODEC.SMART_ROLLUP_MESSAGE]: smartRollupMessageEncoder\n};\nencoders[CODEC.OPERATION] = operationEncoder(encoders);\nencoders[CODEC.OP_ACTIVATE_ACCOUNT] = (val)=>schemaEncoder(encoders)(ActivationSchema)(val);\nencoders[CODEC.OP_DELEGATION] = (val)=>schemaEncoder(encoders)(DelegationSchema)(val);\nencoders[CODEC.OP_TRANSACTION] = (val)=>schemaEncoder(encoders)(TransactionSchema)(val);\nencoders[CODEC.OP_ORIGINATION] = (val)=>schemaEncoder(encoders)(OriginationSchema)(val);\nencoders[CODEC.OP_BALLOT] = (val)=>schemaEncoder(encoders)(BallotSchema)(val);\nencoders[CODEC.OP_ATTESTATION] = (val)=>schemaEncoder(encoders)(AttestationSchema)(val);\nencoders[CODEC.OP_ENDORSEMENT] = (val)=>schemaEncoder(encoders)(EndorsementSchema)(val);\nencoders[CODEC.OP_SEED_NONCE_REVELATION] = (val)=>schemaEncoder(encoders)(SeedNonceRevelationSchema)(val);\nencoders[CODEC.OP_PROPOSALS] = (val)=>schemaEncoder(encoders)(ProposalsSchema)(val);\nencoders[CODEC.OP_REVEAL] = (val)=>schemaEncoder(encoders)(RevealSchema)(val);\nencoders[CODEC.OP_REGISTER_GLOBAL_CONSTANT] = (val)=>schemaEncoder(encoders)(RegisterGlobalConstantSchema)(val);\nencoders[CODEC.OP_TRANSFER_TICKET] = (val)=>schemaEncoder(encoders)(TransferTicketSchema)(val);\nencoders[CODEC.OP_INCREASE_PAID_STORAGE] = (val)=>schemaEncoder(encoders)(IncreasePaidStorageSchema)(val);\nencoders[CODEC.OP_UPDATE_CONSENSUS_KEY] = (val)=>schemaEncoder(encoders)(UpdateConsensusKeySchema)(val);\nencoders[CODEC.OP_DRAIN_DELEGATE] = (val)=>schemaEncoder(encoders)(DrainDelegateSchema)(val);\nencoders[CODEC.OP_SMART_ROLLUP_ORIGINATE] = (val)=>schemaEncoder(encoders)(SmartRollupOriginateSchema)(val);\nencoders[CODEC.OP_SMART_ROLLUP_ADD_MESSAGES] = (val)=>schemaEncoder(encoders)(SmartRollupAddMessagesSchema)(val);\nencoders[CODEC.OP_SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE] = (val)=>schemaEncoder(encoders)(SmartRollupExecuteOutboxMessageSchema)(val);\nencoders[CODEC.MANAGER] = schemaEncoder(encoders)(ManagerOperationSchema);\nencoders[CODEC.OP_SET_DEPOSITS_LIMIT] = (val)=>schemaEncoder(encoders)(SetDepositsLimitSchema)(val);\nencoders[CODEC.OP_FAILING_NOOP] = (val)=>schemaEncoder(encoders)(FailingNoopSchema)(val);\nconst OperationKindMapping = {\n    activate_account: ActivationSchema,\n    reveal: RevealSchema,\n    delegation: DelegationSchema,\n    transaction: TransactionSchema,\n    origination: OriginationSchema,\n    ballot: BallotSchema,\n    attestation: AttestationSchema,\n    endorsement: EndorsementSchema,\n    seed_nonce_revelation: SeedNonceRevelationSchema,\n    proposals: ProposalsSchema,\n    register_global_constant: RegisterGlobalConstantSchema,\n    transfer_ticket: TransferTicketSchema,\n    increase_paid_storage: IncreasePaidStorageSchema,\n    update_consensus_key: UpdateConsensusKeySchema,\n    drain_delegate: DrainDelegateSchema,\n    set_deposits_limit: SetDepositsLimitSchema,\n    smart_rollup_originate: SmartRollupOriginateSchema,\n    smart_rollup_add_messages: SmartRollupAddMessagesSchema,\n    smart_rollup_execute_outbox_message: SmartRollupExecuteOutboxMessageSchema,\n    failing_noop: FailingNoopSchema\n};\n// Asymmetric difference: only account for things in arr2 that are not present in arr1, not vice versa\nconst getArrayDifference = (arr1, arr2)=>{\n    return arr2.filter((x)=>!arr1.includes(x));\n};\nconst deleteArrayElementByValue = (array, item)=>{\n    return array.filter((e)=>e !== item);\n};\n/**\n * @returns A boolean value to indicate whether the operation kind is valid or not\n */ const validateOperationKind = (opKind)=>{\n    const opKindList = Object.keys(OperationKindMapping);\n    return opKindList.includes(opKind);\n};\n/**\n *  returns 0 when the two array of properties are identical or the passed property\n *  does not have any missing parameters from the corresponding schema\n *\n *  @returns array element differences if there are missing required property keys\n */ const validateMissingProperty = (operationContent)=>{\n    const kind = operationContent.kind;\n    const keys = Object.keys(operationContent);\n    const cleanKeys = deleteArrayElementByValue(keys, \"kind\");\n    const schemaKeys = Object.keys(OperationKindMapping[kind]);\n    return getArrayDifference(cleanKeys, schemaKeys);\n};\nvar ProtocolsHash;\n(function(ProtocolsHash) {\n    ProtocolsHash[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n    ProtocolsHash[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n    ProtocolsHash[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n    ProtocolsHash[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n    ProtocolsHash[\"PsDELPH1\"] = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\";\n    ProtocolsHash[\"PtEdo2Zk\"] = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\";\n    ProtocolsHash[\"PsFLorena\"] = \"PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i\";\n    ProtocolsHash[\"PtGRANADs\"] = \"PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV\";\n    ProtocolsHash[\"PtHangz2\"] = \"PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx\";\n    ProtocolsHash[\"Psithaca2\"] = \"Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A\";\n    ProtocolsHash[\"PtJakart2\"] = \"PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY\";\n    ProtocolsHash[\"PtKathman\"] = \"PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg\";\n    ProtocolsHash[\"PtLimaPtL\"] = \"PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW\";\n    ProtocolsHash[\"PtMumbaii\"] = \"PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc\";\n    ProtocolsHash[\"PtMumbai2\"] = \"PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1\";\n    ProtocolsHash[\"PtNairobi\"] = \"PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf\";\n    ProtocolsHash[\"ProxfordY\"] = \"ProxfordYmVfjWnRcgjWH36fW6PArwqykTFzotUxRs6gmTcZDuH\";\n    ProtocolsHash[\"ProtoALpha\"] = \"ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK\";\n})(ProtocolsHash || (ProtocolsHash = {}));\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\n/**\n * @packageDocumentation\n * @module @taquito/local-forging\n */ const PROTOCOL_CURRENT = ProtocolsHash.ProxfordY;\nfunction getCodec(codec, _proto) {\n    return {\n        encoder: encoders[codec],\n        decoder: (hex)=>{\n            const consumer = Uint8ArrayConsumer.fromHexString(hex);\n            return decoders[codec](consumer);\n        }\n    };\n}\n//\nclass LocalForger {\n    constructor(protocolHash = PROTOCOL_CURRENT){\n        this.protocolHash = protocolHash;\n        this.codec = getCodec(CODEC.MANAGER, this.protocolHash);\n    }\n    forge(params) {\n        const branchValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.validateBlock)(params.branch);\n        if (branchValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_0__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidBlockHashError(params.branch, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_0__.invalidDetail)(branchValidation));\n        }\n        for (const content of params.contents){\n            if (!validateOperationKind(content.kind)) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidOperationKindError(content.kind);\n            }\n            const diff = validateMissingProperty(content);\n            if (diff.length === 1) {\n                if (content.kind === \"delegation\" && diff[0] === \"delegate\") {\n                    continue;\n                } else if (content.kind === \"origination\" && diff[0] === \"delegate\") {\n                    continue;\n                } else if (content.kind === \"transaction\" && diff[0] === \"parameters\") {\n                    continue;\n                } else if (content.kind === \"set_deposits_limit\" && diff[0] === \"limit\") {\n                    continue;\n                } else if (content.kind === \"smart_rollup_originate\" && diff[0] === \"whitelist\") {\n                    continue;\n                } else {\n                    throw new InvalidOperationSchemaError(content, `missing properties \"${diff.join(\", \")}\"`);\n                }\n            } else if (diff.length > 1) {\n                throw new InvalidOperationSchemaError(content, `missing properties \"${diff.join(\", \")}\"`);\n            }\n        }\n        const forged = this.codec.encoder(params).toLowerCase();\n        return Promise.resolve(forged);\n    }\n    parse(hex) {\n        return Promise.resolve(this.codec.decoder(hex));\n    }\n}\nconst localForger = new LocalForger();\n //# sourceMappingURL=taquito-local-forging.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vbG9jYWwtZm9yZ2luZy9kaXN0L3RhcXVpdG8tbG9jYWwtZm9yZ2luZy5lczYuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMkw7QUFDUDtBQUM5SDtBQUV0RCxNQUFNbUIsY0FBYyxDQUFDQyxRQUFVQSxNQUFNQyxNQUFNLENBQUMsQ0FBQ0MsS0FBS0MsT0FBU0QsTUFBTUMsS0FBS0MsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQyxHQUFHLE1BQU07QUFDckcsTUFBTUMsTUFBTSxDQUFDQyxLQUFLQyxhQUFhLENBQUM7SUFDNUIsT0FBT0QsSUFBSUgsUUFBUSxDQUFDLElBQUlDLFFBQVEsQ0FBQ0csWUFBWTtBQUNqRDtBQUVBOzs7Q0FHQyxHQUNELDhGQUE4RjtBQUM5RixNQUFNQyx3QkFBd0I7QUFDOUIsSUFBSUM7QUFDSCxVQUFVQSxLQUFLO0lBQ1pBLEtBQUssQ0FBQyxTQUFTLEdBQUc7SUFDbEJBLEtBQUssQ0FBQyxNQUFNLEdBQUc7SUFDZkEsS0FBSyxDQUFDLE1BQU0sR0FBRztJQUNmQSxLQUFLLENBQUMsU0FBUyxHQUFHO0lBQ2xCQSxLQUFLLENBQUMsU0FBUyxHQUFHO0lBQ2xCQSxLQUFLLENBQUMsYUFBYSxHQUFHO0lBQ3RCQSxLQUFLLENBQUMsTUFBTSxHQUFHO0lBQ2ZBLEtBQUssQ0FBQyxVQUFVLEdBQUc7SUFDbkJBLEtBQUssQ0FBQyxXQUFXLEdBQUc7SUFDcEJBLEtBQUssQ0FBQyxTQUFTLEdBQUc7SUFDbEJBLEtBQUssQ0FBQyxtQkFBbUIsR0FBRztJQUM1QkEsS0FBSyxDQUFDLFdBQVcsR0FBRztJQUNwQkEsS0FBSyxDQUFDLGVBQWUsR0FBRztJQUN4QkEsS0FBSyxDQUFDLFFBQVEsR0FBRztJQUNqQkEsS0FBSyxDQUFDLFFBQVEsR0FBRztJQUNqQkEsS0FBSyxDQUFDLGFBQWEsR0FBRztJQUN0QkEsS0FBSyxDQUFDLFVBQVUsR0FBRztJQUNuQkEsS0FBSyxDQUFDLHlCQUF5QixHQUFHO0lBQ2xDQSxLQUFLLENBQUMsdUJBQXVCLEdBQUc7SUFDaENBLEtBQUssQ0FBQywrQkFBK0IsR0FBRztJQUN4Q0EsS0FBSyxDQUFDLFFBQVEsR0FBRztJQUNqQkEsS0FBSyxDQUFDLGVBQWUsR0FBRztJQUN4QkEsS0FBSyxDQUFDLHVCQUF1QixHQUFHO0lBQ2hDQSxLQUFLLENBQUMsVUFBVSxHQUFHO0lBQ25CQSxLQUFLLENBQUMscUJBQXFCLEdBQUc7SUFDOUJBLEtBQUssQ0FBQyxhQUFhLEdBQUc7SUFDdEJBLEtBQUssQ0FBQyxZQUFZLEdBQUc7SUFDckJBLEtBQUssQ0FBQyxzQkFBc0IsR0FBRztJQUMvQkEsS0FBSyxDQUFDLGdCQUFnQixHQUFHO0lBQ3pCQSxLQUFLLENBQUMsaUJBQWlCLEdBQUc7SUFDMUJBLEtBQUssQ0FBQyxpQkFBaUIsR0FBRztJQUMxQkEsS0FBSyxDQUFDLFlBQVksR0FBRztJQUNyQkEsS0FBSyxDQUFDLGtCQUFrQixHQUFHO0lBQzNCQSxLQUFLLENBQUMsaUJBQWlCLEdBQUc7SUFDMUJBLEtBQUssQ0FBQyxpQkFBaUIsR0FBRztJQUMxQkEsS0FBSyxDQUFDLDJCQUEyQixHQUFHO0lBQ3BDQSxLQUFLLENBQUMsWUFBWSxHQUFHO0lBQ3JCQSxLQUFLLENBQUMsZUFBZSxHQUFHO0lBQ3hCQSxLQUFLLENBQUMsOEJBQThCLEdBQUc7SUFDdkNBLEtBQUssQ0FBQyxxQkFBcUIsR0FBRztJQUM5QkEsS0FBSyxDQUFDLGFBQWEsR0FBRztJQUN0QkEsS0FBSyxDQUFDLDJCQUEyQixHQUFHO0lBQ3BDQSxLQUFLLENBQUMsMEJBQTBCLEdBQUc7SUFDbkNBLEtBQUssQ0FBQyxvQkFBb0IsR0FBRztJQUM3QkEsS0FBSyxDQUFDLGlCQUFpQixHQUFHO0lBQzFCQSxLQUFLLENBQUMsd0JBQXdCLEdBQUc7SUFDakNBLEtBQUssQ0FBQyw0QkFBNEIsR0FBRztJQUNyQ0EsS0FBSyxDQUFDLFdBQVcsR0FBRztJQUNwQkEsS0FBSyxDQUFDLCtCQUErQixHQUFHO0lBQ3hDQSxLQUFLLENBQUMseUNBQXlDLEdBQUc7QUFDdEQsR0FBR0EsU0FBVUEsQ0FBQUEsUUFBUSxDQUFDO0FBQ3RCLG1FQUFtRTtBQUNuRSxNQUFNQyxZQUFZO0lBQ2QsTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFBTTtJQUNOLE1BQU07SUFDTixNQUFNO0lBQ04sTUFB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TWdZLGNBQWMsSUFBSVg7QUFFMEgsQ0FDbEoscURBQXFEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdycGVya3MvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vbG9jYWwtZm9yZ2luZy9kaXN0L3RhcXVpdG8tbG9jYWwtZm9yZ2luZy5lczYuanM/ZWRiYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQcmVmaXgsIGJ1ZjJoZXgsIGI1OGNkZWNvZGUsIHByZWZpeCwgcHJlZml4TGVuZ3RoLCBiNThjZW5jb2RlLCBJbnZhbGlkS2V5SGFzaEVycm9yLCBpbnZhbGlkRGV0YWlsLCBWYWxpZGF0aW9uUmVzdWx0LCBJbnZhbGlkUHVibGljS2V5RXJyb3IsIHZhbGlkYXRlQmxvY2sgfSBmcm9tICdAdGFxdWl0by91dGlscyc7XG5pbXBvcnQgeyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3IsIEludmFsaWRIZXhTdHJpbmdFcnJvciwgSW52YWxpZEFkZHJlc3NFcnJvciwgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yLCBJbnZhbGlkT3BlcmF0aW9uS2luZEVycm9yLCBJbnZhbGlkQmxvY2tIYXNoRXJyb3IgfSBmcm9tICdAdGFxdWl0by9jb3JlJztcbmltcG9ydCBCaWdOdW1iZXIkMSwgeyBCaWdOdW1iZXIgfSBmcm9tICdiaWdudW1iZXIuanMnO1xuXG5jb25zdCB0b0hleFN0cmluZyA9IChieXRlcykgPT4gYnl0ZXMucmVkdWNlKChzdHIsIGJ5dGUpID0+IHN0ciArIGJ5dGUudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyksICcnKTtcbmNvbnN0IHBhZCA9IChudW0sIHBhZGRpbmdMZW4gPSA4KSA9PiB7XG4gICAgcmV0dXJuIG51bS50b1N0cmluZygxNikucGFkU3RhcnQocGFkZGluZ0xlbiwgJzAnKTtcbn07XG5cbi8qXG4gKiBTb21lIGNvZGUgaW4gdGhpcyBmaWxlIGlzIG9yaWdpbmFsbHkgZnJvbSBzb3RlelxuICogQ29weXJpZ2h0IChjKSAyMDE4IEFuZHJldyBLaXNoaW5vXG4gKi9cbi8vIFNlZTogaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vcHJvdG9jb2xzLzAwNV9iYWJ5bG9uLmh0bWwjdHJhbnNhY3Rpb25zLW5vdy1oYXZlLWFuLWVudHJ5cG9pbnRcbmNvbnN0IEVOVFJZUE9JTlRfTUFYX0xFTkdUSCA9IDMxO1xudmFyIENPREVDO1xuKGZ1bmN0aW9uIChDT0RFQykge1xuICAgIENPREVDW1wiU0VDUkVUXCJdID0gXCJzZWNyZXRcIjtcbiAgICBDT0RFQ1tcIlJBV1wiXSA9IFwicmF3XCI7XG4gICAgQ09ERUNbXCJUWjFcIl0gPSBcInR6MVwiO1xuICAgIENPREVDW1wiQlJBTkNIXCJdID0gXCJicmFuY2hcIjtcbiAgICBDT0RFQ1tcIlpBUklUSFwiXSA9IFwiemFyaXRoXCI7XG4gICAgQ09ERUNbXCJQVUJMSUNfS0VZXCJdID0gXCJwdWJsaWNfa2V5XCI7XG4gICAgQ09ERUNbXCJQS0hcIl0gPSBcInBraFwiO1xuICAgIENPREVDW1wiUEtIX0FSUlwiXSA9IFwicGtoQXJyXCI7XG4gICAgQ09ERUNbXCJERUxFR0FURVwiXSA9IFwiZGVsZWdhdGVcIjtcbiAgICBDT0RFQ1tcIlNDUklQVFwiXSA9IFwic2NyaXB0XCI7XG4gICAgQ09ERUNbXCJCQUxMT1RfU1RBVEVNRU5UXCJdID0gXCJiYWxsb3RTdG10XCI7XG4gICAgQ09ERUNbXCJQUk9QT1NBTFwiXSA9IFwicHJvcG9zYWxcIjtcbiAgICBDT0RFQ1tcIlBST1BPU0FMX0FSUlwiXSA9IFwicHJvcG9zYWxBcnJcIjtcbiAgICBDT0RFQ1tcIklOVDMyXCJdID0gXCJpbnQzMlwiO1xuICAgIENPREVDW1wiSU5UMTZcIl0gPSBcImludDE2XCI7XG4gICAgQ09ERUNbXCJQQVJBTUVURVJTXCJdID0gXCJwYXJhbWV0ZXJzXCI7XG4gICAgQ09ERUNbXCJBRERSRVNTXCJdID0gXCJhZGRyZXNzXCI7XG4gICAgQ09ERUNbXCJTTUFSVF9DT05UUkFDVF9BRERSRVNTXCJdID0gXCJzbWFydF9jb250cmFjdF9hZGRyZXNzXCI7XG4gICAgQ09ERUNbXCJTTUFSVF9ST0xMVVBfQUREUkVTU1wiXSA9IFwic21hcnRfcm9sbHVwX2FkZHJlc3NcIjtcbiAgICBDT0RFQ1tcIlNNQVJUX1JPTExVUF9DT01NSVRNRU5UX0hBU0hcIl0gPSBcInNtYXJ0X3JvbGx1cF9jb21taXRtZW50X2hhc2hcIjtcbiAgICBDT0RFQ1tcIlZBTFVFXCJdID0gXCJ2YWx1ZVwiO1xuICAgIENPREVDW1wiUEFEREVEX0JZVEVTXCJdID0gXCJwYWRkZWRfYnl0ZXNcIjtcbiAgICBDT0RFQ1tcIlNNQVJUX1JPTExVUF9NRVNTQUdFXCJdID0gXCJzbWFydF9yb2xsdXBfbWVzc2FnZVwiO1xuICAgIENPREVDW1wiTUFOQUdFUlwiXSA9IFwibWFuYWdlclwiO1xuICAgIENPREVDW1wiQkxPQ0tfUEFZTE9BRF9IQVNIXCJdID0gXCJibG9ja1BheWxvYWRIYXNoXCI7XG4gICAgQ09ERUNbXCJFTlRSWVBPSU5UXCJdID0gXCJlbnRyeXBvaW50XCI7XG4gICAgQ09ERUNbXCJPUEVSQVRJT05cIl0gPSBcIm9wZXJhdGlvblwiO1xuICAgIENPREVDW1wiT1BfQUNUSVZBVEVfQUNDT1VOVFwiXSA9IFwiYWN0aXZhdGVfYWNjb3VudFwiO1xuICAgIENPREVDW1wiT1BfREVMRUdBVElPTlwiXSA9IFwiZGVsZWdhdGlvblwiO1xuICAgIENPREVDW1wiT1BfVFJBTlNBQ1RJT05cIl0gPSBcInRyYW5zYWN0aW9uXCI7XG4gICAgQ09ERUNbXCJPUF9PUklHSU5BVElPTlwiXSA9IFwib3JpZ2luYXRpb25cIjtcbiAgICBDT0RFQ1tcIk9QX0JBTExPVFwiXSA9IFwiYmFsbG90XCI7XG4gICAgQ09ERUNbXCJPUF9GQUlMSU5HX05PT1BcIl0gPSBcImZhaWxpbmdfbm9vcFwiO1xuICAgIENPREVDW1wiT1BfQVRURVNUQVRJT05cIl0gPSBcImF0dGVzdGF0aW9uXCI7XG4gICAgQ09ERUNbXCJPUF9FTkRPUlNFTUVOVFwiXSA9IFwiZW5kb3JzZW1lbnRcIjtcbiAgICBDT0RFQ1tcIk9QX1NFRURfTk9OQ0VfUkVWRUxBVElPTlwiXSA9IFwic2VlZF9ub25jZV9yZXZlbGF0aW9uXCI7XG4gICAgQ09ERUNbXCJPUF9SRVZFQUxcIl0gPSBcInJldmVhbFwiO1xuICAgIENPREVDW1wiT1BfUFJPUE9TQUxTXCJdID0gXCJwcm9wb3NhbHNcIjtcbiAgICBDT0RFQ1tcIk9QX1JFR0lTVEVSX0dMT0JBTF9DT05TVEFOVFwiXSA9IFwicmVnaXN0ZXJfZ2xvYmFsX2NvbnN0YW50XCI7XG4gICAgQ09ERUNbXCJPUF9UUkFOU0ZFUl9USUNLRVRcIl0gPSBcInRyYW5zZmVyX3RpY2tldFwiO1xuICAgIENPREVDW1wiQlVSTl9MSU1JVFwiXSA9IFwiYnVybl9saW1pdFwiO1xuICAgIENPREVDW1wiT1BfSU5DUkVBU0VfUEFJRF9TVE9SQUdFXCJdID0gXCJpbmNyZWFzZV9wYWlkX3N0b3JhZ2VcIjtcbiAgICBDT0RFQ1tcIk9QX1VQREFURV9DT05TRU5TVVNfS0VZXCJdID0gXCJ1cGRhdGVfY29uc2Vuc3VzX2tleVwiO1xuICAgIENPREVDW1wiT1BfRFJBSU5fREVMRUdBVEVcIl0gPSBcImRyYWluX2RlbGVnYXRlXCI7XG4gICAgQ09ERUNbXCJERVBPU0lUU19MSU1JVFwiXSA9IFwiZGVwb3NpdHNfbGltaXRcIjtcbiAgICBDT0RFQ1tcIk9QX1NFVF9ERVBPU0lUU19MSU1JVFwiXSA9IFwic2V0X2RlcG9zaXRzX2xpbWl0XCI7XG4gICAgQ09ERUNbXCJPUF9TTUFSVF9ST0xMVVBfT1JJR0lOQVRFXCJdID0gXCJzbWFydF9yb2xsdXBfb3JpZ2luYXRlXCI7XG4gICAgQ09ERUNbXCJQVk1fS0lORFwiXSA9IFwicHZtX2tpbmRcIjtcbiAgICBDT0RFQ1tcIk9QX1NNQVJUX1JPTExVUF9BRERfTUVTU0FHRVNcIl0gPSBcInNtYXJ0X3JvbGx1cF9hZGRfbWVzc2FnZXNcIjtcbiAgICBDT0RFQ1tcIk9QX1NNQVJUX1JPTExVUF9FWEVDVVRFX09VVEJPWF9NRVNTQUdFXCJdID0gXCJzbWFydF9yb2xsdXBfZXhlY3V0ZV9vdXRib3hfbWVzc2FnZVwiO1xufSkoQ09ERUMgfHwgKENPREVDID0ge30pKTtcbi8vIFNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby93aGl0ZWRvYy9taWNoZWxzb24uaHRtbCNmdWxsLWdyYW1tYXJcbmNvbnN0IG9wTWFwcGluZyA9IHtcbiAgICAnMDAnOiAncGFyYW1ldGVyJyxcbiAgICAnMDEnOiAnc3RvcmFnZScsXG4gICAgJzAyJzogJ2NvZGUnLFxuICAgICcwMyc6ICdGYWxzZScsXG4gICAgJzA0JzogJ0VsdCcsXG4gICAgJzA1JzogJ0xlZnQnLFxuICAgICcwNic6ICdOb25lJyxcbiAgICAnMDcnOiAnUGFpcicsXG4gICAgJzA4JzogJ1JpZ2h0JyxcbiAgICAnMDknOiAnU29tZScsXG4gICAgJzBhJzogJ1RydWUnLFxuICAgICcwYic6ICdVbml0JyxcbiAgICAnMGMnOiAnUEFDSycsXG4gICAgJzBkJzogJ1VOUEFDSycsXG4gICAgJzBlJzogJ0JMQUtFMkInLFxuICAgICcwZic6ICdTSEEyNTYnLFxuICAgICcxMCc6ICdTSEE1MTInLFxuICAgICcxMSc6ICdBQlMnLFxuICAgICcxMic6ICdBREQnLFxuICAgICcxMyc6ICdBTU9VTlQnLFxuICAgICcxNCc6ICdBTkQnLFxuICAgICcxNSc6ICdCQUxBTkNFJyxcbiAgICAnMTYnOiAnQ0FSJyxcbiAgICAnMTcnOiAnQ0RSJyxcbiAgICAnMTgnOiAnQ0hFQ0tfU0lHTkFUVVJFJyxcbiAgICAnMTknOiAnQ09NUEFSRScsXG4gICAgJzFhJzogJ0NPTkNBVCcsXG4gICAgJzFiJzogJ0NPTlMnLFxuICAgICcxYyc6ICdDUkVBVEVfQUNDT1VOVCcsXG4gICAgJzFkJzogJ0NSRUFURV9DT05UUkFDVCcsXG4gICAgJzFlJzogJ0lNUExJQ0lUX0FDQ09VTlQnLFxuICAgICcxZic6ICdESVAnLFxuICAgICcyMCc6ICdEUk9QJyxcbiAgICAnMjEnOiAnRFVQJyxcbiAgICAnMjInOiAnRURJVicsXG4gICAgJzIzJzogJ0VNUFRZX01BUCcsXG4gICAgJzI0JzogJ0VNUFRZX1NFVCcsXG4gICAgJzI1JzogJ0VRJyxcbiAgICAnMjYnOiAnRVhFQycsXG4gICAgJzI3JzogJ0ZBSUxXSVRIJyxcbiAgICAnMjgnOiAnR0UnLFxuICAgICcyOSc6ICdHRVQnLFxuICAgICcyYSc6ICdHVCcsXG4gICAgJzJiJzogJ0hBU0hfS0VZJyxcbiAgICAnMmMnOiAnSUYnLFxuICAgICcyZCc6ICdJRl9DT05TJyxcbiAgICAnMmUnOiAnSUZfTEVGVCcsXG4gICAgJzJmJzogJ0lGX05PTkUnLFxuICAgICczMCc6ICdJTlQnLFxuICAgICczMSc6ICdMQU1CREEnLFxuICAgICczMic6ICdMRScsXG4gICAgJzMzJzogJ0xFRlQnLFxuICAgICczNCc6ICdMT09QJyxcbiAgICAnMzUnOiAnTFNMJyxcbiAgICAnMzYnOiAnTFNSJyxcbiAgICAnMzcnOiAnTFQnLFxuICAgICczOCc6ICdNQVAnLFxuICAgICczOSc6ICdNRU0nLFxuICAgICczYSc6ICdNVUwnLFxuICAgICczYic6ICdORUcnLFxuICAgICczYyc6ICdORVEnLFxuICAgICczZCc6ICdOSUwnLFxuICAgICczZSc6ICdOT05FJyxcbiAgICAnM2YnOiAnTk9UJyxcbiAgICAnNDAnOiAnTk9XJyxcbiAgICAnNDEnOiAnT1InLFxuICAgICc0Mic6ICdQQUlSJyxcbiAgICAnNDMnOiAnUFVTSCcsXG4gICAgJzQ0JzogJ1JJR0hUJyxcbiAgICAnNDUnOiAnU0laRScsXG4gICAgJzQ2JzogJ1NPTUUnLFxuICAgICc0Nyc6ICdTT1VSQ0UnLFxuICAgICc0OCc6ICdTRU5ERVInLFxuICAgICc0OSc6ICdTRUxGJyxcbiAgICAnNGEnOiAnU1RFUFNfVE9fUVVPVEEnLFxuICAgICc0Yic6ICdTVUInLFxuICAgICc0Yyc6ICdTV0FQJyxcbiAgICAnNGQnOiAnVFJBTlNGRVJfVE9LRU5TJyxcbiAgICAnNGUnOiAnU0VUX0RFTEVHQVRFJyxcbiAgICAnNGYnOiAnVU5JVCcsXG4gICAgJzUwJzogJ1VQREFURScsXG4gICAgJzUxJzogJ1hPUicsXG4gICAgJzUyJzogJ0lURVInLFxuICAgICc1Myc6ICdMT09QX0xFRlQnLFxuICAgICc1NCc6ICdBRERSRVNTJyxcbiAgICAnNTUnOiAnQ09OVFJBQ1QnLFxuICAgICc1Nic6ICdJU05BVCcsXG4gICAgJzU3JzogJ0NBU1QnLFxuICAgICc1OCc6ICdSRU5BTUUnLFxuICAgICc1OSc6ICdib29sJyxcbiAgICAnNWEnOiAnY29udHJhY3QnLFxuICAgICc1Yic6ICdpbnQnLFxuICAgICc1Yyc6ICdrZXknLFxuICAgICc1ZCc6ICdrZXlfaGFzaCcsXG4gICAgJzVlJzogJ2xhbWJkYScsXG4gICAgJzVmJzogJ2xpc3QnLFxuICAgICc2MCc6ICdtYXAnLFxuICAgICc2MSc6ICdiaWdfbWFwJyxcbiAgICAnNjInOiAnbmF0JyxcbiAgICAnNjMnOiAnb3B0aW9uJyxcbiAgICAnNjQnOiAnb3InLFxuICAgICc2NSc6ICdwYWlyJyxcbiAgICAnNjYnOiAnc2V0JyxcbiAgICAnNjcnOiAnc2lnbmF0dXJlJyxcbiAgICAnNjgnOiAnc3RyaW5nJyxcbiAgICAnNjknOiAnYnl0ZXMnLFxuICAgICc2YSc6ICdtdXRleicsXG4gICAgJzZiJzogJ3RpbWVzdGFtcCcsXG4gICAgJzZjJzogJ3VuaXQnLFxuICAgICc2ZCc6ICdvcGVyYXRpb24nLFxuICAgICc2ZSc6ICdhZGRyZXNzJyxcbiAgICAnNmYnOiAnU0xJQ0UnLFxuICAgICc3MCc6ICdESUcnLFxuICAgICc3MSc6ICdEVUcnLFxuICAgICc3Mic6ICdFTVBUWV9CSUdfTUFQJyxcbiAgICAnNzMnOiAnQVBQTFknLFxuICAgICc3NCc6ICdjaGFpbl9pZCcsXG4gICAgJzc1JzogJ0NIQUlOX0lEJyxcbiAgICAnNzYnOiAnTEVWRUwnLFxuICAgICc3Nyc6ICdTRUxGX0FERFJFU1MnLFxuICAgICc3OCc6ICduZXZlcicsXG4gICAgJzc5JzogJ05FVkVSJyxcbiAgICAnN2EnOiAnVU5QQUlSJyxcbiAgICAnN2InOiAnVk9USU5HX1BPV0VSJyxcbiAgICAnN2MnOiAnVE9UQUxfVk9USU5HX1BPV0VSJyxcbiAgICAnN2QnOiAnS0VDQ0FLJyxcbiAgICAnN2UnOiAnU0hBMycsXG4gICAgJzdmJzogJ1BBSVJJTkdfQ0hFQ0snLFxuICAgICc4MCc6ICdibHMxMl8zODFfZzEnLFxuICAgICc4MSc6ICdibHMxMl8zODFfZzInLFxuICAgICc4Mic6ICdibHMxMl8zODFfZnInLFxuICAgICc4Myc6ICdzYXBsaW5nX3N0YXRlJyxcbiAgICAnODQnOiAnc2FwbGluZ190cmFuc2FjdGlvbl9kZXByZWNhdGVkJyxcbiAgICAnODUnOiAnU0FQTElOR19FTVBUWV9TVEFURScsXG4gICAgJzg2JzogJ1NBUExJTkdfVkVSSUZZX1VQREFURScsXG4gICAgJzg3JzogJ3RpY2tldCcsXG4gICAgJzg4JzogJ1RJQ0tFVF9ERVBSRUNBVEVEJyxcbiAgICAnODknOiAnUkVBRF9USUNLRVQnLFxuICAgICc4YSc6ICdTUExJVF9USUNLRVQnLFxuICAgICc4Yic6ICdKT0lOX1RJQ0tFVFMnLFxuICAgICc4Yyc6ICdHRVRfQU5EX1VQREFURScsXG4gICAgJzhkJzogJ2NoZXN0JyxcbiAgICAnOGUnOiAnY2hlc3Rfa2V5JyxcbiAgICAnOGYnOiAnT1BFTl9DSEVTVCcsXG4gICAgJzkwJzogJ1ZJRVcnLFxuICAgICc5MSc6ICd2aWV3JyxcbiAgICAnOTInOiAnY29uc3RhbnQnLFxuICAgICc5Myc6ICdTVUJfTVVURVonLFxuICAgICc5NCc6ICd0eF9yb2xsdXBfbDJfYWRkcmVzcycsXG4gICAgJzk1JzogJ01JTl9CTE9DS19USU1FJyxcbiAgICAnOTYnOiAnc2FwbGluZ190cmFuc2FjdGlvbicsXG4gICAgJzk3JzogJ0VNSVQnLFxuICAgICc5OCc6ICdMYW1iZGFfcmVjJyxcbiAgICAnOTknOiAnTEFNQkRBX1JFQycsXG4gICAgJzlhJzogJ1RJQ0tFVCcsXG4gICAgJzliJzogJ0JZVEVTJyxcbiAgICAnOWMnOiAnTkFUJyxcbn07XG5jb25zdCBvcE1hcHBpbmdSZXZlcnNlID0gKCgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhvcE1hcHBpbmcpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICByZXN1bHRbb3BNYXBwaW5nW2tleV1dID0ga2V5O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuLy8gU2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL3NoZWxsL3AycF9hcGkuaHRtbD9oaWdobGlnaHQ9cDJwXG5jb25zdCBraW5kTWFwcGluZyA9IHtcbiAgICAweDA0OiAnYWN0aXZhdGVfYWNjb3VudCcsXG4gICAgMHg2YjogJ3JldmVhbCcsXG4gICAgMHg2ZTogJ2RlbGVnYXRpb24nLFxuICAgIDB4NmM6ICd0cmFuc2FjdGlvbicsXG4gICAgMHg2ZDogJ29yaWdpbmF0aW9uJyxcbiAgICAweDA2OiAnYmFsbG90JyxcbiAgICAweDE1OiAnYXR0ZXN0YXRpb24nLFxuICAgIDB4MDE6ICdzZWVkX25vbmNlX3JldmVsYXRpb24nLFxuICAgIDB4MDU6ICdwcm9wb3NhbHMnLFxuICAgIDB4NmY6ICdyZWdpc3Rlcl9nbG9iYWxfY29uc3RhbnQnLFxuICAgIDB4OWU6ICd0cmFuc2Zlcl90aWNrZXQnLFxuICAgIDB4NzA6ICdzZXRfZGVwb3NpdHNfbGltaXQnLFxuICAgIDB4NzE6ICdpbmNyZWFzZV9wYWlkX3N0b3JhZ2UnLFxuICAgIDB4NzI6ICd1cGRhdGVfY29uc2Vuc3VzX2tleScsXG4gICAgMHgwOTogJ2RyYWluX2RlbGVnYXRlJyxcbiAgICAweGM4OiAnc21hcnRfcm9sbHVwX29yaWdpbmF0ZScsXG4gICAgMHhjOTogJ3NtYXJ0X3JvbGx1cF9hZGRfbWVzc2FnZXMnLFxuICAgIDB4Y2U6ICdzbWFydF9yb2xsdXBfZXhlY3V0ZV9vdXRib3hfbWVzc2FnZScsXG4gICAgMHgxMTogJ2ZhaWxpbmdfbm9vcCcsXG59O1xuY29uc3Qga2luZE1hcHBpbmdSZXZlcnNlID0gKCgpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBPYmplY3Qua2V5cyhraW5kTWFwcGluZykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGNvbnN0IGtleU51bSA9IHR5cGVvZiBrZXkgPT09ICdzdHJpbmcnID8gcGFyc2VJbnQoa2V5LCAxMCkgOiBrZXk7XG4gICAgICAgIHJlc3VsdFtraW5kTWFwcGluZ1trZXlOdW1dXSA9IHBhZChrZXlOdW0sIDIpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59KSgpO1xuLy8gU2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL3Byb3RvY29scy8wMDVfYmFieWxvbi5odG1sI3RyYW5zYWN0aW9ucy1ub3ctaGF2ZS1hbi1lbnRyeXBvaW50XG5jb25zdCBlbnRyeXBvaW50TWFwcGluZyA9IHtcbiAgICAnMDAnOiAnZGVmYXVsdCcsXG4gICAgJzAxJzogJ3Jvb3QnLFxuICAgICcwMic6ICdkbycsXG4gICAgJzAzJzogJ3NldF9kZWxlZ2F0ZScsXG4gICAgJzA0JzogJ3JlbW92ZV9kZWxlZ2F0ZScsXG4gICAgJzA1JzogJ2RlcG9zaXQnLFxuICAgICcwNic6ICdzdGFrZScsXG4gICAgJzA3JzogJ3Vuc3Rha2UnLFxuICAgICcwOCc6ICdmaW5hbGl6ZV91bnN0YWtlJyxcbiAgICAnMDknOiAnc2V0X2RlbGVnYXRlX3BhcmFtZXRlcnMnLFxufTtcbmNvbnN0IGVudHJ5cG9pbnRNYXBwaW5nUmV2ZXJzZSA9ICgoKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgT2JqZWN0LmtleXMoZW50cnlwb2ludE1hcHBpbmcpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICByZXN1bHRbZW50cnlwb2ludE1hcHBpbmdba2V5XV0gPSBrZXk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pKCk7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIG9wZXJhdGlvbiBjb250ZW50IGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi8gY2xhc3MgSW52YWxpZE9wZXJhdGlvblNjaGVtYUVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihvcGVyYXRpb24sIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uID0gb3BlcmF0aW9uO1xuICAgICAgICB0aGlzLmVycm9yRGV0YWlsID0gZXJyb3JEZXRhaWw7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkT3BlcmF0aW9uU2NoZW1hRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBvcGVyYXRpb24gY29udGVudCByZWNldmllZGA7XG4gICAgICAgIGVycm9yRGV0YWlsID8gKHRoaXMubWVzc2FnZSArPSBgICR7ZXJyb3JEZXRhaWx9LmApIDogJyc7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGVudHJ5cG9pbnQgbmFtZSBleGNlZWRpbmcgbWF4aW11bSBsZW5ndGhcbiAqL1xuY2xhc3MgT3ZlcnNpemVkRW50cnlQb2ludEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyeXBvaW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZW50cnlwb2ludCA9IGVudHJ5cG9pbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdPdmVyc2l6ZWRFbnRyeVBvaW50RXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBlbnRyeXBvaW50IGxlbmd0aCBcIiR7ZW50cnlwb2ludC5sZW5ndGh9XCIsIG1heGltdW0gbGVuZ3RoIGlzIFwiJHtFTlRSWVBPSU5UX01BWF9MRU5HVEh9XCIuYDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBiYWxsb3QgdmFsdWUgYmVpbmcgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkQmFsbG90VmFsdWVFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoYmFsbG90VmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iYWxsb3RWYWx1ZSA9IGJhbGxvdFZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEJhbGxvdFZhbHVlRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBiYWxsb3QgdmFsdWUgXCIke2JhbGxvdFZhbHVlfVwiIGV4cGVjdGluZyBvbmUgb2YgdGhlIGZvbGxvd2luZzogXCJ5YXlcIiwgXCJuYXlcIiwgXCJwYXNzXCIuYDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSBiYWxsb3QgdmFsdWVcbiAqL1xuY2xhc3MgRGVjb2RlQmFsbG90VmFsdWVFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoYmFsbG90VmFsdWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5iYWxsb3RWYWx1ZSA9IGJhbGxvdFZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRGVjb2RlQmFsbG90VmFsdWVFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIGJhbGxvdCB2YWx1ZSBcIiR7YmFsbG90VmFsdWV9XCIsIGNhbm5vdCBiZSBkZWNvZGVkLmA7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIHVuZXhwZWN0ZWQgTWljaGVsc29uIFZhbHVlIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIFVuZXhwZWN0ZWRNaWNoZWxzb25WYWx1ZUVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdVbmV4cGVjdGVkTWljaGVsc29uVmFsdWVFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIE1pY2hlbHNvbiB2YWx1ZSBcIiR7dmFsdWV9XCIsIHVuYWxiZSB0byBlbmNvZGUuYDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIHdoZW4gdHJ5aW5nIHRvIGRlY29kZSBhbiBvcGVyYXRpb25cbiAqL1xuY2xhc3MgT3BlcmF0aW9uRGVjb2RpbmdFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnT3BlcmF0aW9uRGVjb2RpbmdFcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSB3aGVuIHRyeWluZyB0byBlbmNvZGUgYW4gb3BlcmF0aW9uXG4gKi9cbmNsYXNzIE9wZXJhdGlvbkVuY29kaW5nRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ09wZXJhdGlvbkVuY29kaW5nRXJyb3InO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiB1bnN1cHBvcnRlZCBvcGVyYXRpb24gYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3Iob3ApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5vcCA9IG9wO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBVbnN1cHBvcnRlZCBvcGVyYXRpb24gXCIke29wfVwiLCBjYW4gc3VibWl0IGFuIGlzc3VlIG9uIG91ciBnaXRodWIgZm9yIGZlYXR1cmUgcmVxdWVzdC5gO1xuICAgIH1cbn1cbi8qKlxuICogQGNhdGVvZ3J5IEVycm9yXG4gKiBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gdW5zdXBwb3J0ZWQgcHZtIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIFVuc3VwcG9ydGVkUHZtS2luZEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwdm0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wdm0gPSBwdm07XG4gICAgICAgIHRoaXMubmFtZSA9ICdVbnN1cHBvcnRlZFB2bUtpbmRFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBJbnZhbGlkIFB2bSBraW5kIFwiJHtwdm19XCIgZXhwZWN0aW5nIGVpdGhlciBcImFyaXRoXCIgb3IgXCJ3YXNtXzJfMF8wXCIuYDtcbiAgICB9XG59XG4vKipcbiAqIEBjYXRlZ29yeSBFcnJvclxuICogQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIHVuc3VwcG9ydGVkIHB2bSB0byBkZWNvZGVcbiAqL1xuY2xhc3MgRGVjb2RlUHZtS2luZEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwdm0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5wdm0gPSBwdm07XG4gICAgICAgIHRoaXMubmFtZSA9ICdEZWNvZGVQdm1LaW5kRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBQdm0ga2luZCBcIiR7cHZtfVwiLCBjYW5ub3QgYmUgZGVjb2RlZC5gO1xuICAgIH1cbn1cbi8qKlxuICogQGNhdGVnb3J5IEVycm9yXG4gKiBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBTbWFydCBSb2xsdXAgQWRkcmVzcyAoc3IxKVxuICovXG5jbGFzcyBJbnZhbGlkU21hcnRSb2xsdXBBZGRyZXNzRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWwgPSBlcnJvckRldGFpbDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRTbWFydFJvbGx1cEFkZHJlc3MnO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBzbWFydCByb2xsdXAgYWRkcmVzcyBcIiR7YWRkcmVzc31cImA7XG4gICAgICAgIGVycm9yRGV0YWlsID8gKHRoaXMubWVzc2FnZSArPSBgICR7ZXJyb3JEZXRhaWx9LmApIDogJyc7XG4gICAgfVxufVxuLyoqXG4gKiBAY2F0ZWdvcnkgRXJyb3JcbiAqIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIFNtYXJ0IFJvbGx1cCBjb21taXRtZW50IGhhc2ggKHNyYzEpXG4gKi9cbmNsYXNzIEludmFsaWRTbWFydFJvbGx1cENvbW1pdG1lbnRIYXNoRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIGVycm9yRGV0YWlsKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIHRoaXMuZXJyb3JEZXRhaWwgPSBlcnJvckRldGFpbDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRTbWFydFJvbGx1cENvbW1pdG1lbnRIYXNoRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBzbWFydCByb2xsdXAgY29tbWl0bWVudCBoYXNoIFwiJHtoYXNofVwiYDtcbiAgICAgICAgZXJyb3JEZXRhaWwgPyAodGhpcy5tZXNzYWdlICs9IGAgJHtlcnJvckRldGFpbH0uYCkgOiAnJztcbiAgICB9XG59XG5cbmNsYXNzIFVpbnQ4QXJyYXlDb25zdW1lciB7XG4gICAgc3RhdGljIGZyb21IZXhTdHJpbmcoaGV4KSB7XG4gICAgICAgIGNvbnN0IGxvd0hleCA9IGhleC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoL14oKFthLWZdfFxcZCl7Mn0pKiQvLnRlc3QobG93SGV4KSkge1xuICAgICAgICAgICAgY29uc3QgYXJyID0gbmV3IFVpbnQ4QXJyYXkoKGxvd0hleC5tYXRjaCgvKFthLXpdfFxcZCl7Mn0vZykgfHwgW10pLm1hcCgoYnl0ZSkgPT4gcGFyc2VJbnQoYnl0ZSwgMTYpKSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlDb25zdW1lcihhcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhTdHJpbmdFcnJvcihsb3dIZXgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGFyciwgb2Zmc2V0ID0gMCkge1xuICAgICAgICB0aGlzLmFyciA9IGFycjtcbiAgICAgICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgfVxuICAgIGNvbnN1bWUoY291bnQpIHtcbiAgICAgICAgY29uc3Qgc3ViQXJyID0gdGhpcy5hcnIuc3ViYXJyYXkodGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICsgY291bnQpO1xuICAgICAgICB0aGlzLm9mZnNldCArPSBjb3VudDtcbiAgICAgICAgcmV0dXJuIHN1YkFycjtcbiAgICB9XG4gICAgZ2V0KGlkeCkge1xuICAgICAgICByZXR1cm4gdGhpcy5hcnJbdGhpcy5vZmZzZXQgKyBpZHhdO1xuICAgIH1cbiAgICBsZW5ndGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFyci5sZW5ndGggLSB0aGlzLm9mZnNldDtcbiAgICB9XG4gICAgc2xpY2Uoc3RhcnQsIGVuZCkge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXlDb25zdW1lcih0aGlzLmFyci5zbGljZShzdGFydCwgZW5kKSk7XG4gICAgfVxufVxuXG5jb25zdCBpc1ByaW0gPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gJ3ByaW0nIGluIHZhbHVlO1xufTtcbmNvbnN0IGlzQnl0ZXMgPSAodmFsdWUpID0+IHtcbiAgICByZXR1cm4gJ2J5dGVzJyBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuYnl0ZXMgPT09ICdzdHJpbmcnO1xufTtcbmNvbnN0IGlzU3RyaW5nID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuICdzdHJpbmcnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5zdHJpbmcgPT09ICdzdHJpbmcnO1xufTtcbmNvbnN0IGlzSW50ID0gKHZhbHVlKSA9PiB7XG4gICAgcmV0dXJuICdpbnQnIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pbnQgPT09ICdzdHJpbmcnO1xufTtcbmNvbnN0IHNjcmlwdEVuY29kZXIgPSAoc2NyaXB0KSA9PiB7XG4gICAgY29uc3QgY29kZSA9IHZhbHVlRW5jb2RlcihzY3JpcHQuY29kZSk7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHZhbHVlRW5jb2RlcihzY3JpcHQuc3RvcmFnZSk7XG4gICAgcmV0dXJuIGAke3BhZChjb2RlLmxlbmd0aCAvIDIsIDgpfSR7Y29kZX0ke3BhZChzdG9yYWdlLmxlbmd0aCAvIDIsIDgpfSR7c3RvcmFnZX1gO1xufTtcbmNvbnN0IHNjcmlwdERlY29kZXIgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBjb2RlID0gZXh0cmFjdFJlcXVpcmVkTGVuKHZhbHVlKTtcbiAgICBjb25zdCBzdG9yYWdlID0gZXh0cmFjdFJlcXVpcmVkTGVuKHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBjb2RlOiB2YWx1ZURlY29kZXIobmV3IFVpbnQ4QXJyYXlDb25zdW1lcihjb2RlKSksXG4gICAgICAgIHN0b3JhZ2U6IHZhbHVlRGVjb2RlcihuZXcgVWludDhBcnJheUNvbnN1bWVyKHN0b3JhZ2UpKSxcbiAgICB9O1xufTtcbmNvbnN0IHZhbHVlRW5jb2RlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBlbmNvZGVkID0gdmFsdWUubWFwKCh4KSA9PiB2YWx1ZUVuY29kZXIoeCkpLmpvaW4oJycpO1xuICAgICAgICBjb25zdCBsZW4gPSBlbmNvZGVkLmxlbmd0aCAvIDI7XG4gICAgICAgIHJldHVybiBgMDIke3BhZChsZW4pfSR7ZW5jb2RlZH1gO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1ByaW0odmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBwcmltRW5jb2Rlcih2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBieXRlc0VuY29kZXIodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZ0VuY29kZXIodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0ludCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGludEVuY29kZXIodmFsdWUpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgVW5leHBlY3RlZE1pY2hlbHNvblZhbHVlRXJyb3IoSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbn07XG5jb25zdCB2YWx1ZURlY29kZXIgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBwcmVhbWJsZSA9IHZhbHVlLmNvbnN1bWUoMSk7XG4gICAgc3dpdGNoIChwcmVhbWJsZVswXSkge1xuICAgICAgICBjYXNlIDB4MGE6XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNEZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgY2FzZSAweDAxOlxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ0RlY29kZXIodmFsdWUpO1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICByZXR1cm4gaW50RGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgIGNhc2UgMHgwMjoge1xuICAgICAgICAgICAgY29uc3QgdmFsID0gbmV3IFVpbnQ4QXJyYXlDb25zdW1lcihleHRyYWN0UmVxdWlyZWRMZW4odmFsdWUpKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcbiAgICAgICAgICAgIHdoaWxlICh2YWwubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0cy5wdXNoKHZhbHVlRGVjb2Rlcih2YWwpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gcHJpbURlY29kZXIodmFsdWUsIHByZWFtYmxlKTtcbiAgICB9XG59O1xuY29uc3QgZXh0cmFjdFJlcXVpcmVkTGVuID0gKHZhbHVlLCBieXRlc0xlbmd0aCA9IDQpID0+IHtcbiAgICBjb25zdCBsZW4gPSB2YWx1ZS5jb25zdW1lKGJ5dGVzTGVuZ3RoKTtcbiAgICBjb25zdCB2YWx1ZUxlbiA9IHBhcnNlSW50KEJ1ZmZlci5mcm9tKGxlbikudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgcmV0dXJuIHZhbHVlLmNvbnN1bWUodmFsdWVMZW4pO1xufTtcbi8qKlxuICogQGRlc2NyaXB0aW9uIHBhcnNlIGJ5dGVzIGludG8gbXVsdGlwbGUgaXRlbXMgb2YgYW4gYXJyYXlcbiAqIEBwYXJhbSB2YWx1ZSBVaW50OEFycmF5Q29uc3VtZXIgY2xhc3Mgb2YgZm9yZ2VkIHNlZ21lbnQgdG8gcGFyc2VcbiAqIEBwYXJhbSBieXRlc0xlbmd0aCBkZWZhdWx0IDQgYnl0ZXMgZm9yIGxlbmd0aCBvZiB2YXJpYWJsZSBieXRlc1xuICogQHJldHVybnMgYXJyYXkgb2YgVWludDhBcnJheSB2YWx1ZXMgZm9yIGVhY2ggYXJyYXkgaXRlbVxuICovXG5jb25zdCBzdHJpcExlbmd0aFByZWZpeEZyb21CeXRlcyA9ICh2YWx1ZSwgYnl0ZXNMZW5ndGggPSA0KSA9PiB7XG4gICAgY29uc3QgcmV0ID0gW107XG4gICAgbGV0IHZhbHVlcyA9IHZhbHVlO1xuICAgIHdoaWxlICh2YWx1ZXMubGVuZ3RoKCkpIHtcbiAgICAgICAgY29uc3QgbGVuID0gdmFsdWVzLmNvbnN1bWUoYnl0ZXNMZW5ndGgpO1xuICAgICAgICBjb25zdCB2YWx1ZUxlbiA9IHBhcnNlSW50KEJ1ZmZlci5mcm9tKGxlbikudG9TdHJpbmcoJ2hleCcpLCAxNik7XG4gICAgICAgIHJldC5wdXNoKHZhbHVlcy5jb25zdW1lKHZhbHVlTGVuKSk7XG4gICAgICAgIHZhbHVlcyA9IHZhbHVlcy5zbGljZSh2YWx1ZUxlbiArIGJ5dGVzTGVuZ3RoKTtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbn07XG5jb25zdCBieXRlc0VuY29kZXIgPSAodmFsdWUpID0+IHtcbiAgICBpZiAoIS9eKFtBLUZhLWYwLTldezJ9KSokLy50ZXN0KHZhbHVlLmJ5dGVzKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFN0cmluZ0Vycm9yKHZhbHVlLmJ5dGVzKTtcbiAgICB9XG4gICAgY29uc3QgbGVuID0gdmFsdWUuYnl0ZXMubGVuZ3RoIC8gMjtcbiAgICByZXR1cm4gYDBhJHtwYWQobGVuKX0ke3ZhbHVlLmJ5dGVzfWA7XG59O1xuY29uc3QgYnl0ZXNEZWNvZGVyID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgYnl0ZXMgPSBleHRyYWN0UmVxdWlyZWRMZW4odmFsdWUpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGJ5dGVzOiBCdWZmZXIuZnJvbShieXRlcykudG9TdHJpbmcoJ2hleCcpLFxuICAgIH07XG59O1xuY29uc3Qgc3RyaW5nRW5jb2RlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHN0ciA9IEJ1ZmZlci5mcm9tKHZhbHVlLnN0cmluZywgJ3V0ZjgnKS50b1N0cmluZygnaGV4Jyk7XG4gICAgY29uc3QgaGV4TGVuZ3RoID0gc3RyLmxlbmd0aCAvIDI7XG4gICAgcmV0dXJuIGAwMSR7cGFkKGhleExlbmd0aCl9JHtzdHJ9YDtcbn07XG5jb25zdCBzdHJpbmdEZWNvZGVyID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgc3RyID0gZXh0cmFjdFJlcXVpcmVkTGVuKHZhbHVlKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHJpbmc6IEJ1ZmZlci5mcm9tKHN0cikudG9TdHJpbmcoJ3V0ZjgnKSxcbiAgICB9O1xufTtcbmNvbnN0IGludEVuY29kZXIgPSAoeyBpbnQgfSkgPT4ge1xuICAgIGNvbnN0IG51bSA9IG5ldyBCaWdOdW1iZXIoaW50LCAxMCk7XG4gICAgY29uc3QgcG9zaXRpdmVNYXJrID0gbnVtLnRvU3RyaW5nKDIpWzBdID09PSAnLScgPyAnMScgOiAnMCc7XG4gICAgY29uc3QgYmluYXJ5ID0gbnVtLnRvU3RyaW5nKDIpLnJlcGxhY2UoLy0vZywgJycpO1xuICAgIGNvbnN0IHBhZCA9IGJpbmFyeS5sZW5ndGggPD0gNlxuICAgICAgICA/IDZcbiAgICAgICAgOiAoYmluYXJ5Lmxlbmd0aCAtIDYpICUgN1xuICAgICAgICAgICAgPyBiaW5hcnkubGVuZ3RoICsgNyAtICgoYmluYXJ5Lmxlbmd0aCAtIDYpICUgNylcbiAgICAgICAgICAgIDogYmluYXJ5Lmxlbmd0aDtcbiAgICBjb25zdCBzcGxpdHRlZCA9IGJpbmFyeS5wYWRTdGFydChwYWQsICcwJykubWF0Y2goL1xcZHs2LDd9L2cpO1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tbm9uLW51bGwtYXNzZXJ0aW9uXG4gICAgY29uc3QgcmV2ZXJzZWQgPSBzcGxpdHRlZC5yZXZlcnNlKCk7XG4gICAgcmV2ZXJzZWRbMF0gPSBwb3NpdGl2ZU1hcmsgKyByZXZlcnNlZFswXTtcbiAgICBjb25zdCBudW1IZXggPSByZXZlcnNlZC5tYXAoKHgsIGkpID0+IFxuICAgIC8vIEFkZCBvbmUgdG8gdGhlIGxhc3QgY2h1bmtcbiAgICBwYXJzZUludCgoaSA9PT0gcmV2ZXJzZWQubGVuZ3RoIC0gMSA/ICcwJyA6ICcxJykgKyB4LCAyKVxuICAgICAgICAudG9TdHJpbmcoMTYpXG4gICAgICAgIC5wYWRTdGFydCgyLCAnMCcpKTtcbiAgICByZXR1cm4gYDAwJHtudW1IZXguam9pbignJyl9YDtcbn07XG5jb25zdCBpbnREZWNvZGVyID0gKHZhbHVlKSA9PiB7XG4gICAgbGV0IGMgPSB2YWx1ZS5jb25zdW1lKDEpWzBdO1xuICAgIGNvbnN0IGhleE51bWJlciA9IFtdO1xuICAgIGNvbnN0IGlzTm90TGFzdENodW5rTWFzayA9IDEgPDwgNztcbiAgICB3aGlsZSAoYyAmIGlzTm90TGFzdENodW5rTWFzaykge1xuICAgICAgICBoZXhOdW1iZXIucHVzaChjKTtcbiAgICAgICAgYyA9IHZhbHVlLmNvbnN1bWUoMSlbMF07XG4gICAgfVxuICAgIGhleE51bWJlci5wdXNoKGMpO1xuICAgIGNvbnN0IGlzTmVnYXRpdmUgPSAhISgoMSA8PCA2KSAmIGhleE51bWJlclswXSk7XG4gICAgaGV4TnVtYmVyWzBdID0gaGV4TnVtYmVyWzBdICYgMGIxMTExMTExO1xuICAgIGNvbnN0IG51bUJpbiA9IGhleE51bWJlclxuICAgICAgICAubWFwKCh4LCBpKSA9PiB4XG4gICAgICAgIC50b1N0cmluZygyKVxuICAgICAgICAuc2xpY2UoaSA9PT0gMCA/IC02IDogLTcpXG4gICAgICAgIC5wYWRTdGFydChpID09PSAwID8gNiA6IDcsICcwJykpXG4gICAgICAgIC5yZXZlcnNlKCk7XG4gICAgbGV0IG51bSA9IG5ldyBCaWdOdW1iZXIobnVtQmluLmpvaW4oJycpLCAyKTtcbiAgICBpZiAoaXNOZWdhdGl2ZSkge1xuICAgICAgICBudW0gPSBudW0udGltZXMoLTEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpbnQ6IG51bS50b0ZpeGVkKCksXG4gICAgfTtcbn07XG5jb25zdCBwcmltRW5jb2RlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IGhhc0Fubm90ID0gK0FycmF5LmlzQXJyYXkodmFsdWUuYW5ub3RzKTtcbiAgICBjb25zdCBhcmdzQ291bnQgPSBBcnJheS5pc0FycmF5KHZhbHVlLmFyZ3MpID8gdmFsdWUuYXJncy5sZW5ndGggOiAwO1xuICAgIC8vIFNwZWNpZnkgdGhlIG51bWJlciBvZiBhcmdzIG1heCBpcyAzIHdpdGhvdXQgYW5ub3RhdGlvblxuICAgIGNvbnN0IHByZWFtYmxlID0gcGFkKE1hdGgubWluKDIgKiBhcmdzQ291bnQgKyBoYXNBbm5vdCArIDB4MDMsIDkpLCAyKTtcbiAgICBjb25zdCBvcCA9IG9wTWFwcGluZ1JldmVyc2VbdmFsdWUucHJpbV07XG4gICAgbGV0IGVuY29kZWRBcmdzID0gKHZhbHVlLmFyZ3MgfHwgW10pLm1hcCgoYXJnKSA9PiB2YWx1ZUVuY29kZXIoYXJnKSkuam9pbignJyk7XG4gICAgY29uc3QgZW5jb2RlZEFubm90cyA9IEFycmF5LmlzQXJyYXkodmFsdWUuYW5ub3RzKSA/IGVuY29kZUFubm90cyh2YWx1ZS5hbm5vdHMpIDogJyc7XG4gICAgaWYgKCh2YWx1ZS5wcmltID09PSAnTEFNQkRBJyB8fCB2YWx1ZS5wcmltID09PSAnTEFNQkRBX1JFQycpICYmIGFyZ3NDb3VudCkge1xuICAgICAgICBlbmNvZGVkQXJncyA9IHBhZChlbmNvZGVkQXJncy5sZW5ndGggLyAyKSArIGVuY29kZWRBcmdzICsgcGFkKDApO1xuICAgIH1cbiAgICBpZiAoKHZhbHVlLnByaW0gPT09ICdwYWlyJyB8fCB2YWx1ZS5wcmltID09PSAnUGFpcicpICYmIGFyZ3NDb3VudCA+IDIpIHtcbiAgICAgICAgZW5jb2RlZEFyZ3MgPVxuICAgICAgICAgICAgZW5jb2RlZEFubm90cyA9PT0gJydcbiAgICAgICAgICAgICAgICA/IHBhZChlbmNvZGVkQXJncy5sZW5ndGggLyAyKSArIGVuY29kZWRBcmdzICsgcGFkKDApXG4gICAgICAgICAgICAgICAgOiBwYWQoZW5jb2RlZEFyZ3MubGVuZ3RoIC8gMikgKyBlbmNvZGVkQXJncztcbiAgICB9XG4gICAgaWYgKHZhbHVlLnByaW0gPT09ICd2aWV3JyAmJiB2YWx1ZS5hcmdzKSB7XG4gICAgICAgIGVuY29kZWRBcmdzID0gcGFkKGVuY29kZWRBcmdzLmxlbmd0aCAvIDIpICsgZW5jb2RlZEFyZ3MgKyBwYWQoMCk7XG4gICAgfVxuICAgIHJldHVybiBgJHtwcmVhbWJsZX0ke29wfSR7ZW5jb2RlZEFyZ3N9JHtlbmNvZGVkQW5ub3RzfWA7XG59O1xuY29uc3QgcHJpbURlY29kZXIgPSAodmFsdWUsIHByZWFtYmxlKSA9PiB7XG4gICAgY29uc3QgaGFzQW5ub3QgPSAocHJlYW1ibGVbMF0gLSAweDAzKSAlIDIgPT09IDE7XG4gICAgbGV0IGFyZ3NDb3VudCA9IE1hdGguZmxvb3IoKHByZWFtYmxlWzBdIC0gMHgwMykgLyAyKTtcbiAgICBjb25zdCBvcCA9IHZhbHVlLmNvbnN1bWUoMSlbMF0udG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsICcwJyk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICBwcmltOiBvcE1hcHBpbmdbb3BdLFxuICAgIH07XG4gICAgaWYgKG9wTWFwcGluZ1tvcF0gPT09ICdMQU1CREEnIHx8IG9wTWFwcGluZ1tvcF0gPT09ICdMQU1CREFfUkVDJykge1xuICAgICAgICB2YWx1ZS5jb25zdW1lKDQpO1xuICAgIH1cbiAgICBpZiAob3BNYXBwaW5nW29wXSA9PT0gJ3ZpZXcnKSB7XG4gICAgICAgIGlmIChhcmdzQ291bnQgIT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHByaW1WaWV3RGVjb2Rlcih2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV0IGNvbWJQYWlyQXJncztcbiAgICBsZXQgY29tYlBhaXJBbm5vdHM7XG4gICAgaWYgKChvcE1hcHBpbmdbb3BdID09PSAncGFpcicgfHwgb3BNYXBwaW5nW29wXSA9PT0gJ1BhaXInKSAmJiBhcmdzQ291bnQgPiAyKSB7XG4gICAgICAgIGNvbWJQYWlyQXJncyA9IGRlY29kZUNvbWJQYWlyKHZhbHVlKTtcbiAgICAgICAgYXJnc0NvdW50ID0gMDtcbiAgICAgICAgY29tYlBhaXJBbm5vdHMgPSBkZWNvZGVBbm5vdHModmFsdWUpO1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gbmV3IEFycmF5KGFyZ3NDb3VudCkuZmlsbCgwKS5tYXAoKCkgPT4gdmFsdWVEZWNvZGVyKHZhbHVlKSk7XG4gICAgaWYgKG9wTWFwcGluZ1tvcF0gPT09ICdMQU1CREEnIHx8IG9wTWFwcGluZ1tvcF0gPT09ICdMQU1CREFfUkVDJykge1xuICAgICAgICB2YWx1ZS5jb25zdW1lKDQpO1xuICAgIH1cbiAgICBpZiAoY29tYlBhaXJBcmdzKSB7XG4gICAgICAgIHJlc3VsdFsnYXJncyddID0gY29tYlBhaXJBcmdzO1xuICAgIH1cbiAgICBlbHNlIGlmIChhcmdzLmxlbmd0aCkge1xuICAgICAgICByZXN1bHRbJ2FyZ3MnXSA9IGFyZ3M7XG4gICAgfVxuICAgIGlmIChjb21iUGFpckFubm90cyAmJiBjb21iUGFpckFubm90c1swXSAhPT0gJycpIHtcbiAgICAgICAgcmVzdWx0Wydhbm5vdHMnXSA9IGNvbWJQYWlyQW5ub3RzO1xuICAgIH1cbiAgICBlbHNlIGlmIChoYXNBbm5vdCkge1xuICAgICAgICByZXN1bHRbJ2Fubm90cyddID0gZGVjb2RlQW5ub3RzKHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5jb25zdCBwcmltVmlld0RlY29kZXIgPSAodmFsdWUsIHJlc3VsdCkgPT4ge1xuICAgIHZhbHVlLmNvbnN1bWUoNCk7XG4gICAgcmVzdWx0WydhcmdzJ10gPSBuZXcgQXJyYXkoNCkuZmlsbCgwKS5tYXAoKCkgPT4gdmFsdWVEZWNvZGVyKHZhbHVlKSk7XG4gICAgdmFsdWUuY29uc3VtZSg0KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbmNvbnN0IGRlY29kZUNvbWJQYWlyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IGFycmF5ID0gbmV3IFVpbnQ4QXJyYXlDb25zdW1lcihleHRyYWN0UmVxdWlyZWRMZW4odmFsKSk7XG4gICAgY29uc3QgYXJncyA9IFtdO1xuICAgIHdoaWxlIChhcnJheS5sZW5ndGgoKSA+IDApIHtcbiAgICAgICAgYXJncy5wdXNoKHZhbHVlRGVjb2RlcihhcnJheSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJncztcbn07XG5jb25zdCBlbmNvZGVBbm5vdHMgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBtZXJnZWRBbm5vdCA9IHZhbHVlXG4gICAgICAgIC5tYXAoKHgpID0+IHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHgsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCcyMCcpO1xuICAgIGNvbnN0IGxlbiA9IG1lcmdlZEFubm90Lmxlbmd0aCAvIDI7XG4gICAgcmV0dXJuIGAke3BhZChsZW4pfSR7bWVyZ2VkQW5ub3R9YDtcbn07XG5jb25zdCBkZWNvZGVBbm5vdHMgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbGVuID0gdmFsLmNvbnN1bWUoNCk7XG4gICAgY29uc3QgYW5ub3RMZW4gPSBwYXJzZUludChCdWZmZXIuZnJvbShsZW4pLnRvU3RyaW5nKCdoZXgnKSwgMTYpO1xuICAgIGNvbnN0IHJlc3RPZkFubm90ID0gdmFsLmNvbnN1bWUoYW5ub3RMZW4pO1xuICAgIGNvbnN0IHJlc3RPZkFubm90SGV4ID0gQnVmZmVyLmZyb20ocmVzdE9mQW5ub3QpLnRvU3RyaW5nKCdoZXgnKTtcbiAgICByZXR1cm4gcmVzdE9mQW5ub3RIZXguc3BsaXQoJzIwJykubWFwKCh4KSA9PiBCdWZmZXIuZnJvbSh4LCAnaGV4JykudG9TdHJpbmcoJ3V0ZjgnKSk7XG59O1xuXG4vLyBodHRwczovL3Rlem9zLmdpdGxhYi5pby9zaGVsbC9wMnBfYXBpLmh0bWwgc3BlY2lmaWVzIGRhdGEgdHlwZXMgYW5kIHN0cnVjdHVyZSBmb3IgZm9yZ2luZ1xuY29uc3QgcHJlZml4RW5jb2RlciA9IChwcmVmaXgkMSkgPT4gKHN0cikgPT4ge1xuICAgIHJldHVybiBidWYyaGV4KEJ1ZmZlci5mcm9tKGI1OGNkZWNvZGUoc3RyLCBwcmVmaXhbcHJlZml4JDFdKSkpO1xufTtcbmNvbnN0IHByZWZpeERlY29kZXIgPSAocHJlKSA9PiAoc3RyKSA9PiB7XG4gICAgY29uc3QgdmFsID0gc3RyLmNvbnN1bWUocHJlZml4TGVuZ3RoW3ByZV0pO1xuICAgIHJldHVybiBiNThjZW5jb2RlKHZhbCwgcHJlZml4W3ByZV0pO1xufTtcbmNvbnN0IHR6MURlY29kZXIgPSBwcmVmaXhEZWNvZGVyKFByZWZpeC5UWjEpO1xuY29uc3QgYnJhbmNoRGVjb2RlciA9IHByZWZpeERlY29kZXIoUHJlZml4LkIpO1xuY29uc3QgcHVibGljS2V5SGFzaERlY29kZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ID0gdmFsLmNvbnN1bWUoMSk7XG4gICAgaWYgKHByZWZpeFswXSA9PT0gMHgwMCkge1xuICAgICAgICByZXR1cm4gcHJlZml4RGVjb2RlcihQcmVmaXguVFoxKSh2YWwpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVmaXhbMF0gPT09IDB4MDEpIHtcbiAgICAgICAgcmV0dXJuIHByZWZpeERlY29kZXIoUHJlZml4LlRaMikodmFsKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocHJlZml4WzBdID09PSAweDAyKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhEZWNvZGVyKFByZWZpeC5UWjMpKHZhbCk7XG4gICAgfVxufTtcbmNvbnN0IHB1YmxpY0tleUhhc2hlc0RlY29kZXIgPSAodmFsKSA9PiB7XG4gICAgaWYgKCFib29sRGVjb2Rlcih2YWwpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleUhhc2hlcyA9IFtdO1xuICAgIHZhbC5jb25zdW1lKDQpO1xuICAgIHdoaWxlICh2YWwubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgIHB1YmxpY0tleUhhc2hlcy5wdXNoKHB1YmxpY0tleUhhc2hEZWNvZGVyKHZhbCkpO1xuICAgIH1cbiAgICByZXR1cm4gcHVibGljS2V5SGFzaGVzO1xufTtcbmNvbnN0IGJyYW5jaEVuY29kZXIgPSBwcmVmaXhFbmNvZGVyKFByZWZpeC5CKTtcbmNvbnN0IHR6MUVuY29kZXIgPSBwcmVmaXhFbmNvZGVyKFByZWZpeC5UWjEpO1xuY29uc3QgYm9vbEVuY29kZXIgPSAoYm9vbCkgPT4gKGJvb2wgPyAnZmYnIDogJzAwJyk7XG5jb25zdCBwcm9wb3NhbEVuY29kZXIgPSAocHJvcG9zYWwpID0+IHtcbiAgICByZXR1cm4gcHJlZml4RW5jb2RlcihQcmVmaXguUCkocHJvcG9zYWwpO1xufTtcbmNvbnN0IHByb3Bvc2FsRGVjb2RlciA9IChwcm9wb3NhbCkgPT4ge1xuICAgIHJldHVybiBwcmVmaXhEZWNvZGVyKFByZWZpeC5QKShwcm9wb3NhbCk7XG59O1xuY29uc3QgcHJvcG9zYWxzRGVjb2RlciA9IChwcm9wb3NhbCkgPT4ge1xuICAgIGNvbnN0IHByb3Bvc2FscyA9IFtdO1xuICAgIHByb3Bvc2FsLmNvbnN1bWUoNCk7XG4gICAgd2hpbGUgKHByb3Bvc2FsLmxlbmd0aCgpID4gMCkge1xuICAgICAgICBwcm9wb3NhbHMucHVzaChwcm9wb3NhbERlY29kZXIocHJvcG9zYWwpKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb3Bvc2Fscztcbn07XG5jb25zdCBwcm9wb3NhbHNFbmNvZGVyID0gKHByb3Bvc2FscykgPT4ge1xuICAgIHJldHVybiBwYWQoMzIgKiBwcm9wb3NhbHMubGVuZ3RoKSArIHByb3Bvc2Fscy5tYXAoKHgpID0+IHByb3Bvc2FsRW5jb2Rlcih4KSkuam9pbignJyk7XG59O1xuY29uc3QgYmFsbG90RW5jb2RlciA9IChiYWxsb3QpID0+IHtcbiAgICBzd2l0Y2ggKGJhbGxvdCkge1xuICAgICAgICBjYXNlICd5YXknOlxuICAgICAgICAgICAgcmV0dXJuICcwMCc7XG4gICAgICAgIGNhc2UgJ25heSc6XG4gICAgICAgICAgICByZXR1cm4gJzAxJztcbiAgICAgICAgY2FzZSAncGFzcyc6XG4gICAgICAgICAgICByZXR1cm4gJzAyJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQmFsbG90VmFsdWVFcnJvcihiYWxsb3QpO1xuICAgIH1cbn07XG5jb25zdCBiYWxsb3REZWNvZGVyID0gKGJhbGxvdCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gYmFsbG90LmNvbnN1bWUoMSk7XG4gICAgc3dpdGNoICh2YWx1ZVswXSkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICByZXR1cm4gJ3lheSc7XG4gICAgICAgIGNhc2UgMHgwMTpcbiAgICAgICAgICAgIHJldHVybiAnbmF5JztcbiAgICAgICAgY2FzZSAweDAyOlxuICAgICAgICAgICAgcmV0dXJuICdwYXNzJztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVCYWxsb3RWYWx1ZUVycm9yKHZhbHVlWzBdLnRvU3RyaW5nKCkpO1xuICAgIH1cbn07XG5jb25zdCBwdm1LaW5kRW5jb2RlciA9IChwdm0pID0+IHtcbiAgICBzd2l0Y2ggKHB2bSkge1xuICAgICAgICBjYXNlICdhcml0aCc6XG4gICAgICAgICAgICByZXR1cm4gJzAwJztcbiAgICAgICAgY2FzZSAnd2FzbV8yXzBfMCc6XG4gICAgICAgICAgICByZXR1cm4gJzAxJztcbiAgICAgICAgY2FzZSAncmlzY3YnOlxuICAgICAgICAgICAgcmV0dXJuICcwMic7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRQdm1LaW5kRXJyb3IocHZtKTtcbiAgICB9XG59O1xuY29uc3QgcHZtS2luZERlY29kZXIgPSAocHZtKSA9PiB7XG4gICAgY29uc3QgdmFsdWUgPSBwdm0uY29uc3VtZSgxKTtcbiAgICBzd2l0Y2ggKHZhbHVlWzBdKSB7XG4gICAgICAgIGNhc2UgMHgwMDpcbiAgICAgICAgICAgIHJldHVybiAnYXJpdGgnO1xuICAgICAgICBjYXNlIDB4MDE6XG4gICAgICAgICAgICByZXR1cm4gJ3dhc21fMl8wXzAnO1xuICAgICAgICBjYXNlIDB4MDI6XG4gICAgICAgICAgICByZXR1cm4gJ3Jpc2N2JztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBEZWNvZGVQdm1LaW5kRXJyb3IodmFsdWVbMF0udG9TdHJpbmcoKSk7XG4gICAgfVxufTtcbmNvbnN0IGRlbGVnYXRlRW5jb2RlciA9ICh2YWwpID0+IHtcbiAgICBpZiAodmFsKSB7XG4gICAgICAgIHJldHVybiBib29sRW5jb2Rlcih0cnVlKSArIHB1YmxpY0tleUhhc2hFbmNvZGVyKHZhbCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gYm9vbEVuY29kZXIoZmFsc2UpO1xuICAgIH1cbn07XG5jb25zdCBpbnQzMkVuY29kZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbnVtID0gcGFyc2VJbnQoU3RyaW5nKHZhbCksIDEwKTtcbiAgICBjb25zdCBieXRlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgY29uc3Qgc2hpZnRCeSA9ICg0IC0gKGkgKyAxKSkgKiA4O1xuICAgICAgICBieXRlLnB1c2goKG51bSAmICgweGZmIDw8IHNoaWZ0QnkpKSA+PiBzaGlmdEJ5KTtcbiAgICB9XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGUpLnRvU3RyaW5nKCdoZXgnKTtcbn07XG5jb25zdCBpbnQzMkRlY29kZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbnVtID0gdmFsLmNvbnN1bWUoNCk7XG4gICAgbGV0IGZpbmFsTnVtID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmaW5hbE51bSA9IGZpbmFsTnVtIHwgKG51bVtpXSA8PCAoKG51bS5sZW5ndGggLSAoaSArIDEpKSAqIDgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbmFsTnVtO1xufTtcbmNvbnN0IGludDE2RW5jb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBudW0gPSBwYXJzZUludChTdHJpbmcodmFsKSwgMTApO1xuICAgIGNvbnN0IGJ5dGUgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDI7IGkrKykge1xuICAgICAgICBjb25zdCBzaGlmdEJ5ID0gKDIgLSAoaSArIDEpKSAqIDg7XG4gICAgICAgIGJ5dGUucHVzaCgobnVtICYgKDB4ZmYgPDwgc2hpZnRCeSkpID4+IHNoaWZ0QnkpO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oYnl0ZSkudG9TdHJpbmcoJ2hleCcpO1xufTtcbmNvbnN0IGludDE2RGVjb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBudW0gPSB2YWwuY29uc3VtZSgyKTtcbiAgICBsZXQgZmluYWxOdW0gPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZpbmFsTnVtID0gZmluYWxOdW0gfCAobnVtW2ldIDw8ICgobnVtLmxlbmd0aCAtIChpICsgMSkpICogOCkpO1xuICAgIH1cbiAgICByZXR1cm4gZmluYWxOdW07XG59O1xuY29uc3QgYm9vbERlY29kZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgYm9vbCA9IHZhbC5jb25zdW1lKDEpO1xuICAgIHJldHVybiBib29sWzBdID09PSAweGZmO1xufTtcbmNvbnN0IGRlbGVnYXRlRGVjb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBoYXNEZWxlZ2F0ZSA9IGJvb2xEZWNvZGVyKHZhbCk7XG4gICAgaWYgKGhhc0RlbGVnYXRlKSB7XG4gICAgICAgIHJldHVybiBwdWJsaWNLZXlIYXNoRGVjb2Rlcih2YWwpO1xuICAgIH1cbn07XG5jb25zdCBwdWJsaWNLZXlIYXNoRW5jb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBwdWJrZXlQcmVmaXggPSB2YWwuc3Vic3RyaW5nKDAsIDMpO1xuICAgIHN3aXRjaCAocHVia2V5UHJlZml4KSB7XG4gICAgICAgIGNhc2UgUHJlZml4LlRaMTpcbiAgICAgICAgICAgIHJldHVybiAnMDAnICsgcHJlZml4RW5jb2RlcihQcmVmaXguVFoxKSh2YWwpO1xuICAgICAgICBjYXNlIFByZWZpeC5UWjI6XG4gICAgICAgICAgICByZXR1cm4gJzAxJyArIHByZWZpeEVuY29kZXIoUHJlZml4LlRaMikodmFsKTtcbiAgICAgICAgY2FzZSBQcmVmaXguVFozOlxuICAgICAgICAgICAgcmV0dXJuICcwMicgKyBwcmVmaXhFbmNvZGVyKFByZWZpeC5UWjMpKHZhbCk7XG4gICAgICAgIGNhc2UgUHJlZml4LlRaNDpcbiAgICAgICAgICAgIHJldHVybiAnMDMnICsgcHJlZml4RW5jb2RlcihQcmVmaXguVFo0KSh2YWwpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRLZXlIYXNoRXJyb3IodmFsLCBpbnZhbGlkRGV0YWlsKFZhbGlkYXRpb25SZXN1bHQuTk9fUFJFRklYX01BVENIRUQpICtcbiAgICAgICAgICAgICAgICBgIGV4cGVjdGluZyBvbmUgZm9yIHRoZSBmb2xsb3dpbmcgXCIke1ByZWZpeC5UWjF9XCIsIFwiJHtQcmVmaXguVFoyfVwiLCBcIiR7UHJlZml4LlRaM31cIiBvciBcIiR7UHJlZml4LlRaNH1cIi5gKTtcbiAgICB9XG59O1xuY29uc3QgcHVibGljS2V5SGFzaGVzRW5jb2RlciA9ICh2YWwpID0+IHtcbiAgICBpZiAoIXZhbCkge1xuICAgICAgICByZXR1cm4gYm9vbEVuY29kZXIoZmFsc2UpO1xuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYm9vbEVuY29kZXIodHJ1ZSkgKyBwYWQoMCk7XG4gICAgfVxuICAgIGNvbnN0IHB1YmxpY0tleUhhc2hlcyA9IHZhbC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXYgKyBwdWJsaWNLZXlIYXNoRW5jb2RlcihjdXJyKTtcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIGJvb2xFbmNvZGVyKHRydWUpICsgcGFkKHB1YmxpY0tleUhhc2hlcy5sZW5ndGggLyAyKSArIHB1YmxpY0tleUhhc2hlcztcbn07XG5jb25zdCBwdWJsaWNLZXlFbmNvZGVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IHB1YmtleVByZWZpeCA9IHZhbC5zdWJzdHJpbmcoMCwgNCk7XG4gICAgc3dpdGNoIChwdWJrZXlQcmVmaXgpIHtcbiAgICAgICAgY2FzZSBQcmVmaXguRURQSzpcbiAgICAgICAgICAgIHJldHVybiAnMDAnICsgcHJlZml4RW5jb2RlcihQcmVmaXguRURQSykodmFsKTtcbiAgICAgICAgY2FzZSBQcmVmaXguU1BQSzpcbiAgICAgICAgICAgIHJldHVybiAnMDEnICsgcHJlZml4RW5jb2RlcihQcmVmaXguU1BQSykodmFsKTtcbiAgICAgICAgY2FzZSBQcmVmaXguUDJQSzpcbiAgICAgICAgICAgIHJldHVybiAnMDInICsgcHJlZml4RW5jb2RlcihQcmVmaXguUDJQSykodmFsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHVibGljS2V5RXJyb3IodmFsLCBpbnZhbGlkRGV0YWlsKFZhbGlkYXRpb25SZXN1bHQuTk9fUFJFRklYX01BVENIRUQpICtcbiAgICAgICAgICAgICAgICBgIGV4cGVjdGluZyBvbmUgb2YgdGhlIGZvbGxvd2luZyAnJHtQcmVmaXguRURQS30nLCAnJHtQcmVmaXguU1BQS30nLCAnJHtQcmVmaXguUDJQS30nIG9yICcke1ByZWZpeC5CTFBLfScuYCk7XG4gICAgfVxufTtcbmNvbnN0IGFkZHJlc3NFbmNvZGVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IHB1YmtleVByZWZpeCA9IHZhbC5zdWJzdHJpbmcoMCwgMyk7XG4gICAgc3dpdGNoIChwdWJrZXlQcmVmaXgpIHtcbiAgICAgICAgY2FzZSBQcmVmaXguVFoxOlxuICAgICAgICBjYXNlIFByZWZpeC5UWjI6XG4gICAgICAgIGNhc2UgUHJlZml4LlRaMzpcbiAgICAgICAgY2FzZSBQcmVmaXguVFo0OlxuICAgICAgICAgICAgcmV0dXJuICcwMCcgKyBwdWJsaWNLZXlIYXNoRW5jb2Rlcih2YWwpO1xuICAgICAgICBjYXNlIFByZWZpeC5LVDE6XG4gICAgICAgICAgICByZXR1cm4gJzAxJyArIHByZWZpeEVuY29kZXIoUHJlZml4LktUMSkodmFsKSArICcwMCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcih2YWwsIGludmFsaWREZXRhaWwoVmFsaWRhdGlvblJlc3VsdC5OT19QUkVGSVhfTUFUQ0hFRCkgK1xuICAgICAgICAgICAgICAgIGAgZXhwZWN0aW5nIG9uZSBvZiB0aGUgZm9sbG93aW5nIHByZWZpeCAnJHtQcmVmaXguVFoxfScsICR7UHJlZml4LlRaMn0nLCAnJHtQcmVmaXguVFozfScsICcke1ByZWZpeC5UWjR9JyBvciAnJHtQcmVmaXguS1QxfScuYCk7XG4gICAgfVxufTtcbmNvbnN0IHNtYXJ0Um9sbHVwQWRkcmVzc0VuY29kZXIgPSAodmFsKSA9PiB7XG4gICAgaWYgKHZhbC5zdWJzdHJpbmcoMCwgMykgIT09IFByZWZpeC5TUjEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTbWFydFJvbGx1cEFkZHJlc3NFcnJvcih2YWwsIGludmFsaWREZXRhaWwoVmFsaWRhdGlvblJlc3VsdC5OT19QUkVGSVhfTUFUQ0hFRCkgKyBgIGV4cGVjdGluZyBwcmVmaXggJyR7UHJlZml4LlNSMX0nLmApO1xuICAgIH1cbiAgICByZXR1cm4gcHJlZml4RW5jb2RlcihQcmVmaXguU1IxKSh2YWwpO1xufTtcbmNvbnN0IHNtYXJ0Q29udHJhY3RBZGRyZXNzRW5jb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBwcmVmaXggPSB2YWwuc3Vic3RyaW5nKDAsIDMpO1xuICAgIGlmIChwcmVmaXggPT09IFByZWZpeC5LVDEpIHtcbiAgICAgICAgcmV0dXJuICcwMScgKyBwcmVmaXhFbmNvZGVyKFByZWZpeC5LVDEpKHZhbCkgKyAnMDAnO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yKHZhbCwgaW52YWxpZERldGFpbChWYWxpZGF0aW9uUmVzdWx0Lk5PX1BSRUZJWF9NQVRDSEVEKSArIGAgZXhwZWN0aW5nIHByZWZpeCAnJHtQcmVmaXguS1QxfScuYCk7XG59O1xuY29uc3QgcHVibGljS2V5RGVjb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBwcmVhbWJsZSA9IHZhbC5jb25zdW1lKDEpO1xuICAgIHN3aXRjaCAocHJlYW1ibGVbMF0pIHtcbiAgICAgICAgY2FzZSAweDAwOlxuICAgICAgICAgICAgcmV0dXJuIHByZWZpeERlY29kZXIoUHJlZml4LkVEUEspKHZhbCk7XG4gICAgICAgIGNhc2UgMHgwMTpcbiAgICAgICAgICAgIHJldHVybiBwcmVmaXhEZWNvZGVyKFByZWZpeC5TUFBLKSh2YWwpO1xuICAgICAgICBjYXNlIDB4MDI6XG4gICAgICAgICAgICByZXR1cm4gcHJlZml4RGVjb2RlcihQcmVmaXguUDJQSykodmFsKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUHVibGljS2V5RXJyb3IodmFsLnRvU3RyaW5nKCksIGludmFsaWREZXRhaWwoVmFsaWRhdGlvblJlc3VsdC5OT19QUkVGSVhfTUFUQ0hFRCkpO1xuICAgIH1cbn07XG5jb25zdCBzbWFydFJvbGx1cENvbW1pdG1lbnRIYXNoRW5jb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBwcmVmaXggPSB2YWwuc3Vic3RyaW5nKDAsIDQpO1xuICAgIGlmIChwcmVmaXggPT09IFByZWZpeC5TUkMxKSB7XG4gICAgICAgIHJldHVybiBwcmVmaXhFbmNvZGVyKFByZWZpeC5TUkMxKSh2YWwpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSW52YWxpZFNtYXJ0Um9sbHVwQ29tbWl0bWVudEhhc2hFcnJvcih2YWwsIGludmFsaWREZXRhaWwoVmFsaWRhdGlvblJlc3VsdC5OT19QUkVGSVhfTUFUQ0hFRCkgKyBgIGV4cGVjdGluZyBwcmVmaXggJyR7UHJlZml4LlNSQzF9J2ApO1xufTtcbmNvbnN0IGFkZHJlc3NEZWNvZGVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IHByZWFtYmxlID0gdmFsLmNvbnN1bWUoMSk7XG4gICAgc3dpdGNoIChwcmVhbWJsZVswXSkge1xuICAgICAgICBjYXNlIDB4MDA6XG4gICAgICAgICAgICByZXR1cm4gcHVibGljS2V5SGFzaERlY29kZXIodmFsKTtcbiAgICAgICAgY2FzZSAweDAxOiB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gcHJlZml4RGVjb2RlcihQcmVmaXguS1QxKSh2YWwpO1xuICAgICAgICAgICAgdmFsLmNvbnN1bWUoMSk7XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IodmFsLnRvU3RyaW5nKCksICc6IFVuYWJsZSB0byBkZWNvZGUuJyk7XG4gICAgfVxufTtcbmNvbnN0IHNtYXJ0Um9sbHVwQWRkcmVzc0RlY29kZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgYWRkcmVzcyA9IHByZWZpeERlY29kZXIoUHJlZml4LlNSMSkodmFsKTtcbiAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMCwgMykgIT09IFByZWZpeC5TUjEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTbWFydFJvbGx1cEFkZHJlc3NFcnJvcihhZGRyZXNzLCBpbnZhbGlkRGV0YWlsKFZhbGlkYXRpb25SZXN1bHQuTk9fUFJFRklYX01BVENIRUQpICsgYCBleHBlY3RpbmcgcHJlZml4ICcke1ByZWZpeC5TUjF9Jy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZHJlc3M7XG59O1xuY29uc3Qgc21hcnRDb250cmFjdEFkZHJlc3NEZWNvZGVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IHByZWFtYmxlID0gdmFsLmNvbnN1bWUoMSk7XG4gICAgaWYgKHByZWFtYmxlWzBdID09PSAweDAxKSB7XG4gICAgICAgIGNvbnN0IHNjQWRkcmVzcyA9IHByZWZpeERlY29kZXIoUHJlZml4LktUMSkodmFsKTtcbiAgICAgICAgdmFsLmNvbnN1bWUoMSk7XG4gICAgICAgIHJldHVybiBzY0FkZHJlc3M7XG4gICAgfVxuICAgIHRocm93IG5ldyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IodmFsLnRvU3RyaW5nKCksIGludmFsaWREZXRhaWwoVmFsaWRhdGlvblJlc3VsdC5OT19QUkVGSVhfTUFUQ0hFRCkpO1xufTtcbmNvbnN0IHNtYXJ0Um9sbHVwQ29tbWl0bWVudEhhc2hEZWNvZGVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IGFkZHJlc3MgPSBwcmVmaXhEZWNvZGVyKFByZWZpeC5TUkMxKSh2YWwpO1xuICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygwLCA0KSAhPT0gUHJlZml4LlNSQzEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTbWFydFJvbGx1cENvbW1pdG1lbnRIYXNoRXJyb3IoYWRkcmVzcywgaW52YWxpZERldGFpbChWYWxpZGF0aW9uUmVzdWx0Lk5PX1BSRUZJWF9NQVRDSEVEKSArIGAgZXhwZWN0aW5nIHByZWZpeCAnJHtQcmVmaXguU1JDMX0nYCk7XG4gICAgfVxuICAgIHJldHVybiBhZGRyZXNzO1xufTtcbmNvbnN0IHphcml0aEVuY29kZXIgPSAobikgPT4ge1xuICAgIGNvbnN0IGZuID0gW107XG4gICAgbGV0IG5uID0gbmV3IEJpZ051bWJlciQxKG4sIDEwKTtcbiAgICBpZiAobm4uaXNOYU4oKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIHphcml0aCBudW1iZXIgJHtufWApO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc3RhbnQtY29uZGl0aW9uXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgaWYgKG5uLmx0KDEyOCkpIHtcbiAgICAgICAgICAgIGlmIChubi5sdCgxNikpXG4gICAgICAgICAgICAgICAgZm4ucHVzaCgnMCcpO1xuICAgICAgICAgICAgZm4ucHVzaChubi50b1N0cmluZygxNikpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgYiA9IG5uLm1vZCgxMjgpO1xuICAgICAgICAgICAgbm4gPSBubi5taW51cyhiKTtcbiAgICAgICAgICAgIG5uID0gbm4uZGl2aWRlZEJ5KDEyOCk7XG4gICAgICAgICAgICBiID0gYi5wbHVzKDEyOCk7XG4gICAgICAgICAgICBmbi5wdXNoKGIudG9TdHJpbmcoMTYpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZm4uam9pbignJyk7XG59O1xuY29uc3QgemFyaXRoRGVjb2RlciA9IChuKSA9PiB7XG4gICAgbGV0IG1vc3RTaWduaWZpY2FudEJ5dGUgPSAwO1xuICAgIHdoaWxlIChtb3N0U2lnbmlmaWNhbnRCeXRlIDwgbi5sZW5ndGgoKSAmJiAobi5nZXQobW9zdFNpZ25pZmljYW50Qnl0ZSkgJiAxMjgpICE9PSAwKSB7XG4gICAgICAgIG1vc3RTaWduaWZpY2FudEJ5dGUgKz0gMTtcbiAgICB9XG4gICAgbGV0IG51bSA9IG5ldyBCaWdOdW1iZXIkMSgwKTtcbiAgICBmb3IgKGxldCBpID0gbW9zdFNpZ25pZmljYW50Qnl0ZTsgaSA+PSAwOyBpIC09IDEpIHtcbiAgICAgICAgY29uc3QgdG1wID0gbi5nZXQoaSkgJiAweDdmO1xuICAgICAgICBudW0gPSBudW0ubXVsdGlwbGllZEJ5KDEyOCk7XG4gICAgICAgIG51bSA9IG51bS5wbHVzKHRtcCk7XG4gICAgfVxuICAgIG4uY29uc3VtZShtb3N0U2lnbmlmaWNhbnRCeXRlICsgMSk7XG4gICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIkMShudW0pLnRvU3RyaW5nKCk7XG59O1xuY29uc3QgZW50cnlwb2ludERlY29kZXIgPSAodmFsdWUpID0+IHtcbiAgICBjb25zdCBwcmVhbWJsZSA9IHBhZCh2YWx1ZS5jb25zdW1lKDEpWzBdLCAyKTtcbiAgICBpZiAocHJlYW1ibGUgaW4gZW50cnlwb2ludE1hcHBpbmcpIHtcbiAgICAgICAgcmV0dXJuIGVudHJ5cG9pbnRNYXBwaW5nW3ByZWFtYmxlXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVudHJ5ID0gZXh0cmFjdFJlcXVpcmVkTGVuKHZhbHVlLCAxKTtcbiAgICAgICAgY29uc3QgZW50cnlwb2ludCA9IEJ1ZmZlci5mcm9tKGVudHJ5KS50b1N0cmluZygndXRmOCcpO1xuICAgICAgICBpZiAoZW50cnlwb2ludC5sZW5ndGggPiBFTlRSWVBPSU5UX01BWF9MRU5HVEgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPdmVyc2l6ZWRFbnRyeVBvaW50RXJyb3IoZW50cnlwb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVudHJ5cG9pbnQ7XG4gICAgfVxufTtcbmNvbnN0IHBhcmFtZXRlcnNEZWNvZGVyID0gKHZhbCkgPT4ge1xuICAgIGNvbnN0IHByZWFtYmxlID0gdmFsLmNvbnN1bWUoMSk7XG4gICAgaWYgKHByZWFtYmxlWzBdID09PSAweDAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGNvbnN0IGVuY29kZWRFbnRyeXBvaW50ID0gZW50cnlwb2ludERlY29kZXIodmFsKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gZXh0cmFjdFJlcXVpcmVkTGVuKHZhbCk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB2YWx1ZURlY29kZXIobmV3IFVpbnQ4QXJyYXlDb25zdW1lcihwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGVudHJ5cG9pbnQ6IGVuY29kZWRFbnRyeXBvaW50LFxuICAgICAgICAgICAgdmFsdWU6IHBhcmFtZXRlcnMsXG4gICAgICAgIH07XG4gICAgfVxufTtcbmNvbnN0IGVudHJ5cG9pbnRFbmNvZGVyID0gKGVudHJ5cG9pbnQpID0+IHtcbiAgICBpZiAoZW50cnlwb2ludCBpbiBlbnRyeXBvaW50TWFwcGluZ1JldmVyc2UpIHtcbiAgICAgICAgcmV0dXJuIGAke2VudHJ5cG9pbnRNYXBwaW5nUmV2ZXJzZVtlbnRyeXBvaW50XX1gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGVudHJ5cG9pbnQubGVuZ3RoID4gRU5UUllQT0lOVF9NQVhfTEVOR1RIKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgT3ZlcnNpemVkRW50cnlQb2ludEVycm9yKGVudHJ5cG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0geyBzdHJpbmc6IGVudHJ5cG9pbnQgfTtcbiAgICAgICAgcmV0dXJuIGBmZiR7dmFsdWVFbmNvZGVyKHZhbHVlKS5zbGljZSg4KX1gO1xuICAgIH1cbn07XG5jb25zdCBwYXJhbWV0ZXJzRW5jb2RlciA9ICh2YWwpID0+IHtcbiAgICBpZiAoIXZhbCB8fCAodmFsLmVudHJ5cG9pbnQgPT09ICdkZWZhdWx0JyAmJiAncHJpbScgaW4gdmFsLnZhbHVlICYmIHZhbC52YWx1ZS5wcmltID09PSAnVW5pdCcpKSB7XG4gICAgICAgIHJldHVybiAnMDAnO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGVkRW50cnlwb2ludCA9IGVudHJ5cG9pbnRFbmNvZGVyKHZhbC5lbnRyeXBvaW50KTtcbiAgICBjb25zdCBwYXJhbWV0ZXJzID0gdmFsdWVFbmNvZGVyKHZhbC52YWx1ZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gKHBhcmFtZXRlcnMubGVuZ3RoIC8gMikudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDgsICcwJyk7XG4gICAgcmV0dXJuIGBmZiR7ZW5jb2RlZEVudHJ5cG9pbnR9JHtsZW5ndGh9JHtwYXJhbWV0ZXJzfWA7XG59O1xuY29uc3QgdmFsdWVQYXJhbWV0ZXJFbmNvZGVyID0gKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgdmFsdWVFbmNvZGVkID0gdmFsdWVFbmNvZGVyKHZhbHVlKTtcbiAgICByZXR1cm4gYCR7cGFkKHZhbHVlRW5jb2RlZC5sZW5ndGggLyAyKX0ke3ZhbHVlRW5jb2RlZH1gO1xufTtcbmNvbnN0IHZhbHVlUGFyYW1ldGVyRGVjb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dHJhY3RSZXF1aXJlZExlbih2YWwpO1xuICAgIHJldHVybiB2YWx1ZURlY29kZXIobmV3IFVpbnQ4QXJyYXlDb25zdW1lcih2YWx1ZSkpO1xufTtcbmNvbnN0IGJsb2NrUGF5bG9hZEhhc2hFbmNvZGVyID0gcHJlZml4RW5jb2RlcihQcmVmaXguVkgpO1xuY29uc3QgYmxvY2tQYXlsb2FkSGFzaERlY29kZXIgPSBwcmVmaXhEZWNvZGVyKFByZWZpeC5WSCk7XG5jb25zdCBlbnRyeXBvaW50TmFtZUVuY29kZXIgPSAoZW50cnlwb2ludCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0geyBzdHJpbmc6IGVudHJ5cG9pbnQgfTtcbiAgICByZXR1cm4gYCR7dmFsdWVFbmNvZGVyKHZhbHVlKS5zbGljZSgyKX1gO1xufTtcbmNvbnN0IGVudHJ5cG9pbnROYW1lRGVjb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCBlbnRyeSA9IGV4dHJhY3RSZXF1aXJlZExlbih2YWwpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShlbnRyeSkudG9TdHJpbmcoJ3V0ZjgnKTtcbn07XG5jb25zdCBidXJuTGltaXRFbmNvZGVyID0gKHZhbCkgPT4ge1xuICAgIHJldHVybiAhdmFsID8gJzAwJyA6IGBmZiR7emFyaXRoRW5jb2Rlcih2YWwpfWA7XG59O1xuY29uc3QgYnVybkxpbWl0RGVjb2RlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHByZWZpeCA9IHZhbHVlLmNvbnN1bWUoMSk7XG4gICAgaWYgKEJ1ZmZlci5mcm9tKHByZWZpeCkudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAnKSB7XG4gICAgICAgIHJldHVybiB6YXJpdGhEZWNvZGVyKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3QgZGVwb3NpdHNMaW1pdEVuY29kZXIgPSAodmFsKSA9PiB7XG4gICAgcmV0dXJuICF2YWwgPyAnMDAnIDogYGZmJHt6YXJpdGhFbmNvZGVyKHZhbCl9YDtcbn07XG5jb25zdCBkZXBvc2l0c0xpbWl0RGVjb2RlciA9ICh2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHByZWZpeCA9IHZhbHVlLmNvbnN1bWUoMSk7XG4gICAgaWYgKEJ1ZmZlci5mcm9tKHByZWZpeCkudG9TdHJpbmcoJ2hleCcpICE9PSAnMDAnKSB7XG4gICAgICAgIHJldHVybiB6YXJpdGhEZWNvZGVyKHZhbHVlKTtcbiAgICB9XG59O1xuY29uc3QgcGFkZGVkQnl0ZXNFbmNvZGVyID0gKHZhbCwgcGFkZGluZ0xlbmd0aCA9IDgpID0+IHtcbiAgICByZXR1cm4gYCR7cGFkKHZhbC5sZW5ndGggLyAyLCBwYWRkaW5nTGVuZ3RoKX0ke3ZhbH1gO1xufTtcbmNvbnN0IHBhZGRlZEJ5dGVzRGVjb2RlciA9ICh2YWwpID0+IHtcbiAgICBjb25zdCB2YWx1ZSA9IGV4dHJhY3RSZXF1aXJlZExlbih2YWwpO1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoJ2hleCcpO1xufTtcbmNvbnN0IHNtYXJ0Um9sbHVwTWVzc2FnZUVuY29kZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgbWVzc2FnZSA9IHZhbC5yZWR1Y2UoKHByZXYsIGN1cnIpID0+IHtcbiAgICAgICAgcmV0dXJuIHByZXYgKyBgJHtwYWQoY3Vyci5sZW5ndGggLyAyKX0ke2N1cnJ9YDtcbiAgICB9LCAnJyk7XG4gICAgcmV0dXJuIGAke3BhZChtZXNzYWdlLmxlbmd0aCAvIDIpfSR7bWVzc2FnZX1gO1xufTtcbmNvbnN0IHNtYXJ0Um9sbHVwTWVzc2FnZURlY29kZXIgPSAodmFsKSA9PiB7XG4gICAgY29uc3QgdmFsdWVBcnJheSA9IGV4dHJhY3RSZXF1aXJlZExlbih2YWwpO1xuICAgIGNvbnN0IHJldCA9IHN0cmlwTGVuZ3RoUHJlZml4RnJvbUJ5dGVzKG5ldyBVaW50OEFycmF5Q29uc3VtZXIodmFsdWVBcnJheSkpO1xuICAgIHJldHVybiByZXQubWFwKCh2YWx1ZSkgPT4gQnVmZmVyLmZyb20odmFsdWUpLnRvU3RyaW5nKCdoZXgnKSk7XG59O1xuXG5jb25zdCBNYW5hZ2VyT3BlcmF0aW9uU2NoZW1hID0ge1xuICAgIGJyYW5jaDogQ09ERUMuQlJBTkNILFxuICAgIGNvbnRlbnRzOiBbQ09ERUMuT1BFUkFUSU9OXSxcbn07XG5jb25zdCBBY3RpdmF0aW9uU2NoZW1hID0ge1xuICAgIHBraDogQ09ERUMuVFoxLFxuICAgIHNlY3JldDogQ09ERUMuU0VDUkVULFxufTtcbmNvbnN0IFJldmVhbFNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIHB1YmxpY19rZXk6IENPREVDLlBVQkxJQ19LRVksXG59O1xuY29uc3QgRGVsZWdhdGlvblNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIGRlbGVnYXRlOiBDT0RFQy5ERUxFR0FURSxcbn07XG5jb25zdCBUcmFuc2FjdGlvblNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIGFtb3VudDogQ09ERUMuWkFSSVRILFxuICAgIGRlc3RpbmF0aW9uOiBDT0RFQy5BRERSRVNTLFxuICAgIHBhcmFtZXRlcnM6IENPREVDLlBBUkFNRVRFUlMsXG59O1xuY29uc3QgT3JpZ2luYXRpb25TY2hlbWEgPSB7XG4gICAgc291cmNlOiBDT0RFQy5QS0gsXG4gICAgZmVlOiBDT0RFQy5aQVJJVEgsXG4gICAgY291bnRlcjogQ09ERUMuWkFSSVRILFxuICAgIGdhc19saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIHN0b3JhZ2VfbGltaXQ6IENPREVDLlpBUklUSCxcbiAgICBiYWxhbmNlOiBDT0RFQy5aQVJJVEgsXG4gICAgZGVsZWdhdGU6IENPREVDLkRFTEVHQVRFLFxuICAgIHNjcmlwdDogQ09ERUMuU0NSSVBULFxufTtcbmNvbnN0IEJhbGxvdFNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBwZXJpb2Q6IENPREVDLklOVDMyLFxuICAgIHByb3Bvc2FsOiBDT0RFQy5QUk9QT1NBTCxcbiAgICBiYWxsb3Q6IENPREVDLkJBTExPVF9TVEFURU1FTlQsXG59O1xuY29uc3QgQXR0ZXN0YXRpb25TY2hlbWEgPSB7XG4gICAgc2xvdDogQ09ERUMuSU5UMTYsXG4gICAgbGV2ZWw6IENPREVDLklOVDMyLFxuICAgIHJvdW5kOiBDT0RFQy5JTlQzMixcbiAgICBibG9ja19wYXlsb2FkX2hhc2g6IENPREVDLkJMT0NLX1BBWUxPQURfSEFTSCxcbn07XG5jb25zdCBFbmRvcnNlbWVudFNjaGVtYSA9IHtcbiAgICBzbG90OiBDT0RFQy5JTlQxNixcbiAgICBsZXZlbDogQ09ERUMuSU5UMzIsXG4gICAgcm91bmQ6IENPREVDLklOVDMyLFxuICAgIGJsb2NrX3BheWxvYWRfaGFzaDogQ09ERUMuQkxPQ0tfUEFZTE9BRF9IQVNILFxufTtcbmNvbnN0IFNlZWROb25jZVJldmVsYXRpb25TY2hlbWEgPSB7XG4gICAgbGV2ZWw6IENPREVDLklOVDMyLFxuICAgIG5vbmNlOiBDT0RFQy5SQVcsXG59O1xuY29uc3QgUHJvcG9zYWxzU2NoZW1hID0ge1xuICAgIHNvdXJjZTogQ09ERUMuUEtILFxuICAgIHBlcmlvZDogQ09ERUMuSU5UMzIsXG4gICAgcHJvcG9zYWxzOiBDT0RFQy5QUk9QT1NBTF9BUlIsXG59O1xuY29uc3QgUmVnaXN0ZXJHbG9iYWxDb25zdGFudFNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIHZhbHVlOiBDT0RFQy5WQUxVRSxcbn07XG5jb25zdCBUcmFuc2ZlclRpY2tldFNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIHRpY2tldF9jb250ZW50czogQ09ERUMuVkFMVUUsXG4gICAgdGlja2V0X3R5OiBDT0RFQy5WQUxVRSxcbiAgICB0aWNrZXRfdGlja2V0ZXI6IENPREVDLkFERFJFU1MsXG4gICAgdGlja2V0X2Ftb3VudDogQ09ERUMuWkFSSVRILFxuICAgIGRlc3RpbmF0aW9uOiBDT0RFQy5BRERSRVNTLFxuICAgIGVudHJ5cG9pbnQ6IENPREVDLkVOVFJZUE9JTlQsXG59O1xuY29uc3QgSW5jcmVhc2VQYWlkU3RvcmFnZVNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIGFtb3VudDogQ09ERUMuWkFSSVRILFxuICAgIGRlc3RpbmF0aW9uOiBDT0RFQy5TTUFSVF9DT05UUkFDVF9BRERSRVNTLFxufTtcbmNvbnN0IFVwZGF0ZUNvbnNlbnN1c0tleVNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIHBrOiBDT0RFQy5QVUJMSUNfS0VZLFxufTtcbmNvbnN0IERyYWluRGVsZWdhdGVTY2hlbWEgPSB7XG4gICAgY29uc2Vuc3VzX2tleTogQ09ERUMuUEtILFxuICAgIGRlbGVnYXRlOiBDT0RFQy5QS0gsXG4gICAgZGVzdGluYXRpb246IENPREVDLlBLSCxcbn07XG5jb25zdCBTZXREZXBvc2l0c0xpbWl0U2NoZW1hID0ge1xuICAgIHNvdXJjZTogQ09ERUMuUEtILFxuICAgIGZlZTogQ09ERUMuWkFSSVRILFxuICAgIGNvdW50ZXI6IENPREVDLlpBUklUSCxcbiAgICBnYXNfbGltaXQ6IENPREVDLlpBUklUSCxcbiAgICBzdG9yYWdlX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgbGltaXQ6IENPREVDLkRFUE9TSVRTX0xJTUlULFxufTtcbmNvbnN0IFNtYXJ0Um9sbHVwT3JpZ2luYXRlU2NoZW1hID0ge1xuICAgIHNvdXJjZTogQ09ERUMuUEtILFxuICAgIGZlZTogQ09ERUMuWkFSSVRILFxuICAgIGNvdW50ZXI6IENPREVDLlpBUklUSCxcbiAgICBnYXNfbGltaXQ6IENPREVDLlpBUklUSCxcbiAgICBzdG9yYWdlX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgcHZtX2tpbmQ6IENPREVDLlBWTV9LSU5ELFxuICAgIGtlcm5lbDogQ09ERUMuUEFEREVEX0JZVEVTLFxuICAgIHBhcmFtZXRlcnNfdHk6IENPREVDLlZBTFVFLFxuICAgIHdoaXRlbGlzdDogQ09ERUMuUEtIX0FSUixcbn07XG5jb25zdCBTbWFydFJvbGx1cEFkZE1lc3NhZ2VzU2NoZW1hID0ge1xuICAgIHNvdXJjZTogQ09ERUMuUEtILFxuICAgIGZlZTogQ09ERUMuWkFSSVRILFxuICAgIGNvdW50ZXI6IENPREVDLlpBUklUSCxcbiAgICBnYXNfbGltaXQ6IENPREVDLlpBUklUSCxcbiAgICBzdG9yYWdlX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgbWVzc2FnZTogQ09ERUMuU01BUlRfUk9MTFVQX01FU1NBR0UsXG59O1xuY29uc3QgU21hcnRSb2xsdXBFeGVjdXRlT3V0Ym94TWVzc2FnZVNjaGVtYSA9IHtcbiAgICBzb3VyY2U6IENPREVDLlBLSCxcbiAgICBmZWU6IENPREVDLlpBUklUSCxcbiAgICBjb3VudGVyOiBDT0RFQy5aQVJJVEgsXG4gICAgZ2FzX2xpbWl0OiBDT0RFQy5aQVJJVEgsXG4gICAgc3RvcmFnZV9saW1pdDogQ09ERUMuWkFSSVRILFxuICAgIHJvbGx1cDogQ09ERUMuU01BUlRfUk9MTFVQX0FERFJFU1MsXG4gICAgY2VtZW50ZWRfY29tbWl0bWVudDogQ09ERUMuU01BUlRfUk9MTFVQX0NPTU1JVE1FTlRfSEFTSCxcbiAgICBvdXRwdXRfcHJvb2Y6IENPREVDLlBBRERFRF9CWVRFUyxcbn07XG5jb25zdCBGYWlsaW5nTm9vcFNjaGVtYSA9IHtcbiAgICBhcmJpdHJhcnk6IENPREVDLlBBRERFRF9CWVRFUyxcbn07XG5jb25zdCBvcGVyYXRpb25FbmNvZGVyID0gKGVuY29kZXJzKSA9PiAob3BlcmF0aW9uKSA9PiB7XG4gICAgaWYgKCEob3BlcmF0aW9uLmtpbmQgaW4gZW5jb2RlcnMpIHx8ICEob3BlcmF0aW9uLmtpbmQgaW4ga2luZE1hcHBpbmdSZXZlcnNlKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9wZXJhdGlvbktpbmRFcnJvcihvcGVyYXRpb24ua2luZCk7XG4gICAgfVxuICAgIHJldHVybiBraW5kTWFwcGluZ1JldmVyc2Vbb3BlcmF0aW9uLmtpbmRdICsgZW5jb2RlcnNbb3BlcmF0aW9uLmtpbmRdKG9wZXJhdGlvbik7XG59O1xuY29uc3Qgb3BlcmF0aW9uRGVjb2RlciA9IChkZWNvZGVycykgPT4gKHZhbHVlKSA9PiB7XG4gICAgY29uc3Qgb3AgPSB2YWx1ZS5jb25zdW1lKDEpO1xuICAgIGNvbnN0IG9wZXJhdGlvbk5hbWUgPSBraW5kTWFwcGluZ1tvcFswXV07XG4gICAgaWYgKG9wZXJhdGlvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvcihvcFswXS50b1N0cmluZygpKTtcbiAgICB9XG4gICAgY29uc3QgZGVjb2RlZE9iaiA9IGRlY29kZXJzW29wZXJhdGlvbk5hbWVdKHZhbHVlKTtcbiAgICBpZiAodHlwZW9mIGRlY29kZWRPYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBPcGVyYXRpb25EZWNvZGluZ0Vycm9yKCdJbnZhbGlkIG9wZXJhdGlvbiwgY2Fubm90IGJlIGRlY29kZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHsga2luZDogb3BlcmF0aW9uTmFtZSB9LCBkZWNvZGVkT2JqKTtcbn07XG5jb25zdCBzY2hlbWFFbmNvZGVyID0gKGVuY29kZXJzKSA9PiAoc2NoZW1hKSA9PiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKHByZXYsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZVRvRW5jb2RlID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiBBcnJheS5pc0FycmF5KHZhbHVlVG9FbmNvZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZW5jb2RlcnNbdmFsdWVUb0VuY29kZVswXV07XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT3BlcmF0aW9uRW5jb2RpbmdFcnJvcihgSW52YWxpZCBvcGVyYXRpb24gdmFsdWUgXCIke0pTT04uc3RyaW5naWZ5KHZhbHVlcyl9XCIgb2Yga2V5IFwiJHtrZXl9LCBleHBlY3RlZCB2YWx1ZSB0byBiZSBBcnJheS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiAocHJldiArIHZhbHVlcy5yZWR1Y2UoKHByZXZCeXRlcywgY3VycmVudCkgPT4gcHJldkJ5dGVzICsgZW5jb2RlcihjdXJyZW50KSwgJycpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBlbmNvZGVyc1t2YWx1ZVRvRW5jb2RlXTtcbiAgICAgICAgICAgIHJldHVybiBwcmV2ICsgZW5jb2Rlcih2YWx1ZVtrZXldKTtcbiAgICAgICAgfVxuICAgIH0sICcnKTtcbn07XG5jb25zdCBzY2hlbWFEZWNvZGVyID0gKGRlY29kZXJzKSA9PiAoc2NoZW1hKSA9PiAodmFsdWUpID0+IHtcbiAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoc2NoZW1hKTtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoKHByZXYsIGtleSkgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZVRvRW5jb2RlID0gc2NoZW1hW2tleV07XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlVG9FbmNvZGUpKSB7XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVyID0gZGVjb2RlcnNbdmFsdWVUb0VuY29kZVswXV07XG4gICAgICAgICAgICBjb25zdCBkZWNvZGVkID0gW107XG4gICAgICAgICAgICBjb25zdCBsYXN0TGVuZ3RoID0gdmFsdWUubGVuZ3RoKCk7XG4gICAgICAgICAgICB3aGlsZSAodmFsdWUubGVuZ3RoKCkgPiAwKSB7XG4gICAgICAgICAgICAgICAgZGVjb2RlZC5wdXNoKGRlY29kZXIodmFsdWUpKTtcbiAgICAgICAgICAgICAgICBpZiAobGFzdExlbmd0aCA9PT0gdmFsdWUubGVuZ3RoKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9wZXJhdGlvbkRlY29kaW5nRXJyb3IoJ1VuYWJsZSB0byBkZWNvZGUgdmFsdWUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwcmV2KSwgeyBba2V5XTogZGVjb2RlZCB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGRlY29kZXIgPSBkZWNvZGVyc1t2YWx1ZVRvRW5jb2RlXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXN1bHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIHsgW2tleV06IHJlc3VsdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBwcmV2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIHt9KTtcbn07XG5cbmNvbnN0IGRlY29kZXJzID0ge1xuICAgIFtDT0RFQy5TRUNSRVRdOiAodmFsKSA9PiB0b0hleFN0cmluZyh2YWwuY29uc3VtZSgyMCkpLFxuICAgIFtDT0RFQy5SQVddOiAodmFsKSA9PiB0b0hleFN0cmluZyh2YWwuY29uc3VtZSgzMikpLFxuICAgIFtDT0RFQy5UWjFdOiB0ejFEZWNvZGVyLFxuICAgIFtDT0RFQy5CUkFOQ0hdOiBicmFuY2hEZWNvZGVyLFxuICAgIFtDT0RFQy5aQVJJVEhdOiB6YXJpdGhEZWNvZGVyLFxuICAgIFtDT0RFQy5QVUJMSUNfS0VZXTogcHVibGljS2V5RGVjb2RlcixcbiAgICBbQ09ERUMuUEtIXTogcHVibGljS2V5SGFzaERlY29kZXIsXG4gICAgW0NPREVDLlBLSF9BUlJdOiBwdWJsaWNLZXlIYXNoZXNEZWNvZGVyLFxuICAgIFtDT0RFQy5ERUxFR0FURV06IGRlbGVnYXRlRGVjb2RlcixcbiAgICBbQ09ERUMuSU5UMzJdOiBpbnQzMkRlY29kZXIsXG4gICAgW0NPREVDLlNDUklQVF06IHNjcmlwdERlY29kZXIsXG4gICAgW0NPREVDLkJBTExPVF9TVEFURU1FTlRdOiBiYWxsb3REZWNvZGVyLFxuICAgIFtDT0RFQy5QUk9QT1NBTF06IHByb3Bvc2FsRGVjb2RlcixcbiAgICBbQ09ERUMuUFJPUE9TQUxfQVJSXTogcHJvcG9zYWxzRGVjb2RlcixcbiAgICBbQ09ERUMuUEFSQU1FVEVSU106IHBhcmFtZXRlcnNEZWNvZGVyLFxuICAgIFtDT0RFQy5BRERSRVNTXTogYWRkcmVzc0RlY29kZXIsXG4gICAgW0NPREVDLlNNQVJUX1JPTExVUF9BRERSRVNTXTogc21hcnRSb2xsdXBBZGRyZXNzRGVjb2RlcixcbiAgICBbQ09ERUMuU01BUlRfQ09OVFJBQ1RfQUREUkVTU106IHNtYXJ0Q29udHJhY3RBZGRyZXNzRGVjb2RlcixcbiAgICBbQ09ERUMuU01BUlRfUk9MTFVQX0NPTU1JVE1FTlRfSEFTSF06IHNtYXJ0Um9sbHVwQ29tbWl0bWVudEhhc2hEZWNvZGVyLFxuICAgIFtDT0RFQy5WQUxVRV06IHZhbHVlUGFyYW1ldGVyRGVjb2RlcixcbiAgICBbQ09ERUMuSU5UMTZdOiBpbnQxNkRlY29kZXIsXG4gICAgW0NPREVDLkJMT0NLX1BBWUxPQURfSEFTSF06IGJsb2NrUGF5bG9hZEhhc2hEZWNvZGVyLFxuICAgIFtDT0RFQy5FTlRSWVBPSU5UXTogZW50cnlwb2ludE5hbWVEZWNvZGVyLFxuICAgIFtDT0RFQy5CVVJOX0xJTUlUXTogYnVybkxpbWl0RGVjb2RlcixcbiAgICBbQ09ERUMuREVQT1NJVFNfTElNSVRdOiBkZXBvc2l0c0xpbWl0RGVjb2RlcixcbiAgICBbQ09ERUMuUFZNX0tJTkRdOiBwdm1LaW5kRGVjb2RlcixcbiAgICBbQ09ERUMuUEFEREVEX0JZVEVTXTogcGFkZGVkQnl0ZXNEZWNvZGVyLFxuICAgIFtDT0RFQy5TTUFSVF9ST0xMVVBfTUVTU0FHRV06IHNtYXJ0Um9sbHVwTWVzc2FnZURlY29kZXIsXG59O1xuZGVjb2RlcnNbQ09ERUMuT1BFUkFUSU9OXSA9IG9wZXJhdGlvbkRlY29kZXIoZGVjb2RlcnMpO1xuZGVjb2RlcnNbQ09ERUMuT1BfQUNUSVZBVEVfQUNDT1VOVF0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShBY3RpdmF0aW9uU2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfRkFJTElOR19OT09QXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKEZhaWxpbmdOb29wU2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfREVMRUdBVElPTl0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShEZWxlZ2F0aW9uU2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfVFJBTlNBQ1RJT05dID0gKHZhbCkgPT4gc2NoZW1hRGVjb2RlcihkZWNvZGVycykoVHJhbnNhY3Rpb25TY2hlbWEpKHZhbCk7XG5kZWNvZGVyc1tDT0RFQy5PUF9PUklHSU5BVElPTl0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShPcmlnaW5hdGlvblNjaGVtYSkodmFsKTtcbmRlY29kZXJzW0NPREVDLk9QX0JBTExPVF0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShCYWxsb3RTY2hlbWEpKHZhbCk7XG5kZWNvZGVyc1tDT0RFQy5PUF9BVFRFU1RBVElPTl0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShBdHRlc3RhdGlvblNjaGVtYSkodmFsKTtcbmRlY29kZXJzW0NPREVDLk9QX0VORE9SU0VNRU5UXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKEVuZG9yc2VtZW50U2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfU0VFRF9OT05DRV9SRVZFTEFUSU9OXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKFNlZWROb25jZVJldmVsYXRpb25TY2hlbWEpKHZhbCk7XG5kZWNvZGVyc1tDT0RFQy5PUF9QUk9QT1NBTFNdID0gKHZhbCkgPT4gc2NoZW1hRGVjb2RlcihkZWNvZGVycykoUHJvcG9zYWxzU2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfUkVWRUFMXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKFJldmVhbFNjaGVtYSkodmFsKTtcbmRlY29kZXJzW0NPREVDLk9QX1JFR0lTVEVSX0dMT0JBTF9DT05TVEFOVF0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShSZWdpc3Rlckdsb2JhbENvbnN0YW50U2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfVFJBTlNGRVJfVElDS0VUXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKFRyYW5zZmVyVGlja2V0U2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfSU5DUkVBU0VfUEFJRF9TVE9SQUdFXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKEluY3JlYXNlUGFpZFN0b3JhZ2VTY2hlbWEpKHZhbCk7XG5kZWNvZGVyc1tDT0RFQy5PUF9VUERBVEVfQ09OU0VOU1VTX0tFWV0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShVcGRhdGVDb25zZW5zdXNLZXlTY2hlbWEpKHZhbCk7XG5kZWNvZGVyc1tDT0RFQy5PUF9EUkFJTl9ERUxFR0FURV0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShEcmFpbkRlbGVnYXRlU2NoZW1hKSh2YWwpO1xuZGVjb2RlcnNbQ09ERUMuT1BfU01BUlRfUk9MTFVQX09SSUdJTkFURV0gPSAodmFsKSA9PiBzY2hlbWFEZWNvZGVyKGRlY29kZXJzKShTbWFydFJvbGx1cE9yaWdpbmF0ZVNjaGVtYSkodmFsKTtcbmRlY29kZXJzW0NPREVDLk9QX1NNQVJUX1JPTExVUF9BRERfTUVTU0FHRVNdID0gKHZhbCkgPT4gc2NoZW1hRGVjb2RlcihkZWNvZGVycykoU21hcnRSb2xsdXBBZGRNZXNzYWdlc1NjaGVtYSkodmFsKTtcbmRlY29kZXJzW0NPREVDLk9QX1NNQVJUX1JPTExVUF9FWEVDVVRFX09VVEJPWF9NRVNTQUdFXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKFNtYXJ0Um9sbHVwRXhlY3V0ZU91dGJveE1lc3NhZ2VTY2hlbWEpKHZhbCk7XG5kZWNvZGVyc1tDT0RFQy5NQU5BR0VSXSA9IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKE1hbmFnZXJPcGVyYXRpb25TY2hlbWEpO1xuZGVjb2RlcnNbQ09ERUMuT1BfU0VUX0RFUE9TSVRTX0xJTUlUXSA9ICh2YWwpID0+IHNjaGVtYURlY29kZXIoZGVjb2RlcnMpKFNldERlcG9zaXRzTGltaXRTY2hlbWEpKHZhbCk7XG5cbmNvbnN0IGVuY29kZXJzID0ge1xuICAgIFtDT0RFQy5TRUNSRVRdOiAodmFsKSA9PiB2YWwsXG4gICAgW0NPREVDLlJBV106ICh2YWwpID0+IHZhbCxcbiAgICBbQ09ERUMuVFoxXTogdHoxRW5jb2RlcixcbiAgICBbQ09ERUMuQlJBTkNIXTogYnJhbmNoRW5jb2RlcixcbiAgICBbQ09ERUMuWkFSSVRIXTogemFyaXRoRW5jb2RlcixcbiAgICBbQ09ERUMuUFVCTElDX0tFWV06IHB1YmxpY0tleUVuY29kZXIsXG4gICAgW0NPREVDLlBLSF06IHB1YmxpY0tleUhhc2hFbmNvZGVyLFxuICAgIFtDT0RFQy5QS0hfQVJSXTogcHVibGljS2V5SGFzaGVzRW5jb2RlcixcbiAgICBbQ09ERUMuREVMRUdBVEVdOiBkZWxlZ2F0ZUVuY29kZXIsXG4gICAgW0NPREVDLlNDUklQVF06IHNjcmlwdEVuY29kZXIsXG4gICAgW0NPREVDLkJBTExPVF9TVEFURU1FTlRdOiBiYWxsb3RFbmNvZGVyLFxuICAgIFtDT0RFQy5QUk9QT1NBTF06IHByb3Bvc2FsRW5jb2RlcixcbiAgICBbQ09ERUMuUFJPUE9TQUxfQVJSXTogcHJvcG9zYWxzRW5jb2RlcixcbiAgICBbQ09ERUMuSU5UMzJdOiBpbnQzMkVuY29kZXIsXG4gICAgW0NPREVDLlBBUkFNRVRFUlNdOiBwYXJhbWV0ZXJzRW5jb2RlcixcbiAgICBbQ09ERUMuQUREUkVTU106IGFkZHJlc3NFbmNvZGVyLFxuICAgIFtDT0RFQy5TTUFSVF9ST0xMVVBfQUREUkVTU106IHNtYXJ0Um9sbHVwQWRkcmVzc0VuY29kZXIsXG4gICAgW0NPREVDLlNNQVJUX0NPTlRSQUNUX0FERFJFU1NdOiBzbWFydENvbnRyYWN0QWRkcmVzc0VuY29kZXIsXG4gICAgW0NPREVDLlNNQVJUX1JPTExVUF9DT01NSVRNRU5UX0hBU0hdOiBzbWFydFJvbGx1cENvbW1pdG1lbnRIYXNoRW5jb2RlcixcbiAgICBbQ09ERUMuVkFMVUVdOiB2YWx1ZVBhcmFtZXRlckVuY29kZXIsXG4gICAgW0NPREVDLklOVDE2XTogaW50MTZFbmNvZGVyLFxuICAgIFtDT0RFQy5CTE9DS19QQVlMT0FEX0hBU0hdOiBibG9ja1BheWxvYWRIYXNoRW5jb2RlcixcbiAgICBbQ09ERUMuRU5UUllQT0lOVF06IGVudHJ5cG9pbnROYW1lRW5jb2RlcixcbiAgICBbQ09ERUMuQlVSTl9MSU1JVF06IGJ1cm5MaW1pdEVuY29kZXIsXG4gICAgW0NPREVDLkRFUE9TSVRTX0xJTUlUXTogZGVwb3NpdHNMaW1pdEVuY29kZXIsXG4gICAgW0NPREVDLlBWTV9LSU5EXTogcHZtS2luZEVuY29kZXIsXG4gICAgW0NPREVDLlBBRERFRF9CWVRFU106IHBhZGRlZEJ5dGVzRW5jb2RlcixcbiAgICBbQ09ERUMuU01BUlRfUk9MTFVQX01FU1NBR0VdOiBzbWFydFJvbGx1cE1lc3NhZ2VFbmNvZGVyLFxufTtcbmVuY29kZXJzW0NPREVDLk9QRVJBVElPTl0gPSBvcGVyYXRpb25FbmNvZGVyKGVuY29kZXJzKTtcbmVuY29kZXJzW0NPREVDLk9QX0FDVElWQVRFX0FDQ09VTlRdID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoQWN0aXZhdGlvblNjaGVtYSkodmFsKTtcbmVuY29kZXJzW0NPREVDLk9QX0RFTEVHQVRJT05dID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoRGVsZWdhdGlvblNjaGVtYSkodmFsKTtcbmVuY29kZXJzW0NPREVDLk9QX1RSQU5TQUNUSU9OXSA9ICh2YWwpID0+IHNjaGVtYUVuY29kZXIoZW5jb2RlcnMpKFRyYW5zYWN0aW9uU2NoZW1hKSh2YWwpO1xuZW5jb2RlcnNbQ09ERUMuT1BfT1JJR0lOQVRJT05dID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoT3JpZ2luYXRpb25TY2hlbWEpKHZhbCk7XG5lbmNvZGVyc1tDT0RFQy5PUF9CQUxMT1RdID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoQmFsbG90U2NoZW1hKSh2YWwpO1xuZW5jb2RlcnNbQ09ERUMuT1BfQVRURVNUQVRJT05dID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoQXR0ZXN0YXRpb25TY2hlbWEpKHZhbCk7XG5lbmNvZGVyc1tDT0RFQy5PUF9FTkRPUlNFTUVOVF0gPSAodmFsKSA9PiBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShFbmRvcnNlbWVudFNjaGVtYSkodmFsKTtcbmVuY29kZXJzW0NPREVDLk9QX1NFRURfTk9OQ0VfUkVWRUxBVElPTl0gPSAodmFsKSA9PiBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShTZWVkTm9uY2VSZXZlbGF0aW9uU2NoZW1hKSh2YWwpO1xuZW5jb2RlcnNbQ09ERUMuT1BfUFJPUE9TQUxTXSA9ICh2YWwpID0+IHNjaGVtYUVuY29kZXIoZW5jb2RlcnMpKFByb3Bvc2Fsc1NjaGVtYSkodmFsKTtcbmVuY29kZXJzW0NPREVDLk9QX1JFVkVBTF0gPSAodmFsKSA9PiBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShSZXZlYWxTY2hlbWEpKHZhbCk7XG5lbmNvZGVyc1tDT0RFQy5PUF9SRUdJU1RFUl9HTE9CQUxfQ09OU1RBTlRdID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoUmVnaXN0ZXJHbG9iYWxDb25zdGFudFNjaGVtYSkodmFsKTtcbmVuY29kZXJzW0NPREVDLk9QX1RSQU5TRkVSX1RJQ0tFVF0gPSAodmFsKSA9PiBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShUcmFuc2ZlclRpY2tldFNjaGVtYSkodmFsKTtcbmVuY29kZXJzW0NPREVDLk9QX0lOQ1JFQVNFX1BBSURfU1RPUkFHRV0gPSAodmFsKSA9PiBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShJbmNyZWFzZVBhaWRTdG9yYWdlU2NoZW1hKSh2YWwpO1xuZW5jb2RlcnNbQ09ERUMuT1BfVVBEQVRFX0NPTlNFTlNVU19LRVldID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoVXBkYXRlQ29uc2Vuc3VzS2V5U2NoZW1hKSh2YWwpO1xuZW5jb2RlcnNbQ09ERUMuT1BfRFJBSU5fREVMRUdBVEVdID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoRHJhaW5EZWxlZ2F0ZVNjaGVtYSkodmFsKTtcbmVuY29kZXJzW0NPREVDLk9QX1NNQVJUX1JPTExVUF9PUklHSU5BVEVdID0gKHZhbCkgPT4gc2NoZW1hRW5jb2RlcihlbmNvZGVycykoU21hcnRSb2xsdXBPcmlnaW5hdGVTY2hlbWEpKHZhbCk7XG5lbmNvZGVyc1tDT0RFQy5PUF9TTUFSVF9ST0xMVVBfQUREX01FU1NBR0VTXSA9ICh2YWwpID0+IHNjaGVtYUVuY29kZXIoZW5jb2RlcnMpKFNtYXJ0Um9sbHVwQWRkTWVzc2FnZXNTY2hlbWEpKHZhbCk7XG5lbmNvZGVyc1tDT0RFQy5PUF9TTUFSVF9ST0xMVVBfRVhFQ1VURV9PVVRCT1hfTUVTU0FHRV0gPSAodmFsKSA9PiBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShTbWFydFJvbGx1cEV4ZWN1dGVPdXRib3hNZXNzYWdlU2NoZW1hKSh2YWwpO1xuZW5jb2RlcnNbQ09ERUMuTUFOQUdFUl0gPSBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShNYW5hZ2VyT3BlcmF0aW9uU2NoZW1hKTtcbmVuY29kZXJzW0NPREVDLk9QX1NFVF9ERVBPU0lUU19MSU1JVF0gPSAodmFsKSA9PiBzY2hlbWFFbmNvZGVyKGVuY29kZXJzKShTZXREZXBvc2l0c0xpbWl0U2NoZW1hKSh2YWwpO1xuZW5jb2RlcnNbQ09ERUMuT1BfRkFJTElOR19OT09QXSA9ICh2YWwpID0+IHNjaGVtYUVuY29kZXIoZW5jb2RlcnMpKEZhaWxpbmdOb29wU2NoZW1hKSh2YWwpO1xuXG5jb25zdCBPcGVyYXRpb25LaW5kTWFwcGluZyA9IHtcbiAgICBhY3RpdmF0ZV9hY2NvdW50OiBBY3RpdmF0aW9uU2NoZW1hLFxuICAgIHJldmVhbDogUmV2ZWFsU2NoZW1hLFxuICAgIGRlbGVnYXRpb246IERlbGVnYXRpb25TY2hlbWEsXG4gICAgdHJhbnNhY3Rpb246IFRyYW5zYWN0aW9uU2NoZW1hLFxuICAgIG9yaWdpbmF0aW9uOiBPcmlnaW5hdGlvblNjaGVtYSxcbiAgICBiYWxsb3Q6IEJhbGxvdFNjaGVtYSxcbiAgICBhdHRlc3RhdGlvbjogQXR0ZXN0YXRpb25TY2hlbWEsXG4gICAgZW5kb3JzZW1lbnQ6IEVuZG9yc2VtZW50U2NoZW1hLFxuICAgIHNlZWRfbm9uY2VfcmV2ZWxhdGlvbjogU2VlZE5vbmNlUmV2ZWxhdGlvblNjaGVtYSxcbiAgICBwcm9wb3NhbHM6IFByb3Bvc2Fsc1NjaGVtYSxcbiAgICByZWdpc3Rlcl9nbG9iYWxfY29uc3RhbnQ6IFJlZ2lzdGVyR2xvYmFsQ29uc3RhbnRTY2hlbWEsXG4gICAgdHJhbnNmZXJfdGlja2V0OiBUcmFuc2ZlclRpY2tldFNjaGVtYSxcbiAgICBpbmNyZWFzZV9wYWlkX3N0b3JhZ2U6IEluY3JlYXNlUGFpZFN0b3JhZ2VTY2hlbWEsXG4gICAgdXBkYXRlX2NvbnNlbnN1c19rZXk6IFVwZGF0ZUNvbnNlbnN1c0tleVNjaGVtYSxcbiAgICBkcmFpbl9kZWxlZ2F0ZTogRHJhaW5EZWxlZ2F0ZVNjaGVtYSxcbiAgICBzZXRfZGVwb3NpdHNfbGltaXQ6IFNldERlcG9zaXRzTGltaXRTY2hlbWEsXG4gICAgc21hcnRfcm9sbHVwX29yaWdpbmF0ZTogU21hcnRSb2xsdXBPcmlnaW5hdGVTY2hlbWEsXG4gICAgc21hcnRfcm9sbHVwX2FkZF9tZXNzYWdlczogU21hcnRSb2xsdXBBZGRNZXNzYWdlc1NjaGVtYSxcbiAgICBzbWFydF9yb2xsdXBfZXhlY3V0ZV9vdXRib3hfbWVzc2FnZTogU21hcnRSb2xsdXBFeGVjdXRlT3V0Ym94TWVzc2FnZVNjaGVtYSxcbiAgICBmYWlsaW5nX25vb3A6IEZhaWxpbmdOb29wU2NoZW1hLFxufTtcbi8vIEFzeW1tZXRyaWMgZGlmZmVyZW5jZTogb25seSBhY2NvdW50IGZvciB0aGluZ3MgaW4gYXJyMiB0aGF0IGFyZSBub3QgcHJlc2VudCBpbiBhcnIxLCBub3QgdmljZSB2ZXJzYVxuY29uc3QgZ2V0QXJyYXlEaWZmZXJlbmNlID0gKGFycjEsIGFycjIpID0+IHtcbiAgICByZXR1cm4gYXJyMi5maWx0ZXIoKHgpID0+ICFhcnIxLmluY2x1ZGVzKHgpKTtcbn07XG5jb25zdCBkZWxldGVBcnJheUVsZW1lbnRCeVZhbHVlID0gKGFycmF5LCBpdGVtKSA9PiB7XG4gICAgcmV0dXJuIGFycmF5LmZpbHRlcigoZSkgPT4gZSAhPT0gaXRlbSk7XG59O1xuLyoqXG4gKiBAcmV0dXJucyBBIGJvb2xlYW4gdmFsdWUgdG8gaW5kaWNhdGUgd2hldGhlciB0aGUgb3BlcmF0aW9uIGtpbmQgaXMgdmFsaWQgb3Igbm90XG4gKi9cbmNvbnN0IHZhbGlkYXRlT3BlcmF0aW9uS2luZCA9IChvcEtpbmQpID0+IHtcbiAgICBjb25zdCBvcEtpbmRMaXN0ID0gT2JqZWN0LmtleXMoT3BlcmF0aW9uS2luZE1hcHBpbmcpO1xuICAgIHJldHVybiBvcEtpbmRMaXN0LmluY2x1ZGVzKG9wS2luZCk7XG59O1xuLyoqXG4gKiAgcmV0dXJucyAwIHdoZW4gdGhlIHR3byBhcnJheSBvZiBwcm9wZXJ0aWVzIGFyZSBpZGVudGljYWwgb3IgdGhlIHBhc3NlZCBwcm9wZXJ0eVxuICogIGRvZXMgbm90IGhhdmUgYW55IG1pc3NpbmcgcGFyYW1ldGVycyBmcm9tIHRoZSBjb3JyZXNwb25kaW5nIHNjaGVtYVxuICpcbiAqICBAcmV0dXJucyBhcnJheSBlbGVtZW50IGRpZmZlcmVuY2VzIGlmIHRoZXJlIGFyZSBtaXNzaW5nIHJlcXVpcmVkIHByb3BlcnR5IGtleXNcbiAqL1xuY29uc3QgdmFsaWRhdGVNaXNzaW5nUHJvcGVydHkgPSAob3BlcmF0aW9uQ29udGVudCkgPT4ge1xuICAgIGNvbnN0IGtpbmQgPSBvcGVyYXRpb25Db250ZW50LmtpbmQ7XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9wZXJhdGlvbkNvbnRlbnQpO1xuICAgIGNvbnN0IGNsZWFuS2V5cyA9IGRlbGV0ZUFycmF5RWxlbWVudEJ5VmFsdWUoa2V5cywgJ2tpbmQnKTtcbiAgICBjb25zdCBzY2hlbWFLZXlzID0gT2JqZWN0LmtleXMoT3BlcmF0aW9uS2luZE1hcHBpbmdba2luZF0pO1xuICAgIHJldHVybiBnZXRBcnJheURpZmZlcmVuY2UoY2xlYW5LZXlzLCBzY2hlbWFLZXlzKTtcbn07XG5cbnZhciBQcm90b2NvbHNIYXNoO1xuKGZ1bmN0aW9uIChQcm90b2NvbHNIYXNoKSB7XG4gICAgUHJvdG9jb2xzSGFzaFtcIlB0MjRtNHhpXCJdID0gXCJQdDI0bTR4aVBiTERoVmdWZkFCVWppcmJtZGEzeW9oZE44MlNwOUZldUFYSjRlVjlvdGRcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHNCQUJZNUhcIl0gPSBcIlBzQkFCWTVIUVRTa0E0Mjk3ek5IZnNaTkt0eFVMZkwxOHk5NXFiM201M1FKaVhHbXJiVVwiO1xuICAgIFByb3RvY29sc0hhc2hbXCJQc0JhYnlNMVwiXSA9IFwiUHNCYWJ5TTFlVVhac2VhSmRtWEZBcERTQnFqOFlCZndFTG94WkhIVzc3RU1jQWJid0FTXCI7XG4gICAgUHJvdG9jb2xzSGFzaFtcIlBzQ0FSVEhBXCJdID0gXCJQc0NBUlRIQUdhektiSHRuS2ZMelFnM2ttczUya1NScGduRFk5ODJhOW9Zc1NYUkxRRWJcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHNERUxQSDFcIl0gPSBcIlBzREVMUEgxS3hzeHQ4ZjllV2J4UWVSeGtqZmJ4b3FNNTJqdnM1WTVmQnhXV2g0aWZwb1wiO1xuICAgIFByb3RvY29sc0hhc2hbXCJQdEVkbzJaa1wiXSA9IFwiUHRFZG8yWmtUOW9LcGltVGFoNngyZW1iRjI1b3NzNTRuak11UHprSlRFaTVScWZkWkZBXCI7XG4gICAgUHJvdG9jb2xzSGFzaFtcIlBzRkxvcmVuYVwiXSA9IFwiUHNGTG9yZW5hVVV1aWtEV3ZNRHI2ZkdCUkc4a3QzZTNEM2ZIb1hLMWoxQkZSeGVTSDRpXCI7XG4gICAgUHJvdG9jb2xzSGFzaFtcIlB0R1JBTkFEc1wiXSA9IFwiUHRHUkFOQURzRFU4UjlkYVlLQWdXblFZQUo2NG9tTjFvM0tNR1ZDeWtTaEE5N3ZRYnZWXCI7XG4gICAgUHJvdG9jb2xzSGFzaFtcIlB0SGFuZ3oyXCJdID0gXCJQdEhhbmd6MmFSbmd5d21TUkdHdnJjVHlNYmJkcFdkcEZLdVM0dU1XeGcyUmFIOWkxcXhcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHNpdGhhY2EyXCJdID0gXCJQc2l0aGFjYTJNTFJGWWFyZ2l2cG83WXZVcjd3VURxeXhyZGhDNUNRcTc4bVJ2aW16NkFcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHRKYWthcnQyXCJdID0gXCJQdEpha2FydDJ4Vmo3cFlYSkJYcnFIZ2Q4MnJka0xleTVaZWVHd0RnUHA5cmhRVWJTcVlcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHRLYXRobWFuXCJdID0gXCJQdEthdGhtYW5rU3BMTERBTHpXdzdDR0QyajJNdHl2ZVR3Ym9FWW9rcVVDUDRhMUx4TWdcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHRMaW1hUHRMXCJdID0gXCJQdExpbWFQdExNd2ZOaW5KaTlyQ2ZEUFdlYThkRmdUWjFNZUo5ZjFtMlNSaWM2YXlpd1dcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHRNdW1iYWlpXCJdID0gXCJQdE11bWJhaWlGRkVHYmV3MXJSanpTUHl6UmJBNTFUbTNSVlpMNXN1SFB4U1pZRGhDRWNcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHRNdW1iYWkyXCJdID0gXCJQdE11bWJhaTJUbXNKSE5HUmtEOHY4WURidGFvN0JMVUMzd2pBU24xaW5BS0xGQ2phSDFcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHROYWlyb2JpXCJdID0gXCJQdE5haXJvYml5c3NIdWg4N2hFaGZWQkdDVnJLM1duUzhaMkZUNHltQjV0QWE0cjFuUWZcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHJveGZvcmRZXCJdID0gXCJQcm94Zm9yZFltVmZqV25SY2dqV0gzNmZXNlBBcndxeWtURnpvdFV4UnM2Z21UY1pEdUhcIjtcbiAgICBQcm90b2NvbHNIYXNoW1wiUHJvdG9BTHBoYVwiXSA9IFwiUHJvdG9BTHBoYUFMcGhhQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYUFMcGhhRGRwM3pLXCI7XG59KShQcm90b2NvbHNIYXNoIHx8IChQcm90b2NvbHNIYXNoID0ge30pKTtcblxuLy8gSU1QT1JUQU5UOiBUSElTIEZJTEUgSVMgQVVUTyBHRU5FUkFURUQhIERPIE5PVCBNQU5VQUxMWSBFRElUIE9SIENIRUNLSU4hXG5jb25zdCBWRVJTSU9OID0ge1xuICAgIFwiY29tbWl0SGFzaFwiOiBcIjEzYTEyYWI3Y2Y0NDIwNDM1MjY3NDVkYjJiYmY0ZWYzYjA4OWMzNGFcIixcbiAgICBcInZlcnNpb25cIjogXCIxOS4wLjJcIlxufTtcblxuLyoqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqIEBtb2R1bGUgQHRhcXVpdG8vbG9jYWwtZm9yZ2luZ1xuICovXG5jb25zdCBQUk9UT0NPTF9DVVJSRU5UID0gUHJvdG9jb2xzSGFzaC5Qcm94Zm9yZFk7XG5mdW5jdGlvbiBnZXRDb2RlYyhjb2RlYywgX3Byb3RvKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlcjogZW5jb2RlcnNbY29kZWNdLFxuICAgICAgICBkZWNvZGVyOiAoaGV4KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb25zdW1lciA9IFVpbnQ4QXJyYXlDb25zdW1lci5mcm9tSGV4U3RyaW5nKGhleCk7XG4gICAgICAgICAgICByZXR1cm4gZGVjb2RlcnNbY29kZWNdKGNvbnN1bWVyKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuLy9cbmNsYXNzIExvY2FsRm9yZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm90b2NvbEhhc2ggPSBQUk9UT0NPTF9DVVJSRU5UKSB7XG4gICAgICAgIHRoaXMucHJvdG9jb2xIYXNoID0gcHJvdG9jb2xIYXNoO1xuICAgICAgICB0aGlzLmNvZGVjID0gZ2V0Q29kZWMoQ09ERUMuTUFOQUdFUiwgdGhpcy5wcm90b2NvbEhhc2gpO1xuICAgIH1cbiAgICBmb3JnZShwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgYnJhbmNoVmFsaWRhdGlvbiA9IHZhbGlkYXRlQmxvY2socGFyYW1zLmJyYW5jaCk7XG4gICAgICAgIGlmIChicmFuY2hWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJsb2NrSGFzaEVycm9yKHBhcmFtcy5icmFuY2gsIGludmFsaWREZXRhaWwoYnJhbmNoVmFsaWRhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBwYXJhbXMuY29udGVudHMpIHtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVPcGVyYXRpb25LaW5kKGNvbnRlbnQua2luZCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9wZXJhdGlvbktpbmRFcnJvcihjb250ZW50LmtpbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZGlmZiA9IHZhbGlkYXRlTWlzc2luZ1Byb3BlcnR5KGNvbnRlbnQpO1xuICAgICAgICAgICAgaWYgKGRpZmYubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRlbnQua2luZCA9PT0gJ2RlbGVnYXRpb24nICYmIGRpZmZbMF0gPT09ICdkZWxlZ2F0ZScpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnQua2luZCA9PT0gJ29yaWdpbmF0aW9uJyAmJiBkaWZmWzBdID09PSAnZGVsZWdhdGUnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50LmtpbmQgPT09ICd0cmFuc2FjdGlvbicgJiYgZGlmZlswXSA9PT0gJ3BhcmFtZXRlcnMnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250ZW50LmtpbmQgPT09ICdzZXRfZGVwb3NpdHNfbGltaXQnICYmIGRpZmZbMF0gPT09ICdsaW1pdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRlbnQua2luZCA9PT0gJ3NtYXJ0X3JvbGx1cF9vcmlnaW5hdGUnICYmIGRpZmZbMF0gPT09ICd3aGl0ZWxpc3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25TY2hlbWFFcnJvcihjb250ZW50LCBgbWlzc2luZyBwcm9wZXJ0aWVzIFwiJHtkaWZmLmpvaW4oJywgJyl9XCJgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChkaWZmLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE9wZXJhdGlvblNjaGVtYUVycm9yKGNvbnRlbnQsIGBtaXNzaW5nIHByb3BlcnRpZXMgXCIke2RpZmYuam9pbignLCAnKX1cImApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZvcmdlZCA9IHRoaXMuY29kZWMuZW5jb2RlcihwYXJhbXMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZm9yZ2VkKTtcbiAgICB9XG4gICAgcGFyc2UoaGV4KSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5jb2RlYy5kZWNvZGVyKGhleCkpO1xuICAgIH1cbn1cbmNvbnN0IGxvY2FsRm9yZ2VyID0gbmV3IExvY2FsRm9yZ2VyKCk7XG5cbmV4cG9ydCB7IENPREVDLCBMb2NhbEZvcmdlciwgUHJvdG9jb2xzSGFzaCwgVWludDhBcnJheUNvbnN1bWVyLCBWRVJTSU9OLCBkZWNvZGVycywgZW5jb2RlcnMsIGdldENvZGVjLCBsb2NhbEZvcmdlciwgb3BNYXBwaW5nLCBvcE1hcHBpbmdSZXZlcnNlIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD10YXF1aXRvLWxvY2FsLWZvcmdpbmcuZXM2LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlByZWZpeCIsImJ1ZjJoZXgiLCJiNThjZGVjb2RlIiwicHJlZml4IiwicHJlZml4TGVuZ3RoIiwiYjU4Y2VuY29kZSIsIkludmFsaWRLZXlIYXNoRXJyb3IiLCJpbnZhbGlkRGV0YWlsIiwiVmFsaWRhdGlvblJlc3VsdCIsIkludmFsaWRQdWJsaWNLZXlFcnJvciIsInZhbGlkYXRlQmxvY2siLCJQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3IiLCJJbnZhbGlkSGV4U3RyaW5nRXJyb3IiLCJJbnZhbGlkQWRkcmVzc0Vycm9yIiwiSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yIiwiSW52YWxpZE9wZXJhdGlvbktpbmRFcnJvciIsIkludmFsaWRCbG9ja0hhc2hFcnJvciIsIkJpZ051bWJlciQxIiwiQmlnTnVtYmVyIiwidG9IZXhTdHJpbmciLCJieXRlcyIsInJlZHVjZSIsInN0ciIsImJ5dGUiLCJ0b1N0cmluZyIsInBhZFN0YXJ0IiwicGFkIiwibnVtIiwicGFkZGluZ0xlbiIsIkVOVFJZUE9JTlRfTUFYX0xFTkdUSCIsIkNPREVDIiwib3BNYXBwaW5nIiwib3BNYXBwaW5nUmV2ZXJzZSIsInJlc3VsdCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5Iiwia2luZE1hcHBpbmciLCJraW5kTWFwcGluZ1JldmVyc2UiLCJrZXlOdW0iLCJwYXJzZUludCIsImVudHJ5cG9pbnRNYXBwaW5nIiwiZW50cnlwb2ludE1hcHBpbmdSZXZlcnNlIiwiSW52YWxpZE9wZXJhdGlvblNjaGVtYUVycm9yIiwiY29uc3RydWN0b3IiLCJvcGVyYXRpb24iLCJlcnJvckRldGFpbCIsIm5hbWUiLCJtZXNzYWdlIiwiT3ZlcnNpemVkRW50cnlQb2ludEVycm9yIiwiZW50cnlwb2ludCIsImxlbmd0aCIsIkludmFsaWRCYWxsb3RWYWx1ZUVycm9yIiwiYmFsbG90VmFsdWUiLCJEZWNvZGVCYWxsb3RWYWx1ZUVycm9yIiwiVW5leHBlY3RlZE1pY2hlbHNvblZhbHVlRXJyb3IiLCJ2YWx1ZSIsIk9wZXJhdGlvbkRlY29kaW5nRXJyb3IiLCJPcGVyYXRpb25FbmNvZGluZ0Vycm9yIiwiVW5zdXBwb3J0ZWRPcGVyYXRpb25FcnJvciIsIm9wIiwiVW5zdXBwb3J0ZWRQdm1LaW5kRXJyb3IiLCJwdm0iLCJEZWNvZGVQdm1LaW5kRXJyb3IiLCJJbnZhbGlkU21hcnRSb2xsdXBBZGRyZXNzRXJyb3IiLCJhZGRyZXNzIiwiSW52YWxpZFNtYXJ0Um9sbHVwQ29tbWl0bWVudEhhc2hFcnJvciIsImhhc2giLCJVaW50OEFycmF5Q29uc3VtZXIiLCJmcm9tSGV4U3RyaW5nIiwiaGV4IiwibG93SGV4IiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwiYXJyIiwiVWludDhBcnJheSIsIm1hdGNoIiwibWFwIiwib2Zmc2V0IiwiY29uc3VtZSIsImNvdW50Iiwic3ViQXJyIiwic3ViYXJyYXkiLCJnZXQiLCJpZHgiLCJzbGljZSIsInN0YXJ0IiwiZW5kIiwiaXNQcmltIiwiaXNCeXRlcyIsImlzU3RyaW5nIiwic3RyaW5nIiwiaXNJbnQiLCJpbnQiLCJzY3JpcHRFbmNvZGVyIiwic2NyaXB0IiwiY29kZSIsInZhbHVlRW5jb2RlciIsInN0b3JhZ2UiLCJzY3JpcHREZWNvZGVyIiwiZXh0cmFjdFJlcXVpcmVkTGVuIiwidmFsdWVEZWNvZGVyIiwiQXJyYXkiLCJpc0FycmF5IiwiZW5jb2RlZCIsIngiLCJqb2luIiwibGVuIiwicHJpbUVuY29kZXIiLCJieXRlc0VuY29kZXIiLCJzdHJpbmdFbmNvZGVyIiwiaW50RW5jb2RlciIsIkpTT04iLCJzdHJpbmdpZnkiLCJwcmVhbWJsZSIsImJ5dGVzRGVjb2RlciIsInN0cmluZ0RlY29kZXIiLCJpbnREZWNvZGVyIiwidmFsIiwicmVzdWx0cyIsInB1c2giLCJwcmltRGVjb2RlciIsImJ5dGVzTGVuZ3RoIiwidmFsdWVMZW4iLCJCdWZmZXIiLCJmcm9tIiwic3RyaXBMZW5ndGhQcmVmaXhGcm9tQnl0ZXMiLCJyZXQiLCJ2YWx1ZXMiLCJoZXhMZW5ndGgiLCJwb3NpdGl2ZU1hcmsiLCJiaW5hcnkiLCJyZXBsYWNlIiwic3BsaXR0ZWQiLCJyZXZlcnNlZCIsInJldmVyc2UiLCJudW1IZXgiLCJpIiwiYyIsImhleE51bWJlciIsImlzTm90TGFzdENodW5rTWFzayIsImlzTmVnYXRpdmUiLCJudW1CaW4iLCJ0aW1lcyIsInRvRml4ZWQiLCJoYXNBbm5vdCIsImFubm90cyIsImFyZ3NDb3VudCIsImFyZ3MiLCJNYXRoIiwibWluIiwicHJpbSIsImVuY29kZWRBcmdzIiwiYXJnIiwiZW5jb2RlZEFubm90cyIsImVuY29kZUFubm90cyIsImZsb29yIiwicHJpbVZpZXdEZWNvZGVyIiwiY29tYlBhaXJBcmdzIiwiY29tYlBhaXJBbm5vdHMiLCJkZWNvZGVDb21iUGFpciIsImRlY29kZUFubm90cyIsImZpbGwiLCJhcnJheSIsIm1lcmdlZEFubm90IiwiYW5ub3RMZW4iLCJyZXN0T2ZBbm5vdCIsInJlc3RPZkFubm90SGV4Iiwic3BsaXQiLCJwcmVmaXhFbmNvZGVyIiwicHJlZml4JDEiLCJwcmVmaXhEZWNvZGVyIiwicHJlIiwidHoxRGVjb2RlciIsIlRaMSIsImJyYW5jaERlY29kZXIiLCJCIiwicHVibGljS2V5SGFzaERlY29kZXIiLCJUWjIiLCJUWjMiLCJwdWJsaWNLZXlIYXNoZXNEZWNvZGVyIiwiYm9vbERlY29kZXIiLCJ1bmRlZmluZWQiLCJwdWJsaWNLZXlIYXNoZXMiLCJicmFuY2hFbmNvZGVyIiwidHoxRW5jb2RlciIsImJvb2xFbmNvZGVyIiwiYm9vbCIsInByb3Bvc2FsRW5jb2RlciIsInByb3Bvc2FsIiwiUCIsInByb3Bvc2FsRGVjb2RlciIsInByb3Bvc2Fsc0RlY29kZXIiLCJwcm9wb3NhbHMiLCJwcm9wb3NhbHNFbmNvZGVyIiwiYmFsbG90RW5jb2RlciIsImJhbGxvdCIsImJhbGxvdERlY29kZXIiLCJwdm1LaW5kRW5jb2RlciIsInB2bUtpbmREZWNvZGVyIiwiZGVsZWdhdGVFbmNvZGVyIiwicHVibGljS2V5SGFzaEVuY29kZXIiLCJpbnQzMkVuY29kZXIiLCJTdHJpbmciLCJzaGlmdEJ5IiwiaW50MzJEZWNvZGVyIiwiZmluYWxOdW0iLCJpbnQxNkVuY29kZXIiLCJpbnQxNkRlY29kZXIiLCJkZWxlZ2F0ZURlY29kZXIiLCJoYXNEZWxlZ2F0ZSIsInB1YmtleVByZWZpeCIsInN1YnN0cmluZyIsIlRaNCIsIk5PX1BSRUZJWF9NQVRDSEVEIiwicHVibGljS2V5SGFzaGVzRW5jb2RlciIsInByZXYiLCJjdXJyIiwicHVibGljS2V5RW5jb2RlciIsIkVEUEsiLCJTUFBLIiwiUDJQSyIsIkJMUEsiLCJhZGRyZXNzRW5jb2RlciIsIktUMSIsInNtYXJ0Um9sbHVwQWRkcmVzc0VuY29kZXIiLCJTUjEiLCJzbWFydENvbnRyYWN0QWRkcmVzc0VuY29kZXIiLCJwdWJsaWNLZXlEZWNvZGVyIiwic21hcnRSb2xsdXBDb21taXRtZW50SGFzaEVuY29kZXIiLCJTUkMxIiwiYWRkcmVzc0RlY29kZXIiLCJzbWFydFJvbGx1cEFkZHJlc3NEZWNvZGVyIiwic21hcnRDb250cmFjdEFkZHJlc3NEZWNvZGVyIiwic2NBZGRyZXNzIiwic21hcnRSb2xsdXBDb21taXRtZW50SGFzaERlY29kZXIiLCJ6YXJpdGhFbmNvZGVyIiwibiIsImZuIiwibm4iLCJpc05hTiIsIlR5cGVFcnJvciIsImx0IiwiYiIsIm1vZCIsIm1pbnVzIiwiZGl2aWRlZEJ5IiwicGx1cyIsInphcml0aERlY29kZXIiLCJtb3N0U2lnbmlmaWNhbnRCeXRlIiwidG1wIiwibXVsdGlwbGllZEJ5IiwiZW50cnlwb2ludERlY29kZXIiLCJlbnRyeSIsInBhcmFtZXRlcnNEZWNvZGVyIiwiZW5jb2RlZEVudHJ5cG9pbnQiLCJwYXJhbXMiLCJwYXJhbWV0ZXJzIiwiZW50cnlwb2ludEVuY29kZXIiLCJwYXJhbWV0ZXJzRW5jb2RlciIsInZhbHVlUGFyYW1ldGVyRW5jb2RlciIsInZhbHVlRW5jb2RlZCIsInZhbHVlUGFyYW1ldGVyRGVjb2RlciIsImJsb2NrUGF5bG9hZEhhc2hFbmNvZGVyIiwiVkgiLCJibG9ja1BheWxvYWRIYXNoRGVjb2RlciIsImVudHJ5cG9pbnROYW1lRW5jb2RlciIsImVudHJ5cG9pbnROYW1lRGVjb2RlciIsImJ1cm5MaW1pdEVuY29kZXIiLCJidXJuTGltaXREZWNvZGVyIiwiZGVwb3NpdHNMaW1pdEVuY29kZXIiLCJkZXBvc2l0c0xpbWl0RGVjb2RlciIsInBhZGRlZEJ5dGVzRW5jb2RlciIsInBhZGRpbmdMZW5ndGgiLCJwYWRkZWRCeXRlc0RlY29kZXIiLCJzbWFydFJvbGx1cE1lc3NhZ2VFbmNvZGVyIiwic21hcnRSb2xsdXBNZXNzYWdlRGVjb2RlciIsInZhbHVlQXJyYXkiLCJNYW5hZ2VyT3BlcmF0aW9uU2NoZW1hIiwiYnJhbmNoIiwiQlJBTkNIIiwiY29udGVudHMiLCJPUEVSQVRJT04iLCJBY3RpdmF0aW9uU2NoZW1hIiwicGtoIiwic2VjcmV0IiwiU0VDUkVUIiwiUmV2ZWFsU2NoZW1hIiwic291cmNlIiwiUEtIIiwiZmVlIiwiWkFSSVRIIiwiY291bnRlciIsImdhc19saW1pdCIsInN0b3JhZ2VfbGltaXQiLCJwdWJsaWNfa2V5IiwiUFVCTElDX0tFWSIsIkRlbGVnYXRpb25TY2hlbWEiLCJkZWxlZ2F0ZSIsIkRFTEVHQVRFIiwiVHJhbnNhY3Rpb25TY2hlbWEiLCJhbW91bnQiLCJkZXN0aW5hdGlvbiIsIkFERFJFU1MiLCJQQVJBTUVURVJTIiwiT3JpZ2luYXRpb25TY2hlbWEiLCJiYWxhbmNlIiwiU0NSSVBUIiwiQmFsbG90U2NoZW1hIiwicGVyaW9kIiwiSU5UMzIiLCJQUk9QT1NBTCIsIkJBTExPVF9TVEFURU1FTlQiLCJBdHRlc3RhdGlvblNjaGVtYSIsInNsb3QiLCJJTlQxNiIsImxldmVsIiwicm91bmQiLCJibG9ja19wYXlsb2FkX2hhc2giLCJCTE9DS19QQVlMT0FEX0hBU0giLCJFbmRvcnNlbWVudFNjaGVtYSIsIlNlZWROb25jZVJldmVsYXRpb25TY2hlbWEiLCJub25jZSIsIlJBVyIsIlByb3Bvc2Fsc1NjaGVtYSIsIlBST1BPU0FMX0FSUiIsIlJlZ2lzdGVyR2xvYmFsQ29uc3RhbnRTY2hlbWEiLCJWQUxVRSIsIlRyYW5zZmVyVGlja2V0U2NoZW1hIiwidGlja2V0X2NvbnRlbnRzIiwidGlja2V0X3R5IiwidGlja2V0X3RpY2tldGVyIiwidGlja2V0X2Ftb3VudCIsIkVOVFJZUE9JTlQiLCJJbmNyZWFzZVBhaWRTdG9yYWdlU2NoZW1hIiwiU01BUlRfQ09OVFJBQ1RfQUREUkVTUyIsIlVwZGF0ZUNvbnNlbnN1c0tleVNjaGVtYSIsInBrIiwiRHJhaW5EZWxlZ2F0ZVNjaGVtYSIsImNvbnNlbnN1c19rZXkiLCJTZXREZXBvc2l0c0xpbWl0U2NoZW1hIiwibGltaXQiLCJERVBPU0lUU19MSU1JVCIsIlNtYXJ0Um9sbHVwT3JpZ2luYXRlU2NoZW1hIiwicHZtX2tpbmQiLCJQVk1fS0lORCIsImtlcm5lbCIsIlBBRERFRF9CWVRFUyIsInBhcmFtZXRlcnNfdHkiLCJ3aGl0ZWxpc3QiLCJQS0hfQVJSIiwiU21hcnRSb2xsdXBBZGRNZXNzYWdlc1NjaGVtYSIsIlNNQVJUX1JPTExVUF9NRVNTQUdFIiwiU21hcnRSb2xsdXBFeGVjdXRlT3V0Ym94TWVzc2FnZVNjaGVtYSIsInJvbGx1cCIsIlNNQVJUX1JPTExVUF9BRERSRVNTIiwiY2VtZW50ZWRfY29tbWl0bWVudCIsIlNNQVJUX1JPTExVUF9DT01NSVRNRU5UX0hBU0giLCJvdXRwdXRfcHJvb2YiLCJGYWlsaW5nTm9vcFNjaGVtYSIsImFyYml0cmFyeSIsIm9wZXJhdGlvbkVuY29kZXIiLCJlbmNvZGVycyIsImtpbmQiLCJvcGVyYXRpb25EZWNvZGVyIiwiZGVjb2RlcnMiLCJvcGVyYXRpb25OYW1lIiwiZGVjb2RlZE9iaiIsImFzc2lnbiIsInNjaGVtYUVuY29kZXIiLCJzY2hlbWEiLCJ2YWx1ZVRvRW5jb2RlIiwiZW5jb2RlciIsInByZXZCeXRlcyIsImN1cnJlbnQiLCJzY2hlbWFEZWNvZGVyIiwiZGVjb2RlciIsImRlY29kZWQiLCJsYXN0TGVuZ3RoIiwiQlVSTl9MSU1JVCIsIk9QX0FDVElWQVRFX0FDQ09VTlQiLCJPUF9GQUlMSU5HX05PT1AiLCJPUF9ERUxFR0FUSU9OIiwiT1BfVFJBTlNBQ1RJT04iLCJPUF9PUklHSU5BVElPTiIsIk9QX0JBTExPVCIsIk9QX0FUVEVTVEFUSU9OIiwiT1BfRU5ET1JTRU1FTlQiLCJPUF9TRUVEX05PTkNFX1JFVkVMQVRJT04iLCJPUF9QUk9QT1NBTFMiLCJPUF9SRVZFQUwiLCJPUF9SRUdJU1RFUl9HTE9CQUxfQ09OU1RBTlQiLCJPUF9UUkFOU0ZFUl9USUNLRVQiLCJPUF9JTkNSRUFTRV9QQUlEX1NUT1JBR0UiLCJPUF9VUERBVEVfQ09OU0VOU1VTX0tFWSIsIk9QX0RSQUlOX0RFTEVHQVRFIiwiT1BfU01BUlRfUk9MTFVQX09SSUdJTkFURSIsIk9QX1NNQVJUX1JPTExVUF9BRERfTUVTU0FHRVMiLCJPUF9TTUFSVF9ST0xMVVBfRVhFQ1VURV9PVVRCT1hfTUVTU0FHRSIsIk1BTkFHRVIiLCJPUF9TRVRfREVQT1NJVFNfTElNSVQiLCJPcGVyYXRpb25LaW5kTWFwcGluZyIsImFjdGl2YXRlX2FjY291bnQiLCJyZXZlYWwiLCJkZWxlZ2F0aW9uIiwidHJhbnNhY3Rpb24iLCJvcmlnaW5hdGlvbiIsImF0dGVzdGF0aW9uIiwiZW5kb3JzZW1lbnQiLCJzZWVkX25vbmNlX3JldmVsYXRpb24iLCJyZWdpc3Rlcl9nbG9iYWxfY29uc3RhbnQiLCJ0cmFuc2Zlcl90aWNrZXQiLCJpbmNyZWFzZV9wYWlkX3N0b3JhZ2UiLCJ1cGRhdGVfY29uc2Vuc3VzX2tleSIsImRyYWluX2RlbGVnYXRlIiwic2V0X2RlcG9zaXRzX2xpbWl0Iiwic21hcnRfcm9sbHVwX29yaWdpbmF0ZSIsInNtYXJ0X3JvbGx1cF9hZGRfbWVzc2FnZXMiLCJzbWFydF9yb2xsdXBfZXhlY3V0ZV9vdXRib3hfbWVzc2FnZSIsImZhaWxpbmdfbm9vcCIsImdldEFycmF5RGlmZmVyZW5jZSIsImFycjEiLCJhcnIyIiwiZmlsdGVyIiwiaW5jbHVkZXMiLCJkZWxldGVBcnJheUVsZW1lbnRCeVZhbHVlIiwiaXRlbSIsImUiLCJ2YWxpZGF0ZU9wZXJhdGlvbktpbmQiLCJvcEtpbmQiLCJvcEtpbmRMaXN0IiwidmFsaWRhdGVNaXNzaW5nUHJvcGVydHkiLCJvcGVyYXRpb25Db250ZW50IiwiY2xlYW5LZXlzIiwic2NoZW1hS2V5cyIsIlByb3RvY29sc0hhc2giLCJWRVJTSU9OIiwiUFJPVE9DT0xfQ1VSUkVOVCIsIlByb3hmb3JkWSIsImdldENvZGVjIiwiY29kZWMiLCJfcHJvdG8iLCJjb25zdW1lciIsIkxvY2FsRm9yZ2VyIiwicHJvdG9jb2xIYXNoIiwiZm9yZ2UiLCJicmFuY2hWYWxpZGF0aW9uIiwiVkFMSUQiLCJjb250ZW50IiwiZGlmZiIsImZvcmdlZCIsIlByb21pc2UiLCJyZXNvbHZlIiwicGFyc2UiLCJsb2NhbEZvcmdlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/local-forging/dist/taquito-local-forging.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es6.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es6.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Contract: () => (/* binding */ Contract),\n/* harmony export */   DefaultProtocol: () => (/* binding */ DefaultProtocol),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   MacroError: () => (/* binding */ MacroError),\n/* harmony export */   MichelineParseError: () => (/* binding */ MichelineParseError),\n/* harmony export */   MichelsonError: () => (/* binding */ MichelsonError),\n/* harmony export */   MichelsonInstructionError: () => (/* binding */ MichelsonInstructionError),\n/* harmony export */   MichelsonTypeError: () => (/* binding */ MichelsonTypeError),\n/* harmony export */   MichelsonValidationError: () => (/* binding */ MichelsonValidationError),\n/* harmony export */   Parser: () => (/* binding */ Parser),\n/* harmony export */   ProtoGreaterOrEqual: () => (/* binding */ ProtoGreaterOrEqual),\n/* harmony export */   ProtoInferiorTo: () => (/* binding */ ProtoInferiorTo),\n/* harmony export */   Protocol: () => (/* binding */ Protocol),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   assertContractValid: () => (/* binding */ assertContractValid),\n/* harmony export */   assertDataListIfAny: () => (/* binding */ assertDataListIfAny),\n/* harmony export */   assertDataValid: () => (/* binding */ assertDataValid),\n/* harmony export */   assertMichelsonBigMapStorableType: () => (/* binding */ assertMichelsonBigMapStorableType),\n/* harmony export */   assertMichelsonComparableType: () => (/* binding */ assertMichelsonComparableType),\n/* harmony export */   assertMichelsonContract: () => (/* binding */ assertMichelsonContract),\n/* harmony export */   assertMichelsonData: () => (/* binding */ assertMichelsonData),\n/* harmony export */   assertMichelsonInstruction: () => (/* binding */ assertMichelsonInstruction),\n/* harmony export */   assertMichelsonPackableType: () => (/* binding */ assertMichelsonPackableType),\n/* harmony export */   assertMichelsonPassableType: () => (/* binding */ assertMichelsonPassableType),\n/* harmony export */   assertMichelsonPushableType: () => (/* binding */ assertMichelsonPushableType),\n/* harmony export */   assertMichelsonStorableType: () => (/* binding */ assertMichelsonStorableType),\n/* harmony export */   assertMichelsonType: () => (/* binding */ assertMichelsonType),\n/* harmony export */   assertTypeAnnotationsValid: () => (/* binding */ assertTypeAnnotationsValid),\n/* harmony export */   assertTypesEqual: () => (/* binding */ assertTypesEqual),\n/* harmony export */   assertViewNameValid: () => (/* binding */ assertViewNameValid),\n/* harmony export */   contractEntryPoint: () => (/* binding */ contractEntryPoint),\n/* harmony export */   contractEntryPoints: () => (/* binding */ contractEntryPoints),\n/* harmony export */   contractSection: () => (/* binding */ contractSection),\n/* harmony export */   contractViews: () => (/* binding */ contractViews),\n/* harmony export */   decodeAddressBytes: () => (/* binding */ decodeAddressBytes),\n/* harmony export */   decodePublicKeyBytes: () => (/* binding */ decodePublicKeyBytes),\n/* harmony export */   decodePublicKeyHashBytes: () => (/* binding */ decodePublicKeyHashBytes),\n/* harmony export */   dummyContract: () => (/* binding */ dummyContract),\n/* harmony export */   emitMicheline: () => (/* binding */ emitMicheline),\n/* harmony export */   formatError: () => (/* binding */ formatError),\n/* harmony export */   formatStack: () => (/* binding */ formatStack),\n/* harmony export */   functionType: () => (/* binding */ functionType),\n/* harmony export */   instructionIDs: () => (/* binding */ instructionIDs),\n/* harmony export */   isContractValid: () => (/* binding */ isContractValid),\n/* harmony export */   isDataValid: () => (/* binding */ isDataValid),\n/* harmony export */   isInstruction: () => (/* binding */ isInstruction),\n/* harmony export */   isMichelsonCode: () => (/* binding */ isMichelsonCode),\n/* harmony export */   isMichelsonData: () => (/* binding */ isMichelsonData),\n/* harmony export */   isMichelsonError: () => (/* binding */ isMichelsonError),\n/* harmony export */   isMichelsonScript: () => (/* binding */ isMichelsonScript),\n/* harmony export */   isMichelsonType: () => (/* binding */ isMichelsonType),\n/* harmony export */   isTypeAnnotationsValid: () => (/* binding */ isTypeAnnotationsValid),\n/* harmony export */   isTypeEqual: () => (/* binding */ isTypeEqual),\n/* harmony export */   packData: () => (/* binding */ packData),\n/* harmony export */   packDataBytes: () => (/* binding */ packDataBytes),\n/* harmony export */   refContract: () => (/* binding */ refContract),\n/* harmony export */   sourceReference: () => (/* binding */ sourceReference),\n/* harmony export */   traceDumpFunc: () => (/* binding */ traceDumpFunc),\n/* harmony export */   unpackData: () => (/* binding */ unpackData),\n/* harmony export */   unpackDataBytes: () => (/* binding */ unpackDataBytes)\n/* harmony export */ });\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n\n// Michelson abstract syntax tree types https://tezos.gitlab.io/whitedoc/michelson.html#concrete-syntax\nconst sourceReference = Symbol(\"source_reference\");\n/**\n *  @category Error\n *  @description Error that indicates a failure when performing the scan step when parsing Michelson\n */ class ScanError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    constructor(src, idx, message){\n        super();\n        this.src = src;\n        this.idx = idx;\n        this.message = message;\n        this.name = \"ScanError\";\n    }\n}\nvar Literal;\n(function(Literal) {\n    Literal[Literal[\"Comment\"] = 0] = \"Comment\";\n    Literal[Literal[\"Number\"] = 1] = \"Number\";\n    Literal[Literal[\"String\"] = 2] = \"String\";\n    Literal[Literal[\"Bytes\"] = 3] = \"Bytes\";\n    Literal[Literal[\"Ident\"] = 4] = \"Ident\";\n})(Literal || (Literal = {}));\nconst isSpace = new RegExp(\"\\\\s\");\nconst isIdentStart = new RegExp(\"[:@%_A-Za-z]\");\nconst isIdent = new RegExp(\"[@%_\\\\.A-Za-z0-9]\");\nconst isDigit = new RegExp(\"[0-9]\");\nconst isHex = new RegExp(\"[0-9a-fA-F]\");\nfunction* scan(src, scanComments = false) {\n    let i = 0;\n    while(i < src.length){\n        // Skip space\n        while(i < src.length && isSpace.test(src[i])){\n            i++;\n        }\n        if (i === src.length) {\n            return;\n        }\n        const s = src[i];\n        const start = i;\n        if (isIdentStart.test(s)) {\n            // Identifier\n            i++;\n            while(i < src.length && isIdent.test(src[i])){\n                i++;\n            }\n            yield {\n                t: Literal.Ident,\n                v: src.slice(start, i),\n                first: start,\n                last: i\n            };\n        } else if (src.length - i > 1 && src.substring(i, i + 2) === \"0x\") {\n            // Bytes\n            i += 2;\n            while(i < src.length && isHex.test(src[i])){\n                i++;\n            }\n            if ((i - start & 1) !== 0) {\n                throw new ScanError(src, i, \"Bytes literal length is expected to be power of two\");\n            }\n            yield {\n                t: Literal.Bytes,\n                v: src.slice(start, i),\n                first: start,\n                last: i\n            };\n        } else if (isDigit.test(s) || s === \"-\") {\n            // Number\n            if (s === \"-\") {\n                i++;\n            }\n            const ii = i;\n            while(i < src.length && isDigit.test(src[i])){\n                i++;\n            }\n            if (ii === i) {\n                throw new ScanError(src, i, \"Number literal is too short\");\n            }\n            yield {\n                t: Literal.Number,\n                v: src.slice(start, i),\n                first: start,\n                last: i\n            };\n        } else if (s === '\"') {\n            // String\n            i++;\n            let esc = false;\n            for(; i < src.length && (esc || src[i] !== '\"'); i++){\n                if (!esc && src[i] === \"\\\\\") {\n                    esc = true;\n                } else {\n                    esc = false;\n                }\n            }\n            if (i === src.length) {\n                throw new ScanError(src, i, \"Unterminated string literal\");\n            }\n            i++;\n            yield {\n                t: Literal.String,\n                v: src.slice(start, i),\n                first: start,\n                last: i\n            };\n        } else if (s === \"#\") {\n            // Comment\n            i++;\n            while(i < src.length && src[i] !== \"\\n\"){\n                i++;\n            }\n            if (scanComments) {\n                yield {\n                    t: Literal.Comment,\n                    v: src.slice(start, i),\n                    first: start,\n                    last: i\n                };\n            }\n        } else if (src.length - i > 1 && src.substring(i, i + 2) === \"/*\") {\n            // C style comment\n            i += 2;\n            while(i < src.length && !(src.length - i > 1 && src.substring(i, i + 2) === \"*/\")){\n                i++;\n            }\n            if (i === src.length) {\n                throw new ScanError(src, i, \"Unterminated C style comment\");\n            }\n            i += 2;\n            if (scanComments) {\n                yield {\n                    t: Literal.Comment,\n                    v: src.slice(start, i),\n                    first: start,\n                    last: i\n                };\n            }\n        } else if (s === \"(\" || s === \")\" || s === \"{\" || s === \"}\" || s === \";\") {\n            i++;\n            yield {\n                t: s,\n                v: s,\n                first: start,\n                last: i\n            };\n        } else {\n            throw new ScanError(src, i, `Invalid character at offset ${i}: \\`${s}'`);\n        }\n    }\n}\n// Michelson types\nconst refContract = Symbol(\"ref_contract\");\nvar Protocol;\n(function(Protocol) {\n    Protocol[\"Ps9mPmXa\"] = \"Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P\";\n    Protocol[\"PtCJ7pwo\"] = \"PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY\";\n    Protocol[\"PsYLVpVv\"] = \"PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt\";\n    Protocol[\"PsddFKi3\"] = \"PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP\";\n    Protocol[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n    Protocol[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n    Protocol[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n    Protocol[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n    Protocol[\"PsDELPH1\"] = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\";\n    Protocol[\"PtEdoTez\"] = \"PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq\";\n    Protocol[\"PtEdo2Zk\"] = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\";\n    Protocol[\"PsFLorena\"] = \"PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i\";\n    Protocol[\"PtGRANADs\"] = \"PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV\";\n    Protocol[\"PtHangzH\"] = \"PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r\";\n    Protocol[\"PtHangz2\"] = \"PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx\";\n    Protocol[\"PsiThaCa\"] = \"PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP\";\n    Protocol[\"Psithaca2\"] = \"Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A\";\n    Protocol[\"PtJakarta\"] = \"PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw\";\n    Protocol[\"PtJakart2\"] = \"PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY\";\n    Protocol[\"PtKathman\"] = \"PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg\";\n    Protocol[\"PtLimaPtL\"] = \"PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW\";\n    Protocol[\"PtMumbaii\"] = \"PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc\";\n    Protocol[\"PtMumbai2\"] = \"PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1\";\n    Protocol[\"PtNairobi\"] = \"PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf\";\n    Protocol[\"ProxfordY\"] = \"ProxfordYmVfjWnRcgjWH36fW6PArwqykTFzotUxRs6gmTcZDuH\";\n    Protocol[\"ProtoALpha\"] = \"ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK\";\n})(Protocol || (Protocol = {}));\nconst DefaultProtocol = Protocol.Psithaca2;\nconst protoLevel = {\n    Ps9mPmXaRzmzk35gbAYNCAw6UXdE2qoABTHbN2oEEc1qM7CwT9P: 0,\n    PtCJ7pwoxe8JasnHY8YonnLYjcVHmhiARPJvqcC6VfHT5s8k8sY: 1,\n    PsYLVpVvgbLhAhoqAkMFUo6gudkJ9weNXhUYCiLDzcUpFpkk8Wt: 2,\n    PsddFKi32cMJ2qPjf43Qv5GDWLDPZb3T3bF6fLKiF5HtvHNU7aP: 3,\n    Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd: 4,\n    PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU: 5,\n    PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS: 5,\n    PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb: 6,\n    PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo: 7,\n    PtEdoTezd3RHSC31mpxxo1npxFjoWWcFgQtxapi51Z8TLu6v6Uq: 8,\n    PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA: 8,\n    PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i: 9,\n    PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV: 10,\n    PtHangzHogokSuiMHemCuowEavgYTP8J5qQ9fQS793MHYFpCY3r: 11,\n    PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx: 11,\n    PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP: 12,\n    Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A: 12,\n    PtJakartaiDz69SfDDLXJSiuZqTSeSKRDbKVZC8MNzJnvRjvnGw: 13,\n    PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY: 13,\n    PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg: 14,\n    PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW: 15,\n    PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc: 16,\n    PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1: 16,\n    PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf: 17,\n    ProxfordYmVfjWnRcgjWH36fW6PArwqykTFzotUxRs6gmTcZDuH: 19,\n    ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK: 20\n};\nfunction ProtoGreaterOrEqual(a, b) {\n    return protoLevel[a] >= protoLevel[b];\n}\nfunction ProtoInferiorTo(a, b) {\n    return protoLevel[a] < protoLevel[b];\n}\n/**\n *  @category Error\n *  @description Error that indicates macros failed to be expanded\n */ class MacroError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    constructor(prim, message){\n        super();\n        this.prim = prim;\n        this.message = message;\n        this.name = \"MacroError\";\n    }\n}\nfunction assertArgs$1(ex, n) {\n    var _a, _b;\n    if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects ${n} arguments, was given ${(_b = ex.args) === null || _b === void 0 ? void 0 : _b.length}`);\n}\nfunction assertNoAnnots(ex) {\n    if (ex.annots === undefined) {\n        return true;\n    }\n    throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${ex.annots}`);\n}\nfunction assertIntArg(ex, arg) {\n    if (\"int\" in arg) {\n        return true;\n    }\n    throw new MacroError(ex, `macro ${ex.prim} expects int argument`);\n}\nfunction parsePairUnpairExpr(p, expr, annotations, agg) {\n    let i = 0;\n    let ai = 0;\n    const ann = [\n        null,\n        null\n    ];\n    // Left expression\n    let lexpr;\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    let c = expr[i++];\n    switch(c){\n        case \"P\":\n            {\n                const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n                lexpr = r;\n                i += n;\n                ai += an;\n                break;\n            }\n        case \"A\":\n            if (ai !== annotations.length) {\n                ann[0] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n    // Right expression\n    let rexpr;\n    if (i === expr.length) {\n        throw new MacroError(p, `unexpected end: ${p.prim}`);\n    }\n    c = expr[i++];\n    switch(c){\n        case \"P\":\n            {\n                const { r, n, an } = parsePairUnpairExpr(p, expr.slice(i), annotations.slice(ai), agg);\n                rexpr = r.map(([v, a])=>[\n                        v + 1,\n                        a\n                    ]);\n                i += n;\n                ai += an;\n                break;\n            }\n        case \"I\":\n            if (ai !== annotations.length) {\n                ann[1] = annotations[ai++];\n            }\n            break;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n    return {\n        r: agg(lexpr, rexpr, [\n            0,\n            ann\n        ]),\n        n: i,\n        an: ai\n    };\n}\nfunction parseSetMapCadr(p, expr, vann, term) {\n    const c = expr[0];\n    switch(c){\n        case \"A\":\n            return expr.length > 1 ? [\n                {\n                    prim: \"DUP\"\n                },\n                {\n                    prim: \"DIP\",\n                    args: [\n                        [\n                            {\n                                prim: \"CAR\",\n                                annots: [\n                                    \"@%%\"\n                                ]\n                            },\n                            parseSetMapCadr(p, expr.slice(1), [], term)\n                        ]\n                    ]\n                },\n                {\n                    prim: \"CDR\",\n                    annots: [\n                        \"@%%\"\n                    ]\n                },\n                {\n                    prim: \"SWAP\"\n                },\n                {\n                    prim: \"PAIR\",\n                    annots: [\n                        \"%@\",\n                        \"%@\",\n                        ...vann\n                    ]\n                }\n            ] : term.a;\n        case \"D\":\n            return expr.length > 1 ? [\n                {\n                    prim: \"DUP\"\n                },\n                {\n                    prim: \"DIP\",\n                    args: [\n                        [\n                            {\n                                prim: \"CDR\",\n                                annots: [\n                                    \"@%%\"\n                                ]\n                            },\n                            parseSetMapCadr(p, expr.slice(1), [], term)\n                        ]\n                    ]\n                },\n                {\n                    prim: \"CAR\",\n                    annots: [\n                        \"@%%\"\n                    ]\n                },\n                {\n                    prim: \"PAIR\",\n                    annots: [\n                        \"%@\",\n                        \"%@\",\n                        ...vann\n                    ]\n                }\n            ] : term.d;\n        default:\n            throw new MacroError(p, `${p.prim}: unexpected character: ${c}`);\n    }\n}\nfunction trimLast(a, v) {\n    let l = a.length;\n    while(l > 0 && a[l - 1] === v){\n        l--;\n    }\n    return a.slice(0, l);\n}\nfunction filterAnnotations(a) {\n    const fields = [];\n    const rest = [];\n    if (a !== undefined) {\n        for (const v of a){\n            (v.length !== 0 && v[0] === \"%\" ? fields : rest).push(v);\n        }\n    }\n    return {\n        fields,\n        rest\n    };\n}\nfunction mkPrim({ prim, annots, args }) {\n    return Object.assign(Object.assign({\n        prim\n    }, annots && {\n        annots\n    }), args && {\n        args\n    });\n}\nconst pairRe = /^P[PAI]{3,}R$/;\nconst unpairRe = /^UNP[PAI]{2,}R$/;\nconst cadrRe = /^C[AD]{2,}R$/;\nconst setCadrRe = /^SET_C[AD]+R$/;\nconst mapCadrRe = /^MAP_C[AD]+R$/;\nconst diipRe = /^DI{2,}P$/;\nconst duupRe = /^DU+P$/;\nfunction expandMacros(ex, opt) {\n    const proto = (opt === null || opt === void 0 ? void 0 : opt.protocol) || DefaultProtocol;\n    function mayRename(annots) {\n        return annots !== undefined ? [\n            {\n                prim: \"RENAME\",\n                annots\n            }\n        ] : [];\n    }\n    switch(ex.prim){\n        // Compare\n        case \"CMPEQ\":\n        case \"CMPNEQ\":\n        case \"CMPLT\":\n        case \"CMPGT\":\n        case \"CMPLE\":\n        case \"CMPGE\":\n            if (assertArgs$1(ex, 0)) {\n                return [\n                    {\n                        prim: \"COMPARE\"\n                    },\n                    mkPrim({\n                        prim: ex.prim.slice(3),\n                        annots: ex.annots\n                    })\n                ];\n            }\n            break;\n        case \"IFEQ\":\n        case \"IFNEQ\":\n        case \"IFLT\":\n        case \"IFGT\":\n        case \"IFLE\":\n        case \"IFGE\":\n            if (assertArgs$1(ex, 2)) {\n                return [\n                    {\n                        prim: ex.prim.slice(2)\n                    },\n                    mkPrim({\n                        prim: \"IF\",\n                        annots: ex.annots,\n                        args: ex.args\n                    })\n                ];\n            }\n            break;\n        case \"IFCMPEQ\":\n        case \"IFCMPNEQ\":\n        case \"IFCMPLT\":\n        case \"IFCMPGT\":\n        case \"IFCMPLE\":\n        case \"IFCMPGE\":\n            if (assertArgs$1(ex, 2)) {\n                return [\n                    {\n                        prim: \"COMPARE\"\n                    },\n                    {\n                        prim: ex.prim.slice(5)\n                    },\n                    mkPrim({\n                        prim: \"IF\",\n                        annots: ex.annots,\n                        args: ex.args\n                    })\n                ];\n            }\n            break;\n        // Fail\n        case \"FAIL\":\n            if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    {\n                        prim: \"UNIT\"\n                    },\n                    {\n                        prim: \"FAILWITH\"\n                    }\n                ];\n            }\n            break;\n        // Assertion macros\n        case \"ASSERT\":\n            if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    {\n                        prim: \"IF\",\n                        args: [\n                            [],\n                            [\n                                [\n                                    {\n                                        prim: \"UNIT\"\n                                    },\n                                    {\n                                        prim: \"FAILWITH\"\n                                    }\n                                ]\n                            ]\n                        ]\n                    }\n                ];\n            }\n            break;\n        case \"ASSERT_EQ\":\n        case \"ASSERT_NEQ\":\n        case \"ASSERT_LT\":\n        case \"ASSERT_GT\":\n        case \"ASSERT_LE\":\n        case \"ASSERT_GE\":\n            if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    {\n                        prim: ex.prim.slice(7)\n                    },\n                    {\n                        prim: \"IF\",\n                        args: [\n                            [],\n                            [\n                                [\n                                    {\n                                        prim: \"UNIT\"\n                                    },\n                                    {\n                                        prim: \"FAILWITH\"\n                                    }\n                                ]\n                            ]\n                        ]\n                    }\n                ];\n            }\n            break;\n        case \"ASSERT_CMPEQ\":\n        case \"ASSERT_CMPNEQ\":\n        case \"ASSERT_CMPLT\":\n        case \"ASSERT_CMPGT\":\n        case \"ASSERT_CMPLE\":\n        case \"ASSERT_CMPGE\":\n            if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    [\n                        {\n                            prim: \"COMPARE\"\n                        },\n                        {\n                            prim: ex.prim.slice(10)\n                        }\n                    ],\n                    {\n                        prim: \"IF\",\n                        args: [\n                            [],\n                            [\n                                [\n                                    {\n                                        prim: \"UNIT\"\n                                    },\n                                    {\n                                        prim: \"FAILWITH\"\n                                    }\n                                ]\n                            ]\n                        ]\n                    }\n                ];\n            }\n            break;\n        case \"ASSERT_NONE\":\n            if (assertArgs$1(ex, 0) && assertNoAnnots(ex)) {\n                return [\n                    {\n                        prim: \"IF_NONE\",\n                        args: [\n                            [],\n                            [\n                                [\n                                    {\n                                        prim: \"UNIT\"\n                                    },\n                                    {\n                                        prim: \"FAILWITH\"\n                                    }\n                                ]\n                            ]\n                        ]\n                    }\n                ];\n            }\n            break;\n        case \"ASSERT_SOME\":\n            if (assertArgs$1(ex, 0)) {\n                return [\n                    {\n                        prim: \"IF_NONE\",\n                        args: [\n                            [\n                                [\n                                    {\n                                        prim: \"UNIT\"\n                                    },\n                                    {\n                                        prim: \"FAILWITH\"\n                                    }\n                                ]\n                            ],\n                            mayRename(ex.annots)\n                        ]\n                    }\n                ];\n            }\n            break;\n        case \"ASSERT_LEFT\":\n            if (assertArgs$1(ex, 0)) {\n                return [\n                    {\n                        prim: \"IF_LEFT\",\n                        args: [\n                            mayRename(ex.annots),\n                            [\n                                [\n                                    {\n                                        prim: \"UNIT\"\n                                    },\n                                    {\n                                        prim: \"FAILWITH\"\n                                    }\n                                ]\n                            ]\n                        ]\n                    }\n                ];\n            }\n            break;\n        case \"ASSERT_RIGHT\":\n            if (assertArgs$1(ex, 0)) {\n                return [\n                    {\n                        prim: \"IF_LEFT\",\n                        args: [\n                            [\n                                [\n                                    {\n                                        prim: \"UNIT\"\n                                    },\n                                    {\n                                        prim: \"FAILWITH\"\n                                    }\n                                ]\n                            ],\n                            mayRename(ex.annots)\n                        ]\n                    }\n                ];\n            }\n            break;\n        // Syntactic conveniences\n        case \"IF_SOME\":\n            if (assertArgs$1(ex, 2)) {\n                return [\n                    mkPrim({\n                        prim: \"IF_NONE\",\n                        annots: ex.annots,\n                        args: [\n                            ex.args[1],\n                            ex.args[0]\n                        ]\n                    })\n                ];\n            }\n            break;\n        case \"IF_RIGHT\":\n            if (assertArgs$1(ex, 2)) {\n                return [\n                    mkPrim({\n                        prim: \"IF_LEFT\",\n                        annots: ex.annots,\n                        args: [\n                            ex.args[1],\n                            ex.args[0]\n                        ]\n                    })\n                ];\n            }\n            break;\n        // CAR/CDR n\n        case \"CAR\":\n        case \"CDR\":\n            if (ex.args !== undefined) {\n                if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {\n                    const n = parseInt(ex.args[0].int, 10);\n                    return mkPrim({\n                        prim: \"GET\",\n                        args: [\n                            {\n                                int: ex.prim === \"CAR\" ? String(n * 2 + 1) : String(n * 2)\n                            }\n                        ],\n                        annots: ex.annots\n                    });\n                }\n            } else {\n                return ex;\n            }\n    }\n    // More syntactic conveniences\n    // PAPPAIIR macro\n    if (pairRe.test(ex.prim)) {\n        if (assertArgs$1(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(1), fields, (l, r, top)=>[\n                    ...l || [],\n                    ...r || [],\n                    top\n                ]);\n            return r.map(([v, a], i)=>{\n                const ann = [\n                    ...trimLast(a, null).map((v)=>v === null ? \"%\" : v),\n                    ...v === 0 && i === r.length - 1 ? rest : []\n                ];\n                const leaf = mkPrim({\n                    prim: \"PAIR\",\n                    annots: ann.length !== 0 ? ann : undefined\n                });\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [\n                        [\n                            leaf\n                        ]\n                    ] : [\n                        {\n                            int: String(v)\n                        },\n                        [\n                            leaf\n                        ]\n                    ]\n                };\n            });\n        }\n    }\n    // UNPAPPAIIR macro\n    if (unpairRe.test(ex.prim)) {\n        if (ProtoInferiorTo(proto, Protocol.PtEdo2Zk) && assertArgs$1(ex, 0)) {\n            const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), ex.annots || [], (l, r, top)=>[\n                    top,\n                    ...r || [],\n                    ...l || []\n                ]);\n            return r.map(([v, a])=>{\n                const leaf = [\n                    {\n                        prim: \"DUP\"\n                    },\n                    mkPrim({\n                        prim: \"CAR\",\n                        annots: a[0] !== null ? [\n                            a[0]\n                        ] : undefined\n                    }),\n                    {\n                        prim: \"DIP\",\n                        args: [\n                            [\n                                mkPrim({\n                                    prim: \"CDR\",\n                                    annots: a[1] !== null ? [\n                                        a[1]\n                                    ] : undefined\n                                })\n                            ]\n                        ]\n                    }\n                ];\n                return v === 0 ? leaf : {\n                    prim: \"DIP\",\n                    args: v === 1 ? [\n                        [\n                            leaf\n                        ]\n                    ] : [\n                        {\n                            int: String(v)\n                        },\n                        [\n                            leaf\n                        ]\n                    ]\n                };\n            });\n        } else {\n            if (ex.prim === \"UNPAIR\") {\n                return ex;\n            }\n            if (assertArgs$1(ex, 0)) {\n                // 008_edo: annotations are deprecated\n                const { r } = parsePairUnpairExpr(ex, ex.prim.slice(3), [], (l, r, top)=>[\n                        top,\n                        ...r || [],\n                        ...l || []\n                    ]);\n                return r.map(([v])=>{\n                    const leaf = mkPrim({\n                        prim: \"UNPAIR\"\n                    });\n                    return v === 0 ? leaf : {\n                        prim: \"DIP\",\n                        args: v === 1 ? [\n                            [\n                                leaf\n                            ]\n                        ] : [\n                            {\n                                int: String(v)\n                            },\n                            [\n                                leaf\n                            ]\n                        ]\n                    };\n                });\n            }\n        }\n    }\n    // C[AD]+R macro\n    if (cadrRe.test(ex.prim)) {\n        if (assertArgs$1(ex, 0)) {\n            const ch = [\n                ...ex.prim.slice(1, ex.prim.length - 1)\n            ];\n            return ch.map((c, i)=>{\n                const ann = i === ch.length - 1 ? ex.annots : undefined;\n                switch(c){\n                    case \"A\":\n                        return mkPrim({\n                            prim: \"CAR\",\n                            annots: ann\n                        });\n                    case \"D\":\n                        return mkPrim({\n                            prim: \"CDR\",\n                            annots: ann\n                        });\n                    default:\n                        throw new MacroError(ex, `unexpected character: ${c}`);\n                }\n            });\n        }\n    }\n    // SET_C[AD]+R macro\n    if (setCadrRe.test(ex.prim)) {\n        if (assertArgs$1(ex, 0)) {\n            const { fields, rest } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n            const term = fields.length !== 0 ? {\n                a: [\n                    {\n                        prim: \"DUP\"\n                    },\n                    {\n                        prim: \"CAR\",\n                        annots: fields\n                    },\n                    {\n                        prim: \"DROP\"\n                    },\n                    {\n                        prim: \"CDR\",\n                        annots: [\n                            \"@%%\"\n                        ]\n                    },\n                    {\n                        prim: \"SWAP\"\n                    },\n                    {\n                        prim: \"PAIR\",\n                        annots: [\n                            fields[0],\n                            \"%@\"\n                        ]\n                    }\n                ],\n                d: [\n                    {\n                        prim: \"DUP\"\n                    },\n                    {\n                        prim: \"CDR\",\n                        annots: fields\n                    },\n                    {\n                        prim: \"DROP\"\n                    },\n                    {\n                        prim: \"CAR\",\n                        annots: [\n                            \"@%%\"\n                        ]\n                    },\n                    {\n                        prim: \"PAIR\",\n                        annots: [\n                            \"%@\",\n                            fields[0]\n                        ]\n                    }\n                ]\n            } : {\n                a: [\n                    {\n                        prim: \"CDR\",\n                        annots: [\n                            \"@%%\"\n                        ]\n                    },\n                    {\n                        prim: \"SWAP\"\n                    },\n                    {\n                        prim: \"PAIR\",\n                        annots: [\n                            \"%\",\n                            \"%@\"\n                        ]\n                    }\n                ],\n                d: [\n                    {\n                        prim: \"CAR\",\n                        annots: [\n                            \"@%%\"\n                        ]\n                    },\n                    {\n                        prim: \"PAIR\",\n                        annots: [\n                            \"%@\",\n                            \"%\"\n                        ]\n                    }\n                ]\n            };\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), rest, term);\n        }\n    }\n    // MAP_C[AD]+R macro\n    if (mapCadrRe.test(ex.prim)) {\n        if (assertArgs$1(ex, 1)) {\n            const { fields } = filterAnnotations(ex.annots);\n            if (fields.length > 1) {\n                throw new MacroError(ex, `unexpected annotation on macro ${ex.prim}: ${fields}`);\n            }\n            const term = {\n                a: [\n                    {\n                        prim: \"DUP\"\n                    },\n                    {\n                        prim: \"CDR\",\n                        annots: [\n                            \"@%%\"\n                        ]\n                    },\n                    {\n                        prim: \"DIP\",\n                        args: [\n                            [\n                                mkPrim({\n                                    prim: \"CAR\",\n                                    annots: fields.length !== 0 ? [\n                                        \"@\" + fields[0].slice(1)\n                                    ] : undefined\n                                }),\n                                ex.args[0]\n                            ]\n                        ]\n                    },\n                    {\n                        prim: \"SWAP\"\n                    },\n                    {\n                        prim: \"PAIR\",\n                        annots: [\n                            fields.length !== 0 ? fields[0] : \"%\",\n                            \"%@\"\n                        ]\n                    }\n                ],\n                d: [\n                    {\n                        prim: \"DUP\"\n                    },\n                    mkPrim({\n                        prim: \"CDR\",\n                        annots: fields.length !== 0 ? [\n                            \"@\" + fields[0].slice(1)\n                        ] : undefined\n                    }),\n                    ex.args[0],\n                    {\n                        prim: \"SWAP\"\n                    },\n                    {\n                        prim: \"CAR\",\n                        annots: [\n                            \"@%%\"\n                        ]\n                    },\n                    {\n                        prim: \"PAIR\",\n                        annots: [\n                            \"%@\",\n                            fields.length !== 0 ? fields[0] : \"%\"\n                        ]\n                    }\n                ]\n            };\n            return parseSetMapCadr(ex, ex.prim.slice(5, ex.prim.length - 1), [], term);\n        }\n    }\n    // Expand deprecated DI...IP to [DIP n]\n    if (diipRe.test(ex.prim)) {\n        if (assertArgs$1(ex, 1)) {\n            let n = 0;\n            while(ex.prim[1 + n] === \"I\"){\n                n++;\n            }\n            return mkPrim({\n                prim: \"DIP\",\n                args: [\n                    {\n                        int: String(n)\n                    },\n                    ex.args[0]\n                ]\n            });\n        }\n    }\n    // Expand DU...UP and DUP n\n    if (duupRe.test(ex.prim)) {\n        let n = 0;\n        while(ex.prim[1 + n] === \"U\"){\n            n++;\n        }\n        if (ProtoInferiorTo(proto, Protocol.PtEdo2Zk)) {\n            if (n === 1) {\n                if (ex.args === undefined) {\n                    return ex; // skip\n                }\n                if (assertArgs$1(ex, 1) && assertIntArg(ex, ex.args[0])) {\n                    n = parseInt(ex.args[0].int, 10);\n                }\n            } else {\n                assertArgs$1(ex, 0);\n            }\n            if (n === 1) {\n                return [\n                    mkPrim({\n                        prim: \"DUP\",\n                        annots: ex.annots\n                    })\n                ];\n            } else if (n === 2) {\n                return [\n                    {\n                        prim: \"DIP\",\n                        args: [\n                            [\n                                mkPrim({\n                                    prim: \"DUP\",\n                                    annots: ex.annots\n                                })\n                            ]\n                        ]\n                    },\n                    {\n                        prim: \"SWAP\"\n                    }\n                ];\n            } else {\n                return [\n                    {\n                        prim: \"DIP\",\n                        args: [\n                            {\n                                int: String(n - 1)\n                            },\n                            [\n                                mkPrim({\n                                    prim: \"DUP\",\n                                    annots: ex.annots\n                                })\n                            ]\n                        ]\n                    },\n                    {\n                        prim: \"DIG\",\n                        args: [\n                            {\n                                int: String(n)\n                            }\n                        ]\n                    }\n                ];\n            }\n        } else {\n            if (n === 1) {\n                return ex;\n            }\n            if (assertArgs$1(ex, 0)) {\n                return mkPrim({\n                    prim: \"DUP\",\n                    args: [\n                        {\n                            int: String(n)\n                        }\n                    ],\n                    annots: ex.annots\n                });\n            }\n        }\n    }\n    return ex;\n}\nfunction expandGlobalConstants(ex, hashAndValue) {\n    if (ex.args !== undefined && ex.args.length === 1 && \"string\" in ex.args[0] && ex.args[0].string in hashAndValue) {\n        return hashAndValue[ex.args[0].string];\n    }\n    return ex;\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when parsing Micheline expressions\n */ class MichelineParseError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    /**\n     * @param token A token caused the error\n     * @param message An error message\n     */ constructor(token, message){\n        super();\n        this.token = token;\n        this.message = message;\n        this.name = \"MichelineParseError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error indicates a failure when parsing Micheline JSON\n */ class JSONParseError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    /**\n     * @param node A node caused the error\n     * @param message An error message\n     */ constructor(node, message){\n        super();\n        this.node = node;\n        this.message = message;\n        this.name = \"JSONParseError\";\n    }\n}\nconst errEOF = new MichelineParseError(null, \"Unexpected EOF\");\nfunction isAnnotation(tok) {\n    return tok.t === Literal.Ident && (tok.v[0] === \"@\" || tok.v[0] === \"%\" || tok.v[0] === \":\");\n}\nconst intRe = new RegExp(\"^-?[0-9]+$\");\nconst bytesRe = new RegExp(\"^([0-9a-fA-F]{2})*$\");\n/**\n * Converts and validates Michelson expressions between JSON-based Michelson and Micheline\n *\n * Pretty Print a Michelson Smart Contract:\n * ```\n * const contract = await Tezos.contract.at(\"KT1Vsw3kh9638gqWoHTjvHCoHLPKvCbMVbCg\");\n * const p = new Parser();\n *\n * const michelsonCode = p.parseJSON(contract.script.code);\n * const storage = p.parseJSON(contract.script.storage);\n *\n * console.log(\"Pretty print Michelson smart contract:\");\n * console.log(emitMicheline(michelsonCode, {indent:\"    \", newline: \"\\n\",}));\n *\n * console.log(\"Pretty print Storage:\");\n * console.log(emitMicheline(storage, {indent:\"    \", newline: \"\\n\",}));\n * ```\n *\n * Encode a Michelson expression for initial storage of a smart contract\n * ```\n * const src = `(Pair (Pair { Elt 1\n *                (Pair (Pair \"tz1gjaF81ZRRvdzjobyfVNsAeSC6PScjfQwN\" \"tz1KqTpEZ7Yob7QbPE4Hy4Wo8fHG8LhKxZSx\")\n *                      0x0501000000026869) }\n *          10000000)\n *    (Pair 2 333))`;\n *\n * const p = new Parser();\n *\n * const exp = p.parseMichelineExpression(src);\n * console.log(JSON.stringify(exp));\n * ```\n */ class Parser {\n    constructor(opt){\n        this.opt = opt;\n    }\n    expand(ex) {\n        var _a, _b, _c;\n        if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.expandGlobalConstant) !== undefined && ex.prim === \"constant\") {\n            const ret = expandGlobalConstants(ex, this.opt.expandGlobalConstant);\n            if (ret !== ex) {\n                ret[sourceReference] = Object.assign(Object.assign({}, ex[sourceReference] || {\n                    first: 0,\n                    last: 0\n                }), {\n                    globalConstant: ex\n                });\n            }\n            return ret;\n        }\n        if (((_b = this.opt) === null || _b === void 0 ? void 0 : _b.expandMacros) !== undefined ? (_c = this.opt) === null || _c === void 0 ? void 0 : _c.expandMacros : true) {\n            const ret = expandMacros(ex, this.opt);\n            if (ret !== ex) {\n                ret[sourceReference] = Object.assign(Object.assign({}, ex[sourceReference] || {\n                    first: 0,\n                    last: 0\n                }), {\n                    macro: ex\n                });\n            }\n            return ret;\n        } else {\n            return ex;\n        }\n    }\n    parseListExpr(scanner, start) {\n        var _a;\n        const ref = {\n            first: start.first,\n            last: start.last\n        };\n        const expectBracket = start.t === \"(\";\n        let tok;\n        if (expectBracket) {\n            tok = scanner.next();\n            if (tok.done) {\n                throw errEOF;\n            }\n            ref.last = tok.value.last;\n        } else {\n            tok = {\n                value: start\n            };\n        }\n        if (tok.value.t !== Literal.Ident) {\n            throw new MichelineParseError(tok.value, `not an identifier: ${tok.value.v}`);\n        }\n        const ret = {\n            prim: tok.value.v,\n            [sourceReference]: ref\n        };\n        for(;;){\n            const tok = scanner.next();\n            if (tok.done) {\n                if (expectBracket) {\n                    throw errEOF;\n                }\n                break;\n            } else if (tok.value.t === \")\") {\n                if (!expectBracket) {\n                    throw new MichelineParseError(tok.value, \"unexpected closing bracket\");\n                }\n                ref.last = tok.value.last;\n                break;\n            } else if (isAnnotation(tok.value)) {\n                ret.annots = ret.annots || [];\n                ret.annots.push(tok.value.v);\n                ref.last = tok.value.last;\n            } else {\n                ret.args = ret.args || [];\n                const arg = this.parseExpr(scanner, tok.value);\n                ref.last = ((_a = arg[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) || ref.last;\n                ret.args.push(arg);\n            }\n        }\n        return this.expand(ret);\n    }\n    parseArgs(scanner, start) {\n        var _a;\n        // Identifier with arguments\n        const ref = {\n            first: start.first,\n            last: start.last\n        };\n        const p = {\n            prim: start.v,\n            [sourceReference]: ref\n        };\n        for(;;){\n            const t = scanner.next();\n            if (t.done || t.value.t === \"}\" || t.value.t === \";\") {\n                return [\n                    p,\n                    t\n                ];\n            }\n            if (isAnnotation(t.value)) {\n                ref.last = t.value.last;\n                p.annots = p.annots || [];\n                p.annots.push(t.value.v);\n            } else {\n                const arg = this.parseExpr(scanner, t.value);\n                ref.last = ((_a = arg[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) || ref.last;\n                p.args = p.args || [];\n                p.args.push(arg);\n            }\n        }\n    }\n    parseSequenceExpr(scanner, start) {\n        var _a, _b;\n        const ref = {\n            first: start.first,\n            last: start.last\n        };\n        const seq = [];\n        seq[sourceReference] = ref;\n        const expectBracket = start.t === \"{\";\n        let tok = start.t === \"{\" ? null : {\n            value: start\n        };\n        for(;;){\n            if (tok === null) {\n                tok = scanner.next();\n                if (!tok.done) {\n                    ref.last = tok.value.last;\n                }\n            }\n            if (tok.done) {\n                if (expectBracket) {\n                    throw errEOF;\n                } else {\n                    return seq;\n                }\n            }\n            if (tok.value.t === \"}\") {\n                if (!expectBracket) {\n                    throw new MichelineParseError(tok.value, \"unexpected closing bracket\");\n                } else {\n                    return seq;\n                }\n            } else if (tok.value.t === Literal.Ident) {\n                // Identifier with arguments\n                const [itm, n] = this.parseArgs(scanner, tok.value);\n                ref.last = ((_a = itm[sourceReference]) === null || _a === void 0 ? void 0 : _a.last) || ref.last;\n                seq.push(this.expand(itm));\n                tok = n;\n            } else {\n                // Other\n                const ex = this.parseExpr(scanner, tok.value);\n                ref.last = ((_b = ex[sourceReference]) === null || _b === void 0 ? void 0 : _b.last) || ref.last;\n                seq.push(ex);\n                tok = null;\n            }\n            if (tok === null) {\n                tok = scanner.next();\n                if (!tok.done) {\n                    ref.last = tok.value.last;\n                }\n            }\n            if (!tok.done && tok.value.t === \";\") {\n                tok = null;\n            }\n        }\n    }\n    parseExpr(scanner, tok) {\n        switch(tok.t){\n            case Literal.Ident:\n                return this.expand({\n                    prim: tok.v,\n                    [sourceReference]: {\n                        first: tok.first,\n                        last: tok.last\n                    }\n                });\n            case Literal.Number:\n                return {\n                    int: tok.v,\n                    [sourceReference]: {\n                        first: tok.first,\n                        last: tok.last\n                    }\n                };\n            case Literal.String:\n                return {\n                    string: JSON.parse(tok.v),\n                    [sourceReference]: {\n                        first: tok.first,\n                        last: tok.last\n                    }\n                };\n            case Literal.Bytes:\n                return {\n                    bytes: tok.v.slice(2),\n                    [sourceReference]: {\n                        first: tok.first,\n                        last: tok.last\n                    }\n                };\n            case \"{\":\n                return this.parseSequenceExpr(scanner, tok);\n            default:\n                return this.parseListExpr(scanner, tok);\n        }\n    }\n    /**\n     * Parses a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */ parseSequence(src) {\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseSequenceExpr(scanner, tok.value);\n    }\n    /**\n     * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\n     * @param src A Michelson list expression such as `(Pair {Elt \"0\" 0} 0)` or `Pair {Elt \"0\" 0} 0`\n     * @returns An AST node or null for empty document.\n     */ parseList(src) {\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseListExpr(scanner, tok.value);\n    }\n    /**\n     * Parse any Michelson expression\n     * @param src A Michelson expression such as `(Pair {Elt \"0\" 0} 0)` or `{parameter ...; storage int; code { DUP ; ...};}`\n     * @returns An AST node or null for empty document.\n     */ parseMichelineExpression(src) {\n        if (typeof src !== \"string\") {\n            throw new TypeError(`string type was expected, got ${typeof src} instead`);\n        }\n        const scanner = scan(src);\n        const tok = scanner.next();\n        if (tok.done) {\n            return null;\n        }\n        return this.parseExpr(scanner, tok.value);\n    }\n    /**\n     * Parse a Micheline sequence expression, such as smart contract source. Enclosing curly brackets may be omitted.\n     * An alias for `parseSequence`\n     * @param src A Micheline sequence `{parameter ...; storage int; code { DUP ; ...};}` or `parameter ...; storage int; code { DUP ; ...};`\n     */ parseScript(src) {\n        return this.parseSequence(src);\n    }\n    /**\n     * Parse a Micheline sequence expression. Enclosing curly brackets may be omitted.\n     * An alias for `parseList`\n     * @param src A Michelson list expression such as `(Pair {Elt \"0\" 0} 0)` or `Pair {Elt \"0\" 0} 0`\n     * @returns An AST node or null for empty document.\n     */ parseData(src) {\n        return this.parseList(src);\n    }\n    /**\n     * Takes a JSON-encoded Michelson, validates it, strips away unneeded properties and optionally expands macros (See {@link ParserOptions}).\n     * @param src An object containing JSON-encoded Michelson, usually returned by `JSON.parse()`\n     */ parseJSON(src) {\n        if (typeof src !== \"object\") {\n            throw new TypeError(`object type was expected, got ${typeof src} instead`);\n        }\n        if (Array.isArray(src)) {\n            const ret = [];\n            for (const n of src){\n                if (n === null || typeof n !== \"object\") {\n                    throw new JSONParseError(n, `unexpected sequence element: ${n}`);\n                }\n                ret.push(this.parseJSON(n));\n            }\n            return ret;\n        } else if (\"prim\" in src) {\n            const p = src;\n            if (typeof p.prim === \"string\" && (p.annots === undefined || Array.isArray(p.annots)) && (p.args === undefined || Array.isArray(p.args))) {\n                const ret = {\n                    prim: p.prim\n                };\n                if (p.annots !== undefined) {\n                    for (const a of p.annots){\n                        if (typeof a !== \"string\") {\n                            throw new JSONParseError(a, `string expected: ${a}`);\n                        }\n                    }\n                    ret.annots = p.annots;\n                }\n                if (p.args !== undefined) {\n                    ret.args = [];\n                    for (const a of p.args){\n                        if (a === null || typeof a !== \"object\") {\n                            throw new JSONParseError(a, `unexpected argument: ${a}`);\n                        }\n                        ret.args.push(this.parseJSON(a));\n                    }\n                }\n                return this.expand(ret);\n            }\n            throw new JSONParseError(src, `malformed prim expression: ${src}`);\n        } else if (\"string\" in src) {\n            if (typeof src.string === \"string\") {\n                return {\n                    string: src.string\n                };\n            }\n            throw new JSONParseError(src, `malformed string literal: ${src}`);\n        } else if (\"int\" in src) {\n            if (typeof src.int === \"string\" && intRe.test(src.int)) {\n                return {\n                    int: src.int\n                };\n            }\n            throw new JSONParseError(src, `malformed int literal: ${src}`);\n        } else if (\"bytes\" in src) {\n            if (typeof src.bytes === \"string\" && bytesRe.test(src.bytes)) {\n                return {\n                    bytes: src.bytes\n                };\n            }\n            throw new JSONParseError(src, `malformed bytes literal: ${src}`);\n        } else {\n            throw new JSONParseError(src, `unexpected object: ${src}`);\n        }\n    }\n}\nclass Formatter {\n    constructor(opt, lev = 0){\n        this.opt = opt;\n        this.lev = lev;\n    }\n    indent(n = 0) {\n        var _a;\n        let ret = \"\";\n        if (((_a = this.opt) === null || _a === void 0 ? void 0 : _a.indent) !== undefined) {\n            for(let i = this.lev + n; i > 0; i--){\n                ret += this.opt.indent;\n            }\n        }\n        return ret;\n    }\n    get lf() {\n        var _a;\n        return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \"\";\n    }\n    get lfsp() {\n        var _a;\n        return ((_a = this.opt) === null || _a === void 0 ? void 0 : _a.newline) || \" \";\n    }\n    down(n) {\n        return new Formatter(this.opt, this.lev + n);\n    }\n}\nfunction hasArgs(node) {\n    return \"prim\" in node && (node.annots !== undefined && node.annots.length !== 0 || node.args !== undefined && node.args.length !== 0);\n}\nfunction isMultiline(node) {\n    if (node.args !== undefined) {\n        for (const a of node.args){\n            if (Array.isArray(a) || hasArgs(a)) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction emitExpr(node, f, foldMacros) {\n    var _a;\n    const macro = (_a = node[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;\n    if (foldMacros && macro) {\n        return emitExpr(macro, f, foldMacros);\n    }\n    if (Array.isArray(node)) {\n        return emitSeq(node, f, foldMacros);\n    } else if (\"string\" in node) {\n        return JSON.stringify(node.string);\n    } else if (\"int\" in node) {\n        return node.int;\n    } else if (\"bytes\" in node) {\n        return \"0x\" + node.bytes;\n    } else {\n        if ((node.annots === undefined || node.annots.length === 0) && (node.args === undefined || node.args.length === 0)) {\n            return node.prim;\n        }\n        let ret = \"(\" + node.prim;\n        if (node.annots !== undefined) {\n            for (const a of node.annots){\n                ret += \" \" + a;\n            }\n        }\n        if (node.args !== undefined) {\n            const multiline = isMultiline(node);\n            for (const a of node.args){\n                if (multiline) {\n                    ret += f.lfsp + f.indent(1) + emitExpr(a, f.down(1), foldMacros);\n                } else {\n                    ret += \" \" + emitExpr(a, f, foldMacros);\n                }\n            }\n        }\n        return ret + \")\";\n    }\n}\nfunction emitSeq(node, f, foldMacros) {\n    let ret = \"{\" + f.lf;\n    let i = node.length;\n    for (const el of node){\n        ret += f.indent(1);\n        if (\"prim\" in el) {\n            ret += el.prim;\n            if (el.annots !== undefined) {\n                for (const a of el.annots){\n                    ret += \" \" + a;\n                }\n            }\n            if (el.args !== undefined) {\n                const multiline = isMultiline(el);\n                for (const a of el.args){\n                    if (multiline) {\n                        ret += f.lfsp + f.indent(2) + emitExpr(a, f.down(2), foldMacros);\n                    } else {\n                        ret += \" \" + emitExpr(a, f, foldMacros);\n                    }\n                }\n            }\n        } else {\n            ret += emitExpr(el, f.down(1), foldMacros);\n        }\n        ret += i > 1 ? \";\" + f.lfsp : f.lf;\n        i--;\n    }\n    return ret + f.indent() + \"}\";\n}\n/**\n * Formats Micheline expression\n * @param expr An AST node\n * @param opt Options\n */ function emitMicheline(expr, opt, foldMacros = false) {\n    if (typeof expr !== \"object\") {\n        throw new TypeError(`object type was expected, got ${typeof expr} instead`);\n    }\n    return emitExpr(expr, new Formatter(opt), foldMacros);\n}\nconst H = [\n    0x6a09e667 | 0,\n    0xbb67ae85 | 0,\n    0x3c6ef372 | 0,\n    0xa54ff53a | 0,\n    0x510e527f | 0,\n    0x9b05688c | 0,\n    0x1f83d9ab | 0,\n    0x5be0cd19 | 0\n];\nconst K = [\n    0x428a2f98 | 0,\n    0x71374491 | 0,\n    0xb5c0fbcf | 0,\n    0xe9b5dba5 | 0,\n    0x3956c25b | 0,\n    0x59f111f1 | 0,\n    0x923f82a4 | 0,\n    0xab1c5ed5 | 0,\n    0xd807aa98 | 0,\n    0x12835b01 | 0,\n    0x243185be | 0,\n    0x550c7dc3 | 0,\n    0x72be5d74 | 0,\n    0x80deb1fe | 0,\n    0x9bdc06a7 | 0,\n    0xc19bf174 | 0,\n    0xe49b69c1 | 0,\n    0xefbe4786 | 0,\n    0x0fc19dc6 | 0,\n    0x240ca1cc | 0,\n    0x2de92c6f | 0,\n    0x4a7484aa | 0,\n    0x5cb0a9dc | 0,\n    0x76f988da | 0,\n    0x983e5152 | 0,\n    0xa831c66d | 0,\n    0xb00327c8 | 0,\n    0xbf597fc7 | 0,\n    0xc6e00bf3 | 0,\n    0xd5a79147 | 0,\n    0x06ca6351 | 0,\n    0x14292967 | 0,\n    0x27b70a85 | 0,\n    0x2e1b2138 | 0,\n    0x4d2c6dfc | 0,\n    0x53380d13 | 0,\n    0x650a7354 | 0,\n    0x766a0abb | 0,\n    0x81c2c92e | 0,\n    0x92722c85 | 0,\n    0xa2bfe8a1 | 0,\n    0xa81a664b | 0,\n    0xc24b8b70 | 0,\n    0xc76c51a3 | 0,\n    0xd192e819 | 0,\n    0xd6990624 | 0,\n    0xf40e3585 | 0,\n    0x106aa070 | 0,\n    0x19a4c116 | 0,\n    0x1e376c08 | 0,\n    0x2748774c | 0,\n    0x34b0bcb5 | 0,\n    0x391c0cb3 | 0,\n    0x4ed8aa4a | 0,\n    0x5b9cca4f | 0,\n    0x682e6ff3 | 0,\n    0x748f82ee | 0,\n    0x78a5636f | 0,\n    0x84c87814 | 0,\n    0x8cc70208 | 0,\n    0x90befffa | 0,\n    0xa4506ceb | 0,\n    0xbef9a3f7 | 0,\n    0xc67178f2 | 0\n];\n/**\n *  @category Error\n *  @description Error that indicates a failure when decoding a base58 encoding\n */ class Base58DecodingError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"Base58DecodingError\";\n    }\n}\n// https://tools.ietf.org/html/rfc6234\nfunction sha256(msg) {\n    // pad the message\n    const r = (msg.length + 9) % 64;\n    const pad = r === 0 ? 0 : 64 - r;\n    if (msg.length > 268435455) {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_0__.InvalidMessageError(\"\", `: Invalid length ${msg.length} is too big -- SHA-256.`);\n    }\n    const l = msg.length << 3;\n    const buffer = [\n        ...msg,\n        0x80,\n        ...new Array(pad).fill(0),\n        0,\n        0,\n        0,\n        0,\n        l >> 24 & 0xff,\n        l >> 16 & 0xff,\n        l >> 8 & 0xff,\n        l & 0xff\n    ];\n    function ror(x, n) {\n        return x >>> n | x << 32 - n;\n    }\n    const h = [\n        ...H\n    ];\n    const w = new Array(64);\n    const v = new Array(8);\n    for(let offset = 0; offset < buffer.length; offset += 64){\n        let q = offset;\n        let i = 0;\n        while(i < 16){\n            w[i] = buffer[q] << 24 | buffer[q + 1] << 16 | buffer[q + 2] << 8 | buffer[q + 3];\n            q += 4;\n            i++;\n        }\n        while(i < 64){\n            const s0 = ror(w[i - 15], 7) ^ ror(w[i - 15], 18) ^ w[i - 15] >>> 3;\n            const s1 = ror(w[i - 2], 17) ^ ror(w[i - 2], 19) ^ w[i - 2] >>> 10;\n            w[i] = (s1 | 0) + w[i - 7] + s0 + w[i - 16] | 0;\n            i++;\n        }\n        for(let i = 0; i < 8; i++){\n            v[i] = h[i];\n        }\n        for(let i = 0; i < 64; i++){\n            const b0 = ror(v[0], 2) ^ ror(v[0], 13) ^ ror(v[0], 22);\n            const b1 = ror(v[4], 6) ^ ror(v[4], 11) ^ ror(v[4], 25);\n            const t1 = v[7] + b1 + (v[4] & v[5] ^ ~v[4] & v[6]) + K[i] + w[i] | 0;\n            const t2 = b0 + (v[0] & v[1] ^ v[0] & v[2] ^ v[1] & v[2]) | 0;\n            v[7] = v[6];\n            v[6] = v[5];\n            v[5] = v[4];\n            v[4] = v[3] + t1 | 0;\n            v[3] = v[2];\n            v[2] = v[1];\n            v[1] = v[0];\n            v[0] = t1 + t2 | 0;\n        }\n        for(let i = 0; i < 8; i++){\n            h[i] = h[i] + v[i] | 0;\n        }\n    }\n    const digest = [];\n    for (const v of h){\n        digest.push(v >> 24 & 0xff);\n        digest.push(v >> 16 & 0xff);\n        digest.push(v >> 8 & 0xff);\n        digest.push(v & 0xff);\n    }\n    return digest;\n}\nconst base58alphabetFwd = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    9,\n    10,\n    11,\n    12,\n    13,\n    14,\n    15,\n    16,\n    -1,\n    17,\n    18,\n    19,\n    20,\n    21,\n    -1,\n    22,\n    23,\n    24,\n    25,\n    26,\n    27,\n    28,\n    29,\n    30,\n    31,\n    32,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    -1,\n    33,\n    34,\n    35,\n    36,\n    37,\n    38,\n    39,\n    40,\n    41,\n    42,\n    43,\n    -1,\n    44,\n    45,\n    46,\n    47,\n    48,\n    49,\n    50,\n    51,\n    52,\n    53,\n    54,\n    55,\n    56,\n    57\n];\nconst base58alphabetBwd = [\n    0,\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    16,\n    17,\n    18,\n    19,\n    20,\n    21,\n    22,\n    23,\n    25,\n    26,\n    27,\n    28,\n    29,\n    31,\n    32,\n    33,\n    34,\n    35,\n    36,\n    37,\n    38,\n    39,\n    40,\n    41,\n    48,\n    49,\n    50,\n    51,\n    52,\n    53,\n    54,\n    55,\n    56,\n    57,\n    58,\n    60,\n    61,\n    62,\n    63,\n    64,\n    65,\n    66,\n    67,\n    68,\n    69,\n    70,\n    71,\n    72,\n    73\n];\nfunction byteAt(src, i) {\n    const c = src.charCodeAt(i) - 49;\n    if (c >= base58alphabetFwd.length || base58alphabetFwd[c] === -1) {\n        throw new Base58DecodingError(`Unexpected character at position ${i}: ${src[i]}`);\n    }\n    return base58alphabetFwd[c];\n}\nfunction decodeBase58(src) {\n    const acc = [];\n    let i = 0;\n    // count and skip leading zeros\n    while(i < src.length && byteAt(src, i) === 0){\n        i++;\n    }\n    let zeros = i;\n    while(i < src.length){\n        let carry = byteAt(src, i++);\n        /*\n            for every symbol x\n            acc = acc * 58 + x\n            where acc is a little endian arbitrary length integer\n            */ let ii = 0;\n        while(carry !== 0 || ii < acc.length){\n            const m = (acc[ii] || 0) * 58 + carry;\n            acc[ii++] = m % 256;\n            carry = Math.floor(m / 256);\n        }\n    }\n    while(zeros-- > 0){\n        acc.push(0);\n    }\n    return acc.reverse();\n}\nfunction encodeBase58(src) {\n    const acc = [];\n    let i = 0;\n    // count and skip leading zeros\n    while(i < src.length && src[i] === 0){\n        i++;\n    }\n    let zeros = i;\n    while(i < src.length){\n        let carry = src[i++];\n        let ii = 0;\n        while(carry !== 0 || ii < acc.length){\n            const m = (acc[ii] || 0) * 256 + carry;\n            acc[ii++] = m % 58;\n            carry = Math.floor(m / 58);\n        }\n    }\n    while(zeros-- > 0){\n        acc.push(0);\n    }\n    acc.reverse();\n    return String.fromCharCode(...acc.map((v)=>base58alphabetBwd[v] + 49));\n}\nfunction decodeBase58Check(src) {\n    const buffer = decodeBase58(src);\n    if (buffer.length < 4) {\n        throw new Base58DecodingError(`Data is too short ${buffer.length}`);\n    }\n    const data = buffer.slice(0, buffer.length - 4);\n    const sum = buffer.slice(buffer.length - 4);\n    const computed = sha256(sha256(data));\n    if (sum[0] !== computed[0] || sum[1] !== computed[1] || sum[2] !== computed[2] || sum[3] !== computed[3]) {\n        throw new Base58DecodingError(\"Invalid checksum\");\n    }\n    return data;\n}\nfunction encodeBase58Check(src) {\n    const sum = sha256(sha256(src));\n    return encodeBase58([\n        ...src,\n        ...sum.slice(0, 4)\n    ]);\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid Michelson being passed or used\n */ class InvalidMichelsonError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"InvalidMichelsonError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid type expression being passed or used\n */ class InvalidTypeExpressionError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"InvalidTypeExpressionError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid data expression being passed or used\n */ class InvalidDataExpressionError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"InvalidDataExpressionError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid contract entrypoint being referenced or passed\n */ class InvalidEntrypointError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.ParameterValidationError {\n    constructor(entrypoint){\n        super();\n        this.entrypoint = entrypoint;\n        this.name = \"InvalidEntrypointError\";\n        this.message = `Contract has no entrypoint named: \"${entrypoint}\"`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when trying to encode Tezos ID\n */ class TezosIdEncodeError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"TezosIdEncodeError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a general error happening when trying to create a LongInteger\n */ class LongIntegerError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"LongIntegerError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure occurring when trying to parse a hex byte\n */ class HexParseError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    constructor(hexByte){\n        super();\n        this.hexByte = hexByte;\n        this.name = \"HexParseError\";\n        this.message = `Unable to parse hex byte \"${hexByte}\"`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a Michelson failure occurring\n */ class MichelsonError extends _taquito_core__WEBPACK_IMPORTED_MODULE_0__.TaquitoError {\n    /**\n     * @param val Value of a AST node caused the error\n     * @param path Path to a node caused the error\n     * @param message An error message\n     */ constructor(val, message){\n        super();\n        this.val = val;\n        this.message = message;\n        this.name = \"MichelsonError\";\n    }\n}\nfunction isMichelsonError(err) {\n    return err instanceof MichelsonError;\n}\nclass MichelsonTypeError extends MichelsonError {\n    /**\n     * @param val Value of a type node caused the error\n     * @param data Value of a data node caused the error\n     * @param message An error message\n     */ constructor(val, message, data){\n        super(val, message);\n        this.val = val;\n        this.message = message;\n        this.name = \"MichelsonTypeError\";\n        if (data !== undefined) {\n            this.data = data;\n        }\n    }\n}\n// Ad hoc big integer parser\nclass LongInteger {\n    append(c) {\n        let i = 0;\n        while(c !== 0 || i < this.buf.length){\n            const m = (this.buf[i] || 0) * 10 + c;\n            this.buf[i++] = m % 256;\n            c = Math.floor(m / 256);\n        }\n    }\n    constructor(arg){\n        this.neg = false;\n        this.buf = [];\n        if (arg === undefined) {\n            return;\n        }\n        if (typeof arg === \"string\") {\n            for(let i = 0; i < arg.length; i++){\n                const c = arg.charCodeAt(i);\n                if (i === 0 && c === 0x2d) {\n                    this.neg = true;\n                } else {\n                    if (c < 0x30 || c > 0x39) {\n                        throw new LongIntegerError(`unexpected character in integer constant \"${arg[i]}\"`);\n                    }\n                    this.append(c - 0x30);\n                }\n            }\n        } else if (arg < 0) {\n            this.neg = true;\n            this.append(-arg);\n        } else {\n            this.append(arg);\n        }\n    }\n    cmp(arg) {\n        if (this.neg !== arg.neg) {\n            return (arg.neg ? 1 : 0) - (this.neg ? 1 : 0);\n        } else {\n            let ret = 0;\n            if (this.buf.length !== arg.buf.length) {\n                ret = this.buf.length < arg.buf.length ? -1 : 1;\n            } else if (this.buf.length !== 0) {\n                let i = arg.buf.length - 1;\n                while(i >= 0 && this.buf[i] === arg.buf[i]){\n                    i--;\n                }\n                ret = i < 0 ? 0 : this.buf[i] < arg.buf[i] ? -1 : 1;\n            }\n            return !this.neg ? ret : ret === 0 ? 0 : -ret;\n        }\n    }\n    get sign() {\n        return this.buf.length === 0 ? 0 : this.neg ? -1 : 1;\n    }\n}\nfunction parseBytes(s) {\n    const ret = [];\n    for(let i = 0; i < s.length; i += 2){\n        const x = parseInt(s.slice(i, i + 2), 16);\n        if (Number.isNaN(x)) {\n            return null;\n        }\n        ret.push(x);\n    }\n    return ret;\n}\nfunction isDecimal(x) {\n    try {\n        new LongInteger(x);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction isNatural(x) {\n    try {\n        return new LongInteger(x).sign >= 0;\n    } catch (_a) {\n        return false;\n    }\n}\nconst annRe = /^(@%|@%%|%@|[@:%]([_0-9a-zA-Z][_0-9a-zA-Z.%@]*)?)$/;\nfunction unpackAnnotations(p, opt) {\n    if (Array.isArray(p)) {\n        return {};\n    }\n    let field;\n    let type;\n    let vars;\n    if (p.annots !== undefined) {\n        for (const v of p.annots){\n            if (v.length !== 0) {\n                if (!annRe.test(v) || !(opt === null || opt === void 0 ? void 0 : opt.specialVar) && (v === \"@%\" || v === \"@%%\") || !(opt === null || opt === void 0 ? void 0 : opt.specialFields) && v === \"%@\") {\n                    throw new MichelsonError(p, `${p.prim}: unexpected annotation: ${v}`);\n                }\n                switch(v[0]){\n                    case \"%\":\n                        if ((opt === null || opt === void 0 ? void 0 : opt.emptyFields) || v.length > 1) {\n                            field = field || [];\n                            field.push(v);\n                        }\n                        break;\n                    case \":\":\n                        if (v.length > 1) {\n                            type = type || [];\n                            type.push(v);\n                        }\n                        break;\n                    case \"@\":\n                        if ((opt === null || opt === void 0 ? void 0 : opt.emptyVar) || v.length > 1) {\n                            vars = vars || [];\n                            vars.push(v);\n                        }\n                        break;\n                }\n            }\n        }\n    }\n    return {\n        f: field,\n        t: type,\n        v: vars\n    };\n}\nconst tezosPrefix = {\n    BlockHash: [\n        32,\n        [\n            1,\n            52\n        ]\n    ],\n    OperationHash: [\n        32,\n        [\n            5,\n            116\n        ]\n    ],\n    OperationListHash: [\n        32,\n        [\n            133,\n            233\n        ]\n    ],\n    OperationListListHash: [\n        32,\n        [\n            29,\n            159,\n            109\n        ]\n    ],\n    ProtocolHash: [\n        32,\n        [\n            2,\n            170\n        ]\n    ],\n    ContextHash: [\n        32,\n        [\n            79,\n            199\n        ]\n    ],\n    ED25519PublicKeyHash: [\n        20,\n        [\n            6,\n            161,\n            159\n        ]\n    ],\n    SECP256K1PublicKeyHash: [\n        20,\n        [\n            6,\n            161,\n            161\n        ]\n    ],\n    P256PublicKeyHash: [\n        20,\n        [\n            6,\n            161,\n            164\n        ]\n    ],\n    ContractHash: [\n        20,\n        [\n            2,\n            90,\n            121\n        ]\n    ],\n    CryptoboxPublicKeyHash: [\n        16,\n        [\n            153,\n            103\n        ]\n    ],\n    ED25519Seed: [\n        32,\n        [\n            13,\n            15,\n            58,\n            7\n        ]\n    ],\n    ED25519PublicKey: [\n        32,\n        [\n            13,\n            15,\n            37,\n            217\n        ]\n    ],\n    SECP256K1SecretKey: [\n        32,\n        [\n            17,\n            162,\n            224,\n            201\n        ]\n    ],\n    P256SecretKey: [\n        32,\n        [\n            16,\n            81,\n            238,\n            189\n        ]\n    ],\n    ED25519EncryptedSeed: [\n        56,\n        [\n            7,\n            90,\n            60,\n            179,\n            41\n        ]\n    ],\n    SECP256K1EncryptedSecretKey: [\n        56,\n        [\n            9,\n            237,\n            241,\n            174,\n            150\n        ]\n    ],\n    P256EncryptedSecretKey: [\n        56,\n        [\n            9,\n            48,\n            57,\n            115,\n            171\n        ]\n    ],\n    SECP256K1PublicKey: [\n        33,\n        [\n            3,\n            254,\n            226,\n            86\n        ]\n    ],\n    P256PublicKey: [\n        33,\n        [\n            3,\n            178,\n            139,\n            127\n        ]\n    ],\n    SECP256K1Scalar: [\n        33,\n        [\n            38,\n            248,\n            136\n        ]\n    ],\n    SECP256K1Element: [\n        33,\n        [\n            5,\n            92,\n            0\n        ]\n    ],\n    ED25519SecretKey: [\n        64,\n        [\n            43,\n            246,\n            78,\n            7\n        ]\n    ],\n    ED25519Signature: [\n        64,\n        [\n            9,\n            245,\n            205,\n            134,\n            18\n        ]\n    ],\n    SECP256K1Signature: [\n        64,\n        [\n            13,\n            115,\n            101,\n            19,\n            63\n        ]\n    ],\n    P256Signature: [\n        64,\n        [\n            54,\n            240,\n            44,\n            52\n        ]\n    ],\n    GenericSignature: [\n        64,\n        [\n            4,\n            130,\n            43\n        ]\n    ],\n    ChainID: [\n        4,\n        [\n            87,\n            82,\n            0\n        ]\n    ],\n    RollupAddress: [\n        20,\n        [\n            1,\n            128,\n            120,\n            31\n        ]\n    ]\n};\nfunction checkDecodeTezosID(id, ...types) {\n    const buf = decodeBase58Check(id);\n    for (const t of types){\n        const [plen, p] = tezosPrefix[t];\n        if (buf.length === plen + p.length) {\n            let i = 0;\n            while(i < p.length && buf[i] === p[i]){\n                i++;\n            }\n            if (i === p.length) {\n                return [\n                    t,\n                    buf.slice(p.length)\n                ];\n            }\n        }\n    }\n    return null;\n}\nfunction encodeTezosID(id, data) {\n    const [plen, p] = tezosPrefix[id];\n    if (data.length !== plen) {\n        throw new TezosIdEncodeError(`Incorrect data length for ${id}: ${data.length}`);\n    }\n    return encodeBase58Check([\n        ...p,\n        ...data\n    ]);\n}\nfunction unpackComb(id, v) {\n    const vv = v;\n    const args = Array.isArray(vv) ? vv : vv.args;\n    if (args.length === 2) {\n        // it's a way to make a union of two interfaces not an interface with two independent properties of union types\n        const ret = id === \"pair\" ? {\n            prim: \"pair\",\n            args\n        } : {\n            prim: \"Pair\",\n            args\n        };\n        return ret;\n    }\n    return Object.assign(Object.assign({}, Array.isArray(vv) ? {\n        prim: id\n    } : vv), {\n        args: [\n            args[0],\n            {\n                prim: id,\n                args: args.slice(1)\n            }\n        ]\n    });\n}\nfunction isPairType(t) {\n    return Array.isArray(t) || t.prim === \"pair\";\n}\nfunction isPairData(d) {\n    return Array.isArray(d) || \"prim\" in d && d.prim === \"Pair\";\n}\nconst rfc3339Re = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])[T ]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\\.[0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):([0-5][0-9]))$/;\nfunction parseDate(a) {\n    if (\"string\" in a) {\n        if (isNatural(a.string)) {\n            return new Date(parseInt(a.string, 10));\n        } else if (rfc3339Re.test(a.string)) {\n            const x = new Date(a.string);\n            if (!Number.isNaN(x.valueOf)) {\n                return x;\n            }\n        }\n    } else if (isDecimal(a.int)) {\n        return new Date(parseInt(a.int, 10));\n    }\n    return null;\n}\nfunction parseHex(s) {\n    const res = [];\n    for(let i = 0; i < s.length; i += 2){\n        const ss = s.slice(i, i + 2);\n        const x = parseInt(ss, 16);\n        if (Number.isNaN(x)) {\n            throw new HexParseError(ss);\n        }\n        res.push(x);\n    }\n    return res;\n}\nfunction hexBytes(bytes) {\n    return bytes.map((x)=>(x >> 4 & 0xf).toString(16) + (x & 0xf).toString(16)).join(\"\");\n}\n// Michelson validator\nconst maxViewNameLength = 31;\nconst noArgInstructionIDs = {\n    ABS: true,\n    ADD: true,\n    ADDRESS: true,\n    AMOUNT: true,\n    AND: true,\n    APPLY: true,\n    BALANCE: true,\n    BLAKE2B: true,\n    CAR: true,\n    CDR: true,\n    CHAIN_ID: true,\n    CHECK_SIGNATURE: true,\n    COMPARE: true,\n    CONCAT: true,\n    CONS: true,\n    EDIV: true,\n    EQ: true,\n    EXEC: true,\n    FAILWITH: true,\n    GE: true,\n    GET_AND_UPDATE: true,\n    GT: true,\n    HASH_KEY: true,\n    IMPLICIT_ACCOUNT: true,\n    INT: true,\n    ISNAT: true,\n    JOIN_TICKETS: true,\n    KECCAK: true,\n    LE: true,\n    LEVEL: true,\n    LSL: true,\n    LSR: true,\n    LT: true,\n    MEM: true,\n    MUL: true,\n    NEG: true,\n    NEQ: true,\n    NEVER: true,\n    NOT: true,\n    NOW: true,\n    OR: true,\n    PACK: true,\n    PAIRING_CHECK: true,\n    READ_TICKET: true,\n    SAPLING_VERIFY_UPDATE: true,\n    SELF: true,\n    SELF_ADDRESS: true,\n    SENDER: true,\n    SET_DELEGATE: true,\n    SHA256: true,\n    SHA3: true,\n    SHA512: true,\n    SIZE: true,\n    SLICE: true,\n    SOME: true,\n    SOURCE: true,\n    SPLIT_TICKET: true,\n    SUB: true,\n    SWAP: true,\n    TICKET: true,\n    TICKET_DEPRECATED: true,\n    TOTAL_VOTING_POWER: true,\n    TRANSFER_TOKENS: true,\n    UNIT: true,\n    VOTING_POWER: true,\n    XOR: true,\n    RENAME: true,\n    OPEN_CHEST: true,\n    SUB_MUTEZ: true,\n    MIN_BLOCK_TIME: true,\n    BYTES: true,\n    NAT: true\n};\nconst instructionIDs = Object.assign({}, noArgInstructionIDs, {\n    CONTRACT: true,\n    CREATE_CONTRACT: true,\n    DIG: true,\n    DIP: true,\n    DROP: true,\n    DUG: true,\n    DUP: true,\n    EMIT: true,\n    EMPTY_BIG_MAP: true,\n    EMPTY_MAP: true,\n    EMPTY_SET: true,\n    GET: true,\n    IF: true,\n    IF_CONS: true,\n    IF_LEFT: true,\n    IF_NONE: true,\n    ITER: true,\n    LAMBDA: true,\n    LAMBDA_REC: true,\n    LEFT: true,\n    LOOP: true,\n    LOOP_LEFT: true,\n    MAP: true,\n    NIL: true,\n    NONE: true,\n    PAIR: true,\n    PUSH: true,\n    RIGHT: true,\n    SAPLING_EMPTY_STATE: true,\n    UNPACK: true,\n    UNPAIR: true,\n    UPDATE: true,\n    CAST: true,\n    VIEW: true\n});\nconst simpleComparableTypeIDs = {\n    unit: true,\n    never: true,\n    bool: true,\n    int: true,\n    nat: true,\n    string: true,\n    chain_id: true,\n    bytes: true,\n    mutez: true,\n    key_hash: true,\n    key: true,\n    signature: true,\n    timestamp: true,\n    address: true,\n    tx_rollup_l2_address: true\n};\nconst typeIDs = Object.assign({}, simpleComparableTypeIDs, {\n    or: true,\n    pair: true,\n    set: true,\n    big_map: true,\n    contract: true,\n    lambda: true,\n    list: true,\n    map: true,\n    operation: true,\n    option: true,\n    bls12_381_g1: true,\n    bls12_381_g2: true,\n    bls12_381_fr: true,\n    sapling_transaction: true,\n    sapling_transaction_deprecated: true,\n    sapling_state: true,\n    ticket: true,\n    chest_key: true,\n    chest: true\n});\nclass MichelsonValidationError extends MichelsonError {\n    /**\n     * @param val Value of a node caused the error\n     * @param message An error message\n     */ constructor(val, message){\n        super(val, message);\n        this.val = val;\n        this.message = message;\n        this.name = \"MichelsonValidationError\";\n    }\n}\nfunction isPrim(ex) {\n    return \"prim\" in ex;\n}\nfunction isPrimOrSeq(ex) {\n    return Array.isArray(ex) || \"prim\" in ex;\n}\nfunction assertPrim(ex) {\n    if (isPrim(ex)) {\n        return true;\n    }\n    throw new MichelsonValidationError(ex, \"prim expression expected\");\n}\nfunction assertSeq(ex) {\n    if (Array.isArray(ex)) {\n        return true;\n    }\n    throw new MichelsonValidationError(ex, \"sequence expression expected\");\n}\nfunction assertPrimOrSeq(ex) {\n    if (isPrimOrSeq(ex)) {\n        return true;\n    }\n    throw new MichelsonValidationError(ex, \"prim or sequence expression expected\");\n}\nfunction assertNatural(i) {\n    if (i.int[0] === \"-\") {\n        throw new MichelsonValidationError(i, \"natural number expected\");\n    }\n}\nfunction assertIntLiteral(ex) {\n    if (\"int\" in ex) {\n        return true;\n    }\n    throw new MichelsonValidationError(ex, \"int literal expected\");\n}\nfunction assertStringLiteral(ex) {\n    if (\"string\" in ex) {\n        return true;\n    }\n    throw new MichelsonValidationError(ex, \"string literal expected\");\n}\nfunction assertArgs(ex, n) {\n    var _a;\n    if (n === 0 && ex.args === undefined || ((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === n) {\n        return true;\n    }\n    throw new MichelsonValidationError(ex, `${n} arguments expected`);\n}\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */ function assertMichelsonInstruction(ex) {\n    var _a, _b;\n    if (Array.isArray(ex)) {\n        for (const n of ex){\n            if (!Array.isArray(n) && !isPrim(n)) {\n                throw new MichelsonValidationError(ex, \"sequence or prim expected\");\n            }\n            assertMichelsonInstruction(n);\n        }\n        return true;\n    }\n    if (assertPrim(ex)) {\n        if (Object.prototype.hasOwnProperty.call(noArgInstructionIDs, ex.prim)) {\n            assertArgs(ex, 0);\n            return true;\n        }\n        switch(ex.prim){\n            case \"DROP\":\n            case \"PAIR\":\n            case \"UNPAIR\":\n            case \"DUP\":\n            case \"UPDATE\":\n            case \"GET\":\n                if (ex.args !== undefined && assertArgs(ex, 1)) {\n                    /* istanbul ignore else */ if (assertIntLiteral(ex.args[0])) {\n                        assertNatural(ex.args[0]);\n                    }\n                }\n                break;\n            case \"DIG\":\n            case \"DUG\":\n            case \"SAPLING_EMPTY_STATE\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    /* istanbul ignore else */ if (assertIntLiteral(ex.args[0])) {\n                        assertNatural(ex.args[0]);\n                    }\n                }\n                break;\n            case \"NONE\":\n            case \"LEFT\":\n            case \"RIGHT\":\n            case \"NIL\":\n            case \"CAST\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    assertMichelsonType(ex.args[0]);\n                }\n                break;\n            case \"UNPACK\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    assertMichelsonPackableType(ex.args[0]);\n                }\n                break;\n            case \"CONTRACT\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    assertMichelsonPassableType(ex.args[0]);\n                }\n                break;\n            case \"IF_NONE\":\n            case \"IF_LEFT\":\n            case \"IF_CONS\":\n            case \"IF\":\n                /* istanbul ignore else */ if (assertArgs(ex, 2)) {\n                    /* istanbul ignore else */ if (assertSeq(ex.args[0])) {\n                        assertMichelsonInstruction(ex.args[0]);\n                    }\n                    /* istanbul ignore else */ if (assertSeq(ex.args[1])) {\n                        assertMichelsonInstruction(ex.args[1]);\n                    }\n                }\n                break;\n            case \"MAP\":\n            case \"ITER\":\n            case \"LOOP\":\n            case \"LOOP_LEFT\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    assertMichelsonInstruction(ex.args[0]);\n                }\n                break;\n            case \"CREATE_CONTRACT\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    assertMichelsonContract(ex.args[0]);\n                }\n                break;\n            case \"DIP\":\n                if (((_a = ex.args) === null || _a === void 0 ? void 0 : _a.length) === 2) {\n                    /* istanbul ignore else */ if (assertIntLiteral(ex.args[0])) {\n                        assertNatural(ex.args[0]);\n                    }\n                    /* istanbul ignore else */ if (assertSeq(ex.args[1])) {\n                        assertMichelsonInstruction(ex.args[1]);\n                    }\n                } else if (((_b = ex.args) === null || _b === void 0 ? void 0 : _b.length) === 1) {\n                    /* istanbul ignore else */ if (assertSeq(ex.args[0])) {\n                        assertMichelsonInstruction(ex.args[0]);\n                    }\n                } else {\n                    throw new MichelsonValidationError(ex, \"1 or 2 arguments expected\");\n                }\n                break;\n            case \"PUSH\":\n                /* istanbul ignore else */ if (assertArgs(ex, 2)) {\n                    assertMichelsonPushableType(ex.args[0]);\n                    assertMichelsonData(ex.args[1]);\n                }\n                break;\n            case \"EMPTY_SET\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    assertMichelsonComparableType(ex.args[0]);\n                }\n                break;\n            case \"EMPTY_MAP\":\n                /* istanbul ignore else */ if (assertArgs(ex, 2)) {\n                    assertMichelsonComparableType(ex.args[0]);\n                    assertMichelsonType(ex.args[1]);\n                }\n                break;\n            case \"EMPTY_BIG_MAP\":\n                /* istanbul ignore else */ if (assertArgs(ex, 2)) {\n                    assertMichelsonComparableType(ex.args[0]);\n                    assertMichelsonBigMapStorableType(ex.args[1]);\n                }\n                break;\n            case \"LAMBDA_REC\":\n            case \"LAMBDA\":\n                /* istanbul ignore else */ if (assertArgs(ex, 3)) {\n                    assertMichelsonType(ex.args[0]);\n                    assertMichelsonType(ex.args[1]);\n                    /* istanbul ignore else */ if (assertSeq(ex.args[2])) {\n                        assertMichelsonInstruction(ex.args[2]);\n                    }\n                }\n                break;\n            case \"VIEW\":\n                /* istanbul ignore else */ if (assertArgs(ex, 2)) {\n                    if (assertStringLiteral(ex.args[0])) {\n                        assertViewNameValid(ex.args[0]);\n                    }\n                    if (assertMichelsonType(ex.args[1])) {\n                        assertMichelsonPushableType(ex.args[1]);\n                    }\n                }\n                break;\n            case \"EMIT\":\n                if (ex.args && ex.args.length > 0) {\n                    assertArgs(ex, 1);\n                } else {\n                    assertArgs(ex, 0);\n                }\n                break;\n            default:\n                throw new MichelsonValidationError(ex, \"instruction expected\");\n        }\n    }\n    return true;\n}\nfunction assertMichelsonComparableType(ex) {\n    /* istanbul ignore else */ if (assertPrimOrSeq(ex)) {\n        if (Array.isArray(ex) || ex.prim === \"pair\" || ex.prim === \"or\" || ex.prim === \"option\") {\n            traverseType(ex, (ex)=>assertMichelsonComparableType(ex));\n        } else if (!Object.prototype.hasOwnProperty.call(simpleComparableTypeIDs, ex.prim)) {\n            throw new MichelsonValidationError(ex, `${ex.prim}: type is not comparable`);\n        }\n    }\n    return true;\n}\nfunction assertMichelsonPackableType(ex) {\n    /* istanbul ignore else */ if (assertPrimOrSeq(ex)) {\n        if (isPrim(ex)) {\n            if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"big_map\" || ex.prim === \"operation\" || ex.prim === \"sapling_state\" || ex.prim === \"ticket\") {\n                throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside PACK/UNPACK instructions`);\n            }\n            traverseType(ex, (ex)=>assertMichelsonPackableType(ex));\n        }\n    }\n    return true;\n}\nfunction assertMichelsonPushableType(ex) {\n    /* istanbul ignore else */ if (assertPrimOrSeq(ex)) {\n        if (isPrim(ex)) {\n            if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"big_map\" || ex.prim === \"operation\" || ex.prim === \"sapling_state\" || ex.prim === \"ticket\" || ex.prim === \"contract\") {\n                throw new MichelsonValidationError(ex, `${ex.prim}: type can't be pushed`);\n            }\n            traverseType(ex, (ex)=>assertMichelsonPushableType(ex));\n        }\n    }\n    return true;\n}\nfunction assertMichelsonStorableType(ex) {\n    /* istanbul ignore else */ if (assertPrimOrSeq(ex)) {\n        if (isPrim(ex)) {\n            if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"operation\" || ex.prim === \"contract\") {\n                throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a storage`);\n            }\n            traverseType(ex, (ex)=>assertMichelsonStorableType(ex));\n        }\n    }\n    return true;\n}\nfunction assertMichelsonPassableType(ex) {\n    /* istanbul ignore else */ if (assertPrimOrSeq(ex)) {\n        if (isPrim(ex)) {\n            if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"operation\") {\n                throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used as part of a parameter`);\n            }\n            traverseType(ex, (ex)=>assertMichelsonPassableType(ex));\n        }\n    }\n    return true;\n}\nfunction assertMichelsonBigMapStorableType(ex) {\n    /* istanbul ignore else */ if (assertPrimOrSeq(ex)) {\n        if (isPrim(ex)) {\n            if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim) || ex.prim === \"big_map\" || ex.prim === \"operation\" || ex.prim === \"sapling_state\") {\n                throw new MichelsonValidationError(ex, `${ex.prim}: type can't be used inside a big_map`);\n            }\n            traverseType(ex, (ex)=>assertMichelsonBigMapStorableType(ex));\n        }\n    }\n    return true;\n}\nconst viewRe = new RegExp(\"^[a-zA-Z0-9_.%@]*$\");\nfunction assertViewNameValid(name) {\n    if (name.string.length > maxViewNameLength) {\n        throw new MichelsonValidationError(name, `view name too long: ${name.string}`);\n    }\n    if (!viewRe.test(name.string)) {\n        throw new MichelsonValidationError(name, `invalid character(s) in view name: ${name.string}`);\n    }\n}\n/**\n * Checks if the node is a valid Michelson type expression.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */ function assertMichelsonType(ex) {\n    /* istanbul ignore else */ if (assertPrimOrSeq(ex)) {\n        if (isPrim(ex)) {\n            if (!Object.prototype.hasOwnProperty.call(typeIDs, ex.prim)) {\n                throw new MichelsonValidationError(ex, \"type expected\");\n            }\n            traverseType(ex, (ex)=>assertMichelsonType(ex));\n        }\n    }\n    return true;\n}\nfunction traverseType(ex, cb) {\n    if (Array.isArray(ex) || ex.prim === \"pair\") {\n        const args = Array.isArray(ex) ? ex : ex.args;\n        if (args === undefined || args.length < 2) {\n            throw new MichelsonValidationError(ex, \"at least 2 arguments expected\");\n        }\n        args.forEach((a)=>{\n            if (assertPrimOrSeq(a)) {\n                cb(a);\n            }\n        });\n        return true;\n    }\n    switch(ex.prim){\n        case \"option\":\n        case \"list\":\n            /* istanbul ignore else */ if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {\n                cb(ex.args[0]);\n            }\n            break;\n        case \"contract\":\n            /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                assertMichelsonPassableType(ex.args[0]);\n            }\n            break;\n        case \"or\":\n            /* istanbul ignore else */ if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n                cb(ex.args[0]);\n                cb(ex.args[1]);\n            }\n            break;\n        case \"lambda\":\n            /* istanbul ignore else */ if (assertArgs(ex, 2)) {\n                assertMichelsonType(ex.args[0]);\n                assertMichelsonType(ex.args[1]);\n            }\n            break;\n        case \"set\":\n            /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                assertMichelsonComparableType(ex.args[0]);\n            }\n            break;\n        case \"map\":\n            /* istanbul ignore else */ if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n                assertMichelsonComparableType(ex.args[0]);\n                cb(ex.args[1]);\n            }\n            break;\n        case \"big_map\":\n            /* istanbul ignore else */ if (assertArgs(ex, 2) && assertPrimOrSeq(ex.args[0]) && assertPrimOrSeq(ex.args[1])) {\n                assertMichelsonComparableType(ex.args[0]);\n                assertMichelsonBigMapStorableType(ex.args[1]);\n                cb(ex.args[1]);\n            }\n            break;\n        case \"ticket\":\n            /* istanbul ignore else */ if (assertArgs(ex, 1) && assertPrimOrSeq(ex.args[0])) {\n                assertMichelsonComparableType(ex.args[0]);\n            }\n            break;\n        case \"sapling_state\":\n        case \"sapling_transaction\":\n            if (assertArgs(ex, 1)) {\n                assertIntLiteral(ex.args[0]);\n            }\n            break;\n        default:\n            assertArgs(ex, 0);\n    }\n    return true;\n}\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */ function assertMichelsonData(ex) {\n    if (\"int\" in ex || \"string\" in ex || \"bytes\" in ex) {\n        return true;\n    }\n    if (Array.isArray(ex)) {\n        let mapElts = 0;\n        for (const n of ex){\n            if (isPrim(n) && n.prim === \"Elt\") {\n                /* istanbul ignore else */ if (assertArgs(n, 2)) {\n                    assertMichelsonData(n.args[0]);\n                    assertMichelsonData(n.args[1]);\n                }\n                mapElts++;\n            } else {\n                assertMichelsonData(n);\n            }\n        }\n        if (mapElts !== 0 && mapElts !== ex.length) {\n            throw new MichelsonValidationError(ex, \"data entries and map elements can't be intermixed\");\n        }\n        return true;\n    }\n    if (isPrim(ex)) {\n        switch(ex.prim){\n            case \"Unit\":\n            case \"True\":\n            case \"False\":\n            case \"None\":\n                assertArgs(ex, 0);\n                break;\n            case \"Pair\":\n                /* istanbul ignore else */ if (ex.args === undefined || ex.args.length < 2) {\n                    throw new MichelsonValidationError(ex, \"at least 2 arguments expected\");\n                }\n                for (const a of ex.args){\n                    assertMichelsonData(a);\n                }\n                break;\n            case \"Left\":\n            case \"Right\":\n            case \"Some\":\n                /* istanbul ignore else */ if (assertArgs(ex, 1)) {\n                    assertMichelsonData(ex.args[0]);\n                }\n                break;\n            case \"Lambda_rec\":\n                if (ex.args) {\n                    assertMichelsonInstruction(ex.args);\n                }\n                break;\n            default:\n                if (Object.prototype.hasOwnProperty.call(instructionIDs, ex.prim)) {\n                    assertMichelsonInstruction(ex);\n                } else {\n                    throw new MichelsonValidationError(ex, \"data entry or instruction expected\");\n                }\n        }\n    } else {\n        throw new MichelsonValidationError(ex, \"data entry expected\");\n    }\n    return true;\n}\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * This is a type guard function which either returns true of throws an exception.\n * @param ex An AST node\n */ function assertMichelsonContract(ex) {\n    /* istanbul ignore else */ if (assertSeq(ex)) {\n        const toplevelSec = {};\n        const views = {};\n        for (const sec of ex){\n            if (assertPrim(sec)) {\n                if (sec.prim !== \"view\") {\n                    if (sec.prim in toplevelSec) {\n                        throw new MichelsonValidationError(ex, `duplicate contract section: ${sec.prim}`);\n                    }\n                    toplevelSec[sec.prim] = true;\n                }\n                /* istanbul ignore else */ switch(sec.prim){\n                    case \"code\":\n                        if (assertArgs(sec, 1)) {\n                            /* istanbul ignore else */ if (assertSeq(sec.args[0])) {\n                                assertMichelsonInstruction(sec.args[0]);\n                            }\n                        }\n                        break;\n                    case \"parameter\":\n                        if (assertArgs(sec, 1)) {\n                            assertMichelsonPassableType(sec.args[0]);\n                        }\n                        if (sec.annots) {\n                            throw new MichelsonValidationError(sec, \"Annotation must be part of the parameter type\");\n                        }\n                        break;\n                    case \"storage\":\n                        if (assertArgs(sec, 1)) {\n                            assertMichelsonStorableType(sec.args[0]);\n                        }\n                        break;\n                    case \"view\":\n                        if (assertArgs(sec, 4)) {\n                            if (assertStringLiteral(sec.args[0])) {\n                                const name = sec.args[0];\n                                if (name.string in views) {\n                                    throw new MichelsonValidationError(ex, `duplicate view name: ${name.string}`);\n                                }\n                                views[name.string] = true;\n                                assertViewNameValid(name);\n                            }\n                            assertMichelsonPushableType(sec.args[1]);\n                            assertMichelsonPushableType(sec.args[2]);\n                            if (assertSeq(sec.args[3])) {\n                                assertMichelsonInstruction(sec.args[3]);\n                            }\n                        }\n                        break;\n                    default:\n                        throw new MichelsonValidationError(ex, `unexpected contract section: ${sec.prim}`);\n                }\n            }\n        }\n    }\n    return true;\n}\n/**\n * Checks if the node is a valid Michelson smart contract source containing all required and valid properties such as `parameter`, `storage` and `code`.\n * @param ex An AST node\n */ function isMichelsonScript(ex) {\n    try {\n        assertMichelsonContract(ex);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\n/**\n * Checks if the node is a valid Michelson data literal such as `(Pair {Elt \"0\" 0} 0)`.\n * @param ex An AST node\n */ function isMichelsonData(ex) {\n    try {\n        assertMichelsonData(ex);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\n/**\n * Checks if the node is a valid Michelson code (sequence of instructions).\n * @param ex An AST node\n */ function isMichelsonCode(ex) {\n    try {\n        assertMichelsonInstruction(ex);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\n/**\n * Checks if the node is a valid Michelson type expression.\n * @param ex An AST node\n */ function isMichelsonType(ex) {\n    try {\n        assertMichelsonType(ex);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction isInstruction(p) {\n    return Object.prototype.hasOwnProperty.call(instructionIDs, p.prim);\n}\nfunction assertDataListIfAny(d) {\n    if (!Array.isArray(d)) {\n        return false;\n    }\n    for (const v of d){\n        if (\"prim\" in v) {\n            if (isInstruction(v)) {\n                throw new MichelsonError(d, `Instruction outside of a lambda: ${JSON.stringify(d)}`);\n            } else if (v.prim === \"Elt\") {\n                throw new MichelsonError(d, `Elt item outside of a map literal: ${JSON.stringify(d)}`);\n            }\n        }\n    }\n    return true;\n}\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\n// The order is important!\n// The position represent the encoding value.\nconst primitives = [\n    \"parameter\",\n    \"storage\",\n    \"code\",\n    \"False\",\n    \"Elt\",\n    \"Left\",\n    \"None\",\n    \"Pair\",\n    \"Right\",\n    \"Some\",\n    \"True\",\n    \"Unit\",\n    \"PACK\",\n    \"UNPACK\",\n    \"BLAKE2B\",\n    \"SHA256\",\n    \"SHA512\",\n    \"ABS\",\n    \"ADD\",\n    \"AMOUNT\",\n    \"AND\",\n    \"BALANCE\",\n    \"CAR\",\n    \"CDR\",\n    \"CHECK_SIGNATURE\",\n    \"COMPARE\",\n    \"CONCAT\",\n    \"CONS\",\n    \"CREATE_ACCOUNT\",\n    \"CREATE_CONTRACT\",\n    \"IMPLICIT_ACCOUNT\",\n    \"DIP\",\n    \"DROP\",\n    \"DUP\",\n    \"EDIV\",\n    \"EMPTY_MAP\",\n    \"EMPTY_SET\",\n    \"EQ\",\n    \"EXEC\",\n    \"FAILWITH\",\n    \"GE\",\n    \"GET\",\n    \"GT\",\n    \"HASH_KEY\",\n    \"IF\",\n    \"IF_CONS\",\n    \"IF_LEFT\",\n    \"IF_NONE\",\n    \"INT\",\n    \"LAMBDA\",\n    \"LE\",\n    \"LEFT\",\n    \"LOOP\",\n    \"LSL\",\n    \"LSR\",\n    \"LT\",\n    \"MAP\",\n    \"MEM\",\n    \"MUL\",\n    \"NEG\",\n    \"NEQ\",\n    \"NIL\",\n    \"NONE\",\n    \"NOT\",\n    \"NOW\",\n    \"OR\",\n    \"PAIR\",\n    \"PUSH\",\n    \"RIGHT\",\n    \"SIZE\",\n    \"SOME\",\n    \"SOURCE\",\n    \"SENDER\",\n    \"SELF\",\n    \"STEPS_TO_QUOTA\",\n    \"SUB\",\n    \"SWAP\",\n    \"TRANSFER_TOKENS\",\n    \"SET_DELEGATE\",\n    \"UNIT\",\n    \"UPDATE\",\n    \"XOR\",\n    \"ITER\",\n    \"LOOP_LEFT\",\n    \"ADDRESS\",\n    \"CONTRACT\",\n    \"ISNAT\",\n    \"CAST\",\n    \"RENAME\",\n    \"bool\",\n    \"contract\",\n    \"int\",\n    \"key\",\n    \"key_hash\",\n    \"lambda\",\n    \"list\",\n    \"map\",\n    \"big_map\",\n    \"nat\",\n    \"option\",\n    \"or\",\n    \"pair\",\n    \"set\",\n    \"signature\",\n    \"string\",\n    \"bytes\",\n    \"mutez\",\n    \"timestamp\",\n    \"unit\",\n    \"operation\",\n    \"address\",\n    \"SLICE\",\n    \"DIG\",\n    \"DUG\",\n    \"EMPTY_BIG_MAP\",\n    \"APPLY\",\n    \"chain_id\",\n    \"CHAIN_ID\",\n    \"LEVEL\",\n    \"SELF_ADDRESS\",\n    \"never\",\n    \"NEVER\",\n    \"UNPAIR\",\n    \"VOTING_POWER\",\n    \"TOTAL_VOTING_POWER\",\n    \"KECCAK\",\n    \"SHA3\",\n    \"PAIRING_CHECK\",\n    \"bls12_381_g1\",\n    \"bls12_381_g2\",\n    \"bls12_381_fr\",\n    \"sapling_state\",\n    \"sapling_transaction_deprecated\",\n    \"SAPLING_EMPTY_STATE\",\n    \"SAPLING_VERIFY_UPDATE\",\n    \"ticket\",\n    \"TICKET_DEPRECATED\",\n    \"READ_TICKET\",\n    \"SPLIT_TICKET\",\n    \"JOIN_TICKETS\",\n    \"GET_AND_UPDATE\",\n    \"chest\",\n    \"chest_key\",\n    \"OPEN_CHEST\",\n    \"VIEW\",\n    \"view\",\n    \"constant\",\n    \"SUB_MUTEZ\",\n    \"tx_rollup_l2_address\",\n    \"MIN_BLOCK_TIME\",\n    \"sapling_transaction\",\n    \"EMIT\",\n    \"Lambda_rec\",\n    \"LAMBDA_REC\",\n    \"TICKET\",\n    \"BYTES\",\n    \"NAT\"\n];\nconst primTags = Object.assign({}, ...primitives.map((v, i)=>({\n        [v]: i\n    })));\nvar Tag;\n(function(Tag) {\n    Tag[Tag[\"Int\"] = 0] = \"Int\";\n    Tag[Tag[\"String\"] = 1] = \"String\";\n    Tag[Tag[\"Sequence\"] = 2] = \"Sequence\";\n    Tag[Tag[\"Prim0\"] = 3] = \"Prim0\";\n    Tag[Tag[\"Prim0Annot\"] = 4] = \"Prim0Annot\";\n    Tag[Tag[\"Prim1\"] = 5] = \"Prim1\";\n    Tag[Tag[\"Prim1Annot\"] = 6] = \"Prim1Annot\";\n    Tag[Tag[\"Prim2\"] = 7] = \"Prim2\";\n    Tag[Tag[\"Prim2Annot\"] = 8] = \"Prim2Annot\";\n    Tag[Tag[\"Prim\"] = 9] = \"Prim\";\n    Tag[Tag[\"Bytes\"] = 10] = \"Bytes\";\n})(Tag || (Tag = {}));\nclass Writer {\n    constructor(){\n        this.buffer = [];\n    }\n    get length() {\n        return this.buffer.length;\n    }\n    writeBytes(val) {\n        this.buffer.push(...val.map((v)=>v & 0xff));\n    }\n    writeUint8(val) {\n        const v = val | 0;\n        this.buffer.push(v & 0xff);\n    }\n    writeUint16(val) {\n        const v = val | 0;\n        this.buffer.push(v >> 8 & 0xff);\n        this.buffer.push(v & 0xff);\n    }\n    writeUint32(val) {\n        const v = val | 0;\n        this.buffer.push(v >> 24 & 0xff);\n        this.buffer.push(v >> 16 & 0xff);\n        this.buffer.push(v >> 8 & 0xff);\n        this.buffer.push(v & 0xff);\n    }\n    writeInt8(val) {\n        this.writeUint8(val);\n    }\n    writeInt16(val) {\n        this.writeUint16(val);\n    }\n    writeInt32(val) {\n        this.writeUint32(val);\n    }\n}\nconst boundsErr = new Error(\"bounds out of range\");\nclass Reader {\n    constructor(buffer, idx = 0, cap = buffer.length){\n        this.buffer = buffer;\n        this.idx = idx;\n        this.cap = cap;\n    }\n    /** Remaining length */ get length() {\n        return this.cap - this.idx;\n    }\n    readBytes(len) {\n        if (this.cap - this.idx < len) {\n            throw boundsErr;\n        }\n        const ret = this.buffer.slice(this.idx, this.idx + len);\n        this.idx += len;\n        return ret;\n    }\n    reader(len) {\n        if (this.cap - this.idx < len) {\n            throw boundsErr;\n        }\n        const ret = new Reader(this.buffer, this.idx, this.idx + len);\n        this.idx += len;\n        return ret;\n    }\n    copy() {\n        return new Reader(this.buffer, this.idx, this.cap);\n    }\n    readUint8() {\n        if (this.cap - this.idx < 1) {\n            throw boundsErr;\n        }\n        return this.buffer[this.idx++] >>> 0;\n    }\n    readUint16() {\n        if (this.cap - this.idx < 2) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        return (x0 << 8 | x1) >>> 0;\n    }\n    readUint32() {\n        if (this.cap - this.idx < 4) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        const x2 = this.buffer[this.idx++];\n        const x3 = this.buffer[this.idx++];\n        return (x0 << 24 | x1 << 16 | x2 << 8 | x3) >>> 0;\n    }\n    readInt8() {\n        if (this.cap - this.idx < 1) {\n            throw boundsErr;\n        }\n        const x = this.buffer[this.idx++];\n        return x << 24 >> 24;\n    }\n    readInt16() {\n        if (this.cap - this.idx < 2) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        return (x0 << 8 | x1) << 16 >> 16;\n    }\n    readInt32() {\n        if (this.cap - this.idx < 4) {\n            throw boundsErr;\n        }\n        const x0 = this.buffer[this.idx++];\n        const x1 = this.buffer[this.idx++];\n        const x2 = this.buffer[this.idx++];\n        const x3 = this.buffer[this.idx++];\n        return x0 << 24 | x1 << 16 | x2 << 8 | x3;\n    }\n}\nvar ContractID;\n(function(ContractID) {\n    ContractID[ContractID[\"Implicit\"] = 0] = \"Implicit\";\n    ContractID[ContractID[\"Originated\"] = 1] = \"Originated\";\n})(ContractID || (ContractID = {}));\nvar PublicKeyHashID;\n(function(PublicKeyHashID) {\n    PublicKeyHashID[PublicKeyHashID[\"ED25519\"] = 0] = \"ED25519\";\n    PublicKeyHashID[PublicKeyHashID[\"SECP256K1\"] = 1] = \"SECP256K1\";\n    PublicKeyHashID[PublicKeyHashID[\"P256\"] = 2] = \"P256\";\n})(PublicKeyHashID || (PublicKeyHashID = {}));\nfunction readPublicKeyHash(rd) {\n    let type;\n    const tag = rd.readUint8();\n    switch(tag){\n        case PublicKeyHashID.ED25519:\n            type = \"ED25519PublicKeyHash\";\n            break;\n        case PublicKeyHashID.SECP256K1:\n            type = \"SECP256K1PublicKeyHash\";\n            break;\n        case PublicKeyHashID.P256:\n            type = \"P256PublicKeyHash\";\n            break;\n        default:\n            throw new Error(`unknown public key hash tag: ${tag}`);\n    }\n    return {\n        type,\n        hash: rd.readBytes(20)\n    };\n}\nfunction readAddress(rd) {\n    let address;\n    const tag = rd.readUint8();\n    switch(tag){\n        case ContractID.Implicit:\n            address = readPublicKeyHash(rd);\n            break;\n        case ContractID.Originated:\n            address = {\n                type: \"ContractHash\",\n                hash: rd.readBytes(20)\n            };\n            rd.readBytes(1);\n            break;\n        default:\n            throw new Error(`unknown address tag: ${tag}`);\n    }\n    if (rd.length !== 0) {\n        // entry point\n        const dec = new TextDecoder();\n        address.entryPoint = dec.decode(new Uint8Array(rd.readBytes(rd.length)));\n    }\n    return address;\n}\nfunction writePublicKeyHash(a, w) {\n    let tag;\n    switch(a.type){\n        case \"ED25519PublicKeyHash\":\n            tag = PublicKeyHashID.ED25519;\n            break;\n        case \"SECP256K1PublicKeyHash\":\n            tag = PublicKeyHashID.SECP256K1;\n            break;\n        case \"P256PublicKeyHash\":\n            tag = PublicKeyHashID.P256;\n            break;\n        default:\n            throw new Error(`unexpected address type: ${a.type}`);\n    }\n    w.writeUint8(tag);\n    w.writeBytes(Array.from(a.hash));\n}\nfunction writeAddress(a, w) {\n    if (a.type === \"ContractHash\") {\n        w.writeUint8(ContractID.Originated);\n        w.writeBytes(Array.from(a.hash));\n        w.writeUint8(0);\n    } else {\n        w.writeUint8(ContractID.Implicit);\n        writePublicKeyHash(a, w);\n    }\n    if (a.entryPoint !== undefined && a.entryPoint !== \"\" && a.entryPoint !== \"default\") {\n        const enc = new TextEncoder();\n        const bytes = enc.encode(a.entryPoint);\n        w.writeBytes(Array.from(bytes));\n    }\n}\nvar PublicKeyID;\n(function(PublicKeyID) {\n    PublicKeyID[PublicKeyID[\"ED25519\"] = 0] = \"ED25519\";\n    PublicKeyID[PublicKeyID[\"SECP256K1\"] = 1] = \"SECP256K1\";\n    PublicKeyID[PublicKeyID[\"P256\"] = 2] = \"P256\";\n})(PublicKeyID || (PublicKeyID = {}));\nfunction readPublicKey(rd) {\n    let ln;\n    let type;\n    const tag = rd.readUint8();\n    switch(tag){\n        case PublicKeyID.ED25519:\n            type = \"ED25519PublicKey\";\n            ln = 32;\n            break;\n        case PublicKeyID.SECP256K1:\n            type = \"SECP256K1PublicKey\";\n            ln = 33;\n            break;\n        case PublicKeyID.P256:\n            type = \"P256PublicKey\";\n            ln = 33;\n            break;\n        default:\n            throw new Error(`unknown public key tag: ${tag}`);\n    }\n    return {\n        type,\n        publicKey: rd.readBytes(ln)\n    };\n}\nfunction writePublicKey(pk, w) {\n    let tag;\n    switch(pk.type){\n        case \"ED25519PublicKey\":\n            tag = PublicKeyID.ED25519;\n            break;\n        case \"SECP256K1PublicKey\":\n            tag = PublicKeyID.SECP256K1;\n            break;\n        case \"P256PublicKey\":\n            tag = PublicKeyID.P256;\n            break;\n        default:\n            throw new Error(`unexpected public key type: ${pk.type}`);\n    }\n    w.writeUint8(tag);\n    w.writeBytes(Array.from(pk.publicKey));\n}\nfunction writeExpr(expr, wr, tf) {\n    var _a, _b;\n    const [e, args] = tf(expr);\n    if (Array.isArray(e)) {\n        const w = new Writer();\n        for (const v of e){\n            const a = args.next();\n            if (a.done) {\n                throw new Error(\"REPORT ME: iterator is done\");\n            }\n            writeExpr(v, w, a.value);\n        }\n        wr.writeUint8(Tag.Sequence);\n        wr.writeUint32(w.length);\n        wr.writeBytes(w.buffer);\n        return;\n    }\n    if (\"string\" in e) {\n        const enc = new TextEncoder();\n        const bytes = enc.encode(e.string);\n        wr.writeUint8(Tag.String);\n        wr.writeUint32(bytes.length);\n        wr.writeBytes(Array.from(bytes));\n        return;\n    }\n    if (\"int\" in e) {\n        wr.writeUint8(Tag.Int);\n        let val = BigInt(e.int);\n        const sign = val < 0;\n        if (sign) {\n            val = -val;\n        }\n        let i = 0;\n        do {\n            const bits = i === 0 ? BigInt(6) : BigInt(7);\n            let byte = val & (BigInt(1) << bits) - BigInt(1);\n            val >>= bits;\n            if (val) {\n                byte |= BigInt(0x80);\n            }\n            if (i === 0 && sign) {\n                byte |= BigInt(0x40);\n            }\n            wr.writeUint8(Number(byte));\n            i++;\n        }while (val);\n        return;\n    }\n    if (\"bytes\" in e) {\n        const bytes = parseHex(e.bytes);\n        wr.writeUint8(Tag.Bytes);\n        wr.writeUint32(bytes.length);\n        wr.writeBytes(bytes);\n        return;\n    }\n    const prim = primTags[e.prim];\n    if (prim === undefined) {\n        throw new TypeError(`Can't encode primary: ${e.prim}`);\n    }\n    const tag = (((_a = e.args) === null || _a === void 0 ? void 0 : _a.length) || 0) < 3 ? Tag.Prim0 + (((_b = e.args) === null || _b === void 0 ? void 0 : _b.length) || 0) * 2 + (e.annots === undefined || e.annots.length === 0 ? 0 : 1) : Tag.Prim;\n    wr.writeUint8(tag);\n    wr.writeUint8(prim);\n    if (e.args !== undefined) {\n        if (e.args.length < 3) {\n            for (const v of e.args){\n                const a = args.next();\n                if (a.done) {\n                    throw new Error(\"REPORT ME: iterator is done\");\n                }\n                writeExpr(v, wr, a.value);\n            }\n        } else {\n            const w = new Writer();\n            for (const v of e.args){\n                const a = args.next();\n                if (a.done) {\n                    throw new Error(\"REPORT ME: iterator is done\");\n                }\n                writeExpr(v, w, a.value);\n            }\n            wr.writeUint32(w.length);\n            wr.writeBytes(w.buffer);\n        }\n    }\n    if (e.annots !== undefined && e.annots.length !== 0) {\n        const enc = new TextEncoder();\n        const bytes = enc.encode(e.annots.join(\" \"));\n        wr.writeUint32(bytes.length);\n        wr.writeBytes(Array.from(bytes));\n    } else if (e.args !== undefined && e.args.length >= 3) {\n        wr.writeUint32(0);\n    }\n}\nfunction readExpr(rd, tf) {\n    function* passThrough() {\n        while(true){\n            yield readPassThrough;\n        }\n    }\n    const [args, tr] = tf;\n    const tag = rd.readUint8();\n    switch(tag){\n        case Tag.Int:\n            {\n                const buf = [];\n                let byte;\n                do {\n                    byte = rd.readInt8();\n                    buf.push(byte);\n                }while ((byte & 0x80) !== 0);\n                let val = BigInt(0);\n                let sign = false;\n                for(let i = buf.length - 1; i >= 0; i--){\n                    const bits = i === 0 ? BigInt(6) : BigInt(7);\n                    const byte = BigInt(buf[i]);\n                    val <<= bits;\n                    val |= byte & (BigInt(1) << bits) - BigInt(1);\n                    if (i === 0) {\n                        sign = !!(byte & BigInt(0x40));\n                    }\n                }\n                if (sign) {\n                    val = -val;\n                }\n                return tr({\n                    int: String(val)\n                });\n            }\n        case Tag.String:\n            {\n                const length = rd.readUint32();\n                const bytes = rd.readBytes(length);\n                const dec = new TextDecoder();\n                return tr({\n                    string: dec.decode(new Uint8Array(bytes))\n                });\n            }\n        case Tag.Bytes:\n            {\n                const length = rd.readUint32();\n                const bytes = rd.readBytes(length);\n                const hex = hexBytes(Array.from(bytes));\n                return tr({\n                    bytes: hex\n                });\n            }\n        case Tag.Sequence:\n            {\n                const length = rd.readUint32();\n                let res = [];\n                let savedrd = rd.copy();\n                // make two passes\n                let it = passThrough();\n                for(let n = 0; n < 2; n++){\n                    const r = savedrd.reader(length);\n                    res = [];\n                    while(r.length > 0){\n                        const a = it.next();\n                        if (a.done) {\n                            throw new Error(\"REPORT ME: iterator is done\");\n                        }\n                        res.push(readExpr(r, a.value));\n                    }\n                    // make a second pass with injected side effects\n                    it = args(res);\n                    savedrd = rd;\n                }\n                return tr(res);\n            }\n        default:\n            {\n                if (tag > 9) {\n                    throw new Error(`Unknown tag: ${tag}`);\n                }\n                const p = rd.readUint8();\n                if (p >= primitives.length) {\n                    throw new Error(`Unknown primitive tag: ${p}`);\n                }\n                const prim = primitives[p];\n                const argn = tag - 3 >> 1;\n                let res = {\n                    prim\n                };\n                // make two passes\n                let it = passThrough();\n                let savedrd = rd.copy();\n                for(let n = 0; n < 2; n++){\n                    res = {\n                        prim\n                    };\n                    if (argn < 3) {\n                        for(let i = 0; i < argn; i++){\n                            const a = it.next();\n                            if (a.done) {\n                                throw new Error(\"REPORT ME: iterator is done\");\n                            }\n                            res.args = res.args || [];\n                            res.args.push(readExpr(savedrd, a.value));\n                        }\n                    } else {\n                        res.args = res.args || [];\n                        const length = savedrd.readUint32();\n                        const r = savedrd.reader(length);\n                        while(r.length > 0){\n                            const a = it.next();\n                            if (a.done) {\n                                throw new Error(\"REPORT ME: iterator is done\");\n                            }\n                            res.args.push(readExpr(r, a.value));\n                        }\n                    }\n                    // make a second pass with injected side effects\n                    it = args(res);\n                    savedrd = rd;\n                }\n                if ((tag - 3 & 1) === 1 || argn === 3) {\n                    // read annotations\n                    const length = rd.readUint32();\n                    if (length !== 0) {\n                        const bytes = rd.readBytes(length);\n                        const dec = new TextDecoder();\n                        res.annots = dec.decode(new Uint8Array(bytes)).split(\" \");\n                    }\n                }\n                return tr(res);\n            }\n    }\n}\nconst isOrData = (e)=>\"prim\" in e && (e.prim === \"Left\" || e.prim === \"Right\");\nconst isOptionData = (e)=>\"prim\" in e && (e.prim === \"Some\" || e.prim === \"None\");\nconst getWriteTransformFunc = (t)=>{\n    if (isPairType(t)) {\n        return (d)=>{\n            if (!isPairData(d)) {\n                throw new MichelsonTypeError(t, `pair expected: ${JSON.stringify(d)}`, d);\n            }\n            assertDataListIfAny(d);\n            // combs aren't used in pack format\n            const tc = unpackComb(\"pair\", t);\n            const dc = unpackComb(\"Pair\", d);\n            return [\n                dc,\n                function*() {\n                    for (const a of tc.args){\n                        yield getWriteTransformFunc(a);\n                    }\n                }()\n            ];\n        };\n    }\n    switch(t.prim){\n        case \"or\":\n            return (d)=>{\n                if (!isOrData(d)) {\n                    throw new MichelsonTypeError(t, `or expected: ${JSON.stringify(d)}`, d);\n                }\n                return [\n                    d,\n                    function*() {\n                        yield getWriteTransformFunc(t.args[d.prim === \"Left\" ? 0 : 1]);\n                    }()\n                ];\n            };\n        case \"option\":\n            return (d)=>{\n                if (!isOptionData(d)) {\n                    throw new MichelsonTypeError(t, `option expected: ${JSON.stringify(d)}`, d);\n                }\n                return [\n                    d,\n                    function*() {\n                        const dd = d;\n                        // TODO: refactor and remove ts-ignore\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                        // @ts-ignore\n                        if (dd.prim === \"Some\") {\n                            yield getWriteTransformFunc(t.args[0]);\n                        }\n                    }()\n                ];\n            };\n        case \"list\":\n        case \"set\":\n            return (d)=>{\n                if (!Array.isArray(d)) {\n                    throw new MichelsonTypeError(t, `${t.prim} expected: ${JSON.stringify(d)}`, d);\n                }\n                return [\n                    d,\n                    function*() {\n                        for (const _v of d){\n                            yield getWriteTransformFunc(t.args[0]);\n                        }\n                    }()\n                ];\n            };\n        case \"map\":\n            return (d)=>{\n                if (!Array.isArray(d)) {\n                    throw new MichelsonTypeError(t, `map expected: ${JSON.stringify(d)}`, d);\n                }\n                return [\n                    d,\n                    function*() {\n                        for (const _elt of d){\n                            yield (elt)=>{\n                                if (!(\"prim\" in elt) || elt.prim !== \"Elt\") {\n                                    throw new MichelsonTypeError(t, `map element expected: ${JSON.stringify(elt)}`, elt);\n                                }\n                                return [\n                                    elt,\n                                    function*() {\n                                        for (const a of t.args){\n                                            yield getWriteTransformFunc(a);\n                                        }\n                                    }()\n                                ];\n                            };\n                        }\n                    }()\n                ];\n            };\n        case \"chain_id\":\n            return (d)=>{\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, `chain id expected: ${JSON.stringify(d)}`, d);\n                }\n                let bytes;\n                if (\"string\" in d) {\n                    const id = checkDecodeTezosID(d.string, \"ChainID\");\n                    if (id === null) {\n                        throw new MichelsonTypeError(t, `chain id base58 expected: ${d.string}`, d);\n                    }\n                    bytes = {\n                        bytes: hexBytes(id[1])\n                    };\n                } else {\n                    bytes = d;\n                }\n                return [\n                    bytes,\n                    [][Symbol.iterator]()\n                ];\n            };\n        case \"signature\":\n            return (d)=>{\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, `signature expected: ${JSON.stringify(d)}`, d);\n                }\n                let bytes;\n                if (\"string\" in d) {\n                    const sig = checkDecodeTezosID(d.string, \"ED25519Signature\", \"SECP256K1Signature\", \"P256Signature\", \"GenericSignature\");\n                    if (sig === null) {\n                        throw new MichelsonTypeError(t, `signature base58 expected: ${d.string}`, d);\n                    }\n                    bytes = {\n                        bytes: hexBytes(sig[1])\n                    };\n                } else {\n                    bytes = d;\n                }\n                return [\n                    bytes,\n                    [][Symbol.iterator]()\n                ];\n            };\n        case \"key_hash\":\n            return (d)=>{\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, `key hash expected: ${JSON.stringify(d)}`, d);\n                }\n                let bytes;\n                if (\"string\" in d) {\n                    const pkh = checkDecodeTezosID(d.string, \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\");\n                    if (pkh === null) {\n                        throw new MichelsonTypeError(t, `key hash base58 expected: ${d.string}`, d);\n                    }\n                    const w = new Writer();\n                    writePublicKeyHash({\n                        type: pkh[0],\n                        hash: pkh[1]\n                    }, w);\n                    bytes = {\n                        bytes: hexBytes(w.buffer)\n                    };\n                } else {\n                    bytes = d;\n                }\n                return [\n                    bytes,\n                    [][Symbol.iterator]()\n                ];\n            };\n        case \"key\":\n            return (d)=>{\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, `public key expected: ${JSON.stringify(d)}`, d);\n                }\n                let bytes;\n                if (\"string\" in d) {\n                    const key = checkDecodeTezosID(d.string, \"ED25519PublicKey\", \"SECP256K1PublicKey\", \"P256PublicKey\");\n                    if (key === null) {\n                        throw new MichelsonTypeError(t, `public key base58 expected: ${d.string}`, d);\n                    }\n                    const w = new Writer();\n                    writePublicKey({\n                        type: key[0],\n                        publicKey: key[1]\n                    }, w);\n                    bytes = {\n                        bytes: hexBytes(w.buffer)\n                    };\n                } else {\n                    bytes = d;\n                }\n                return [\n                    bytes,\n                    [][Symbol.iterator]()\n                ];\n            };\n        case \"address\":\n            return (d)=>{\n                if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                    throw new MichelsonTypeError(t, `address expected: ${JSON.stringify(d)}`, d);\n                }\n                let bytes;\n                if (\"string\" in d) {\n                    const s = d.string.split(\"%\");\n                    const address = checkDecodeTezosID(s[0], \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\", \"ContractHash\");\n                    if (address === null) {\n                        throw new MichelsonTypeError(t, `address base58 expected: ${d.string}`, d);\n                    }\n                    const w = new Writer();\n                    writeAddress({\n                        type: address[0],\n                        hash: address[1],\n                        entryPoint: s.length > 1 ? s[1] : undefined\n                    }, w);\n                    bytes = {\n                        bytes: hexBytes(w.buffer)\n                    };\n                } else {\n                    bytes = d;\n                }\n                return [\n                    bytes,\n                    [][Symbol.iterator]()\n                ];\n            };\n        case \"timestamp\":\n            return (d)=>{\n                if (!(\"string\" in d) && !(\"int\" in d)) {\n                    throw new MichelsonTypeError(t, `timestamp expected: ${JSON.stringify(d)}`, d);\n                }\n                let int;\n                if (\"string\" in d) {\n                    const p = parseDate(d);\n                    if (p === null) {\n                        throw new MichelsonTypeError(t, `can't parse date: ${d.string}`, d);\n                    }\n                    int = {\n                        int: String(Math.floor(p.getTime() / 1000))\n                    };\n                } else {\n                    int = d;\n                }\n                return [\n                    int,\n                    [][Symbol.iterator]()\n                ];\n            };\n        default:\n            return writePassThrough;\n    }\n};\nconst isPushInstruction = (e)=>\"prim\" in e && e.prim === \"PUSH\";\nconst writePassThrough = (e)=>{\n    if (isPushInstruction(e)) {\n        assertMichelsonInstruction(e);\n        // capture inlined type definition\n        return [\n            e,\n            function*() {\n                yield writePassThrough;\n                yield getWriteTransformFunc(e.args[0]);\n            }()\n        ];\n    }\n    return [\n        e,\n        function*() {\n            while(true){\n                yield writePassThrough;\n            }\n        }()\n    ];\n};\n/**\n * Serializes any value of packable type to its optimized binary representation\n * identical to the one used by PACK and UNPACK Michelson instructions.\n * Without a type definition (not recommended) the data will be encoded as a binary form of a generic Michelson expression.\n * Type definition allows some types like `timestamp` and `address` and other base58 representable types to be encoded to\n * corresponding optimized binary forms borrowed from the Tezos protocol\n *\n * ```typescript\n * const data: MichelsonData = {\n *     string: \"KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo\"\n * };\n *\n * const typ: MichelsonType = {\n *     prim: \"address\"\n * };\n *\n * const packed = packData(data, typ);\n *\n * // 050a0000001901be41ee922ddd2cf33201e49d32da0afec571dce300666f6f\n * ```\n *\n * Without a type definition the base58 encoded address will be treated as a string\n * ```typescript\n * const data: MichelsonData = {\n *     string: \"KT1RvkwF4F7pz1gCoxkyZrG1RkrxQy3gmFTv%foo\"\n * };\n *\n * const packed = packData(data);\n *\n * // 0501000000284b543152766b7746344637707a3167436f786b795a724731526b7278517933676d46547625666f6f\n * ```\n * @param d Data object\n * @param t Optional type definition\n * @returns Binary representation as numeric array\n */ function packData(d, t) {\n    const w = new Writer();\n    w.writeUint8(5);\n    writeExpr(d, w, t !== undefined ? getWriteTransformFunc(t) : writePassThrough);\n    return w.buffer;\n}\n/**\n * Serializes any value of packable type to its optimized binary representation\n * identical to the one used by PACK and UNPACK Michelson instructions.\n * Same as {@link packData} but returns a `bytes` Michelson data literal instead of an array\n *\n * ```typescript\n * const data: MichelsonData = {\n *     string: \"2019-09-26T10:59:51Z\"\n * };\n *\n * const typ: MichelsonType = {\n *     prim: \"timestamp\"\n * };\n *\n * const packed = packDataBytes(data, typ);\n *\n * // { bytes: \"0500a7e8e4d80b\" }\n * ```\n * @param d Data object\n * @param t Optional type definition\n * @returns Binary representation as a bytes literal\n */ function packDataBytes(d, t) {\n    return {\n        bytes: hexBytes(packData(d, t))\n    };\n}\nconst getReadTransformFuncs = (t)=>{\n    if (isPairType(t)) {\n        return [\n            (d)=>{\n                if (!isPairData(d)) {\n                    throw new MichelsonTypeError(t, `pair expected: ${JSON.stringify(d)}`, d);\n                }\n                const tc = unpackComb(\"pair\", t);\n                return function*() {\n                    for (const a of tc.args){\n                        yield getReadTransformFuncs(a);\n                    }\n                }();\n            },\n            (d)=>d\n        ];\n    }\n    switch(t.prim){\n        case \"or\":\n            return [\n                (d)=>{\n                    if (!isOrData(d)) {\n                        throw new MichelsonTypeError(t, `or expected: ${JSON.stringify(d)}`, d);\n                    }\n                    return function*() {\n                        yield getReadTransformFuncs(t.args[d.prim === \"Left\" ? 0 : 1]);\n                    }();\n                },\n                (d)=>d\n            ];\n        case \"option\":\n            return [\n                (d)=>{\n                    if (!isOptionData(d)) {\n                        throw new MichelsonTypeError(t, `option expected: ${JSON.stringify(d)}`, d);\n                    }\n                    return function*() {\n                        // TODO: refactor and remove ts-ignore\n                        // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n                        // @ts-ignore\n                        if (d.prim === \"Some\") {\n                            yield getReadTransformFuncs(t.args[0]);\n                        }\n                    }();\n                },\n                (d)=>d\n            ];\n        case \"list\":\n        case \"set\":\n            return [\n                (d)=>{\n                    if (!Array.isArray(d)) {\n                        throw new MichelsonTypeError(t, `${t.prim} expected: ${JSON.stringify(d)}`, d);\n                    }\n                    return function*() {\n                        while(true){\n                            yield getReadTransformFuncs(t.args[0]);\n                        }\n                    }();\n                },\n                (d)=>d\n            ];\n        case \"map\":\n            return [\n                (d)=>{\n                    if (!Array.isArray(d)) {\n                        throw new MichelsonTypeError(t, `map expected: ${JSON.stringify(d)}`, d);\n                    }\n                    return function*() {\n                        while(true){\n                            yield [\n                                (elt)=>{\n                                    if (!(\"prim\" in elt) || elt.prim !== \"Elt\") {\n                                        throw new MichelsonTypeError(t, `map element expected: ${JSON.stringify(elt)}`, elt);\n                                    }\n                                    return function*() {\n                                        for (const a of t.args){\n                                            yield getReadTransformFuncs(a);\n                                        }\n                                    }();\n                                },\n                                (elt)=>elt\n                            ];\n                        }\n                    }();\n                },\n                (d)=>d\n            ];\n        case \"chain_id\":\n            return [\n                ()=>[][Symbol.iterator](),\n                (d)=>{\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, `chain id expected: ${JSON.stringify(d)}`, d);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, `can't parse bytes: ${d.bytes}`, d);\n                    }\n                    return {\n                        string: encodeTezosID(\"ChainID\", bytes)\n                    };\n                }\n            ];\n        case \"signature\":\n            return [\n                ()=>[][Symbol.iterator](),\n                (d)=>{\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, `signature expected: ${JSON.stringify(d)}`, d);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, `can't parse bytes: ${d.bytes}`, d);\n                    }\n                    return {\n                        string: encodeTezosID(\"GenericSignature\", bytes)\n                    };\n                }\n            ];\n        case \"key_hash\":\n            return [\n                ()=>[][Symbol.iterator](),\n                (d)=>{\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, `key hash expected: ${JSON.stringify(d)}`, d);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, `can't parse bytes: ${d.bytes}`, d);\n                    }\n                    const rd = new Reader(new Uint8Array(bytes));\n                    const addr = readPublicKeyHash(rd);\n                    return {\n                        string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? \"%\" + addr.entryPoint : \"\")\n                    };\n                }\n            ];\n        case \"key\":\n            return [\n                ()=>[][Symbol.iterator](),\n                (d)=>{\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, `public key expected: ${JSON.stringify(d)}`, d);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, `can't parse bytes: ${d.bytes}`, d);\n                    }\n                    const rd = new Reader(new Uint8Array(bytes));\n                    const pk = readPublicKey(rd);\n                    return {\n                        string: encodeTezosID(pk.type, pk.publicKey)\n                    };\n                }\n            ];\n        case \"address\":\n            return [\n                ()=>[][Symbol.iterator](),\n                (d)=>{\n                    if (!(\"bytes\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, `address expected: ${JSON.stringify(d)}`, d);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const bytes = parseBytes(d.bytes);\n                    if (bytes === null) {\n                        throw new MichelsonTypeError(t, `can't parse bytes: ${d.bytes}`, d);\n                    }\n                    const rd = new Reader(new Uint8Array(bytes));\n                    const addr = readAddress(rd);\n                    return {\n                        string: encodeTezosID(addr.type, addr.hash) + (addr.entryPoint ? \"%\" + addr.entryPoint : \"\")\n                    };\n                }\n            ];\n        case \"timestamp\":\n            return [\n                ()=>[][Symbol.iterator](),\n                (d)=>{\n                    if (!(\"int\" in d) && !(\"string\" in d)) {\n                        throw new MichelsonTypeError(t, `address expected: ${JSON.stringify(d)}`, d);\n                    }\n                    if (\"string\" in d) {\n                        return d;\n                    }\n                    const date = new Date(parseInt(d.int, 10) * 1000);\n                    return {\n                        string: date.toISOString().slice(0, 19) + \"Z\"\n                    };\n                }\n            ];\n        default:\n            return readPassThrough;\n    }\n};\nconst readPassThrough = [\n    (e)=>{\n        if (isPushInstruction(e)) {\n            assertMichelsonInstruction(e);\n            // capture inlined type definition\n            return function*() {\n                yield readPassThrough;\n                yield getReadTransformFuncs(e.args[0]);\n            }();\n        }\n        return function*() {\n            while(true){\n                yield readPassThrough;\n            }\n        }();\n    },\n    (e)=>e\n];\n/**\n * Deserialize a byte array into the corresponding Michelson value.\n * Without a type definition (not recommended) the binary data will be treated as a binary form of a generic Michelson expression and returned as is.\n * Type definition allows some types like `timestamp` and `address` and other types usually encoded in optimized binary forms to be transformed\n * back to their string representations like base58 and ISO timestamps.\n *\n * ```typescript\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\n *\n * const typ: MichelsonType = {\n *     prim: \"timestamp\"\n * };\n *\n * const data = unpackData(src, typ);\n *\n * // { string: \"2019-09-26T10:59:51Z\" }\n * ```\n *\n * Same binary data without a type definition\n * ```typescript\n * const src = [0x05, 0x00, 0xa7, 0xe8, 0xe4, 0xd8, 0x0b];\n *\n * const data = unpackData(src);\n *\n * // { int: \"1569495591\" }\n * ```\n * @param src Byte array\n * @param t Optional type definition\n * @returns Deserialized data\n */ function unpackData(src, t) {\n    const r = new Reader(src);\n    if (r.readUint8() !== 5) {\n        throw new Error(\"incorrect packed data magic number\");\n    }\n    const ex = readExpr(r, t !== undefined ? getReadTransformFuncs(t) : readPassThrough);\n    if (assertMichelsonData(ex)) {\n        return ex;\n    }\n    throw new Error(); // never\n}\n/**\n * Deserialize a byte array into the corresponding Michelson value.\n * Same as {@link unpackData} but takes a `bytes` Michelson data literal instead of an array\n *\n * ```typescript\n * const src = { bytes: \"0500a7e8e4d80b\" };\n *\n * const typ: MichelsonType = {\n *     prim: \"timestamp\"\n * };\n *\n * const data = unpackDataBytes(src, typ);\n *\n * // { string: \"2019-09-26T10:59:51Z\" }\n * ```\n * @param src Bytes object\n * @param t Optional type definition\n * @returns Deserialized data\n */ function unpackDataBytes(src, t) {\n    const bytes = parseBytes(src.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${src.bytes}\"`);\n    }\n    return unpackData(bytes, t);\n}\n// helper functions also used by validator\nfunction decodeAddressBytes(b) {\n    const bytes = parseBytes(b.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${b.bytes}\"`);\n    }\n    const rd = new Reader(new Uint8Array(bytes));\n    return readAddress(rd);\n}\nfunction decodePublicKeyHashBytes(b) {\n    const bytes = parseBytes(b.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${b.bytes}\"`);\n    }\n    const rd = new Reader(new Uint8Array(bytes));\n    return readPublicKeyHash(rd);\n}\nfunction decodePublicKeyBytes(b) {\n    const bytes = parseBytes(b.bytes);\n    if (bytes === null) {\n        throw new Error(`can't parse bytes: \"${b.bytes}\"`);\n    }\n    const rd = new Reader(new Uint8Array(bytes));\n    return readPublicKey(rd);\n}\nclass MichelsonInstructionError extends MichelsonError {\n    /**\n     * @param val Value of a type node caused the error\n     * @param stackState Current stack state\n     * @param message An error message\n     */ constructor(val, stackState, message){\n        super(val, message);\n        this.val = val;\n        this.stackState = stackState;\n        this.message = message;\n        this.name = \"MichelsonInstructionError\";\n    }\n}\n// 'sequence as a pair' edo syntax helpers\nfunction typeID(t) {\n    return Array.isArray(t) ? \"pair\" : t.prim;\n}\nfunction typeArgs(t) {\n    return \"prim\" in t ? t.args : t;\n}\nfunction assertScalarTypesEqual(a, b, field = false) {\n    if (typeID(a) !== typeID(b)) {\n        throw new MichelsonTypeError(a, `types mismatch: ${typeID(a)} != ${typeID(b)}`, undefined);\n    }\n    const ann = [\n        unpackAnnotations(a),\n        unpackAnnotations(b)\n    ];\n    if (ann[0].t && ann[1].t && ann[0].t[0] !== ann[1].t[0]) {\n        throw new MichelsonTypeError(a, `${typeID(a)}: type names mismatch: ${ann[0].t[0]} != ${ann[1].t[0]}`, undefined);\n    }\n    if (field && ann[0].f && ann[1].f && ann[0].f[0] !== ann[1].f[0]) {\n        throw new MichelsonTypeError(a, `${typeID(a)}: field names mismatch: ${ann[0].f[0]} != ${ann[1].f}`, undefined);\n    }\n    if (isPairType(a)) {\n        const aArgs = unpackComb(\"pair\", a);\n        const bArgs = unpackComb(\"pair\", b);\n        assertScalarTypesEqual(aArgs.args[0], bArgs.args[0], true);\n        assertScalarTypesEqual(aArgs.args[1], bArgs.args[1], true);\n        return;\n    }\n    switch(a.prim){\n        case \"option\":\n        case \"list\":\n        case \"contract\":\n        case \"set\":\n        case \"ticket\":\n            assertScalarTypesEqual(a.args[0], b.args[0]);\n            break;\n        case \"or\":\n            assertScalarTypesEqual(a.args[0], b.args[0], true);\n            assertScalarTypesEqual(a.args[1], b.args[1], true);\n            break;\n        case \"lambda\":\n        case \"map\":\n        case \"big_map\":\n            assertScalarTypesEqual(a.args[0], b.args[0]);\n            assertScalarTypesEqual(a.args[1], b.args[1]);\n            break;\n        case \"sapling_state\":\n        case \"sapling_transaction\":\n            if (parseInt(a.args[0].int, 10) !== parseInt(b.args[0].int, 10)) {\n                throw new MichelsonTypeError(a, `${typeID(a)}: type argument mismatch: ${a.args[0].int} != ${b.args[0].int}`, undefined);\n            }\n    }\n}\nfunction assertStacksEqual(a, b) {\n    if (a.length !== b.length) {\n        throw new MichelsonTypeError(a, `stack length mismatch: ${a.length} != ${b.length}`, undefined);\n    }\n    for(let i = 0; i < a.length; i++){\n        assertScalarTypesEqual(a[i], b[i]);\n    }\n}\nfunction assertTypeAnnotationsValid(t, field = false) {\n    var _a, _b, _c;\n    if (!Array.isArray(t)) {\n        const ann = unpackAnnotations(t);\n        if ((((_a = ann.t) === null || _a === void 0 ? void 0 : _a.length) || 0) > 1) {\n            throw new MichelsonTypeError(t, `${t.prim}: at most one type annotation allowed: ${t.annots}`, undefined);\n        }\n        if (field) {\n            if ((((_b = ann.f) === null || _b === void 0 ? void 0 : _b.length) || 0) > 1) {\n                throw new MichelsonTypeError(t, `${t.prim}: at most one field annotation allowed: ${t.annots}`, undefined);\n            }\n        } else {\n            if ((((_c = ann.f) === null || _c === void 0 ? void 0 : _c.length) || 0) > 0) {\n                throw new MichelsonTypeError(t, `${t.prim}: field annotations aren't allowed: ${t.annots}`, undefined);\n            }\n        }\n    }\n    if (isPairType(t)) {\n        const args = typeArgs(t);\n        for (const a of args){\n            assertTypeAnnotationsValid(a, true);\n        }\n        return;\n    }\n    switch(t.prim){\n        case \"option\":\n        case \"list\":\n        case \"contract\":\n        case \"set\":\n            assertTypeAnnotationsValid(t.args[0]);\n            break;\n        case \"or\":\n            for (const a of t.args){\n                assertTypeAnnotationsValid(a, true);\n            }\n            break;\n        case \"lambda\":\n        case \"map\":\n        case \"big_map\":\n            assertTypeAnnotationsValid(t.args[0]);\n            assertTypeAnnotationsValid(t.args[1]);\n    }\n}\n// Simplified version of assertMichelsonInstruction() for previously validated data\nfunction isFunction(d) {\n    if (!Array.isArray(d)) {\n        return false;\n    }\n    for (const v of d){\n        if (!(Array.isArray(v) && isFunction(v) || \"prim\" in v && isInstruction(v))) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction assertDataValidInternal(d, t, ctx) {\n    if (isPairType(t)) {\n        if (isPairData(d)) {\n            assertDataListIfAny(d);\n            const dc = unpackComb(\"Pair\", d);\n            const tc = unpackComb(\"pair\", t);\n            assertDataValidInternal(dc.args[0], tc.args[0], ctx);\n            assertDataValidInternal(dc.args[1], tc.args[1], ctx);\n            return;\n        }\n        throw new MichelsonTypeError(t, `pair expected: ${JSON.stringify(d)}`, d);\n    }\n    switch(t.prim){\n        // Atomic literals\n        case \"int\":\n            if (\"int\" in d && isDecimal(d.int)) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `integer value expected: ${JSON.stringify(d)}`, d);\n        case \"nat\":\n        case \"mutez\":\n            if (\"int\" in d && isNatural(d.int)) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `natural value expected: ${JSON.stringify(d)}`, d);\n        case \"string\":\n            if (\"string\" in d) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `string value expected: ${JSON.stringify(d)}`, d);\n        case \"bytes\":\n        case \"bls12_381_g1\":\n        case \"bls12_381_g2\":\n            if (\"bytes\" in d && parseBytes(d.bytes) !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `bytes value expected: ${JSON.stringify(d)}`, d);\n        case \"bool\":\n            if (\"prim\" in d && (d.prim === \"True\" || d.prim === \"False\")) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `boolean value expected: ${JSON.stringify(d)}`, d);\n        case \"key_hash\":\n            if (\"string\" in d && checkDecodeTezosID(d.string, \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\") !== null) {\n                return;\n            } else if (\"bytes\" in d) {\n                try {\n                    decodePublicKeyHashBytes(d);\n                    return;\n                } catch (err) {\n                // ignore message\n                }\n            }\n            throw new MichelsonTypeError(t, `key hash expected: ${JSON.stringify(d)}`, d);\n        case \"timestamp\":\n            if ((\"string\" in d || \"int\" in d) && parseDate(d) !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `timestamp expected: ${JSON.stringify(d)}`, d);\n        case \"address\":\n            if (\"string\" in d) {\n                let address = d.string;\n                const ep = d.string.indexOf(\"%\");\n                if (ep >= 0) {\n                    // trim entry point\n                    address = d.string.slice(0, ep);\n                }\n                if (checkDecodeTezosID(address, \"ED25519PublicKeyHash\", \"SECP256K1PublicKeyHash\", \"P256PublicKeyHash\", \"ContractHash\", \"RollupAddress\") !== null) {\n                    return;\n                }\n            } else if (\"bytes\" in d) {\n                try {\n                    decodeAddressBytes(d);\n                    return;\n                } catch (err) {\n                // ignore message\n                }\n            }\n            throw new MichelsonTypeError(t, `address expected: ${JSON.stringify(d)}`, d);\n        case \"key\":\n            if (\"string\" in d && checkDecodeTezosID(d.string, \"ED25519PublicKey\", \"SECP256K1PublicKey\", \"P256PublicKey\") !== null) {\n                return;\n            } else if (\"bytes\" in d) {\n                try {\n                    decodePublicKeyBytes(d);\n                    return;\n                } catch (err) {\n                // ignore message\n                }\n            }\n            throw new MichelsonTypeError(t, `public key expected: ${JSON.stringify(d)}`, d);\n        case \"unit\":\n            if (\"prim\" in d && d.prim === \"Unit\") {\n                return;\n            }\n            throw new MichelsonTypeError(t, `unit value expected: ${JSON.stringify(d)}`, d);\n        case \"signature\":\n            if (\"bytes\" in d || \"string\" in d && checkDecodeTezosID(d.string, \"ED25519Signature\", \"SECP256K1Signature\", \"P256Signature\", \"GenericSignature\") !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `signature expected: ${JSON.stringify(d)}`, d);\n        case \"chain_id\":\n            if (\"bytes\" in d || \"string\" in d) {\n                const x = \"string\" in d ? decodeBase58Check(d.string) : parseBytes(d.bytes);\n                if (x !== null) {\n                    return;\n                }\n            }\n            throw new MichelsonTypeError(t, `chain id expected: ${JSON.stringify(d)}`, d);\n        // Complex types\n        case \"option\":\n            if (\"prim\" in d) {\n                if (d.prim === \"None\") {\n                    return;\n                } else if (d.prim === \"Some\") {\n                    assertDataValidInternal(d.args[0], t.args[0], ctx);\n                    return;\n                }\n            }\n            throw new MichelsonTypeError(t, `option expected: ${JSON.stringify(d)}`, d);\n        case \"list\":\n        case \"set\":\n            if (assertDataListIfAny(d)) {\n                //let prev: MichelsonData | undefined;\n                for (const v of d){\n                    assertDataValidInternal(v, t.args[0], ctx);\n                }\n                return;\n            }\n            throw new MichelsonTypeError(t, `${t.prim} expected: ${JSON.stringify(d)}`, d);\n        case \"or\":\n            if (\"prim\" in d) {\n                if (d.prim === \"Left\") {\n                    assertDataValidInternal(d.args[0], t.args[0], ctx);\n                    return;\n                } else if (d.prim === \"Right\") {\n                    assertDataValidInternal(d.args[0], t.args[1], ctx);\n                    return;\n                }\n            }\n            throw new MichelsonTypeError(t, `union (or) expected: ${JSON.stringify(d)}`, d);\n        case \"lambda\":\n            if (isFunction(d)) {\n                const ret = functionTypeInternal(d, [\n                    t.args[0]\n                ], ctx);\n                if (\"failed\" in ret) {\n                    throw new MichelsonTypeError(t, `function is failed with error type: ${ret.failed}`, d);\n                }\n                if (ret.length !== 1) {\n                    throw new MichelsonTypeError(t, \"function must return a value\", d);\n                }\n                assertScalarTypesEqual(t.args[1], ret[0]);\n                return;\n            }\n            throw new MichelsonTypeError(t, `function expected: ${JSON.stringify(d)}`, d);\n        case \"map\":\n        case \"big_map\":\n            if (Array.isArray(d)) {\n                //let prev: MichelsonMapElt | undefined;\n                for (const v of d){\n                    if (!(\"prim\" in v) || v.prim !== \"Elt\") {\n                        throw new MichelsonTypeError(t, `map elements expected: ${JSON.stringify(d)}`, d);\n                    }\n                    assertDataValidInternal(v.args[0], t.args[0], ctx);\n                    assertDataValidInternal(v.args[1], t.args[1], ctx);\n                }\n                return;\n            }\n            throw new MichelsonTypeError(t, `${t.prim} expected: ${JSON.stringify(d)}`, d);\n        case \"bls12_381_fr\":\n            if (\"int\" in d && isDecimal(d.int) || \"bytes\" in d && parseBytes(d.bytes) !== null) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `BLS12-381 element expected: ${JSON.stringify(d)}`, d);\n        case \"sapling_state\":\n            if (Array.isArray(d)) {\n                return;\n            }\n            throw new MichelsonTypeError(t, `sapling state expected: ${JSON.stringify(d)}`, d);\n        case \"ticket\":\n            assertDataValidInternal(d, {\n                prim: \"pair\",\n                args: [\n                    {\n                        prim: \"address\"\n                    },\n                    t.args[0],\n                    {\n                        prim: \"nat\"\n                    }\n                ]\n            }, ctx);\n            return;\n        default:\n            throw new MichelsonTypeError(t, `type ${typeID(t)} don't have Michelson literal representation`, d);\n    }\n}\nfunction instructionListType(inst, stack, ctx) {\n    let ret = stack;\n    let s = stack;\n    let i = 0;\n    for (const op of inst){\n        const ft = functionTypeInternal(op, s, ctx);\n        ret = ft;\n        if (\"failed\" in ft) {\n            break;\n        }\n        s = ft;\n        i++;\n    }\n    if (\"failed\" in ret && ret.level == 0 && (!(\"prim\" in ret.failed) || ret.failed.prim !== \"never\") && i !== inst.length - 1) {\n        throw new MichelsonInstructionError(inst, ret, \"FAIL must appear in a tail position\");\n    }\n    if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {\n        const trace = {\n            op: inst,\n            in: stack,\n            out: ret\n        };\n        ctx.traceCallback(trace);\n    }\n    return \"failed\" in ret ? {\n        failed: ret.failed,\n        level: ret.level + 1\n    } : ret;\n}\nfunction functionTypeInternal(inst, stack, ctx) {\n    const proto = (ctx === null || ctx === void 0 ? void 0 : ctx.protocol) || DefaultProtocol;\n    if (Array.isArray(inst)) {\n        return instructionListType(inst, stack, ctx);\n    }\n    const instruction = inst; // Make it const for type guarding\n    // make sure the stack has enough number of arguments of specific types\n    function args(n, ...typeIds) {\n        if (stack.length < typeIds.length + n) {\n            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack must have at least ${typeIds.length} element(s)`);\n        }\n        let i = n;\n        for (const ids of typeIds){\n            if (ids !== null && ids.length !== 0) {\n                let ii = 0;\n                while(ii < ids.length && ids[ii] !== typeID(stack[i])){\n                    ii++;\n                }\n                if (ii === ids.length) {\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: stack type mismatch: [${i}] expected to be ${ids}, got ${typeID(stack[i])} instead`);\n                }\n            }\n            i++;\n        }\n        return stack.slice(n, typeIds.length + n);\n    }\n    function rethrow(fn) {\n        return (...args)=>{\n            try {\n                return fn(...args);\n            } catch (err) {\n                if (err instanceof MichelsonError) {\n                    throw new MichelsonInstructionError(instruction, stack, err.message);\n                } else {\n                    throw err;\n                }\n            }\n        };\n    }\n    function rethrowTypeGuard(fn) {\n        return (arg)=>{\n            try {\n                return fn(arg);\n            } catch (err) {\n                if (err instanceof MichelsonError) {\n                    throw new MichelsonInstructionError(instruction, stack, err.message);\n                } else {\n                    throw err;\n                }\n            }\n        };\n    }\n    const argAnn = rethrow(unpackAnnotations);\n    const ensureStacksEqual = rethrow(assertStacksEqual);\n    const ensureTypesEqual = rethrow(assertScalarTypesEqual);\n    const ensureComparableType = rethrowTypeGuard(assertMichelsonComparableType);\n    const ensurePackableType = rethrowTypeGuard(assertMichelsonPackableType);\n    const ensureStorableType = rethrowTypeGuard(assertMichelsonStorableType);\n    const ensurePushableType = rethrowTypeGuard(assertMichelsonPushableType);\n    const ensureBigMapStorableType = rethrowTypeGuard(assertMichelsonBigMapStorableType);\n    // unpack instruction annotations and assert their maximum number\n    function instructionAnn(num, opt) {\n        const a = argAnn(instruction, Object.assign(Object.assign({}, opt), {\n            emptyFields: num.f !== undefined && num.f > 1,\n            emptyVar: num.v !== undefined && num.v > 1\n        }));\n        const assertNum = (a, n, type)=>{\n            if (a && a.length > (n || 0)) {\n                throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at most ${n || 0} ${type} annotations allowed`);\n            }\n        };\n        assertNum(a.f, num.f, \"field\");\n        assertNum(a.t, num.t, \"type\");\n        assertNum(a.v, num.v, \"variable\");\n        return a;\n    }\n    // also keeps annotation class if null is provided\n    function annotate(tt, a) {\n        const tx = tt;\n        const t = Array.isArray(tx) ? {\n            prim: \"pair\",\n            args: tx\n        } : tx;\n        const src = argAnn(t);\n        const ann = a.v !== undefined || a.t !== undefined || a.f !== undefined ? [\n            ...(a.v === null ? src.v : a.v) || [],\n            ...(a.t === null ? src.t : a.t) || [],\n            ...(a.f === null ? src.f : a.f) || []\n        ] : undefined;\n        const rest = __rest(t, [\n            \"annots\"\n        ]);\n        return Object.assign(Object.assign({}, rest), ann && ann.length !== 0 && {\n            annots: ann\n        });\n    }\n    // shortcut to copy at most one variable annotation from the instruction to the type\n    function annotateVar(t, def) {\n        const ia = instructionAnn({\n            v: 1\n        });\n        return annotate(t, {\n            v: ia.v !== undefined ? ia.v : def !== undefined ? [\n                def\n            ] : null,\n            t: null\n        });\n    }\n    // annotate CAR/CDR/UNPAIR/GET\n    function annotateField(arg, field, insAnn, n, defField) {\n        var _a, _b, _c, _d;\n        const fieldAnn = (_a = argAnn(field).f) === null || _a === void 0 ? void 0 : _a[0]; // field's field annotation\n        const insFieldAnn = (_b = insAnn.f) === null || _b === void 0 ? void 0 : _b[n];\n        if (insFieldAnn !== undefined && insFieldAnn !== \"%\" && fieldAnn !== undefined && insFieldAnn !== fieldAnn) {\n            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: field names doesn't match: ${insFieldAnn} !== ${fieldAnn}`);\n        }\n        const insVarAnn = (_c = insAnn.v) === null || _c === void 0 ? void 0 : _c[n]; // nth instruction's variable annotation\n        const varAnn = (_d = argAnn(arg).v) === null || _d === void 0 ? void 0 : _d[0]; // instruction argument's variable annotation\n        return annotate(field, {\n            t: null,\n            v: insVarAnn ? insVarAnn === \"@%\" ? fieldAnn ? [\n                \"@\" + fieldAnn.slice(1)\n            ] : undefined : insVarAnn === \"@%%\" ? varAnn ? [\n                \"@\" + varAnn.slice(1) + \".\" + (fieldAnn ? fieldAnn.slice(1) : defField)\n            ] : fieldAnn ? [\n                \"@\" + fieldAnn.slice(1)\n            ] : undefined : [\n                insVarAnn\n            ] : null\n        });\n    }\n    // comb helper functions\n    function getN(src, n, i = n) {\n        const p = unpackComb(\"pair\", src);\n        if (i === 1) {\n            return [\n                p.args[0]\n            ];\n        } else if (i === 2) {\n            return p.args;\n        }\n        const right = p.args[1];\n        if (isPairType(right)) {\n            return [\n                p.args[0],\n                ...getN(right, n, i - 1)\n            ];\n        } else {\n            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n} fields are expected`);\n        }\n    }\n    function getNth(src, n, i = n) {\n        if (i === 0) {\n            return src;\n        }\n        const p = unpackComb(\"pair\", src);\n        if (i === 1) {\n            return p.args[0];\n        }\n        const right = p.args[1];\n        if (isPairType(right)) {\n            return getNth(right, n, i - 2);\n        } else if (i === 2) {\n            return right;\n        }\n        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);\n    }\n    function updateNth(src, x, n, i = n) {\n        if (i === 0) {\n            return x;\n        }\n        const p = unpackComb(\"pair\", src);\n        if (i === 1) {\n            return Object.assign(Object.assign({}, p), {\n                args: [\n                    x,\n                    p.args[1]\n                ]\n            });\n        }\n        const right = p.args[1];\n        if (isPairType(right)) {\n            return Object.assign(Object.assign({}, p), {\n                args: [\n                    p.args[0],\n                    updateNth(right, x, n, i - 2)\n                ]\n            });\n        } else if (i === 2) {\n            return Object.assign(Object.assign({}, p), {\n                args: [\n                    p.args[0],\n                    x\n                ]\n            });\n        }\n        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: at least ${n + 1} fields are expected`);\n    }\n    const varSuffix = (a, suffix)=>[\n            \"@\" + (a.v ? a.v[0].slice(1) + \".\" : \"\") + suffix\n        ];\n    function branchType(br0, br1) {\n        if (\"failed\" in br0 || \"failed\" in br1) {\n            return \"failed\" in br0 ? br1 : br0;\n        } else {\n            ensureStacksEqual(br0, br1);\n            return br0;\n        }\n    }\n    const retStack = ((instruction)=>{\n        var _a, _b, _c, _d, _e;\n        switch(instruction.prim){\n            case \"DUP\":\n                {\n                    const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 1;\n                    if (n === 0) {\n                        throw new MichelsonInstructionError(instruction, stack, \"DUP 0 is forbidden\");\n                    }\n                    const s = args(n - 1, null)[0];\n                    if (typeID(s) === \"ticket\") {\n                        throw new MichelsonInstructionError(instruction, stack, \"ticket can't be DUPed\");\n                    }\n                    return [\n                        s,\n                        ...stack\n                    ];\n                }\n            case \"SWAP\":\n                {\n                    const s = args(0, null, null);\n                    instructionAnn({});\n                    return [\n                        s[1],\n                        s[0],\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"SOME\":\n                return [\n                    annotate({\n                        prim: \"option\",\n                        args: [\n                            args(0, null)[0]\n                        ]\n                    }, instructionAnn({\n                        t: 1,\n                        v: 1\n                    })),\n                    ...stack.slice(1)\n                ];\n            case \"UNIT\":\n                return [\n                    annotate({\n                        prim: \"unit\"\n                    }, instructionAnn({\n                        v: 1,\n                        t: 1\n                    })),\n                    ...stack\n                ];\n            case \"PAIR\":\n                {\n                    const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;\n                    if (n < 2) {\n                        throw new MichelsonInstructionError(instruction, stack, `PAIR ${n} is forbidden`);\n                    }\n                    const s = args(0, ...new Array(n).fill(null));\n                    const ia = instructionAnn({\n                        f: n,\n                        t: 1,\n                        v: 1\n                    }, {\n                        specialFields: true\n                    });\n                    const trim = (s)=>{\n                        const i = s.lastIndexOf(\".\");\n                        return s.slice(i > 0 ? i + 1 : 1);\n                    };\n                    const retArgs = s.map((v, i)=>{\n                        var _a;\n                        const va = argAnn(v);\n                        const f = ia.f && ia.f.length > i && ia.f[i] !== \"%\" ? ia.f[i] === \"%@\" ? va.v ? [\n                            \"%\" + trim(((_a = va.v) === null || _a === void 0 ? void 0 : _a[0]) || \"\")\n                        ] : undefined : [\n                            ia.f[i]\n                        ] : undefined;\n                        return annotate(v, {\n                            v: null,\n                            t: null,\n                            f\n                        });\n                    });\n                    return [\n                        annotate({\n                            prim: \"pair\",\n                            args: retArgs\n                        }, {\n                            t: ia.t,\n                            v: ia.v\n                        }),\n                        ...stack.slice(n)\n                    ];\n                }\n            case \"UNPAIR\":\n                {\n                    const n = instruction.args ? parseInt(instruction.args[0].int, 10) : 2;\n                    if (n < 2) {\n                        throw new MichelsonInstructionError(instruction, stack, `UNPAIR ${n} is forbidden`);\n                    }\n                    const s = args(0, [\n                        \"pair\"\n                    ])[0];\n                    const ia = instructionAnn({\n                        f: 2,\n                        v: 2\n                    }, {\n                        specialVar: true\n                    });\n                    const fields = getN(s, n);\n                    return [\n                        ...fields.map((field, i)=>annotateField(s, field, ia, i, i === 0 ? \"car\" : \"cdr\")),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"CAR\":\n            case \"CDR\":\n                {\n                    const s = unpackComb(\"pair\", args(0, [\n                        \"pair\"\n                    ])[0]);\n                    const field = s.args[instruction.prim === \"CAR\" ? 0 : 1];\n                    const ia = instructionAnn({\n                        f: 1,\n                        v: 1\n                    }, {\n                        specialVar: true\n                    });\n                    return [\n                        annotateField(s, field, ia, 0, instruction.prim.toLocaleLowerCase()),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"CONS\":\n                {\n                    const s = args(0, null, [\n                        \"list\"\n                    ]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [\n                        annotateVar({\n                            prim: \"list\",\n                            args: [\n                                s[1].args[0]\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"SIZE\":\n                args(0, [\n                    \"string\",\n                    \"list\",\n                    \"set\",\n                    \"map\",\n                    \"bytes\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"MEM\":\n                {\n                    const s = args(0, null, [\n                        \"set\",\n                        \"map\",\n                        \"big_map\"\n                    ]);\n                    ensureComparableType(s[0]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [\n                        annotateVar({\n                            prim: \"bool\"\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"GET\":\n                if (instruction.args) {\n                    // comb operation\n                    const n = parseInt(instruction.args[0].int, 10);\n                    const s = args(0, [\n                        \"pair\"\n                    ])[0];\n                    return [\n                        annotateVar(getNth(s, n)),\n                        ...stack.slice(1)\n                    ];\n                } else {\n                    // map operation\n                    const s = args(0, null, [\n                        \"map\",\n                        \"big_map\"\n                    ]);\n                    ensureComparableType(s[0]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                s[1].args[1]\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"UPDATE\":\n                if (instruction.args) {\n                    // comb operation\n                    const n = parseInt(instruction.args[0].int, 10);\n                    const s = args(0, null, [\n                        \"pair\"\n                    ]);\n                    return [\n                        annotateVar(updateNth(s[1], s[0], n)),\n                        ...stack.slice(2)\n                    ];\n                } else {\n                    // map operation\n                    const s0 = args(0, null, [\n                        \"bool\",\n                        \"option\"\n                    ]);\n                    ensureComparableType(s0[0]);\n                    if (s0[1].prim === \"bool\") {\n                        const s1 = args(2, [\n                            \"set\"\n                        ]);\n                        ensureTypesEqual(s0[0], s1[0].args[0]);\n                        return [\n                            annotateVar({\n                                prim: \"set\",\n                                args: [\n                                    annotate(s0[0], {\n                                        t: null\n                                    })\n                                ]\n                            }),\n                            ...stack.slice(3)\n                        ];\n                    }\n                    const s1 = args(2, [\n                        \"map\",\n                        \"big_map\"\n                    ]);\n                    ensureTypesEqual(s0[0], s1[0].args[0]);\n                    if (s1[0].prim === \"map\") {\n                        return [\n                            annotateVar({\n                                prim: \"map\",\n                                args: [\n                                    annotate(s0[0], {\n                                        t: null\n                                    }),\n                                    annotate(s0[1].args[0], {\n                                        t: null\n                                    })\n                                ]\n                            }),\n                            ...stack.slice(3)\n                        ];\n                    }\n                    ensureBigMapStorableType(s0[1].args[0]);\n                    return [\n                        annotateVar({\n                            prim: \"big_map\",\n                            args: [\n                                annotate(s0[0], {\n                                    t: null\n                                }),\n                                annotate(s0[1].args[0], {\n                                    t: null\n                                })\n                            ]\n                        }),\n                        ...stack.slice(3)\n                    ];\n                }\n            case \"GET_AND_UPDATE\":\n                {\n                    const ia = instructionAnn({\n                        v: 2\n                    });\n                    const s = args(0, null, [\n                        \"option\"\n                    ], [\n                        \"map\",\n                        \"big_map\"\n                    ]);\n                    ensureComparableType(s[0]);\n                    ensureTypesEqual(s[0], s[2].args[0]);\n                    ensureTypesEqual(s[1].args[0], s[2].args[1]);\n                    const va = (_a = ia.v) === null || _a === void 0 ? void 0 : _a.map((v)=>v !== \"@\" ? [\n                            v\n                        ] : undefined);\n                    if (s[2].prim === \"map\") {\n                        return [\n                            annotate({\n                                prim: \"option\",\n                                args: [\n                                    s[2].args[1]\n                                ]\n                            }, {\n                                v: va === null || va === void 0 ? void 0 : va[0]\n                            }),\n                            annotate({\n                                prim: \"map\",\n                                args: [\n                                    annotate(s[0], {\n                                        t: null\n                                    }),\n                                    annotate(s[1].args[0], {\n                                        t: null\n                                    })\n                                ]\n                            }, {\n                                v: va === null || va === void 0 ? void 0 : va[1]\n                            }),\n                            ...stack.slice(3)\n                        ];\n                    }\n                    ensureBigMapStorableType(s[1].args[0]);\n                    return [\n                        annotate({\n                            prim: \"option\",\n                            args: [\n                                s[2].args[1]\n                            ]\n                        }, {\n                            v: va === null || va === void 0 ? void 0 : va[0]\n                        }),\n                        annotate({\n                            prim: \"big_map\",\n                            args: [\n                                annotate(s[0], {\n                                    t: null\n                                }),\n                                annotate(s[1].args[0], {\n                                    t: null\n                                })\n                            ]\n                        }, {\n                            v: va === null || va === void 0 ? void 0 : va[1]\n                        }),\n                        ...stack.slice(3)\n                    ];\n                }\n            case \"EXEC\":\n                {\n                    const s = args(0, null, [\n                        \"lambda\"\n                    ]);\n                    ensureTypesEqual(s[0], s[1].args[0]);\n                    return [\n                        annotateVar(s[1].args[1]),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"APPLY\":\n                {\n                    const s = args(0, null, [\n                        \"lambda\"\n                    ]);\n                    ensureStorableType(s[0]);\n                    ensurePushableType(s[0]);\n                    if (!isPairType(s[1].args[0])) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function's argument must be a pair: ${typeID(s[1].args[0])}`);\n                    }\n                    const pt = s[1].args[0];\n                    ensureTypesEqual(s[0], typeArgs(pt)[0]);\n                    return [\n                        annotateVar({\n                            prim: \"lambda\",\n                            args: [\n                                typeArgs(pt)[1],\n                                s[1].args[1]\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"FAILWITH\":\n                {\n                    const s = args(0, null)[0];\n                    if (!ProtoInferiorTo(proto, Protocol.PtEdo2Zk)) {\n                        ensurePackableType(s);\n                    }\n                    return {\n                        failed: s,\n                        level: 0\n                    };\n                }\n            case \"NEVER\":\n                args(0, [\n                    \"never\"\n                ]);\n                return {\n                    failed: {\n                        prim: \"never\"\n                    },\n                    level: 0\n                };\n            case \"RENAME\":\n                return [\n                    annotateVar(args(0, null)[0]),\n                    ...stack.slice(1)\n                ];\n            case \"CONCAT\":\n                {\n                    const s0 = args(0, [\n                        \"string\",\n                        \"list\",\n                        \"bytes\"\n                    ]);\n                    if (s0[0].prim === \"list\") {\n                        if (typeID(s0[0].args[0]) !== \"string\" && typeID(s0[0].args[0]) !== \"bytes\") {\n                            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't concatenate list of ${typeID(s0[0].args[0])}'s`);\n                        }\n                        return [\n                            annotateVar(s0[0].args[0]),\n                            ...stack.slice(1)\n                        ];\n                    }\n                    const s1 = args(1, [\n                        \"string\",\n                        \"bytes\"\n                    ]);\n                    if (s0[0].prim !== s1[0].prim) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't concatenate ${s0[0].prim} with ${s1[0].prim}`);\n                    }\n                    return [\n                        annotateVar(s1[0]),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"SLICE\":\n                return [\n                    annotateVar({\n                        prim: \"option\",\n                        args: [\n                            args(0, [\n                                \"nat\"\n                            ], [\n                                \"nat\"\n                            ], [\n                                \"string\",\n                                \"bytes\"\n                            ])[2]\n                        ]\n                    }, \"@slice\"),\n                    ...stack.slice(3)\n                ];\n            case \"PACK\":\n                {\n                    const s = args(0, null)[0];\n                    ensurePackableType(s);\n                    return [\n                        annotateVar({\n                            prim: \"bytes\"\n                        }, \"@packed\"),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"ADD\":\n                {\n                    const s = args(0, [\n                        \"nat\",\n                        \"int\",\n                        \"timestamp\",\n                        \"mutez\",\n                        \"bls12_381_g1\",\n                        \"bls12_381_g2\",\n                        \"bls12_381_fr\"\n                    ], [\n                        \"nat\",\n                        \"int\",\n                        \"timestamp\",\n                        \"mutez\",\n                        \"bls12_381_g1\",\n                        \"bls12_381_g2\",\n                        \"bls12_381_fr\"\n                    ]);\n                    if (s[0].prim === \"nat\" && s[1].prim === \"int\" || s[0].prim === \"int\" && s[1].prim === \"nat\") {\n                        return [\n                            annotateVar({\n                                prim: \"int\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    } else if (s[0].prim === \"int\" && s[1].prim === \"timestamp\" || s[0].prim === \"timestamp\" && s[1].prim === \"int\") {\n                        return [\n                            annotateVar({\n                                prim: \"timestamp\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    } else if ((s[0].prim === \"int\" || s[0].prim === \"nat\" || s[0].prim === \"mutez\" || s[0].prim === \"bls12_381_g1\" || s[0].prim === \"bls12_381_g2\" || s[0].prim === \"bls12_381_fr\") && s[0].prim === s[1].prim) {\n                        return [\n                            annotateVar(s[0]),\n                            ...stack.slice(2)\n                        ];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't add ${s[0].prim} to ${s[1].prim}`);\n                }\n            case \"SUB\":\n                {\n                    const s = ProtoInferiorTo(proto, Protocol.PsiThaCa) ? args(0, [\n                        \"nat\",\n                        \"int\",\n                        \"timestamp\",\n                        \"mutez\"\n                    ], [\n                        \"nat\",\n                        \"int\",\n                        \"timestamp\",\n                        \"mutez\"\n                    ]) : args(0, [\n                        \"nat\",\n                        \"int\",\n                        \"timestamp\"\n                    ], [\n                        \"nat\",\n                        \"int\",\n                        \"timestamp\"\n                    ]);\n                    if ((s[0].prim === \"nat\" || s[0].prim === \"int\") && (s[1].prim === \"nat\" || s[1].prim === \"int\") || s[0].prim === \"timestamp\" && s[1].prim === \"timestamp\") {\n                        return [\n                            annotateVar({\n                                prim: \"int\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    } else if (s[0].prim === \"timestamp\" && s[1].prim === \"int\") {\n                        return [\n                            annotateVar({\n                                prim: \"timestamp\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    } else if (s[0].prim === \"mutez\" && s[1].prim === \"mutez\") {\n                        return [\n                            annotateVar({\n                                prim: \"mutez\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't subtract ${s[0].prim} from ${s[1].prim}`);\n                }\n            case \"SUB_MUTEZ\":\n                {\n                    args(0, [\n                        \"mutez\"\n                    ], [\n                        \"mutez\"\n                    ]);\n                    return [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                {\n                                    prim: \"mutez\"\n                                }\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"MUL\":\n                {\n                    const s = args(0, [\n                        \"nat\",\n                        \"int\",\n                        \"mutez\",\n                        \"bls12_381_g1\",\n                        \"bls12_381_g2\",\n                        \"bls12_381_fr\"\n                    ], [\n                        \"nat\",\n                        \"int\",\n                        \"mutez\",\n                        \"bls12_381_g1\",\n                        \"bls12_381_g2\",\n                        \"bls12_381_fr\"\n                    ]);\n                    if (s[0].prim === \"nat\" && s[1].prim === \"int\" || s[0].prim === \"int\" && s[1].prim === \"nat\") {\n                        return [\n                            annotateVar({\n                                prim: \"int\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    } else if (s[0].prim === \"nat\" && s[1].prim === \"mutez\" || s[0].prim === \"mutez\" && s[1].prim === \"nat\") {\n                        return [\n                            annotateVar({\n                                prim: \"mutez\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    } else if ((s[0].prim === \"bls12_381_g1\" || s[0].prim === \"bls12_381_g2\" || s[0].prim === \"bls12_381_fr\") && s[1].prim === \"bls12_381_fr\" || (s[0].prim === \"nat\" || s[0].prim === \"int\") && s[0].prim === s[1].prim) {\n                        return [\n                            annotateVar(s[0]),\n                            ...stack.slice(2)\n                        ];\n                    } else if ((s[0].prim === \"nat\" || s[0].prim === \"int\") && s[1].prim === \"bls12_381_fr\" || (s[1].prim === \"nat\" || s[1].prim === \"int\") && s[0].prim === \"bls12_381_fr\") {\n                        return [\n                            annotateVar({\n                                prim: \"bls12_381_fr\"\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't multiply ${s[0].prim} by ${s[1].prim}`);\n                }\n            case \"EDIV\":\n                {\n                    const res = (a, b)=>({\n                            prim: \"option\",\n                            args: [\n                                {\n                                    prim: \"pair\",\n                                    args: [\n                                        {\n                                            prim: a\n                                        },\n                                        {\n                                            prim: b\n                                        }\n                                    ]\n                                }\n                            ]\n                        });\n                    const s = args(0, [\n                        \"nat\",\n                        \"int\",\n                        \"mutez\"\n                    ], [\n                        \"nat\",\n                        \"int\",\n                        \"mutez\"\n                    ]);\n                    if (s[0].prim === \"nat\" && s[1].prim === \"nat\") {\n                        return [\n                            annotateVar(res(\"nat\", \"nat\")),\n                            ...stack.slice(2)\n                        ];\n                    } else if ((s[0].prim === \"nat\" || s[0].prim === \"int\") && (s[1].prim === \"nat\" || s[1].prim === \"int\")) {\n                        return [\n                            annotateVar(res(\"int\", \"nat\")),\n                            ...stack.slice(2)\n                        ];\n                    } else if (s[0].prim === \"mutez\" && s[1].prim === \"nat\") {\n                        return [\n                            annotateVar(res(\"mutez\", \"mutez\")),\n                            ...stack.slice(2)\n                        ];\n                    } else if (s[0].prim === \"mutez\" && s[1].prim === \"mutez\") {\n                        return [\n                            annotateVar(res(\"nat\", \"mutez\")),\n                            ...stack.slice(2)\n                        ];\n                    }\n                    throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: can't euclideally divide ${s[0].prim} by ${s[1].prim}`);\n                }\n            case \"ABS\":\n                args(0, [\n                    \"int\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"ISNAT\":\n                args(0, [\n                    \"int\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"option\",\n                        args: [\n                            {\n                                prim: \"nat\"\n                            }\n                        ]\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"INT\":\n                args(0, [\n                    \"nat\",\n                    \"bls12_381_fr\",\n                    \"bytes\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"int\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"BYTES\":\n                args(0, [\n                    \"nat\",\n                    \"int\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"bytes\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"NAT\":\n                args(0, [\n                    \"bytes\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"NEG\":\n                {\n                    const s = args(0, [\n                        \"nat\",\n                        \"int\",\n                        \"bls12_381_g1\",\n                        \"bls12_381_g2\",\n                        \"bls12_381_fr\"\n                    ])[0];\n                    if (s.prim === \"nat\" || s.prim === \"int\") {\n                        return [\n                            annotateVar({\n                                prim: \"int\"\n                            }),\n                            ...stack.slice(1)\n                        ];\n                    }\n                    return [\n                        annotateVar(s),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"LSL\":\n            case \"LSR\":\n                args(0, [\n                    \"nat\",\n                    \"bytes\"\n                ], [\n                    \"nat\",\n                    \"bytes\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }),\n                    ...stack.slice(2)\n                ];\n            case \"OR\":\n            case \"XOR\":\n                {\n                    const s = args(0, [\n                        \"nat\",\n                        \"bytes\",\n                        \"bool\"\n                    ], [\n                        \"nat\",\n                        \"bytes\",\n                        \"bool\"\n                    ]);\n                    if (s[0].prim !== s[1].prim) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);\n                    }\n                    return [\n                        annotateVar(s[1]),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"AND\":\n                {\n                    const s = args(0, [\n                        \"nat\",\n                        \"bytes\",\n                        \"bool\",\n                        \"int\"\n                    ], [\n                        \"nat\",\n                        \"bytes\",\n                        \"bool\"\n                    ]);\n                    if ((s[0].prim !== \"int\" || s[1].prim !== \"nat\") && s[0].prim !== s[1].prim) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: both arguments must be of the same type: ${s[0].prim}, ${s[1].prim}`);\n                    }\n                    return [\n                        annotateVar(s[1]),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"NOT\":\n                {\n                    const s = args(0, [\n                        \"nat\",\n                        \"bytes\",\n                        \"bool\",\n                        \"int\"\n                    ])[0];\n                    if (s.prim === \"bool\") {\n                        return [\n                            annotateVar({\n                                prim: \"bool\"\n                            }),\n                            ...stack.slice(1)\n                        ];\n                    }\n                    return [\n                        annotateVar({\n                            prim: \"int\"\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"COMPARE\":\n                {\n                    const s = args(0, null, null);\n                    ensureComparableType(s[0]);\n                    ensureComparableType(s[1]);\n                    return [\n                        annotateVar({\n                            prim: \"int\"\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"EQ\":\n            case \"NEQ\":\n            case \"LT\":\n            case \"GT\":\n            case \"LE\":\n            case \"GE\":\n                args(0, [\n                    \"int\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"bool\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"SELF\":\n                {\n                    if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) === undefined) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract required`);\n                    }\n                    const ia = instructionAnn({\n                        f: 1,\n                        v: 1\n                    });\n                    const ep = contractEntryPoint(ctx.contract, (_b = ia.f) === null || _b === void 0 ? void 0 : _b[0]);\n                    if (ep === null) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract has no entrypoint ${ep}`);\n                    }\n                    return [\n                        annotate({\n                            prim: \"contract\",\n                            args: [\n                                ep\n                            ]\n                        }, {\n                            v: ia.v ? ia.v : [\n                                \"@self\"\n                            ]\n                        }),\n                        ...stack\n                    ];\n                }\n            case \"TRANSFER_TOKENS\":\n                {\n                    const s = args(0, null, [\n                        \"mutez\"\n                    ], [\n                        \"contract\"\n                    ]);\n                    ensureTypesEqual(s[0], s[2].args[0]);\n                    return [\n                        annotateVar({\n                            prim: \"operation\"\n                        }),\n                        ...stack.slice(3)\n                    ];\n                }\n            case \"SET_DELEGATE\":\n                {\n                    const s = args(0, [\n                        \"option\"\n                    ])[0];\n                    if (typeID(s.args[0]) !== \"key_hash\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: key hash expected: ${typeID(s.args[0])}`);\n                    }\n                    return [\n                        annotateVar({\n                            prim: \"operation\"\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"IMPLICIT_ACCOUNT\":\n                args(0, [\n                    \"key_hash\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"contract\",\n                        args: [\n                            {\n                                prim: \"unit\"\n                            }\n                        ]\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"NOW\":\n                return [\n                    annotateVar({\n                        prim: \"timestamp\"\n                    }, \"@now\"),\n                    ...stack\n                ];\n            case \"AMOUNT\":\n                return [\n                    annotateVar({\n                        prim: \"mutez\"\n                    }, \"@amount\"),\n                    ...stack\n                ];\n            case \"BALANCE\":\n                return [\n                    annotateVar({\n                        prim: \"mutez\"\n                    }, \"@balance\"),\n                    ...stack\n                ];\n            case \"CHECK_SIGNATURE\":\n                args(0, [\n                    \"key\"\n                ], [\n                    \"signature\"\n                ], [\n                    \"bytes\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"bool\"\n                    }),\n                    ...stack.slice(3)\n                ];\n            case \"BLAKE2B\":\n            case \"SHA256\":\n            case \"SHA512\":\n            case \"KECCAK\":\n            case \"SHA3\":\n                args(0, [\n                    \"bytes\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"bytes\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"HASH_KEY\":\n                args(0, [\n                    \"key\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"key_hash\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"SOURCE\":\n                return [\n                    annotateVar({\n                        prim: \"address\"\n                    }, \"@source\"),\n                    ...stack\n                ];\n            case \"SENDER\":\n                return [\n                    annotateVar({\n                        prim: \"address\"\n                    }, \"@sender\"),\n                    ...stack\n                ];\n            case \"ADDRESS\":\n                {\n                    const s = args(0, [\n                        \"contract\"\n                    ])[0];\n                    const ia = instructionAnn({\n                        v: 1\n                    });\n                    return [\n                        annotate({\n                            prim: \"address\",\n                            [refContract]: s\n                        }, {\n                            v: ia.v ? ia.v : varSuffix(argAnn(s), \"address\")\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"SELF_ADDRESS\":\n                {\n                    const addr = {\n                        prim: \"address\"\n                    };\n                    if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {\n                        addr[refContract] = {\n                            prim: \"contract\",\n                            args: [\n                                contractSection(ctx.contract, \"parameter\").args[0]\n                            ]\n                        };\n                    }\n                    return [\n                        annotateVar(addr, \"@address\"),\n                        ...stack\n                    ];\n                }\n            case \"CHAIN_ID\":\n                return [\n                    annotateVar({\n                        prim: \"chain_id\"\n                    }),\n                    ...stack\n                ];\n            case \"DROP\":\n                {\n                    instructionAnn({});\n                    const n = instruction.args !== undefined ? parseInt(instruction.args[0].int, 10) : 1;\n                    args(n - 1, null);\n                    return stack.slice(n);\n                }\n            case \"DIG\":\n                {\n                    instructionAnn({});\n                    const n = parseInt(instruction.args[0].int, 10);\n                    return [\n                        args(n, null)[0],\n                        ...stack.slice(0, n),\n                        ...stack.slice(n + 1)\n                    ];\n                }\n            case \"DUG\":\n                {\n                    instructionAnn({});\n                    const n = parseInt(instruction.args[0].int, 10);\n                    return [\n                        ...stack.slice(1, n + 1),\n                        args(0, null)[0],\n                        ...stack.slice(n + 1)\n                    ];\n                }\n            case \"NONE\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                return [\n                    annotate({\n                        prim: \"option\",\n                        args: [\n                            instruction.args[0]\n                        ]\n                    }, instructionAnn({\n                        t: 1,\n                        v: 1\n                    })),\n                    ...stack\n                ];\n            case \"LEFT\":\n            case \"RIGHT\":\n                {\n                    const s = args(0, null)[0];\n                    const ia = instructionAnn({\n                        f: 2,\n                        t: 1,\n                        v: 1\n                    }, {\n                        specialFields: true\n                    });\n                    const va = argAnn(s);\n                    const children = [\n                        annotate(s, {\n                            t: null,\n                            v: null,\n                            f: ia.f && ia.f.length > 0 && ia.f[0] !== \"%\" ? ia.f[0] === \"%@\" ? va.v ? [\n                                \"%\" + va.v[0].slice(1)\n                            ] : undefined : ia.f : undefined\n                        }),\n                        annotate(instruction.args[0], {\n                            t: null,\n                            f: ia.f && ia.f.length > 1 && ia.f[1] !== \"%\" ? ia.f : undefined\n                        })\n                    ];\n                    return [\n                        annotate({\n                            prim: \"or\",\n                            args: instruction.prim === \"LEFT\" ? children : [\n                                children[1],\n                                children[0]\n                            ]\n                        }, {\n                            t: ia.t,\n                            v: ia.v\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"NIL\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                return [\n                    annotate({\n                        prim: \"list\",\n                        args: [\n                            instruction.args[0]\n                        ]\n                    }, instructionAnn({\n                        t: 1,\n                        v: 1\n                    })),\n                    ...stack\n                ];\n            case \"UNPACK\":\n                args(0, [\n                    \"bytes\"\n                ]);\n                assertTypeAnnotationsValid(instruction.args[0]);\n                return [\n                    annotateVar({\n                        prim: \"option\",\n                        args: [\n                            instruction.args[0]\n                        ]\n                    }, \"@unpacked\"),\n                    ...stack.slice(1)\n                ];\n            case \"CONTRACT\":\n                {\n                    const s = args(0, [\n                        \"address\"\n                    ])[0];\n                    assertTypeAnnotationsValid(instruction.args[0]);\n                    const ia = instructionAnn({\n                        v: 1,\n                        f: 1\n                    });\n                    const contract = s[refContract];\n                    if (contract !== undefined) {\n                        const ep = contractEntryPoint(contract, (_c = ia.f) === null || _c === void 0 ? void 0 : _c[0]);\n                        if (ep === null) {\n                            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: contract has no entrypoint ${ep}`);\n                        }\n                        ensureTypesEqual(ep, instruction.args[0]);\n                    }\n                    return [\n                        annotate({\n                            prim: \"option\",\n                            args: [\n                                {\n                                    prim: \"contract\",\n                                    args: [\n                                        instruction.args[0]\n                                    ]\n                                }\n                            ]\n                        }, {\n                            v: ia.v ? ia.v : varSuffix(argAnn(s), \"contract\")\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"CAST\":\n                {\n                    instructionAnn({});\n                    const s = args(0, null)[0];\n                    assertTypeAnnotationsValid(instruction.args[0]);\n                    ensureTypesEqual(instruction.args[0], s);\n                    return [\n                        instruction.args[0],\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"IF_NONE\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\n                        \"option\"\n                    ])[0];\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0], tail, ctx);\n                    const br1 = functionTypeInternal(instruction.args[1], [\n                        annotate(s.args[0], {\n                            t: null,\n                            v: varSuffix(argAnn(s), \"some\")\n                        }),\n                        ...tail\n                    ], ctx);\n                    return branchType(br0, br1);\n                }\n            case \"IF_LEFT\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\n                        \"or\"\n                    ])[0];\n                    const va = argAnn(s);\n                    const lefta = argAnn(s.args[0]);\n                    const righta = argAnn(s.args[1]);\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0], [\n                        annotate(s.args[0], {\n                            t: null,\n                            v: varSuffix(va, lefta.f ? lefta.f[0].slice(1) : \"left\")\n                        }),\n                        ...tail\n                    ], ctx);\n                    const br1 = functionTypeInternal(instruction.args[1], [\n                        annotate(s.args[1], {\n                            t: null,\n                            v: varSuffix(va, righta.f ? righta.f[0].slice(1) : \"right\")\n                        }),\n                        ...tail\n                    ], ctx);\n                    return branchType(br0, br1);\n                }\n            case \"IF_CONS\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\n                        \"list\"\n                    ])[0];\n                    const va = argAnn(s);\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0], [\n                        annotate(s.args[0], {\n                            t: null,\n                            v: varSuffix(va, \"hd\")\n                        }),\n                        annotate(s, {\n                            t: null,\n                            v: varSuffix(va, \"tl\")\n                        }),\n                        ...tail\n                    ], ctx);\n                    const br1 = functionTypeInternal(instruction.args[1], tail, ctx);\n                    return branchType(br0, br1);\n                }\n            case \"IF\":\n                {\n                    instructionAnn({});\n                    args(0, [\n                        \"bool\"\n                    ]);\n                    const tail = stack.slice(1);\n                    const br0 = functionTypeInternal(instruction.args[0], tail, ctx);\n                    const br1 = functionTypeInternal(instruction.args[1], tail, ctx);\n                    return branchType(br0, br1);\n                }\n            case \"MAP\":\n                {\n                    const s = args(0, [\n                        \"list\",\n                        \"map\",\n                        \"option\"\n                    ])[0];\n                    const tail = stack.slice(1);\n                    const elt = s.prim === \"map\" ? {\n                        prim: \"pair\",\n                        args: s.args\n                    } : s.args[0];\n                    const body = functionTypeInternal(instruction.args[0], [\n                        annotate(elt, {\n                            t: null,\n                            v: varSuffix(argAnn(s), \"elt\")\n                        }),\n                        ...tail\n                    ], ctx);\n                    if (\"failed\" in body) {\n                        if (!(\"prim\" in body.failed) || body.failed.prim !== \"never\") {\n                            throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: FAIL is not allowed in MAP`);\n                        }\n                        return {\n                            failed: body.failed,\n                            level: body.level + 1\n                        };\n                    }\n                    if (body.length < 1) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function must return a value`);\n                    }\n                    ensureStacksEqual(body.slice(1), tail);\n                    return s.prim === \"list\" ? [\n                        annotateVar({\n                            prim: \"list\",\n                            args: [\n                                body[0]\n                            ]\n                        }),\n                        ...tail\n                    ] : s.prim === \"map\" ? [\n                        annotateVar({\n                            prim: \"map\",\n                            args: [\n                                s.args[0],\n                                body[0]\n                            ]\n                        }),\n                        ...tail\n                    ] : [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                body[0]\n                            ]\n                        }),\n                        ...tail\n                    ];\n                }\n            case \"ITER\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\n                        \"set\",\n                        \"list\",\n                        \"map\"\n                    ])[0];\n                    const tail = stack.slice(1);\n                    const elt = s.prim === \"map\" ? {\n                        prim: \"pair\",\n                        args: s.args\n                    } : s.args[0];\n                    const body = functionTypeInternal(instruction.args[0], [\n                        annotate(elt, {\n                            t: null,\n                            v: varSuffix(argAnn(s), \"elt\")\n                        }),\n                        ...tail\n                    ], ctx);\n                    if (\"failed\" in body) {\n                        return {\n                            failed: body.failed,\n                            level: body.level + 1\n                        };\n                    }\n                    ensureStacksEqual(body, tail);\n                    return tail;\n                }\n            case \"LOOP\":\n                {\n                    instructionAnn({});\n                    args(0, [\n                        \"bool\"\n                    ]);\n                    const tail = stack.slice(1);\n                    const body = functionTypeInternal(instruction.args[0], tail, ctx);\n                    if (\"failed\" in body) {\n                        return {\n                            failed: body.failed,\n                            level: body.level + 1\n                        };\n                    }\n                    ensureStacksEqual(body, [\n                        {\n                            prim: \"bool\"\n                        },\n                        ...tail\n                    ]);\n                    return tail;\n                }\n            case \"LOOP_LEFT\":\n                {\n                    instructionAnn({});\n                    const s = args(0, [\n                        \"or\"\n                    ])[0];\n                    const tail = stack.slice(1);\n                    const body = functionTypeInternal(instruction.args[0], [\n                        annotate(s.args[0], {\n                            t: null,\n                            v: varSuffix(argAnn(s), \"left\")\n                        }),\n                        ...tail\n                    ], ctx);\n                    if (\"failed\" in body) {\n                        return {\n                            failed: body.failed,\n                            level: body.level + 1\n                        };\n                    }\n                    ensureStacksEqual(body, [\n                        s,\n                        ...tail\n                    ]);\n                    return [\n                        annotate(s.args[1], {\n                            t: null,\n                            v: instructionAnn({\n                                v: 1\n                            }).v\n                        }),\n                        ...tail\n                    ];\n                }\n            case \"DIP\":\n                {\n                    instructionAnn({});\n                    const n = instruction.args.length === 2 ? parseInt(instruction.args[0].int, 10) : 1;\n                    args(n - 1, null);\n                    const head = stack.slice(0, n);\n                    const tail = stack.slice(n);\n                    // ternary operator is a type guard so use it instead of just `instruction.args.length - 1`\n                    const body = instruction.args.length === 2 ? functionTypeInternal(instruction.args[1], tail, ctx) : functionTypeInternal(instruction.args[0], tail, ctx);\n                    if (\"failed\" in body) {\n                        return {\n                            failed: body.failed,\n                            level: body.level + 1\n                        };\n                    }\n                    return [\n                        ...head,\n                        ...body\n                    ];\n                }\n            case \"CREATE_CONTRACT\":\n                {\n                    const ia = instructionAnn({\n                        v: 2\n                    });\n                    const s = args(0, [\n                        \"option\"\n                    ], [\n                        \"mutez\"\n                    ], null);\n                    if (typeID(s[0].args[0]) !== \"key_hash\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: key hash expected: ${typeID(s[0].args[0])}`);\n                    }\n                    if (ensureStorableType(s[2])) {\n                        assertContractValid(instruction.args[0]);\n                        assertScalarTypesEqual(contractSection(instruction.args[0], \"storage\").args[0], s[2]);\n                    }\n                    const va = (_d = ia.v) === null || _d === void 0 ? void 0 : _d.map((v)=>v !== \"@\" ? [\n                            v\n                        ] : undefined);\n                    return [\n                        annotate({\n                            prim: \"operation\"\n                        }, {\n                            v: va === null || va === void 0 ? void 0 : va[0]\n                        }),\n                        annotate({\n                            prim: \"address\",\n                            [refContract]: {\n                                prim: \"contract\",\n                                args: [\n                                    contractSection(instruction.args[0], \"parameter\").args[0]\n                                ]\n                            }\n                        }, {\n                            v: va === null || va === void 0 ? void 0 : va[1]\n                        }),\n                        ...stack.slice(3)\n                    ];\n                }\n            case \"PUSH\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                assertDataValidInternal(instruction.args[1], instruction.args[0], Object.assign(Object.assign({}, ctx), {\n                    contract: undefined\n                }));\n                return [\n                    annotateVar(instruction.args[0]),\n                    ...stack\n                ];\n            case \"EMPTY_SET\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                ensureComparableType(instruction.args[0]);\n                return [\n                    annotate({\n                        prim: \"set\",\n                        args: instruction.args\n                    }, instructionAnn({\n                        t: 1,\n                        v: 1\n                    })),\n                    ...stack\n                ];\n            case \"EMPTY_MAP\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                ensureComparableType(instruction.args[0]);\n                assertTypeAnnotationsValid(instruction.args[1]);\n                return [\n                    annotate({\n                        prim: \"map\",\n                        args: instruction.args\n                    }, instructionAnn({\n                        t: 1,\n                        v: 1\n                    })),\n                    ...stack\n                ];\n            case \"EMPTY_BIG_MAP\":\n                assertTypeAnnotationsValid(instruction.args[0]);\n                ensureComparableType(instruction.args[0]);\n                assertTypeAnnotationsValid(instruction.args[1]);\n                ensureBigMapStorableType(instruction.args[0]);\n                return [\n                    annotate({\n                        prim: \"big_map\",\n                        args: instruction.args\n                    }, instructionAnn({\n                        t: 1,\n                        v: 1\n                    })),\n                    ...stack\n                ];\n            case \"LAMBDA_REC\":\n            case \"LAMBDA\":\n                {\n                    assertTypeAnnotationsValid(instruction.args[0]);\n                    assertTypeAnnotationsValid(instruction.args[1]);\n                    const s = [\n                        instruction.args[0]\n                    ];\n                    if (instruction.prim === \"LAMBDA_REC\") {\n                        s.push({\n                            prim: \"lambda\",\n                            args: [\n                                instruction.args[0],\n                                instruction.args[1]\n                            ]\n                        });\n                    }\n                    const body = functionTypeInternal(instruction.args[2], s, Object.assign(Object.assign({}, ctx), {\n                        contract: undefined\n                    }));\n                    if (\"failed\" in body) {\n                        return {\n                            failed: body.failed,\n                            level: body.level + 1\n                        };\n                    }\n                    if (body.length !== 1) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: function must return a value`);\n                    }\n                    ensureTypesEqual(instruction.args[1], body[0]);\n                    return [\n                        annotateVar({\n                            prim: \"lambda\",\n                            args: [\n                                instruction.args[0],\n                                instruction.args[1]\n                            ]\n                        }),\n                        ...stack\n                    ];\n                }\n            case \"LEVEL\":\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }, \"@level\"),\n                    ...stack\n                ];\n            case \"TOTAL_VOTING_POWER\":\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }),\n                    ...stack\n                ];\n            case \"VOTING_POWER\":\n                args(0, [\n                    \"key_hash\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }),\n                    ...stack.slice(1)\n                ];\n            case \"TICKET\":\n                {\n                    const s = args(0, null, [\n                        \"nat\"\n                    ])[0];\n                    ensureComparableType(s);\n                    if (ProtoInferiorTo(proto, Protocol.PtLimaPtL)) {\n                        return [\n                            annotate({\n                                prim: \"ticket\",\n                                args: [\n                                    s\n                                ]\n                            }, instructionAnn({\n                                t: 1,\n                                v: 1\n                            })),\n                            ...stack.slice(2)\n                        ];\n                    } else {\n                        return [\n                            annotateVar({\n                                prim: \"option\",\n                                args: [\n                                    annotate({\n                                        prim: \"ticket\",\n                                        args: [\n                                            s\n                                        ]\n                                    }, instructionAnn({\n                                        t: 1,\n                                        v: 1\n                                    }))\n                                ]\n                            }),\n                            ...stack.slice(2)\n                        ];\n                    }\n                }\n            case \"JOIN_TICKETS\":\n                {\n                    const s = unpackComb(\"pair\", args(0, [\n                        \"pair\"\n                    ])[0]);\n                    if (typeID(s.args[0]) !== \"ticket\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: ticket expected: ${typeID(s.args[0])}`);\n                    }\n                    ensureTypesEqual(s.args[0], s.args[1]);\n                    return [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                annotate(s.args[0], {\n                                    t: null\n                                })\n                            ]\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"SPLIT_TICKET\":\n                {\n                    const s = args(0, [\n                        \"ticket\"\n                    ], [\n                        \"pair\"\n                    ]);\n                    const p = unpackComb(\"pair\", s[1]);\n                    if (typeID(p.args[0]) !== \"nat\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: nat expected: ${typeID(p.args[0])}`);\n                    }\n                    ensureTypesEqual(p.args[0], p.args[1]);\n                    return [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                {\n                                    prim: \"pair\",\n                                    args: [\n                                        annotate(s[0], {\n                                            t: null\n                                        }),\n                                        annotate(s[0], {\n                                            t: null\n                                        })\n                                    ]\n                                }\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"READ_TICKET\":\n                {\n                    const ia = instructionAnn({\n                        v: 2\n                    });\n                    const s = args(0, [\n                        \"ticket\"\n                    ])[0];\n                    const va = (_e = ia.v) === null || _e === void 0 ? void 0 : _e.map((v)=>v !== \"@\" ? [\n                            v\n                        ] : undefined);\n                    return [\n                        annotate({\n                            prim: \"pair\",\n                            args: [\n                                {\n                                    prim: \"address\"\n                                },\n                                annotate(s.args[0], {\n                                    t: null\n                                }),\n                                {\n                                    prim: \"nat\"\n                                }\n                            ]\n                        }, {\n                            v: va === null || va === void 0 ? void 0 : va[0]\n                        }),\n                        annotate(s, {\n                            v: va === null || va === void 0 ? void 0 : va[1],\n                            t: null\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"PAIRING_CHECK\":\n                {\n                    const p = args(0, [\n                        \"list\"\n                    ])[0].args[0];\n                    if (!isPairType(p)) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: pair expected: ${typeID(p)}`);\n                    }\n                    const c = unpackComb(\"pair\", p);\n                    if (typeID(c.args[0]) !== \"bls12_381_g1\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: bls12_381_g1 expected: ${typeID(c.args[0])}`);\n                    }\n                    if (typeID(c.args[1]) !== \"bls12_381_g2\") {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: bls12_381_g2 expected: ${typeID(c.args[1])}`);\n                    }\n                    return [\n                        annotateVar({\n                            prim: \"bool\"\n                        }),\n                        ...stack.slice(1)\n                    ];\n                }\n            case \"SAPLING_EMPTY_STATE\":\n                return [\n                    annotate({\n                        prim: \"sapling_state\",\n                        args: [\n                            instruction.args[0]\n                        ]\n                    }, instructionAnn({\n                        v: 1,\n                        t: 1\n                    })),\n                    ...stack\n                ];\n            case \"SAPLING_VERIFY_UPDATE\":\n                {\n                    const s = args(0, [\n                        \"sapling_transaction\"\n                    ], [\n                        \"sapling_state\"\n                    ]);\n                    if (parseInt(s[0].args[0].int, 10) !== parseInt(s[1].args[0].int, 10)) {\n                        throw new MichelsonInstructionError(instruction, stack, `${instruction.prim}: sapling memo size mismatch: ${s[0].args[0].int} != ${s[1].args[0].int}`);\n                    }\n                    return ProtoInferiorTo(proto, Protocol.PtJakarta) ? [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                {\n                                    prim: \"pair\",\n                                    args: [\n                                        {\n                                            prim: \"int\"\n                                        },\n                                        annotate(s[1], {\n                                            t: null\n                                        })\n                                    ]\n                                }\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ] : [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                {\n                                    prim: \"pair\",\n                                    args: [\n                                        {\n                                            prim: \"bytes\"\n                                        },\n                                        {\n                                            prim: \"pair\",\n                                            args: [\n                                                {\n                                                    prim: \"int\"\n                                                },\n                                                annotate(s[1], {\n                                                    t: null\n                                                })\n                                            ]\n                                        }\n                                    ]\n                                }\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"OPEN_CHEST\":\n                args(0, [\n                    \"chest_key\"\n                ], [\n                    \"chest\"\n                ], [\n                    \"nat\"\n                ]);\n                return [\n                    annotateVar({\n                        prim: \"or\",\n                        args: [\n                            {\n                                prim: \"bytes\"\n                            },\n                            {\n                                prim: \"bool\"\n                            }\n                        ]\n                    }),\n                    ...stack.slice(3)\n                ];\n            case \"VIEW\":\n                {\n                    const s = args(0, null, [\n                        \"address\"\n                    ]);\n                    ensurePushableType(s[0]);\n                    return [\n                        annotateVar({\n                            prim: \"option\",\n                            args: [\n                                instruction.args[1]\n                            ]\n                        }),\n                        ...stack.slice(2)\n                    ];\n                }\n            case \"MIN_BLOCK_TIME\":\n                return [\n                    annotateVar({\n                        prim: \"nat\"\n                    }),\n                    ...stack\n                ];\n            case \"EMIT\":\n                {\n                    const ia = instructionAnn({\n                        f: 1,\n                        t: 1\n                    });\n                    if (instruction.args) {\n                        const s = args(0, null);\n                        ensureTypesEqual(s[0], instruction.args[0]);\n                        return [\n                            annotate({\n                                prim: \"operation\"\n                            }, ia),\n                            ...stack.slice(1)\n                        ];\n                    }\n                    return [\n                        annotate({\n                            prim: \"operation\"\n                        }, ia),\n                        ...stack.slice(1)\n                    ];\n                }\n            default:\n                throw new MichelsonError(instruction, `unexpected instruction: ${instruction.prim}`);\n        }\n    })(instruction);\n    if ((ctx === null || ctx === void 0 ? void 0 : ctx.traceCallback) !== undefined) {\n        const trace = {\n            op: instruction,\n            in: stack,\n            out: retStack\n        };\n        ctx.traceCallback(trace);\n    }\n    return retStack;\n}\nfunction contractSection(contract, section) {\n    for (const s of contract){\n        if (s.prim === section) {\n            return s;\n        }\n    }\n    throw new MichelsonError(contract, `missing contract section: ${section}`);\n}\nfunction contractViews(contract) {\n    const views = {};\n    for (const s of contract){\n        if (s.prim === \"view\") {\n            views[s.args[0].string] = s;\n        }\n    }\n    return views;\n}\nfunction isContract(v) {\n    if (Array.isArray(v)) {\n        for (const s of v){\n            if (\"prim\" in s && (s.prim === \"parameter\" || s.prim === \"storage\" || s.prim === \"code\")) {\n                return true;\n            }\n        }\n    }\n    return false;\n}\nfunction contractEntryPoint(src, ep) {\n    ep = ep || \"%default\";\n    const entryPoint = contractEntryPoints(src).find((x)=>x[0] === ep);\n    if (entryPoint !== undefined) {\n        return entryPoint[1];\n    } else if (ep === \"%default\") {\n        return isContract(src) ? contractSection(src, \"parameter\").args[0] : src;\n    }\n    return null;\n}\nfunction isOrType(t) {\n    return Array.isArray(t) || t.prim === \"or\";\n}\nfunction contractEntryPoints(src) {\n    if (isContract(src)) {\n        const param = contractSection(src, \"parameter\");\n        const ch = contractEntryPoints(param.args[0]);\n        const a = unpackAnnotations(param);\n        return a.f ? [\n            [\n                a.f[0],\n                param.args[0]\n            ],\n            ...ch\n        ] : ch;\n    }\n    if (isOrType(src)) {\n        const args = typeArgs(src);\n        const getArg = (n)=>{\n            const a = unpackAnnotations(args[n]);\n            if (typeID(args[n]) === \"or\") {\n                const ch = contractEntryPoints(args[n]);\n                return a.f ? [\n                    [\n                        a.f[0],\n                        args[n]\n                    ],\n                    ...ch\n                ] : ch;\n            }\n            return a.f ? [\n                [\n                    a.f[0],\n                    args[n]\n                ]\n            ] : [];\n        };\n        return [\n            ...getArg(0),\n            ...getArg(1)\n        ];\n    }\n    return [];\n}\n// Contract validation\nfunction assertContractValid(contract, ctx) {\n    const assertSection = (parameter, storage, ret, code)=>{\n        assertTypeAnnotationsValid(parameter, true);\n        assertTypeAnnotationsValid(storage);\n        const arg = {\n            prim: \"pair\",\n            args: [\n                Object.assign(Object.assign({}, parameter), {\n                    annots: [\n                        \"@parameter\"\n                    ]\n                }),\n                Object.assign(Object.assign({}, storage), {\n                    annots: [\n                        \"@storage\"\n                    ]\n                })\n            ]\n        };\n        const out = functionTypeInternal(code, [\n            arg\n        ], Object.assign(Object.assign({}, ctx), {\n            contract\n        }));\n        if (\"failed\" in out) {\n            return out;\n        }\n        try {\n            assertStacksEqual(out, [\n                ret\n            ]);\n        } catch (err) {\n            if (err instanceof MichelsonError) {\n                throw new MichelsonInstructionError(code, out, err.message);\n            } else {\n                throw err;\n            }\n        }\n        return out;\n    };\n    const parameter = contractSection(contract, \"parameter\").args[0];\n    const storage = contractSection(contract, \"storage\").args[0];\n    const code = contractSection(contract, \"code\").args[0];\n    const expected = {\n        prim: \"pair\",\n        args: [\n            {\n                prim: \"list\",\n                args: [\n                    {\n                        prim: \"operation\"\n                    }\n                ]\n            },\n            storage\n        ]\n    };\n    const ret = assertSection(parameter, storage, expected, code);\n    for (const view of Object.values(contractViews(contract))){\n        assertSection(view.args[1], storage, view.args[2], view.args[3]);\n    }\n    return ret;\n}\n// Exported wrapper functions\nfunction assertDataValid(d, t, ctx) {\n    assertTypeAnnotationsValid(t);\n    assertDataValidInternal(d, t, ctx || null);\n}\nfunction functionType(inst, stack, ctx) {\n    for (const t of stack){\n        assertTypeAnnotationsValid(t);\n    }\n    if ((ctx === null || ctx === void 0 ? void 0 : ctx.contract) !== undefined) {\n        for (const typesec of [\n            \"parameter\",\n            \"storage\"\n        ]){\n            const sec = contractSection(ctx.contract, typesec).args[0];\n            assertTypeAnnotationsValid(sec);\n        }\n    }\n    return functionTypeInternal(inst, stack, ctx || null);\n}\nfunction assertTypesEqual(a, b, field = false) {\n    if (Array.isArray(a)) {\n        // type guards don't work for parametrized generic types\n        for (const v of a){\n            assertTypeAnnotationsValid(v);\n        }\n        for (const v of b){\n            assertTypeAnnotationsValid(v);\n        }\n    } else {\n        assertTypeAnnotationsValid(a);\n        assertTypeAnnotationsValid(b);\n    }\n    assertScalarTypesEqual(a, b, field);\n}\nfunction isTypeAnnotationsValid(t, field = false) {\n    try {\n        assertTypeAnnotationsValid(t, field);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction isContractValid(contract, ctx) {\n    try {\n        return assertContractValid(contract, ctx);\n    } catch (_a) {\n        return null;\n    }\n}\nfunction isDataValid(d, t, ctx) {\n    try {\n        assertDataValid(d, t, ctx);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nfunction isTypeEqual(a, b, field = false) {\n    try {\n        assertTypesEqual(a, b, field);\n        return true;\n    } catch (_a) {\n        return false;\n    }\n}\nclass Contract {\n    constructor(contract, opt){\n        this.contract = contract;\n        this.ctx = Object.assign({\n            contract\n        }, opt);\n        this.output = assertContractValid(contract, this.ctx);\n    }\n    static parse(src, opt) {\n        const p = new Parser(opt);\n        const expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n        if (expr === null) {\n            throw new InvalidMichelsonError(\"empty Michelson\");\n        }\n        if (assertMichelsonContract(expr)) {\n            return new Contract(expr, opt);\n        }\n    }\n    static parseTypeExpression(src, opt) {\n        const p = new Parser(opt);\n        const expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n        if (expr === null) {\n            throw new InvalidTypeExpressionError(\"empty type expression\");\n        }\n        // remove assertTypeAnnotationsValid from if block because: () => void || throw error\n        if (assertMichelsonType(expr)) {\n            assertTypeAnnotationsValid(expr);\n            return expr;\n        }\n    }\n    static parseDataExpression(src, opt) {\n        const p = new Parser(opt);\n        const expr = typeof src === \"string\" ? p.parseScript(src) : p.parseJSON(src);\n        if (expr === null) {\n            throw new InvalidDataExpressionError(\"empty data expression\");\n        }\n        if (assertMichelsonData(expr)) {\n            return expr;\n        }\n        throw undefined;\n    }\n    section(section) {\n        return contractSection(this.contract, section);\n    }\n    entryPoints() {\n        return contractEntryPoints(this.contract);\n    }\n    entryPoint(ep) {\n        return contractEntryPoint(this.contract, ep);\n    }\n    assertDataValid(d, t) {\n        assertDataValid(d, t, this.ctx);\n    }\n    isDataValid(d, t) {\n        return isDataValid(d, t, this.ctx);\n    }\n    assertParameterValid(ep, d) {\n        const t = this.entryPoint(ep || undefined);\n        if (t === null) {\n            throw new InvalidEntrypointError(ep === null || ep === void 0 ? void 0 : ep.toString());\n        }\n        this.assertDataValid(d, t);\n    }\n    isParameterValid(ep, d) {\n        try {\n            this.assertParameterValid(ep, d);\n            return true;\n        } catch (_a) {\n            return false;\n        }\n    }\n    functionType(inst, stack) {\n        return functionType(inst, stack, this.ctx);\n    }\n}\n// TODO: dummyContract not used anywhere in the codebase can be deleted?\nconst dummyContract = new Contract([\n    {\n        prim: \"parameter\",\n        args: [\n            {\n                prim: \"unit\"\n            }\n        ]\n    },\n    {\n        prim: \"storage\",\n        args: [\n            {\n                prim: \"unit\"\n            }\n        ]\n    },\n    {\n        prim: \"code\",\n        args: [\n            [\n                {\n                    prim: \"CAR\"\n                },\n                {\n                    prim: \"NIL\",\n                    args: [\n                        {\n                            prim: \"operation\"\n                        }\n                    ]\n                },\n                {\n                    prim: \"PAIR\"\n                }\n            ]\n        ]\n    }\n]);\nfunction formatStack(s) {\n    if (\"failed\" in s) {\n        return `[FAILED: ${emitMicheline(s.failed)}]`;\n    }\n    return s.map((v, i)=>{\n        const ann = unpackAnnotations(v);\n        return `[${i}${ann.v ? \"/\" + ann.v[0] : \"\"}]: ${emitMicheline(v)}`;\n    }).join(\"\\n\");\n}\nfunction traceDumpFunc(blocks, cb) {\n    return (v)=>{\n        var _a;\n        if (Array.isArray(v) && !blocks) {\n            return;\n        }\n        const macro = (_a = v.op[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;\n        const msg = `${macro ? \"Macro\" : \"Op\"}: ${macro ? emitMicheline(macro, undefined, true) + \" / \" : \"\"}${emitMicheline(v.op)}\nInput:\n${formatStack(v.in)}\nOutput:\n${formatStack(v.out)}\n`;\n        cb(msg);\n    };\n}\nfunction formatError(err) {\n    var _a;\n    if (err instanceof MichelsonInstructionError) {\n        const macro = (_a = err.val[sourceReference]) === null || _a === void 0 ? void 0 : _a.macro;\n        return `${macro ? \"Macro\" : \"Op\"}: ${macro ? emitMicheline(macro, undefined, true) + \" / \" : \"\"}${emitMicheline(err.val)}\nStack:\n${formatStack(err.stackState)}\n`;\n    } else if (err instanceof MichelsonTypeError) {\n        const type = Array.isArray(err.val) ? \"[\" + err.val.map((v, i)=>`[${i}]: ${emitMicheline(v)}`).join(\"; \") + \"]\" : emitMicheline(err.val);\n        return `Type: ${type}\n${err.data ? `Data: ${emitMicheline(err.data)}\n` : \"\"}\n`;\n    } else {\n        return `Value: ${emitMicheline(err.val)}`;\n    }\n}\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\n //# sourceMappingURL=taquito-michel-codec.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vbWljaGVsLWNvZGVjL2Rpc3QvdGFxdWl0by1taWNoZWwtY29kZWMuZXM2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBNEY7QUFFNUYsdUdBQXVHO0FBQ3ZHLE1BQU1HLGtCQUFrQkMsT0FBTztBQUUvQjs7O0NBR0MsR0FDRCxNQUFNQyxrQkFBa0JMLHVEQUFZQTtJQUNoQ00sWUFBWUMsR0FBRyxFQUFFQyxHQUFHLEVBQUVDLE9BQU8sQ0FBRTtRQUMzQixLQUFLO1FBQ0wsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDQyxPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDQyxJQUFJLEdBQUc7SUFDaEI7QUFDSjtBQUNBLElBQUlDO0FBQ0gsVUFBVUEsT0FBTztJQUNkQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxVQUFVLEdBQUcsRUFBRSxHQUFHO0lBQ2xDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxTQUFTLEdBQUcsRUFBRSxHQUFHO0lBQ2pDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0lBQ2hDQSxPQUFPLENBQUNBLE9BQU8sQ0FBQyxRQUFRLEdBQUcsRUFBRSxHQUFHO0FBQ3BDLEdBQUdBLFdBQVlBLENBQUFBLFVBQVUsQ0FBQztBQUMxQixNQUFNQyxVQUFVLElBQUlDLE9BQU87QUFDM0IsTUFBTUMsZUFBZSxJQUFJRCxPQUFPO0FBQ2hDLE1BQU1FLFVBQVUsSUFBSUYsT0FBTztBQUMzQixNQUFNRyxVQUFVLElBQUlILE9BQU87QUFDM0IsTUFBTUksUUFBUSxJQUFJSixPQUFPO0FBQ3pCLFVBQVVLLEtBQUtYLEdBQUcsRUFBRVksZUFBZSxLQUFLO0lBQ3BDLElBQUlDLElBQUk7SUFDUixNQUFPQSxJQUFJYixJQUFJYyxNQUFNLENBQUU7UUFDbkIsYUFBYTtRQUNiLE1BQU9ELElBQUliLElBQUljLE1BQU0sSUFBSVQsUUFBUVUsSUFBSSxDQUFDZixHQUFHLENBQUNhLEVBQUUsRUFBRztZQUMzQ0E7UUFDSjtRQUNBLElBQUlBLE1BQU1iLElBQUljLE1BQU0sRUFBRTtZQUNsQjtRQUNKO1FBQ0EsTUFBTUUsSUFBSWhCLEdBQUcsQ0FBQ2EsRUFBRTtRQUNoQixNQUFNSSxRQUFRSjtRQUNkLElBQUlOLGFBQWFRLElBQUksQ0FBQ0MsSUFBSTtZQUN0QixhQUFhO1lBQ2JIO1lBQ0EsTUFBT0EsSUFBSWIsSUFBSWMsTUFBTSxJQUFJTixRQUFRTyxJQUFJLENBQUNmLEdBQUcsQ0FBQ2EsRUFBRSxFQUFHO2dCQUMzQ0E7WUFDSjtZQUNBLE1BQU07Z0JBQUVLLEdBQUdkLFFBQVFlLEtBQUs7Z0JBQUVDLEdBQUdwQixJQUFJcUIsS0FBSyxDQUFDSixPQUFPSjtnQkFBSVMsT0FBT0w7Z0JBQU9NLE1BQU1WO1lBQUU7UUFDNUUsT0FDSyxJQUFJYixJQUFJYyxNQUFNLEdBQUdELElBQUksS0FBS2IsSUFBSXdCLFNBQVMsQ0FBQ1gsR0FBR0EsSUFBSSxPQUFPLE1BQU07WUFDN0QsUUFBUTtZQUNSQSxLQUFLO1lBQ0wsTUFBT0EsSUFBSWIsSUFBSWMsTUFBTSxJQUFJSixNQUFNSyxJQUFJLENBQUNmLEdBQUcsQ0FBQ2EsRUFBRSxFQUFHO2dCQUN6Q0E7WUFDSjtZQUNBLElBQUksQ0FBQyxJQUFLSSxRQUFTLE9BQU8sR0FBRztnQkFDekIsTUFBTSxJQUFJbkIsVUFBVUUsS0FBS2EsR0FBRztZQUNoQztZQUNBLE1BQU07Z0JBQUVLLEdBQUdkLFFBQVFxQixLQUFLO2dCQUFFTCxHQUFHcEIsSUFBSXFCLEtBQUssQ0FBQ0osT0FBT0o7Z0JBQUlTLE9BQU9MO2dCQUFPTSxNQUFNVjtZQUFFO1FBQzVFLE9BQ0ssSUFBSUosUUFBUU0sSUFBSSxDQUFDQyxNQUFNQSxNQUFNLEtBQUs7WUFDbkMsU0FBUztZQUNULElBQUlBLE1BQU0sS0FBSztnQkFDWEg7WUFDSjtZQUNBLE1BQU1hLEtBQUtiO1lBQ1gsTUFBT0EsSUFBSWIsSUFBSWMsTUFBTSxJQUFJTCxRQUFRTSxJQUFJLENBQUNmLEdBQUcsQ0FBQ2EsRUFBRSxFQUFHO2dCQUMzQ0E7WUFDSjtZQUNBLElBQUlhLE9BQU9iLEdBQUc7Z0JBQ1YsTUFBTSxJQUFJZixVQUFVRSxLQUFLYSxHQUFHO1lBQ2hDO1lBQ0EsTUFBTTtnQkFBRUssR0FBR2QsUUFBUXVCLE1BQU07Z0JBQUVQLEdBQUdwQixJQUFJcUIsS0FBSyxDQUFDSixPQUFPSjtnQkFBSVMsT0FBT0w7Z0JBQU9NLE1BQU1WO1lBQUU7UUFDN0UsT0FDSyxJQUFJRyxNQUFNLEtBQUs7WUFDaEIsU0FBUztZQUNUSDtZQUNBLElBQUllLE1BQU07WUFDVixNQUFPZixJQUFJYixJQUFJYyxNQUFNLElBQUtjLENBQUFBLE9BQU81QixHQUFHLENBQUNhLEVBQUUsS0FBSyxHQUFFLEdBQUlBLElBQUs7Z0JBQ25ELElBQUksQ0FBQ2UsT0FBTzVCLEdBQUcsQ0FBQ2EsRUFBRSxLQUFLLE1BQU07b0JBQ3pCZSxNQUFNO2dCQUNWLE9BQ0s7b0JBQ0RBLE1BQU07Z0JBQ1Y7WUFDSjtZQUNBLElBQUlmLE1BQU1iLElBQUljLE1BQU0sRUFBRTtnQkFDbEIsTUFBTSxJQUFJaEIsVUFBVUUsS0FBS2EsR0FBRztZQUNoQztZQUNBQTtZQUNBLE1BQU07Z0JBQUVLLEdBQUdkLFFBQVF5QixNQUFNO2dCQUFFVCxHQUFHcEIsSUFBSXFCLEtBQUssQ0FBQ0osT0FBT0o7Z0JBQUlTLE9BQU9MO2dCQUFPTSxNQUFNVjtZQUFFO1FBQzdFLE9BQ0ssSUFBSUcsTUFBTSxLQUFLO1lBQ2hCLFVBQVU7WUFDVkg7WUFDQSxNQUFPQSxJQUFJYixJQUFJYyxNQUFNLElBQUlkLEdBQUcsQ0FBQ2EsRUFBRSxLQUFLLEtBQU07Z0JBQ3RDQTtZQUNKO1lBQ0EsSUFBSUQsY0FBYztnQkFDZCxNQUFNO29CQUFFTSxHQUFHZCxRQUFRMEIsT0FBTztvQkFBRVYsR0FBR3BCLElBQUlxQixLQUFLLENBQUNKLE9BQU9KO29CQUFJUyxPQUFPTDtvQkFBT00sTUFBTVY7Z0JBQUU7WUFDOUU7UUFDSixPQUNLLElBQUliLElBQUljLE1BQU0sR0FBR0QsSUFBSSxLQUFLYixJQUFJd0IsU0FBUyxDQUFDWCxHQUFHQSxJQUFJLE9BQU8sTUFBTTtZQUM3RCxrQkFBa0I7WUFDbEJBLEtBQUs7WUFDTCxNQUFPQSxJQUFJYixJQUFJYyxNQUFNLElBQUksQ0FBRWQsQ0FBQUEsSUFBSWMsTUFBTSxHQUFHRCxJQUFJLEtBQUtiLElBQUl3QixTQUFTLENBQUNYLEdBQUdBLElBQUksT0FBTyxJQUFHLEVBQUk7Z0JBQ2hGQTtZQUNKO1lBQ0EsSUFBSUEsTUFBTWIsSUFBSWMsTUFBTSxFQUFFO2dCQUNsQixNQUFNLElBQUloQixVQUFVRSxLQUFLYSxHQUFHO1lBQ2hDO1lBQ0FBLEtBQUs7WUFDTCxJQUFJRCxjQUFjO2dCQUNkLE1BQU07b0JBQUVNLEdBQUdkLFFBQVEwQixPQUFPO29CQUFFVixHQUFHcEIsSUFBSXFCLEtBQUssQ0FBQ0osT0FBT0o7b0JBQUlTLE9BQU9MO29CQUFPTSxNQUFNVjtnQkFBRTtZQUM5RTtRQUNKLE9BQ0ssSUFBSUcsTUFBTSxPQUFPQSxNQUFNLE9BQU9BLE1BQU0sT0FBT0EsTUFBTSxPQUFPQSxNQUFNLEtBQUs7WUFDcEVIO1lBQ0EsTUFBTTtnQkFBRUssR0FBR0Y7Z0JBQUdJLEdBQUdKO2dCQUFHTSxPQUFPTDtnQkFBT00sTUFBTVY7WUFBRTtRQUM5QyxPQUNLO1lBQ0QsTUFBTSxJQUFJZixVQUFVRSxLQUFLYSxHQUFHLENBQUMsNEJBQTRCLEVBQUVBLEVBQUUsSUFBSSxFQUFFRyxFQUFFLENBQUMsQ0FBQztRQUMzRTtJQUNKO0FBQ0o7QUFFQSxrQkFBa0I7QUFDbEIsTUFBTWUsY0FBY2xDLE9BQU87QUFDM0IsSUFBSW1DO0FBQ0gsVUFBVUEsUUFBUTtJQUNmQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsV0FBVyxHQUFHO0lBQ3ZCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsWUFBWSxHQUFHO0lBQ3hCQSxRQUFRLENBQUMsYUFBYSxHQUFHO0FBQzdCLEdBQUdBLFlBQWFBLENBQUFBLFdBQVcsQ0FBQztBQUM1QixNQUFNQyxrQkFBa0JELFNBQVNFLFNBQVM7QUFDMUMsTUFBTUMsYUFBYTtJQUNmQyxxREFBcUQ7SUFDckRDLHFEQUFxRDtJQUNyREMscURBQXFEO0lBQ3JEQyxxREFBcUQ7SUFDckRDLHFEQUFxRDtJQUNyREMscURBQXFEO0lBQ3JEQyxxREFBcUQ7SUFDckRDLHFEQUFxRDtJQUNyREMscURBQXFEO0lBQ3JEQyxxREFBcUQ7SUFDckRDLHFEQUFx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Q0EsSUFBSyxJQUFJQSxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBSztZQUN6QixNQUFNMEwsS0FBS1IsSUFBSTNLLENBQUMsQ0FBQyxFQUFFLEVBQUUsS0FBSzJLLElBQUkzSyxDQUFDLENBQUMsRUFBRSxFQUFFLE1BQU0ySyxJQUFJM0ssQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNwRCxNQUFNb0wsS0FBS1QsSUFBSTNLLENBQUMsQ0FBQyxFQUFFLEVBQUUsS0FBSzJLLElBQUkzSyxDQUFDLENBQUMsRUFBRSxFQUFFLE1BQU0ySyxJQUFJM0ssQ0FBQyxDQUFDLEVBQUUsRUFBRTtZQUNwRCxNQUFNcUwsS0FBSyxDQUFFLENBQUMsRUFBRSxHQUFHRCxLQUFNLEVBQUUsQ0FBQyxFQUFFLEdBQUdwTCxDQUFDLENBQUMsRUFBRSxHQUFLLENBQUNBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFLElBQUtvSyxDQUFDLENBQUMzSyxFQUFFLEdBQUdxTCxDQUFDLENBQUNyTCxFQUFFLEdBQUk7WUFDMUUsTUFBTTZMLEtBQUssS0FBTyxFQUFFLENBQUMsRUFBRSxHQUFHdEwsQ0FBQyxDQUFDLEVBQUUsR0FBS0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsR0FBS0EsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUUsSUFBTTtZQUNwRUEsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUU7WUFDWEEsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUU7WUFDWEEsQ0FBQyxDQUFDLEVBQUUsR0FBR0EsQ0FBQyxDQUFDLEVBQUU7WUFDWEEsQ0FBQyxDQUFDLEVBQUUsR0FBRyxDQUFFLENBQUMsRUFBRSxHQUFHcUwsS0FBTTtZQUNyQnJMLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1lBQ1hBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FBQyxFQUFFO1lBQ1hBLENBQUMsQ0FBQyxFQUFFLEdBQUdBLENBQUMsQ0FB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LENBQUM7SUFDN0M7QUFDSjtBQUVBLDJFQUEyRTtBQUMzRSxNQUFNa2UsVUFBVTtJQUNaLGNBQWM7SUFDZCxXQUFXO0FBQ2Y7QUFFbW5DLENBQ25uQyxvREFBb0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd3JwZXJrcy8uL25vZGVfbW9kdWxlcy9AdGFxdWl0by9taWNoZWwtY29kZWMvZGlzdC90YXF1aXRvLW1pY2hlbC1jb2RlYy5lczYuanM/ODY4YSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBUYXF1aXRvRXJyb3IsIEludmFsaWRNZXNzYWdlRXJyb3IsIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB9IGZyb20gJ0B0YXF1aXRvL2NvcmUnO1xuXG4vLyBNaWNoZWxzb24gYWJzdHJhY3Qgc3ludGF4IHRyZWUgdHlwZXMgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vd2hpdGVkb2MvbWljaGVsc29uLmh0bWwjY29uY3JldGUtc3ludGF4XG5jb25zdCBzb3VyY2VSZWZlcmVuY2UgPSBTeW1ib2woJ3NvdXJjZV9yZWZlcmVuY2UnKTtcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSB3aGVuIHBlcmZvcm1pbmcgdGhlIHNjYW4gc3RlcCB3aGVuIHBhcnNpbmcgTWljaGVsc29uXG4gKi9cbmNsYXNzIFNjYW5FcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc3JjLCBpZHgsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zcmMgPSBzcmM7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU2NhbkVycm9yJztcbiAgICB9XG59XG52YXIgTGl0ZXJhbDtcbihmdW5jdGlvbiAoTGl0ZXJhbCkge1xuICAgIExpdGVyYWxbTGl0ZXJhbFtcIkNvbW1lbnRcIl0gPSAwXSA9IFwiQ29tbWVudFwiO1xuICAgIExpdGVyYWxbTGl0ZXJhbFtcIk51bWJlclwiXSA9IDFdID0gXCJOdW1iZXJcIjtcbiAgICBMaXRlcmFsW0xpdGVyYWxbXCJTdHJpbmdcIl0gPSAyXSA9IFwiU3RyaW5nXCI7XG4gICAgTGl0ZXJhbFtMaXRlcmFsW1wiQnl0ZXNcIl0gPSAzXSA9IFwiQnl0ZXNcIjtcbiAgICBMaXRlcmFsW0xpdGVyYWxbXCJJZGVudFwiXSA9IDRdID0gXCJJZGVudFwiO1xufSkoTGl0ZXJhbCB8fCAoTGl0ZXJhbCA9IHt9KSk7XG5jb25zdCBpc1NwYWNlID0gbmV3IFJlZ0V4cCgnXFxcXHMnKTtcbmNvbnN0IGlzSWRlbnRTdGFydCA9IG5ldyBSZWdFeHAoJ1s6QCVfQS1aYS16XScpO1xuY29uc3QgaXNJZGVudCA9IG5ldyBSZWdFeHAoJ1tAJV9cXFxcLkEtWmEtejAtOV0nKTtcbmNvbnN0IGlzRGlnaXQgPSBuZXcgUmVnRXhwKCdbMC05XScpO1xuY29uc3QgaXNIZXggPSBuZXcgUmVnRXhwKCdbMC05YS1mQS1GXScpO1xuZnVuY3Rpb24qIHNjYW4oc3JjLCBzY2FuQ29tbWVudHMgPSBmYWxzZSkge1xuICAgIGxldCBpID0gMDtcbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgLy8gU2tpcCBzcGFjZVxuICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgaXNTcGFjZS50ZXN0KHNyY1tpXSkpIHtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaSA9PT0gc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHMgPSBzcmNbaV07XG4gICAgICAgIGNvbnN0IHN0YXJ0ID0gaTtcbiAgICAgICAgaWYgKGlzSWRlbnRTdGFydC50ZXN0KHMpKSB7XG4gICAgICAgICAgICAvLyBJZGVudGlmaWVyXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgaXNJZGVudC50ZXN0KHNyY1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB5aWVsZCB7IHQ6IExpdGVyYWwuSWRlbnQsIHY6IHNyYy5zbGljZShzdGFydCwgaSksIGZpcnN0OiBzdGFydCwgbGFzdDogaSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYy5sZW5ndGggLSBpID4gMSAmJiBzcmMuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gJzB4Jykge1xuICAgICAgICAgICAgLy8gQnl0ZXNcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCAmJiBpc0hleC50ZXN0KHNyY1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKChpIC0gc3RhcnQpICYgMSkgIT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2NhbkVycm9yKHNyYywgaSwgJ0J5dGVzIGxpdGVyYWwgbGVuZ3RoIGlzIGV4cGVjdGVkIHRvIGJlIHBvd2VyIG9mIHR3bycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgeyB0OiBMaXRlcmFsLkJ5dGVzLCB2OiBzcmMuc2xpY2Uoc3RhcnQsIGkpLCBmaXJzdDogc3RhcnQsIGxhc3Q6IGkgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0RpZ2l0LnRlc3QocykgfHwgcyA9PT0gJy0nKSB7XG4gICAgICAgICAgICAvLyBOdW1iZXJcbiAgICAgICAgICAgIGlmIChzID09PSAnLScpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpaSA9IGk7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgaXNEaWdpdC50ZXN0KHNyY1tpXSkpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaWkgPT09IGkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2NhbkVycm9yKHNyYywgaSwgJ051bWJlciBsaXRlcmFsIGlzIHRvbyBzaG9ydCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgeyB0OiBMaXRlcmFsLk51bWJlciwgdjogc3JjLnNsaWNlKHN0YXJ0LCBpKSwgZmlyc3Q6IHN0YXJ0LCBsYXN0OiBpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocyA9PT0gJ1wiJykge1xuICAgICAgICAgICAgLy8gU3RyaW5nXG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICBsZXQgZXNjID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKDsgaSA8IHNyYy5sZW5ndGggJiYgKGVzYyB8fCBzcmNbaV0gIT09ICdcIicpOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVzYyAmJiBzcmNbaV0gPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBlc2MgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXNjID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgU2NhbkVycm9yKHNyYywgaSwgJ1VudGVybWluYXRlZCBzdHJpbmcgbGl0ZXJhbCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgeWllbGQgeyB0OiBMaXRlcmFsLlN0cmluZywgdjogc3JjLnNsaWNlKHN0YXJ0LCBpKSwgZmlyc3Q6IHN0YXJ0LCBsYXN0OiBpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocyA9PT0gJyMnKSB7XG4gICAgICAgICAgICAvLyBDb21tZW50XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgc3JjW2ldICE9PSAnXFxuJykge1xuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2FuQ29tbWVudHMpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCB7IHQ6IExpdGVyYWwuQ29tbWVudCwgdjogc3JjLnNsaWNlKHN0YXJ0LCBpKSwgZmlyc3Q6IHN0YXJ0LCBsYXN0OiBpIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoc3JjLmxlbmd0aCAtIGkgPiAxICYmIHNyYy5zdWJzdHJpbmcoaSwgaSArIDIpID09PSAnLyonKSB7XG4gICAgICAgICAgICAvLyBDIHN0eWxlIGNvbW1lbnRcbiAgICAgICAgICAgIGkgKz0gMjtcbiAgICAgICAgICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCAmJiAhKHNyYy5sZW5ndGggLSBpID4gMSAmJiBzcmMuc3Vic3RyaW5nKGksIGkgKyAyKSA9PT0gJyovJykpIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gc3JjLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBTY2FuRXJyb3Ioc3JjLCBpLCAnVW50ZXJtaW5hdGVkIEMgc3R5bGUgY29tbWVudCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSArPSAyO1xuICAgICAgICAgICAgaWYgKHNjYW5Db21tZW50cykge1xuICAgICAgICAgICAgICAgIHlpZWxkIHsgdDogTGl0ZXJhbC5Db21tZW50LCB2OiBzcmMuc2xpY2Uoc3RhcnQsIGkpLCBmaXJzdDogc3RhcnQsIGxhc3Q6IGkgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzID09PSAnKCcgfHwgcyA9PT0gJyknIHx8IHMgPT09ICd7JyB8fCBzID09PSAnfScgfHwgcyA9PT0gJzsnKSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB5aWVsZCB7IHQ6IHMsIHY6IHMsIGZpcnN0OiBzdGFydCwgbGFzdDogaSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNjYW5FcnJvcihzcmMsIGksIGBJbnZhbGlkIGNoYXJhY3RlciBhdCBvZmZzZXQgJHtpfTogXFxgJHtzfSdgKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLy8gTWljaGVsc29uIHR5cGVzXG5jb25zdCByZWZDb250cmFjdCA9IFN5bWJvbCgncmVmX2NvbnRyYWN0Jyk7XG52YXIgUHJvdG9jb2w7XG4oZnVuY3Rpb24gKFByb3RvY29sKSB7XG4gICAgUHJvdG9jb2xbXCJQczltUG1YYVwiXSA9IFwiUHM5bVBtWGFSem16azM1Z2JBWU5DQXc2VVhkRTJxb0FCVEhiTjJvRUVjMXFNN0N3VDlQXCI7XG4gICAgUHJvdG9jb2xbXCJQdENKN3B3b1wiXSA9IFwiUHRDSjdwd294ZThKYXNuSFk4WW9ubkxZamNWSG1oaUFSUEp2cWNDNlZmSFQ1czhrOHNZXCI7XG4gICAgUHJvdG9jb2xbXCJQc1lMVnBWdlwiXSA9IFwiUHNZTFZwVnZnYkxoQWhvcUFrTUZVbzZndWRrSjl3ZU5YaFVZQ2lMRHpjVXBGcGtrOFd0XCI7XG4gICAgUHJvdG9jb2xbXCJQc2RkRktpM1wiXSA9IFwiUHNkZEZLaTMyY01KMnFQamY0M1F2NUdEV0xEUFpiM1QzYkY2ZkxLaUY1SHR2SE5VN2FQXCI7XG4gICAgUHJvdG9jb2xbXCJQdDI0bTR4aVwiXSA9IFwiUHQyNG00eGlQYkxEaFZnVmZBQlVqaXJibWRhM3lvaGROODJTcDlGZXVBWEo0ZVY5b3RkXCI7XG4gICAgUHJvdG9jb2xbXCJQc0JBQlk1SFwiXSA9IFwiUHNCQUJZNUhRVFNrQTQyOTd6Tkhmc1pOS3R4VUxmTDE4eTk1cWIzbTUzUUppWEdtcmJVXCI7XG4gICAgUHJvdG9jb2xbXCJQc0JhYnlNMVwiXSA9IFwiUHNCYWJ5TTFlVVhac2VhSmRtWEZBcERTQnFqOFlCZndFTG94WkhIVzc3RU1jQWJid0FTXCI7XG4gICAgUHJvdG9jb2xbXCJQc0NBUlRIQVwiXSA9IFwiUHNDQVJUSEFHYXpLYkh0bktmTHpRZzNrbXM1MmtTUnBnbkRZOTgyYTlvWXNTWFJMUUViXCI7XG4gICAgUHJvdG9jb2xbXCJQc0RFTFBIMVwiXSA9IFwiUHNERUxQSDFLeHN4dDhmOWVXYnhRZVJ4a2pmYnhvcU01Mmp2czVZNWZCeFdXaDRpZnBvXCI7XG4gICAgUHJvdG9jb2xbXCJQdEVkb1RlelwiXSA9IFwiUHRFZG9UZXpkM1JIU0MzMW1weHhvMW5weEZqb1dXY0ZnUXR4YXBpNTFaOFRMdTZ2NlVxXCI7XG4gICAgUHJvdG9jb2xbXCJQdEVkbzJaa1wiXSA9IFwiUHRFZG8yWmtUOW9LcGltVGFoNngyZW1iRjI1b3NzNTRuak11UHprSlRFaTVScWZkWkZBXCI7XG4gICAgUHJvdG9jb2xbXCJQc0ZMb3JlbmFcIl0gPSBcIlBzRkxvcmVuYVVVdWlrRFd2TURyNmZHQlJHOGt0M2UzRDNmSG9YSzFqMUJGUnhlU0g0aVwiO1xuICAgIFByb3RvY29sW1wiUHRHUkFOQURzXCJdID0gXCJQdEdSQU5BRHNEVThSOWRhWUtBZ1duUVlBSjY0b21OMW8zS01HVkN5a1NoQTk3dlFidlZcIjtcbiAgICBQcm90b2NvbFtcIlB0SGFuZ3pIXCJdID0gXCJQdEhhbmd6SG9nb2tTdWlNSGVtQ3Vvd0VhdmdZVFA4SjVxUTlmUVM3OTNNSFlGcENZM3JcIjtcbiAgICBQcm90b2NvbFtcIlB0SGFuZ3oyXCJdID0gXCJQdEhhbmd6MmFSbmd5d21TUkdHdnJjVHlNYmJkcFdkcEZLdVM0dU1XeGcyUmFIOWkxcXhcIjtcbiAgICBQcm90b2NvbFtcIlBzaVRoYUNhXCJdID0gXCJQc2lUaGFDYVQ0N1pib2F3NzFRV1NjTThzWGVNTTdiYlFGbmNLOUZMcVljNkVLZHBqVlBcIjtcbiAgICBQcm90b2NvbFtcIlBzaXRoYWNhMlwiXSA9IFwiUHNpdGhhY2EyTUxSRllhcmdpdnBvN1l2VXI3d1VEcXl4cmRoQzVDUXE3OG1SdmltejZBXCI7XG4gICAgUHJvdG9jb2xbXCJQdEpha2FydGFcIl0gPSBcIlB0SmFrYXJ0YWlEejY5U2ZERExYSlNpdVpxVFNlU0tSRGJLVlpDOE1OekpudlJqdm5Hd1wiO1xuICAgIFByb3RvY29sW1wiUHRKYWthcnQyXCJdID0gXCJQdEpha2FydDJ4Vmo3cFlYSkJYcnFIZ2Q4MnJka0xleTVaZWVHd0RnUHA5cmhRVWJTcVlcIjtcbiAgICBQcm90b2NvbFtcIlB0S2F0aG1hblwiXSA9IFwiUHRLYXRobWFua1NwTExEQUx6V3c3Q0dEMmoyTXR5dmVUd2JvRVlva3FVQ1A0YTFMeE1nXCI7XG4gICAgUHJvdG9jb2xbXCJQdExpbWFQdExcIl0gPSBcIlB0TGltYVB0TE13Zk5pbkppOXJDZkRQV2VhOGRGZ1RaMU1lSjlmMW0yU1JpYzZheWl3V1wiO1xuICAgIFByb3RvY29sW1wiUHRNdW1iYWlpXCJdID0gXCJQdE11bWJhaWlGRkVHYmV3MXJSanpTUHl6UmJBNTFUbTNSVlpMNXN1SFB4U1pZRGhDRWNcIjtcbiAgICBQcm90b2NvbFtcIlB0TXVtYmFpMlwiXSA9IFwiUHRNdW1iYWkyVG1zSkhOR1JrRDh2OFlEYnRhbzdCTFVDM3dqQVNuMWluQUtMRkNqYUgxXCI7XG4gICAgUHJvdG9jb2xbXCJQdE5haXJvYmlcIl0gPSBcIlB0TmFpcm9iaXlzc0h1aDg3aEVoZlZCR0NWckszV25TOFoyRlQ0eW1CNXRBYTRyMW5RZlwiO1xuICAgIFByb3RvY29sW1wiUHJveGZvcmRZXCJdID0gXCJQcm94Zm9yZFltVmZqV25SY2dqV0gzNmZXNlBBcndxeWtURnpvdFV4UnM2Z21UY1pEdUhcIjtcbiAgICBQcm90b2NvbFtcIlByb3RvQUxwaGFcIl0gPSBcIlByb3RvQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYURkcDN6S1wiO1xufSkoUHJvdG9jb2wgfHwgKFByb3RvY29sID0ge30pKTtcbmNvbnN0IERlZmF1bHRQcm90b2NvbCA9IFByb3RvY29sLlBzaXRoYWNhMjtcbmNvbnN0IHByb3RvTGV2ZWwgPSB7XG4gICAgUHM5bVBtWGFSem16azM1Z2JBWU5DQXc2VVhkRTJxb0FCVEhiTjJvRUVjMXFNN0N3VDlQOiAwLFxuICAgIFB0Q0o3cHdveGU4SmFzbkhZOFlvbm5MWWpjVkhtaGlBUlBKdnFjQzZWZkhUNXM4azhzWTogMSxcbiAgICBQc1lMVnBWdmdiTGhBaG9xQWtNRlVvNmd1ZGtKOXdlTlhoVVlDaUxEemNVcEZwa2s4V3Q6IDIsXG4gICAgUHNkZEZLaTMyY01KMnFQamY0M1F2NUdEV0xEUFpiM1QzYkY2ZkxLaUY1SHR2SE5VN2FQOiAzLFxuICAgIFB0MjRtNHhpUGJMRGhWZ1ZmQUJVamlyYm1kYTN5b2hkTjgyU3A5RmV1QVhKNGVWOW90ZDogNCxcbiAgICBQc0JBQlk1SFFUU2tBNDI5N3pOSGZzWk5LdHhVTGZMMTh5OTVxYjNtNTNRSmlYR21yYlU6IDUsXG4gICAgUHNCYWJ5TTFlVVhac2VhSmRtWEZBcERTQnFqOFlCZndFTG94WkhIVzc3RU1jQWJid0FTOiA1LFxuICAgIFBzQ0FSVEhBR2F6S2JIdG5LZkx6UWcza21zNTJrU1JwZ25EWTk4MmE5b1lzU1hSTFFFYjogNixcbiAgICBQc0RFTFBIMUt4c3h0OGY5ZVdieFFlUnhramZieG9xTTUyanZzNVk1ZkJ4V1doNGlmcG86IDcsXG4gICAgUHRFZG9UZXpkM1JIU0MzMW1weHhvMW5weEZqb1dXY0ZnUXR4YXBpNTFaOFRMdTZ2NlVxOiA4LFxuICAgIFB0RWRvMlprVDlvS3BpbVRhaDZ4MmVtYkYyNW9zczU0bmpNdVB6a0pURWk1UnFmZFpGQTogOCxcbiAgICBQc0ZMb3JlbmFVVXVpa0RXdk1EcjZmR0JSRzhrdDNlM0QzZkhvWEsxajFCRlJ4ZVNINGk6IDksXG4gICAgUHRHUkFOQURzRFU4UjlkYVlLQWdXblFZQUo2NG9tTjFvM0tNR1ZDeWtTaEE5N3ZRYnZWOiAxMCxcbiAgICBQdEhhbmd6SG9nb2tTdWlNSGVtQ3Vvd0VhdmdZVFA4SjVxUTlmUVM3OTNNSFlGcENZM3I6IDExLFxuICAgIFB0SGFuZ3oyYVJuZ3l3bVNSR0d2cmNUeU1iYmRwV2RwRkt1UzR1TVd4ZzJSYUg5aTFxeDogMTEsXG4gICAgUHNpVGhhQ2FUNDdaYm9hdzcxUVdTY004c1hlTU03YmJRRm5jSzlGTHFZYzZFS2RwalZQOiAxMixcbiAgICBQc2l0aGFjYTJNTFJGWWFyZ2l2cG83WXZVcjd3VURxeXhyZGhDNUNRcTc4bVJ2aW16NkE6IDEyLFxuICAgIFB0SmFrYXJ0YWlEejY5U2ZERExYSlNpdVpxVFNlU0tSRGJLVlpDOE1OekpudlJqdm5HdzogMTMsXG4gICAgUHRKYWthcnQyeFZqN3BZWEpCWHJxSGdkODJyZGtMZXk1WmVlR3dEZ1BwOXJoUVViU3FZOiAxMyxcbiAgICBQdEthdGhtYW5rU3BMTERBTHpXdzdDR0QyajJNdHl2ZVR3Ym9FWW9rcVVDUDRhMUx4TWc6IDE0LFxuICAgIFB0TGltYVB0TE13Zk5pbkppOXJDZkRQV2VhOGRGZ1RaMU1lSjlmMW0yU1JpYzZheWl3VzogMTUsXG4gICAgUHRNdW1iYWlpRkZFR2JldzFyUmp6U1B5elJiQTUxVG0zUlZaTDVzdUhQeFNaWURoQ0VjOiAxNixcbiAgICBQdE11bWJhaTJUbXNKSE5HUmtEOHY4WURidGFvN0JMVUMzd2pBU24xaW5BS0xGQ2phSDE6IDE2LFxuICAgIFB0TmFpcm9iaXlzc0h1aDg3aEVoZlZCR0NWckszV25TOFoyRlQ0eW1CNXRBYTRyMW5RZjogMTcsXG4gICAgUHJveGZvcmRZbVZmalduUmNnaldIMzZmVzZQQXJ3cXlrVEZ6b3RVeFJzNmdtVGNaRHVIOiAxOSxcbiAgICBQcm90b0FMcGhhQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYUFMcGhhQUxwaGFEZHAzeks6IDIwLFxufTtcbmZ1bmN0aW9uIFByb3RvR3JlYXRlck9yRXF1YWwoYSwgYikge1xuICAgIHJldHVybiBwcm90b0xldmVsW2FdID49IHByb3RvTGV2ZWxbYl07XG59XG5mdW5jdGlvbiBQcm90b0luZmVyaW9yVG8oYSwgYikge1xuICAgIHJldHVybiBwcm90b0xldmVsW2FdIDwgcHJvdG9MZXZlbFtiXTtcbn1cblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIG1hY3JvcyBmYWlsZWQgdG8gYmUgZXhwYW5kZWRcbiAqL1xuY2xhc3MgTWFjcm9FcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3IocHJpbSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByaW0gPSBwcmltO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTWFjcm9FcnJvcic7XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0QXJncyQxKGV4LCBuKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBpZiAoKG4gPT09IDAgJiYgZXguYXJncyA9PT0gdW5kZWZpbmVkKSB8fCAoKF9hID0gZXguYXJncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPT09IG4pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBNYWNyb0Vycm9yKGV4LCBgbWFjcm8gJHtleC5wcmltfSBleHBlY3RzICR7bn0gYXJndW1lbnRzLCB3YXMgZ2l2ZW4gJHsoX2IgPSBleC5hcmdzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RofWApO1xufVxuZnVuY3Rpb24gYXNzZXJ0Tm9Bbm5vdHMoZXgpIHtcbiAgICBpZiAoZXguYW5ub3RzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBNYWNyb0Vycm9yKGV4LCBgdW5leHBlY3RlZCBhbm5vdGF0aW9uIG9uIG1hY3JvICR7ZXgucHJpbX06ICR7ZXguYW5ub3RzfWApO1xufVxuZnVuY3Rpb24gYXNzZXJ0SW50QXJnKGV4LCBhcmcpIHtcbiAgICBpZiAoJ2ludCcgaW4gYXJnKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTWFjcm9FcnJvcihleCwgYG1hY3JvICR7ZXgucHJpbX0gZXhwZWN0cyBpbnQgYXJndW1lbnRgKTtcbn1cbmZ1bmN0aW9uIHBhcnNlUGFpclVucGFpckV4cHIocCwgZXhwciwgYW5ub3RhdGlvbnMsIGFnZykge1xuICAgIGxldCBpID0gMDtcbiAgICBsZXQgYWkgPSAwO1xuICAgIGNvbnN0IGFubiA9IFtudWxsLCBudWxsXTtcbiAgICAvLyBMZWZ0IGV4cHJlc3Npb25cbiAgICBsZXQgbGV4cHI7XG4gICAgaWYgKGkgPT09IGV4cHIubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBNYWNyb0Vycm9yKHAsIGB1bmV4cGVjdGVkIGVuZDogJHtwLnByaW19YCk7XG4gICAgfVxuICAgIGxldCBjID0gZXhwcltpKytdO1xuICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlICdQJzoge1xuICAgICAgICAgICAgY29uc3QgeyByLCBuLCBhbiB9ID0gcGFyc2VQYWlyVW5wYWlyRXhwcihwLCBleHByLnNsaWNlKGkpLCBhbm5vdGF0aW9ucy5zbGljZShhaSksIGFnZyk7XG4gICAgICAgICAgICBsZXhwciA9IHI7XG4gICAgICAgICAgICBpICs9IG47XG4gICAgICAgICAgICBhaSArPSBhbjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgJ0EnOlxuICAgICAgICAgICAgaWYgKGFpICE9PSBhbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbm5bMF0gPSBhbm5vdGF0aW9uc1thaSsrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IE1hY3JvRXJyb3IocCwgYCR7cC5wcmltfTogdW5leHBlY3RlZCBjaGFyYWN0ZXI6ICR7Y31gKTtcbiAgICB9XG4gICAgLy8gUmlnaHQgZXhwcmVzc2lvblxuICAgIGxldCByZXhwcjtcbiAgICBpZiAoaSA9PT0gZXhwci5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1hY3JvRXJyb3IocCwgYHVuZXhwZWN0ZWQgZW5kOiAke3AucHJpbX1gKTtcbiAgICB9XG4gICAgYyA9IGV4cHJbaSsrXTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnUCc6IHtcbiAgICAgICAgICAgIGNvbnN0IHsgciwgbiwgYW4gfSA9IHBhcnNlUGFpclVucGFpckV4cHIocCwgZXhwci5zbGljZShpKSwgYW5ub3RhdGlvbnMuc2xpY2UoYWkpLCBhZ2cpO1xuICAgICAgICAgICAgcmV4cHIgPSByLm1hcCgoW3YsIGFdKSA9PiBbdiArIDEsIGFdKTtcbiAgICAgICAgICAgIGkgKz0gbjtcbiAgICAgICAgICAgIGFpICs9IGFuO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICBpZiAoYWkgIT09IGFubm90YXRpb25zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGFublsxXSA9IGFubm90YXRpb25zW2FpKytdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWFjcm9FcnJvcihwLCBgJHtwLnByaW19OiB1bmV4cGVjdGVkIGNoYXJhY3RlcjogJHtjfWApO1xuICAgIH1cbiAgICByZXR1cm4geyByOiBhZ2cobGV4cHIsIHJleHByLCBbMCwgYW5uXSksIG46IGksIGFuOiBhaSB9O1xufVxuZnVuY3Rpb24gcGFyc2VTZXRNYXBDYWRyKHAsIGV4cHIsIHZhbm4sIHRlcm0pIHtcbiAgICBjb25zdCBjID0gZXhwclswXTtcbiAgICBzd2l0Y2ggKGMpIHtcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICByZXR1cm4gZXhwci5sZW5ndGggPiAxXG4gICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ0RVUCcgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0RJUCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW3sgcHJpbTogJ0NBUicsIGFubm90czogWydAJSUnXSB9LCBwYXJzZVNldE1hcENhZHIocCwgZXhwci5zbGljZSgxKSwgW10sIHRlcm0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ0NEUicsIGFubm90czogWydAJSUnXSB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdTV0FQJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdQQUlSJywgYW5ub3RzOiBbJyVAJywgJyVAJywgLi4udmFubl0gfSxcbiAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgOiB0ZXJtLmE7XG4gICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgcmV0dXJuIGV4cHIubGVuZ3RoID4gMVxuICAgICAgICAgICAgICAgID8gW1xuICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdEVVAnIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdESVAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFt7IHByaW06ICdDRFInLCBhbm5vdHM6IFsnQCUlJ10gfSwgcGFyc2VTZXRNYXBDYWRyKHAsIGV4cHIuc2xpY2UoMSksIFtdLCB0ZXJtKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdDQVInLCBhbm5vdHM6IFsnQCUlJ10gfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnUEFJUicsIGFubm90czogWyclQCcsICclQCcsIC4uLnZhbm5dIH0sXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIDogdGVybS5kO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IE1hY3JvRXJyb3IocCwgYCR7cC5wcmltfTogdW5leHBlY3RlZCBjaGFyYWN0ZXI6ICR7Y31gKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmltTGFzdChhLCB2KSB7XG4gICAgbGV0IGwgPSBhLmxlbmd0aDtcbiAgICB3aGlsZSAobCA+IDAgJiYgYVtsIC0gMV0gPT09IHYpIHtcbiAgICAgICAgbC0tO1xuICAgIH1cbiAgICByZXR1cm4gYS5zbGljZSgwLCBsKTtcbn1cbmZ1bmN0aW9uIGZpbHRlckFubm90YXRpb25zKGEpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXTtcbiAgICBjb25zdCByZXN0ID0gW107XG4gICAgaWYgKGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYSkge1xuICAgICAgICAgICAgKHYubGVuZ3RoICE9PSAwICYmIHZbMF0gPT09ICclJyA/IGZpZWxkcyA6IHJlc3QpLnB1c2godik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZmllbGRzLCByZXN0IH07XG59XG5mdW5jdGlvbiBta1ByaW0oeyBwcmltLCBhbm5vdHMsIGFyZ3MgfSkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oeyBwcmltIH0sIChhbm5vdHMgJiYgeyBhbm5vdHMgfSkpLCAoYXJncyAmJiB7IGFyZ3MgfSkpO1xufVxuY29uc3QgcGFpclJlID0gL15QW1BBSV17Myx9UiQvO1xuY29uc3QgdW5wYWlyUmUgPSAvXlVOUFtQQUldezIsfVIkLztcbmNvbnN0IGNhZHJSZSA9IC9eQ1tBRF17Mix9UiQvO1xuY29uc3Qgc2V0Q2FkclJlID0gL15TRVRfQ1tBRF0rUiQvO1xuY29uc3QgbWFwQ2FkclJlID0gL15NQVBfQ1tBRF0rUiQvO1xuY29uc3QgZGlpcFJlID0gL15ESXsyLH1QJC87XG5jb25zdCBkdXVwUmUgPSAvXkRVK1AkLztcbmZ1bmN0aW9uIGV4cGFuZE1hY3JvcyhleCwgb3B0KSB7XG4gICAgY29uc3QgcHJvdG8gPSAob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LnByb3RvY29sKSB8fCBEZWZhdWx0UHJvdG9jb2w7XG4gICAgZnVuY3Rpb24gbWF5UmVuYW1lKGFubm90cykge1xuICAgICAgICByZXR1cm4gYW5ub3RzICE9PSB1bmRlZmluZWQgPyBbeyBwcmltOiAnUkVOQU1FJywgYW5ub3RzIH1dIDogW107XG4gICAgfVxuICAgIHN3aXRjaCAoZXgucHJpbSkge1xuICAgICAgICAvLyBDb21wYXJlXG4gICAgICAgIGNhc2UgJ0NNUEVRJzpcbiAgICAgICAgY2FzZSAnQ01QTkVRJzpcbiAgICAgICAgY2FzZSAnQ01QTFQnOlxuICAgICAgICBjYXNlICdDTVBHVCc6XG4gICAgICAgIGNhc2UgJ0NNUExFJzpcbiAgICAgICAgY2FzZSAnQ01QR0UnOlxuICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MkMShleCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3sgcHJpbTogJ0NPTVBBUkUnIH0sIG1rUHJpbSh7IHByaW06IGV4LnByaW0uc2xpY2UoMyksIGFubm90czogZXguYW5ub3RzIH0pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdJRkVRJzpcbiAgICAgICAgY2FzZSAnSUZORVEnOlxuICAgICAgICBjYXNlICdJRkxUJzpcbiAgICAgICAgY2FzZSAnSUZHVCc6XG4gICAgICAgIGNhc2UgJ0lGTEUnOlxuICAgICAgICBjYXNlICdJRkdFJzpcbiAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzJDEoZXgsIDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcmltOiBleC5wcmltLnNsaWNlKDIpIH0sXG4gICAgICAgICAgICAgICAgICAgIG1rUHJpbSh7IHByaW06ICdJRicsIGFubm90czogZXguYW5ub3RzLCBhcmdzOiBleC5hcmdzIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSUZDTVBFUSc6XG4gICAgICAgIGNhc2UgJ0lGQ01QTkVRJzpcbiAgICAgICAgY2FzZSAnSUZDTVBMVCc6XG4gICAgICAgIGNhc2UgJ0lGQ01QR1QnOlxuICAgICAgICBjYXNlICdJRkNNUExFJzpcbiAgICAgICAgY2FzZSAnSUZDTVBHRSc6XG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ0NPTVBBUkUnIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogZXgucHJpbS5zbGljZSg1KSB9LFxuICAgICAgICAgICAgICAgICAgICBta1ByaW0oeyBwcmltOiAnSUYnLCBhbm5vdHM6IGV4LmFubm90cywgYXJnczogZXguYXJncyB9KSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIEZhaWxcbiAgICAgICAgY2FzZSAnRkFJTCc6XG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAwKSAmJiBhc3NlcnROb0Fubm90cyhleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3sgcHJpbTogJ1VOSVQnIH0sIHsgcHJpbTogJ0ZBSUxXSVRIJyB9XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBBc3NlcnRpb24gbWFjcm9zXG4gICAgICAgIGNhc2UgJ0FTU0VSVCc6XG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAwKSAmJiBhc3NlcnROb0Fubm90cyhleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltOiAnSUYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1tdLCBbW3sgcHJpbTogJ1VOSVQnIH0sIHsgcHJpbTogJ0ZBSUxXSVRIJyB9XV1dLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQVNTRVJUX0VRJzpcbiAgICAgICAgY2FzZSAnQVNTRVJUX05FUSc6XG4gICAgICAgIGNhc2UgJ0FTU0VSVF9MVCc6XG4gICAgICAgIGNhc2UgJ0FTU0VSVF9HVCc6XG4gICAgICAgIGNhc2UgJ0FTU0VSVF9MRSc6XG4gICAgICAgIGNhc2UgJ0FTU0VSVF9HRSc6XG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAwKSAmJiBhc3NlcnROb0Fubm90cyhleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7IHByaW06IGV4LnByaW0uc2xpY2UoNykgfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0lGJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtbXSwgW1t7IHByaW06ICdVTklUJyB9LCB7IHByaW06ICdGQUlMV0lUSCcgfV1dXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FTU0VSVF9DTVBFUSc6XG4gICAgICAgIGNhc2UgJ0FTU0VSVF9DTVBORVEnOlxuICAgICAgICBjYXNlICdBU1NFUlRfQ01QTFQnOlxuICAgICAgICBjYXNlICdBU1NFUlRfQ01QR1QnOlxuICAgICAgICBjYXNlICdBU1NFUlRfQ01QTEUnOlxuICAgICAgICBjYXNlICdBU1NFUlRfQ01QR0UnOlxuICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MkMShleCwgMCkgJiYgYXNzZXJ0Tm9Bbm5vdHMoZXgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgW3sgcHJpbTogJ0NPTVBBUkUnIH0sIHsgcHJpbTogZXgucHJpbS5zbGljZSgxMCkgfV0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdJRicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbW10sIFtbeyBwcmltOiAnVU5JVCcgfSwgeyBwcmltOiAnRkFJTFdJVEgnIH1dXV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBU1NFUlRfTk9ORSc6XG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAwKSAmJiBhc3NlcnROb0Fubm90cyhleCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltOiAnSUZfTk9ORScsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbW10sIFtbeyBwcmltOiAnVU5JVCcgfSwgeyBwcmltOiAnRkFJTFdJVEgnIH1dXV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdBU1NFUlRfU09NRSc6XG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAwKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdJRl9OT05FJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtbW3sgcHJpbTogJ1VOSVQnIH0sIHsgcHJpbTogJ0ZBSUxXSVRIJyB9XV0sIG1heVJlbmFtZShleC5hbm5vdHMpXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0FTU0VSVF9MRUZUJzpcbiAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzJDEoZXgsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0lGX0xFRlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW21heVJlbmFtZShleC5hbm5vdHMpLCBbW3sgcHJpbTogJ1VOSVQnIH0sIHsgcHJpbTogJ0ZBSUxXSVRIJyB9XV1dLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQVNTRVJUX1JJR0hUJzpcbiAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzJDEoZXgsIDApKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0lGX0xFRlQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1tbeyBwcmltOiAnVU5JVCcgfSwgeyBwcmltOiAnRkFJTFdJVEgnIH1dXSwgbWF5UmVuYW1lKGV4LmFubm90cyldLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gU3ludGFjdGljIGNvbnZlbmllbmNlc1xuICAgICAgICBjYXNlICdJRl9TT01FJzpcbiAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzJDEoZXgsIDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtta1ByaW0oeyBwcmltOiAnSUZfTk9ORScsIGFubm90czogZXguYW5ub3RzLCBhcmdzOiBbZXguYXJnc1sxXSwgZXguYXJnc1swXV0gfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ0lGX1JJR0hUJzpcbiAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzJDEoZXgsIDIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtta1ByaW0oeyBwcmltOiAnSUZfTEVGVCcsIGFubm90czogZXguYW5ub3RzLCBhcmdzOiBbZXguYXJnc1sxXSwgZXguYXJnc1swXV0gfSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIC8vIENBUi9DRFIgblxuICAgICAgICBjYXNlICdDQVInOlxuICAgICAgICBjYXNlICdDRFInOlxuICAgICAgICAgICAgaWYgKGV4LmFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzJDEoZXgsIDEpICYmIGFzc2VydEludEFyZyhleCwgZXguYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGV4LmFyZ3NbMF0uaW50LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBta1ByaW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0dFVCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbeyBpbnQ6IGV4LnByaW0gPT09ICdDQVInID8gU3RyaW5nKG4gKiAyICsgMSkgOiBTdHJpbmcobiAqIDIpIH1dLFxuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RzOiBleC5hbm5vdHMsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgLy8gTW9yZSBzeW50YWN0aWMgY29udmVuaWVuY2VzXG4gICAgLy8gUEFQUEFJSVIgbWFjcm9cbiAgICBpZiAocGFpclJlLnRlc3QoZXgucHJpbSkpIHtcbiAgICAgICAgaWYgKGFzc2VydEFyZ3MkMShleCwgMCkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmllbGRzLCByZXN0IH0gPSBmaWx0ZXJBbm5vdGF0aW9ucyhleC5hbm5vdHMpO1xuICAgICAgICAgICAgY29uc3QgeyByIH0gPSBwYXJzZVBhaXJVbnBhaXJFeHByKGV4LCBleC5wcmltLnNsaWNlKDEpLCBmaWVsZHMsIChsLCByLCB0b3ApID0+IFtcbiAgICAgICAgICAgICAgICAuLi4obCB8fCBbXSksXG4gICAgICAgICAgICAgICAgLi4uKHIgfHwgW10pLFxuICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgcmV0dXJuIHIubWFwKChbdiwgYV0sIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbm4gPSBbXG4gICAgICAgICAgICAgICAgICAgIC4uLnRyaW1MYXN0KGEsIG51bGwpLm1hcCgodikgPT4gKHYgPT09IG51bGwgPyAnJScgOiB2KSksXG4gICAgICAgICAgICAgICAgICAgIC4uLih2ID09PSAwICYmIGkgPT09IHIubGVuZ3RoIC0gMSA/IHJlc3QgOiBbXSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gbWtQcmltKHsgcHJpbTogJ1BBSVInLCBhbm5vdHM6IGFubi5sZW5ndGggIT09IDAgPyBhbm4gOiB1bmRlZmluZWQgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgPyBsZWFmXG4gICAgICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0RJUCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiB2ID09PSAxID8gW1tsZWFmXV0gOiBbeyBpbnQ6IFN0cmluZyh2KSB9LCBbbGVhZl1dLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVU5QQVBQQUlJUiBtYWNyb1xuICAgIGlmICh1bnBhaXJSZS50ZXN0KGV4LnByaW0pKSB7XG4gICAgICAgIGlmIChQcm90b0luZmVyaW9yVG8ocHJvdG8sIFByb3RvY29sLlB0RWRvMlprKSAmJiBhc3NlcnRBcmdzJDEoZXgsIDApKSB7XG4gICAgICAgICAgICBjb25zdCB7IHIgfSA9IHBhcnNlUGFpclVucGFpckV4cHIoZXgsIGV4LnByaW0uc2xpY2UoMyksIGV4LmFubm90cyB8fCBbXSwgKGwsIHIsIHRvcCkgPT4gW1xuICAgICAgICAgICAgICAgIHRvcCxcbiAgICAgICAgICAgICAgICAuLi4ociB8fCBbXSksXG4gICAgICAgICAgICAgICAgLi4uKGwgfHwgW10pLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gci5tYXAoKFt2LCBhXSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlYWYgPSBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ0RVUCcgfSxcbiAgICAgICAgICAgICAgICAgICAgbWtQcmltKHsgcHJpbTogJ0NBUicsIGFubm90czogYVswXSAhPT0gbnVsbCA/IFthWzBdXSA6IHVuZGVmaW5lZCB9KSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0RJUCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbW21rUHJpbSh7IHByaW06ICdDRFInLCBhbm5vdHM6IGFbMV0gIT09IG51bGwgPyBbYVsxXV0gOiB1bmRlZmluZWQgfSldXSxcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2ID09PSAwXG4gICAgICAgICAgICAgICAgICAgID8gbGVhZlxuICAgICAgICAgICAgICAgICAgICA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdESVAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogdiA9PT0gMSA/IFtbbGVhZl1dIDogW3sgaW50OiBTdHJpbmcodikgfSwgW2xlYWZdXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGV4LnByaW0gPT09ICdVTlBBSVInKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MkMShleCwgMCkpIHtcbiAgICAgICAgICAgICAgICAvLyAwMDhfZWRvOiBhbm5vdGF0aW9ucyBhcmUgZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IHsgciB9ID0gcGFyc2VQYWlyVW5wYWlyRXhwcihleCwgZXgucHJpbS5zbGljZSgzKSwgW10sIChsLCByLCB0b3ApID0+IFtcbiAgICAgICAgICAgICAgICAgICAgdG9wLFxuICAgICAgICAgICAgICAgICAgICAuLi4ociB8fCBbXSksXG4gICAgICAgICAgICAgICAgICAgIC4uLihsIHx8IFtdKSxcbiAgICAgICAgICAgICAgICBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gci5tYXAoKFt2XSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsZWFmID0gbWtQcmltKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdVTlBBSVInLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHYgPT09IDBcbiAgICAgICAgICAgICAgICAgICAgICAgID8gbGVhZlxuICAgICAgICAgICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0RJUCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogdiA9PT0gMSA/IFtbbGVhZl1dIDogW3sgaW50OiBTdHJpbmcodikgfSwgW2xlYWZdXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gQ1tBRF0rUiBtYWNyb1xuICAgIGlmIChjYWRyUmUudGVzdChleC5wcmltKSkge1xuICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAwKSkge1xuICAgICAgICAgICAgY29uc3QgY2ggPSBbLi4uZXgucHJpbS5zbGljZSgxLCBleC5wcmltLmxlbmd0aCAtIDEpXTtcbiAgICAgICAgICAgIHJldHVybiBjaC5tYXAoKGMsIGkpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhbm4gPSBpID09PSBjaC5sZW5ndGggLSAxID8gZXguYW5ub3RzIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdBJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBta1ByaW0oeyBwcmltOiAnQ0FSJywgYW5ub3RzOiBhbm4gfSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ0QnOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1rUHJpbSh7IHByaW06ICdDRFInLCBhbm5vdHM6IGFubiB9KTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNYWNyb0Vycm9yKGV4LCBgdW5leHBlY3RlZCBjaGFyYWN0ZXI6ICR7Y31gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBTRVRfQ1tBRF0rUiBtYWNyb1xuICAgIGlmIChzZXRDYWRyUmUudGVzdChleC5wcmltKSkge1xuICAgICAgICBpZiAoYXNzZXJ0QXJncyQxKGV4LCAwKSkge1xuICAgICAgICAgICAgY29uc3QgeyBmaWVsZHMsIHJlc3QgfSA9IGZpbHRlckFubm90YXRpb25zKGV4LmFubm90cyk7XG4gICAgICAgICAgICBpZiAoZmllbGRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWFjcm9FcnJvcihleCwgYHVuZXhwZWN0ZWQgYW5ub3RhdGlvbiBvbiBtYWNybyAke2V4LnByaW19OiAke2ZpZWxkc31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRlcm0gPSBmaWVsZHMubGVuZ3RoICE9PSAwXG4gICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgIGE6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ0RVUCcgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ0NBUicsIGFubm90czogZmllbGRzIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdEUk9QJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnQ0RSJywgYW5ub3RzOiBbJ0AlJSddIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdTV0FQJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnUEFJUicsIGFubm90czogW2ZpZWxkc1swXSwgJyVAJ10gfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgZDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnRFVQJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnQ0RSJywgYW5ub3RzOiBmaWVsZHMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ0RST1AnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdDQVInLCBhbm5vdHM6IFsnQCUlJ10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ1BBSVInLCBhbm5vdHM6IFsnJUAnLCBmaWVsZHNbMF1dIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDoge1xuICAgICAgICAgICAgICAgICAgICBhOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdDRFInLCBhbm5vdHM6IFsnQCUlJ10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ1NXQVAnIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdQQUlSJywgYW5ub3RzOiBbJyUnLCAnJUAnXSB9LFxuICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICBkOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdDQVInLCBhbm5vdHM6IFsnQCUlJ10gfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ1BBSVInLCBhbm5vdHM6IFsnJUAnLCAnJSddIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZVNldE1hcENhZHIoZXgsIGV4LnByaW0uc2xpY2UoNSwgZXgucHJpbS5sZW5ndGggLSAxKSwgcmVzdCwgdGVybSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gTUFQX0NbQURdK1IgbWFjcm9cbiAgICBpZiAobWFwQ2FkclJlLnRlc3QoZXgucHJpbSkpIHtcbiAgICAgICAgaWYgKGFzc2VydEFyZ3MkMShleCwgMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZmllbGRzIH0gPSBmaWx0ZXJBbm5vdGF0aW9ucyhleC5hbm5vdHMpO1xuICAgICAgICAgICAgaWYgKGZpZWxkcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1hY3JvRXJyb3IoZXgsIGB1bmV4cGVjdGVkIGFubm90YXRpb24gb24gbWFjcm8gJHtleC5wcmltfTogJHtmaWVsZHN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB0ZXJtID0ge1xuICAgICAgICAgICAgICAgIGE6IFtcbiAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnRFVQJyB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdDRFInLCBhbm5vdHM6IFsnQCUlJ10gfSxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0RJUCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBta1ByaW0oe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0NBUicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdHM6IGZpZWxkcy5sZW5ndGggIT09IDAgPyBbJ0AnICsgZmllbGRzWzBdLnNsaWNlKDEpXSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4LmFyZ3NbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ1NXQVAnIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ1BBSVInLCBhbm5vdHM6IFtmaWVsZHMubGVuZ3RoICE9PSAwID8gZmllbGRzWzBdIDogJyUnLCAnJUAnXSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgZDogW1xuICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdEVVAnIH0sXG4gICAgICAgICAgICAgICAgICAgIG1rUHJpbSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltOiAnQ0RSJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90czogZmllbGRzLmxlbmd0aCAhPT0gMCA/IFsnQCcgKyBmaWVsZHNbMF0uc2xpY2UoMSldIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgZXguYXJnc1swXSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnU1dBUCcgfSxcbiAgICAgICAgICAgICAgICAgICAgeyBwcmltOiAnQ0FSJywgYW5ub3RzOiBbJ0AlJSddIH0sXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ1BBSVInLCBhbm5vdHM6IFsnJUAnLCBmaWVsZHMubGVuZ3RoICE9PSAwID8gZmllbGRzWzBdIDogJyUnXSB9LFxuICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHBhcnNlU2V0TWFwQ2FkcihleCwgZXgucHJpbS5zbGljZSg1LCBleC5wcmltLmxlbmd0aCAtIDEpLCBbXSwgdGVybSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhwYW5kIGRlcHJlY2F0ZWQgREkuLi5JUCB0byBbRElQIG5dXG4gICAgaWYgKGRpaXBSZS50ZXN0KGV4LnByaW0pKSB7XG4gICAgICAgIGlmIChhc3NlcnRBcmdzJDEoZXgsIDEpKSB7XG4gICAgICAgICAgICBsZXQgbiA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoZXgucHJpbVsxICsgbl0gPT09ICdJJykge1xuICAgICAgICAgICAgICAgIG4rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBta1ByaW0oeyBwcmltOiAnRElQJywgYXJnczogW3sgaW50OiBTdHJpbmcobikgfSwgZXguYXJnc1swXV0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gRXhwYW5kIERVLi4uVVAgYW5kIERVUCBuXG4gICAgaWYgKGR1dXBSZS50ZXN0KGV4LnByaW0pKSB7XG4gICAgICAgIGxldCBuID0gMDtcbiAgICAgICAgd2hpbGUgKGV4LnByaW1bMSArIG5dID09PSAnVScpIHtcbiAgICAgICAgICAgIG4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoUHJvdG9JbmZlcmlvclRvKHByb3RvLCBQcm90b2NvbC5QdEVkbzJaaykpIHtcbiAgICAgICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4LmFyZ3MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXg7IC8vIHNraXBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MkMShleCwgMSkgJiYgYXNzZXJ0SW50QXJnKGV4LCBleC5hcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICBuID0gcGFyc2VJbnQoZXguYXJnc1swXS5pbnQsIDEwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmdzJDEoZXgsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG4gPT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW21rUHJpbSh7IHByaW06ICdEVVAnLCBhbm5vdHM6IGV4LmFubm90cyB9KV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChuID09PSAyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ0RJUCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbW21rUHJpbSh7IHByaW06ICdEVVAnLCBhbm5vdHM6IGV4LmFubm90cyB9KV1dLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB7IHByaW06ICdTV0FQJyB9LFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltOiAnRElQJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt7IGludDogU3RyaW5nKG4gLSAxKSB9LCBbbWtQcmltKHsgcHJpbTogJ0RVUCcsIGFubm90czogZXguYW5ub3RzIH0pXV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdESUcnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3sgaW50OiBTdHJpbmcobikgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChuID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MkMShleCwgMCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWtQcmltKHsgcHJpbTogJ0RVUCcsIGFyZ3M6IFt7IGludDogU3RyaW5nKG4pIH1dLCBhbm5vdHM6IGV4LmFubm90cyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXg7XG59XG5cbmZ1bmN0aW9uIGV4cGFuZEdsb2JhbENvbnN0YW50cyhleCwgaGFzaEFuZFZhbHVlKSB7XG4gICAgaWYgKGV4LmFyZ3MgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBleC5hcmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAnc3RyaW5nJyBpbiBleC5hcmdzWzBdICYmXG4gICAgICAgIGV4LmFyZ3NbMF0uc3RyaW5nIGluIGhhc2hBbmRWYWx1ZSkge1xuICAgICAgICByZXR1cm4gaGFzaEFuZFZhbHVlW2V4LmFyZ3NbMF0uc3RyaW5nXTtcbiAgICB9XG4gICAgcmV0dXJuIGV4O1xufVxuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIHdoZW4gcGFyc2luZyBNaWNoZWxpbmUgZXhwcmVzc2lvbnNcbiAqL1xuY2xhc3MgTWljaGVsaW5lUGFyc2VFcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHRva2VuIEEgdG9rZW4gY2F1c2VkIHRoZSBlcnJvclxuICAgICAqIEBwYXJhbSBtZXNzYWdlIEFuIGVycm9yIG1lc3NhZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdNaWNoZWxpbmVQYXJzZUVycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgaW5kaWNhdGVzIGEgZmFpbHVyZSB3aGVuIHBhcnNpbmcgTWljaGVsaW5lIEpTT05cbiAqL1xuY2xhc3MgSlNPTlBhcnNlRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIC8qKlxuICAgICAqIEBwYXJhbSBub2RlIEEgbm9kZSBjYXVzZWQgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgQW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5vZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0pTT05QYXJzZUVycm9yJztcbiAgICB9XG59XG5jb25zdCBlcnJFT0YgPSBuZXcgTWljaGVsaW5lUGFyc2VFcnJvcihudWxsLCAnVW5leHBlY3RlZCBFT0YnKTtcbmZ1bmN0aW9uIGlzQW5ub3RhdGlvbih0b2spIHtcbiAgICByZXR1cm4gdG9rLnQgPT09IExpdGVyYWwuSWRlbnQgJiYgKHRvay52WzBdID09PSAnQCcgfHwgdG9rLnZbMF0gPT09ICclJyB8fCB0b2sudlswXSA9PT0gJzonKTtcbn1cbmNvbnN0IGludFJlID0gbmV3IFJlZ0V4cCgnXi0/WzAtOV0rJCcpO1xuY29uc3QgYnl0ZXNSZSA9IG5ldyBSZWdFeHAoJ14oWzAtOWEtZkEtRl17Mn0pKiQnKTtcbi8qKlxuICogQ29udmVydHMgYW5kIHZhbGlkYXRlcyBNaWNoZWxzb24gZXhwcmVzc2lvbnMgYmV0d2VlbiBKU09OLWJhc2VkIE1pY2hlbHNvbiBhbmQgTWljaGVsaW5lXG4gKlxuICogUHJldHR5IFByaW50IGEgTWljaGVsc29uIFNtYXJ0IENvbnRyYWN0OlxuICogYGBgXG4gKiBjb25zdCBjb250cmFjdCA9IGF3YWl0IFRlem9zLmNvbnRyYWN0LmF0KFwiS1QxVnN3M2toOTYzOGdxV29IVGp2SENvSExQS3ZDYk1WYkNnXCIpO1xuICogY29uc3QgcCA9IG5ldyBQYXJzZXIoKTtcbiAqXG4gKiBjb25zdCBtaWNoZWxzb25Db2RlID0gcC5wYXJzZUpTT04oY29udHJhY3Quc2NyaXB0LmNvZGUpO1xuICogY29uc3Qgc3RvcmFnZSA9IHAucGFyc2VKU09OKGNvbnRyYWN0LnNjcmlwdC5zdG9yYWdlKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhcIlByZXR0eSBwcmludCBNaWNoZWxzb24gc21hcnQgY29udHJhY3Q6XCIpO1xuICogY29uc29sZS5sb2coZW1pdE1pY2hlbGluZShtaWNoZWxzb25Db2RlLCB7aW5kZW50OlwiICAgIFwiLCBuZXdsaW5lOiBcIlxcblwiLH0pKTtcbiAqXG4gKiBjb25zb2xlLmxvZyhcIlByZXR0eSBwcmludCBTdG9yYWdlOlwiKTtcbiAqIGNvbnNvbGUubG9nKGVtaXRNaWNoZWxpbmUoc3RvcmFnZSwge2luZGVudDpcIiAgICBcIiwgbmV3bGluZTogXCJcXG5cIix9KSk7XG4gKiBgYGBcbiAqXG4gKiBFbmNvZGUgYSBNaWNoZWxzb24gZXhwcmVzc2lvbiBmb3IgaW5pdGlhbCBzdG9yYWdlIG9mIGEgc21hcnQgY29udHJhY3RcbiAqIGBgYFxuICogY29uc3Qgc3JjID0gYChQYWlyIChQYWlyIHsgRWx0IDFcbiAqICAgICAgICAgICAgICAgIChQYWlyIChQYWlyIFwidHoxZ2phRjgxWlJSdmR6am9ieWZWTnNBZVNDNlBTY2pmUXdOXCIgXCJ0ejFLcVRwRVo3WW9iN1FiUEU0SHk0V284ZkhHOExoS3haU3hcIilcbiAqICAgICAgICAgICAgICAgICAgICAgIDB4MDUwMTAwMDAwMDAyNjg2OSkgfVxuICogICAgICAgICAgMTAwMDAwMDApXG4gKiAgICAoUGFpciAyIDMzMykpYDtcbiAqXG4gKiBjb25zdCBwID0gbmV3IFBhcnNlcigpO1xuICpcbiAqIGNvbnN0IGV4cCA9IHAucGFyc2VNaWNoZWxpbmVFeHByZXNzaW9uKHNyYyk7XG4gKiBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShleHApKTtcbiAqIGBgYFxuICovXG5jbGFzcyBQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKG9wdCkge1xuICAgICAgICB0aGlzLm9wdCA9IG9wdDtcbiAgICB9XG4gICAgZXhwYW5kKGV4KSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICBpZiAoKChfYSA9IHRoaXMub3B0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXhwYW5kR2xvYmFsQ29uc3RhbnQpICE9PSB1bmRlZmluZWQgJiYgZXgucHJpbSA9PT0gJ2NvbnN0YW50Jykge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gZXhwYW5kR2xvYmFsQ29uc3RhbnRzKGV4LCB0aGlzLm9wdC5leHBhbmRHbG9iYWxDb25zdGFudCk7XG4gICAgICAgICAgICBpZiAocmV0ICE9PSBleCkge1xuICAgICAgICAgICAgICAgIHJldFtzb3VyY2VSZWZlcmVuY2VdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoZXhbc291cmNlUmVmZXJlbmNlXSB8fCB7IGZpcnN0OiAwLCBsYXN0OiAwIH0pKSwgeyBnbG9iYWxDb25zdGFudDogZXggfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9iID0gdGhpcy5vcHQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5leHBhbmRNYWNyb3MpICE9PSB1bmRlZmluZWQgPyAoX2MgPSB0aGlzLm9wdCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmV4cGFuZE1hY3JvcyA6IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHJldCA9IGV4cGFuZE1hY3JvcyhleCwgdGhpcy5vcHQpO1xuICAgICAgICAgICAgaWYgKHJldCAhPT0gZXgpIHtcbiAgICAgICAgICAgICAgICByZXRbc291cmNlUmVmZXJlbmNlXSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgKGV4W3NvdXJjZVJlZmVyZW5jZV0gfHwgeyBmaXJzdDogMCwgbGFzdDogMCB9KSksIHsgbWFjcm86IGV4IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUxpc3RFeHByKHNjYW5uZXIsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgY29uc3QgcmVmID0ge1xuICAgICAgICAgICAgZmlyc3Q6IHN0YXJ0LmZpcnN0LFxuICAgICAgICAgICAgbGFzdDogc3RhcnQubGFzdCxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgZXhwZWN0QnJhY2tldCA9IHN0YXJ0LnQgPT09ICcoJztcbiAgICAgICAgbGV0IHRvaztcbiAgICAgICAgaWYgKGV4cGVjdEJyYWNrZXQpIHtcbiAgICAgICAgICAgIHRvayA9IHNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRvay5kb25lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyRU9GO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVmLmxhc3QgPSB0b2sudmFsdWUubGFzdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRvayA9IHsgdmFsdWU6IHN0YXJ0IH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRvay52YWx1ZS50ICE9PSBMaXRlcmFsLklkZW50KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsaW5lUGFyc2VFcnJvcih0b2sudmFsdWUsIGBub3QgYW4gaWRlbnRpZmllcjogJHt0b2sudmFsdWUudn1gKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICBwcmltOiB0b2sudmFsdWUudixcbiAgICAgICAgICAgIFtzb3VyY2VSZWZlcmVuY2VdOiByZWYsXG4gICAgICAgIH07XG4gICAgICAgIGZvciAoOzspIHtcbiAgICAgICAgICAgIGNvbnN0IHRvayA9IHNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHRvay5kb25lKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGVjdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyRU9GO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRvay52YWx1ZS50ID09PSAnKScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cGVjdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbGluZVBhcnNlRXJyb3IodG9rLnZhbHVlLCAndW5leHBlY3RlZCBjbG9zaW5nIGJyYWNrZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVmLmxhc3QgPSB0b2sudmFsdWUubGFzdDtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGlzQW5ub3RhdGlvbih0b2sudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0LmFubm90cyA9IHJldC5hbm5vdHMgfHwgW107XG4gICAgICAgICAgICAgICAgcmV0LmFubm90cy5wdXNoKHRvay52YWx1ZS52KTtcbiAgICAgICAgICAgICAgICByZWYubGFzdCA9IHRvay52YWx1ZS5sYXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0LmFyZ3MgPSByZXQuYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLnBhcnNlRXhwcihzY2FubmVyLCB0b2sudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5sYXN0ID0gKChfYSA9IGFyZ1tzb3VyY2VSZWZlcmVuY2VdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdCkgfHwgcmVmLmxhc3Q7XG4gICAgICAgICAgICAgICAgcmV0LmFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmV4cGFuZChyZXQpO1xuICAgIH1cbiAgICBwYXJzZUFyZ3Moc2Nhbm5lciwgc3RhcnQpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICAvLyBJZGVudGlmaWVyIHdpdGggYXJndW1lbnRzXG4gICAgICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgICAgIGZpcnN0OiBzdGFydC5maXJzdCxcbiAgICAgICAgICAgIGxhc3Q6IHN0YXJ0Lmxhc3QsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHAgPSB7XG4gICAgICAgICAgICBwcmltOiBzdGFydC52LFxuICAgICAgICAgICAgW3NvdXJjZVJlZmVyZW5jZV06IHJlZixcbiAgICAgICAgfTtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgICAgY29uc3QgdCA9IHNjYW5uZXIubmV4dCgpO1xuICAgICAgICAgICAgaWYgKHQuZG9uZSB8fCB0LnZhbHVlLnQgPT09ICd9JyB8fCB0LnZhbHVlLnQgPT09ICc7Jykge1xuICAgICAgICAgICAgICAgIHJldHVybiBbcCwgdF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNBbm5vdGF0aW9uKHQudmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmVmLmxhc3QgPSB0LnZhbHVlLmxhc3Q7XG4gICAgICAgICAgICAgICAgcC5hbm5vdHMgPSBwLmFubm90cyB8fCBbXTtcbiAgICAgICAgICAgICAgICBwLmFubm90cy5wdXNoKHQudmFsdWUudik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLnBhcnNlRXhwcihzY2FubmVyLCB0LnZhbHVlKTtcbiAgICAgICAgICAgICAgICByZWYubGFzdCA9ICgoX2EgPSBhcmdbc291cmNlUmVmZXJlbmNlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxhc3QpIHx8IHJlZi5sYXN0O1xuICAgICAgICAgICAgICAgIHAuYXJncyA9IHAuYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICBwLmFyZ3MucHVzaChhcmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHBhcnNlU2VxdWVuY2VFeHByKHNjYW5uZXIsIHN0YXJ0KSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGNvbnN0IHJlZiA9IHtcbiAgICAgICAgICAgIGZpcnN0OiBzdGFydC5maXJzdCxcbiAgICAgICAgICAgIGxhc3Q6IHN0YXJ0Lmxhc3QsXG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IHNlcSA9IFtdO1xuICAgICAgICBzZXFbc291cmNlUmVmZXJlbmNlXSA9IHJlZjtcbiAgICAgICAgY29uc3QgZXhwZWN0QnJhY2tldCA9IHN0YXJ0LnQgPT09ICd7JztcbiAgICAgICAgbGV0IHRvayA9IHN0YXJ0LnQgPT09ICd7JyA/IG51bGwgOiB7IHZhbHVlOiBzdGFydCB9O1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgICBpZiAodG9rID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9rID0gc2Nhbm5lci5uZXh0KCk7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2suZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICByZWYubGFzdCA9IHRvay52YWx1ZS5sYXN0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2suZG9uZSkge1xuICAgICAgICAgICAgICAgIGlmIChleHBlY3RCcmFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVyckVPRjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRvay52YWx1ZS50ID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWV4cGVjdEJyYWNrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbGluZVBhcnNlRXJyb3IodG9rLnZhbHVlLCAndW5leHBlY3RlZCBjbG9zaW5nIGJyYWNrZXQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodG9rLnZhbHVlLnQgPT09IExpdGVyYWwuSWRlbnQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZGVudGlmaWVyIHdpdGggYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgY29uc3QgW2l0bSwgbl0gPSB0aGlzLnBhcnNlQXJncyhzY2FubmVyLCB0b2sudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5sYXN0ID0gKChfYSA9IGl0bVtzb3VyY2VSZWZlcmVuY2VdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGFzdCkgfHwgcmVmLmxhc3Q7XG4gICAgICAgICAgICAgICAgc2VxLnB1c2godGhpcy5leHBhbmQoaXRtKSk7XG4gICAgICAgICAgICAgICAgdG9rID0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE90aGVyXG4gICAgICAgICAgICAgICAgY29uc3QgZXggPSB0aGlzLnBhcnNlRXhwcihzY2FubmVyLCB0b2sudmFsdWUpO1xuICAgICAgICAgICAgICAgIHJlZi5sYXN0ID0gKChfYiA9IGV4W3NvdXJjZVJlZmVyZW5jZV0pID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sYXN0KSB8fCByZWYubGFzdDtcbiAgICAgICAgICAgICAgICBzZXEucHVzaChleCk7XG4gICAgICAgICAgICAgICAgdG9rID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0b2sgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0b2sgPSBzY2FubmVyLm5leHQoKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRvay5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlZi5sYXN0ID0gdG9rLnZhbHVlLmxhc3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0b2suZG9uZSAmJiB0b2sudmFsdWUudCA9PT0gJzsnKSB7XG4gICAgICAgICAgICAgICAgdG9rID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBwYXJzZUV4cHIoc2Nhbm5lciwgdG9rKSB7XG4gICAgICAgIHN3aXRjaCAodG9rLnQpIHtcbiAgICAgICAgICAgIGNhc2UgTGl0ZXJhbC5JZGVudDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmQoe1xuICAgICAgICAgICAgICAgICAgICBwcmltOiB0b2sudixcbiAgICAgICAgICAgICAgICAgICAgW3NvdXJjZVJlZmVyZW5jZV06IHsgZmlyc3Q6IHRvay5maXJzdCwgbGFzdDogdG9rLmxhc3QgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNhc2UgTGl0ZXJhbC5OdW1iZXI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaW50OiB0b2sudiwgW3NvdXJjZVJlZmVyZW5jZV06IHsgZmlyc3Q6IHRvay5maXJzdCwgbGFzdDogdG9rLmxhc3QgfSB9O1xuICAgICAgICAgICAgY2FzZSBMaXRlcmFsLlN0cmluZzpcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmc6IEpTT04ucGFyc2UodG9rLnYpLFxuICAgICAgICAgICAgICAgICAgICBbc291cmNlUmVmZXJlbmNlXTogeyBmaXJzdDogdG9rLmZpcnN0LCBsYXN0OiB0b2subGFzdCB9LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICBjYXNlIExpdGVyYWwuQnl0ZXM6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYnl0ZXM6IHRvay52LnNsaWNlKDIpLCBbc291cmNlUmVmZXJlbmNlXTogeyBmaXJzdDogdG9rLmZpcnN0LCBsYXN0OiB0b2subGFzdCB9IH07XG4gICAgICAgICAgICBjYXNlICd7JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNlcXVlbmNlRXhwcihzY2FubmVyLCB0b2spO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3RFeHByKHNjYW5uZXIsIHRvayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2VzIGEgTWljaGVsaW5lIHNlcXVlbmNlIGV4cHJlc3Npb24sIHN1Y2ggYXMgc21hcnQgY29udHJhY3Qgc291cmNlLiBFbmNsb3NpbmcgY3VybHkgYnJhY2tldHMgbWF5IGJlIG9taXR0ZWQuXG4gICAgICogQHBhcmFtIHNyYyBBIE1pY2hlbGluZSBzZXF1ZW5jZSBge3BhcmFtZXRlciAuLi47IHN0b3JhZ2UgaW50OyBjb2RlIHsgRFVQIDsgLi4ufTt9YCBvciBgcGFyYW1ldGVyIC4uLjsgc3RvcmFnZSBpbnQ7IGNvZGUgeyBEVVAgOyAuLi59O2BcbiAgICAgKi9cbiAgICBwYXJzZVNlcXVlbmNlKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0cmluZyB0eXBlIHdhcyBleHBlY3RlZCwgZ290ICR7dHlwZW9mIHNyY30gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYW5uZXIgPSBzY2FuKHNyYyk7XG4gICAgICAgIGNvbnN0IHRvayA9IHNjYW5uZXIubmV4dCgpO1xuICAgICAgICBpZiAodG9rLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2VxdWVuY2VFeHByKHNjYW5uZXIsIHRvay52YWx1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgTWljaGVsaW5lIHNlcXVlbmNlIGV4cHJlc3Npb24uIEVuY2xvc2luZyBjdXJseSBicmFja2V0cyBtYXkgYmUgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0gc3JjIEEgTWljaGVsc29uIGxpc3QgZXhwcmVzc2lvbiBzdWNoIGFzIGAoUGFpciB7RWx0IFwiMFwiIDB9IDApYCBvciBgUGFpciB7RWx0IFwiMFwiIDB9IDBgXG4gICAgICogQHJldHVybnMgQW4gQVNUIG5vZGUgb3IgbnVsbCBmb3IgZW1wdHkgZG9jdW1lbnQuXG4gICAgICovXG4gICAgcGFyc2VMaXN0KHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0cmluZyB0eXBlIHdhcyBleHBlY3RlZCwgZ290ICR7dHlwZW9mIHNyY30gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYW5uZXIgPSBzY2FuKHNyYyk7XG4gICAgICAgIGNvbnN0IHRvayA9IHNjYW5uZXIubmV4dCgpO1xuICAgICAgICBpZiAodG9rLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTGlzdEV4cHIoc2Nhbm5lciwgdG9rLnZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGFyc2UgYW55IE1pY2hlbHNvbiBleHByZXNzaW9uXG4gICAgICogQHBhcmFtIHNyYyBBIE1pY2hlbHNvbiBleHByZXNzaW9uIHN1Y2ggYXMgYChQYWlyIHtFbHQgXCIwXCIgMH0gMClgIG9yIGB7cGFyYW1ldGVyIC4uLjsgc3RvcmFnZSBpbnQ7IGNvZGUgeyBEVVAgOyAuLi59O31gXG4gICAgICogQHJldHVybnMgQW4gQVNUIG5vZGUgb3IgbnVsbCBmb3IgZW1wdHkgZG9jdW1lbnQuXG4gICAgICovXG4gICAgcGFyc2VNaWNoZWxpbmVFeHByZXNzaW9uKHNyYykge1xuICAgICAgICBpZiAodHlwZW9mIHNyYyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHN0cmluZyB0eXBlIHdhcyBleHBlY3RlZCwgZ290ICR7dHlwZW9mIHNyY30gaW5zdGVhZGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjYW5uZXIgPSBzY2FuKHNyYyk7XG4gICAgICAgIGNvbnN0IHRvayA9IHNjYW5uZXIubmV4dCgpO1xuICAgICAgICBpZiAodG9rLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXhwcihzY2FubmVyLCB0b2sudmFsdWUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQYXJzZSBhIE1pY2hlbGluZSBzZXF1ZW5jZSBleHByZXNzaW9uLCBzdWNoIGFzIHNtYXJ0IGNvbnRyYWN0IHNvdXJjZS4gRW5jbG9zaW5nIGN1cmx5IGJyYWNrZXRzIG1heSBiZSBvbWl0dGVkLlxuICAgICAqIEFuIGFsaWFzIGZvciBgcGFyc2VTZXF1ZW5jZWBcbiAgICAgKiBAcGFyYW0gc3JjIEEgTWljaGVsaW5lIHNlcXVlbmNlIGB7cGFyYW1ldGVyIC4uLjsgc3RvcmFnZSBpbnQ7IGNvZGUgeyBEVVAgOyAuLi59O31gIG9yIGBwYXJhbWV0ZXIgLi4uOyBzdG9yYWdlIGludDsgY29kZSB7IERVUCA7IC4uLn07YFxuICAgICAqL1xuICAgIHBhcnNlU2NyaXB0KHNyYykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNlcXVlbmNlKHNyYyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFBhcnNlIGEgTWljaGVsaW5lIHNlcXVlbmNlIGV4cHJlc3Npb24uIEVuY2xvc2luZyBjdXJseSBicmFja2V0cyBtYXkgYmUgb21pdHRlZC5cbiAgICAgKiBBbiBhbGlhcyBmb3IgYHBhcnNlTGlzdGBcbiAgICAgKiBAcGFyYW0gc3JjIEEgTWljaGVsc29uIGxpc3QgZXhwcmVzc2lvbiBzdWNoIGFzIGAoUGFpciB7RWx0IFwiMFwiIDB9IDApYCBvciBgUGFpciB7RWx0IFwiMFwiIDB9IDBgXG4gICAgICogQHJldHVybnMgQW4gQVNUIG5vZGUgb3IgbnVsbCBmb3IgZW1wdHkgZG9jdW1lbnQuXG4gICAgICovXG4gICAgcGFyc2VEYXRhKHNyYykge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3Qoc3JjKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFrZXMgYSBKU09OLWVuY29kZWQgTWljaGVsc29uLCB2YWxpZGF0ZXMgaXQsIHN0cmlwcyBhd2F5IHVubmVlZGVkIHByb3BlcnRpZXMgYW5kIG9wdGlvbmFsbHkgZXhwYW5kcyBtYWNyb3MgKFNlZSB7QGxpbmsgUGFyc2VyT3B0aW9uc30pLlxuICAgICAqIEBwYXJhbSBzcmMgQW4gb2JqZWN0IGNvbnRhaW5pbmcgSlNPTi1lbmNvZGVkIE1pY2hlbHNvbiwgdXN1YWxseSByZXR1cm5lZCBieSBgSlNPTi5wYXJzZSgpYFxuICAgICAqL1xuICAgIHBhcnNlSlNPTihzcmMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBvYmplY3QgdHlwZSB3YXMgZXhwZWN0ZWQsIGdvdCAke3R5cGVvZiBzcmN9IGluc3RlYWRgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzcmMpKSB7XG4gICAgICAgICAgICBjb25zdCByZXQgPSBbXTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbiBvZiBzcmMpIHtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gbnVsbCB8fCB0eXBlb2YgbiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKG4sIGB1bmV4cGVjdGVkIHNlcXVlbmNlIGVsZW1lbnQ6ICR7bn1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0LnB1c2godGhpcy5wYXJzZUpTT04obikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgncHJpbScgaW4gc3JjKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gc3JjO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwLnByaW0gPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgKHAuYW5ub3RzID09PSB1bmRlZmluZWQgfHwgQXJyYXkuaXNBcnJheShwLmFubm90cykpICYmXG4gICAgICAgICAgICAgICAgKHAuYXJncyA9PT0gdW5kZWZpbmVkIHx8IEFycmF5LmlzQXJyYXkocC5hcmdzKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgIHByaW06IHAucHJpbSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChwLmFubm90cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBwLmFubm90cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKU09OUGFyc2VFcnJvcihhLCBgc3RyaW5nIGV4cGVjdGVkOiAke2F9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0LmFubm90cyA9IHAuYW5ub3RzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocC5hcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0LmFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhIG9mIHAuYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEgPT09IG51bGwgfHwgdHlwZW9mIGEgIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKGEsIGB1bmV4cGVjdGVkIGFyZ3VtZW50OiAke2F9YCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXQuYXJncy5wdXNoKHRoaXMucGFyc2VKU09OKGEpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5leHBhbmQocmV0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBKU09OUGFyc2VFcnJvcihzcmMsIGBtYWxmb3JtZWQgcHJpbSBleHByZXNzaW9uOiAke3NyY31gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnc3RyaW5nJyBpbiBzcmMpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3JjLnN0cmluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBzdHJpbmc6IHNyYy5zdHJpbmcgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBKU09OUGFyc2VFcnJvcihzcmMsIGBtYWxmb3JtZWQgc3RyaW5nIGxpdGVyYWw6ICR7c3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCdpbnQnIGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMuaW50ID09PSAnc3RyaW5nJyAmJiBpbnRSZS50ZXN0KHNyYy5pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgaW50OiBzcmMuaW50IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgSlNPTlBhcnNlRXJyb3Ioc3JjLCBgbWFsZm9ybWVkIGludCBsaXRlcmFsOiAke3NyY31gKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgnYnl0ZXMnIGluIHNyYykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzcmMuYnl0ZXMgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgYnl0ZXNSZS50ZXN0KHNyYy5ieXRlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBieXRlczogc3JjLmJ5dGVzIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgSlNPTlBhcnNlRXJyb3Ioc3JjLCBgbWFsZm9ybWVkIGJ5dGVzIGxpdGVyYWw6ICR7c3JjfWApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKHNyYywgYHVuZXhwZWN0ZWQgb2JqZWN0OiAke3NyY31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY2xhc3MgRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihvcHQsIGxldiA9IDApIHtcbiAgICAgICAgdGhpcy5vcHQgPSBvcHQ7XG4gICAgICAgIHRoaXMubGV2ID0gbGV2O1xuICAgIH1cbiAgICBpbmRlbnQobiA9IDApIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBsZXQgcmV0ID0gJyc7XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5vcHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5pbmRlbnQpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSB0aGlzLmxldiArIG47IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgICAgICAgICByZXQgKz0gdGhpcy5vcHQuaW5kZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICAgIGdldCBsZigpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKChfYSA9IHRoaXMub3B0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmV3bGluZSkgfHwgJyc7XG4gICAgfVxuICAgIGdldCBsZnNwKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoKF9hID0gdGhpcy5vcHQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5uZXdsaW5lKSB8fCAnICc7XG4gICAgfVxuICAgIGRvd24obikge1xuICAgICAgICByZXR1cm4gbmV3IEZvcm1hdHRlcih0aGlzLm9wdCwgdGhpcy5sZXYgKyBuKTtcbiAgICB9XG59XG5mdW5jdGlvbiBoYXNBcmdzKG5vZGUpIHtcbiAgICByZXR1cm4gKCdwcmltJyBpbiBub2RlICYmXG4gICAgICAgICgobm9kZS5hbm5vdHMgIT09IHVuZGVmaW5lZCAmJiBub2RlLmFubm90cy5sZW5ndGggIT09IDApIHx8XG4gICAgICAgICAgICAobm9kZS5hcmdzICE9PSB1bmRlZmluZWQgJiYgbm9kZS5hcmdzLmxlbmd0aCAhPT0gMCkpKTtcbn1cbmZ1bmN0aW9uIGlzTXVsdGlsaW5lKG5vZGUpIHtcbiAgICBpZiAobm9kZS5hcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZm9yIChjb25zdCBhIG9mIG5vZGUuYXJncykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoYSkgfHwgaGFzQXJncyhhKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGVtaXRFeHByKG5vZGUsIGYsIGZvbGRNYWNyb3MpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgbWFjcm8gPSAoX2EgPSBub2RlW3NvdXJjZVJlZmVyZW5jZV0pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYWNybztcbiAgICBpZiAoZm9sZE1hY3JvcyAmJiBtYWNybykge1xuICAgICAgICByZXR1cm4gZW1pdEV4cHIobWFjcm8sIGYsIGZvbGRNYWNyb3MpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgICAgICByZXR1cm4gZW1pdFNlcShub2RlLCBmLCBmb2xkTWFjcm9zKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ3N0cmluZycgaW4gbm9kZSkge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkobm9kZS5zdHJpbmcpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnaW50JyBpbiBub2RlKSB7XG4gICAgICAgIHJldHVybiBub2RlLmludDtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2J5dGVzJyBpbiBub2RlKSB7XG4gICAgICAgIHJldHVybiAnMHgnICsgbm9kZS5ieXRlcztcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmICgobm9kZS5hbm5vdHMgPT09IHVuZGVmaW5lZCB8fCBub2RlLmFubm90cy5sZW5ndGggPT09IDApICYmXG4gICAgICAgICAgICAobm9kZS5hcmdzID09PSB1bmRlZmluZWQgfHwgbm9kZS5hcmdzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnByaW07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJldCA9ICcoJyArIG5vZGUucHJpbTtcbiAgICAgICAgaWYgKG5vZGUuYW5ub3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBub2RlLmFubm90cykge1xuICAgICAgICAgICAgICAgIHJldCArPSAnICcgKyBhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmFyZ3MgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29uc3QgbXVsdGlsaW5lID0gaXNNdWx0aWxpbmUobm9kZSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGEgb2Ygbm9kZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgaWYgKG11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgICAgICByZXQgKz0gZi5sZnNwICsgZi5pbmRlbnQoMSkgKyBlbWl0RXhwcihhLCBmLmRvd24oMSksIGZvbGRNYWNyb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0ICs9ICcgJyArIGVtaXRFeHByKGEsIGYsIGZvbGRNYWNyb3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV0ICsgJyknO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGVtaXRTZXEobm9kZSwgZiwgZm9sZE1hY3Jvcykge1xuICAgIGxldCByZXQgPSAneycgKyBmLmxmO1xuICAgIGxldCBpID0gbm9kZS5sZW5ndGg7XG4gICAgZm9yIChjb25zdCBlbCBvZiBub2RlKSB7XG4gICAgICAgIHJldCArPSBmLmluZGVudCgxKTtcbiAgICAgICAgaWYgKCdwcmltJyBpbiBlbCkge1xuICAgICAgICAgICAgcmV0ICs9IGVsLnByaW07XG4gICAgICAgICAgICBpZiAoZWwuYW5ub3RzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGEgb2YgZWwuYW5ub3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldCArPSAnICcgKyBhO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChlbC5hcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBtdWx0aWxpbmUgPSBpc011bHRpbGluZShlbCk7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBhIG9mIGVsLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG11bHRpbGluZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0ICs9IGYubGZzcCArIGYuaW5kZW50KDIpICsgZW1pdEV4cHIoYSwgZi5kb3duKDIpLCBmb2xkTWFjcm9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldCArPSAnICcgKyBlbWl0RXhwcihhLCBmLCBmb2xkTWFjcm9zKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldCArPSBlbWl0RXhwcihlbCwgZi5kb3duKDEpLCBmb2xkTWFjcm9zKTtcbiAgICAgICAgfVxuICAgICAgICByZXQgKz0gaSA+IDEgPyAnOycgKyBmLmxmc3AgOiBmLmxmO1xuICAgICAgICBpLS07XG4gICAgfVxuICAgIHJldHVybiByZXQgKyBmLmluZGVudCgpICsgJ30nO1xufVxuLyoqXG4gKiBGb3JtYXRzIE1pY2hlbGluZSBleHByZXNzaW9uXG4gKiBAcGFyYW0gZXhwciBBbiBBU1Qgbm9kZVxuICogQHBhcmFtIG9wdCBPcHRpb25zXG4gKi9cbmZ1bmN0aW9uIGVtaXRNaWNoZWxpbmUoZXhwciwgb3B0LCBmb2xkTWFjcm9zID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZW9mIGV4cHIgIT09ICdvYmplY3QnKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYG9iamVjdCB0eXBlIHdhcyBleHBlY3RlZCwgZ290ICR7dHlwZW9mIGV4cHJ9IGluc3RlYWRgKTtcbiAgICB9XG4gICAgcmV0dXJuIGVtaXRFeHByKGV4cHIsIG5ldyBGb3JtYXR0ZXIob3B0KSwgZm9sZE1hY3Jvcyk7XG59XG5cbmNvbnN0IEggPSBbXG4gICAgMHg2YTA5ZTY2NyB8IDAsXG4gICAgMHhiYjY3YWU4NSB8IDAsXG4gICAgMHgzYzZlZjM3MiB8IDAsXG4gICAgMHhhNTRmZjUzYSB8IDAsXG4gICAgMHg1MTBlNTI3ZiB8IDAsXG4gICAgMHg5YjA1Njg4YyB8IDAsXG4gICAgMHgxZjgzZDlhYiB8IDAsXG4gICAgMHg1YmUwY2QxOSB8IDAsXG5dO1xuY29uc3QgSyA9IFtcbiAgICAweDQyOGEyZjk4IHwgMCxcbiAgICAweDcxMzc0NDkxIHwgMCxcbiAgICAweGI1YzBmYmNmIHwgMCxcbiAgICAweGU5YjVkYmE1IHwgMCxcbiAgICAweDM5NTZjMjViIHwgMCxcbiAgICAweDU5ZjExMWYxIHwgMCxcbiAgICAweDkyM2Y4MmE0IHwgMCxcbiAgICAweGFiMWM1ZWQ1IHwgMCxcbiAgICAweGQ4MDdhYTk4IHwgMCxcbiAgICAweDEyODM1YjAxIHwgMCxcbiAgICAweDI0MzE4NWJlIHwgMCxcbiAgICAweDU1MGM3ZGMzIHwgMCxcbiAgICAweDcyYmU1ZDc0IHwgMCxcbiAgICAweDgwZGViMWZlIHwgMCxcbiAgICAweDliZGMwNmE3IHwgMCxcbiAgICAweGMxOWJmMTc0IHwgMCxcbiAgICAweGU0OWI2OWMxIHwgMCxcbiAgICAweGVmYmU0Nzg2IHwgMCxcbiAgICAweDBmYzE5ZGM2IHwgMCxcbiAgICAweDI0MGNhMWNjIHwgMCxcbiAgICAweDJkZTkyYzZmIHwgMCxcbiAgICAweDRhNzQ4NGFhIHwgMCxcbiAgICAweDVjYjBhOWRjIHwgMCxcbiAgICAweDc2Zjk4OGRhIHwgMCxcbiAgICAweDk4M2U1MTUyIHwgMCxcbiAgICAweGE4MzFjNjZkIHwgMCxcbiAgICAweGIwMDMyN2M4IHwgMCxcbiAgICAweGJmNTk3ZmM3IHwgMCxcbiAgICAweGM2ZTAwYmYzIHwgMCxcbiAgICAweGQ1YTc5MTQ3IHwgMCxcbiAgICAweDA2Y2E2MzUxIHwgMCxcbiAgICAweDE0MjkyOTY3IHwgMCxcbiAgICAweDI3YjcwYTg1IHwgMCxcbiAgICAweDJlMWIyMTM4IHwgMCxcbiAgICAweDRkMmM2ZGZjIHwgMCxcbiAgICAweDUzMzgwZDEzIHwgMCxcbiAgICAweDY1MGE3MzU0IHwgMCxcbiAgICAweDc2NmEwYWJiIHwgMCxcbiAgICAweDgxYzJjOTJlIHwgMCxcbiAgICAweDkyNzIyYzg1IHwgMCxcbiAgICAweGEyYmZlOGExIHwgMCxcbiAgICAweGE4MWE2NjRiIHwgMCxcbiAgICAweGMyNGI4YjcwIHwgMCxcbiAgICAweGM3NmM1MWEzIHwgMCxcbiAgICAweGQxOTJlODE5IHwgMCxcbiAgICAweGQ2OTkwNjI0IHwgMCxcbiAgICAweGY0MGUzNTg1IHwgMCxcbiAgICAweDEwNmFhMDcwIHwgMCxcbiAgICAweDE5YTRjMTE2IHwgMCxcbiAgICAweDFlMzc2YzA4IHwgMCxcbiAgICAweDI3NDg3NzRjIHwgMCxcbiAgICAweDM0YjBiY2I1IHwgMCxcbiAgICAweDM5MWMwY2IzIHwgMCxcbiAgICAweDRlZDhhYTRhIHwgMCxcbiAgICAweDViOWNjYTRmIHwgMCxcbiAgICAweDY4MmU2ZmYzIHwgMCxcbiAgICAweDc0OGY4MmVlIHwgMCxcbiAgICAweDc4YTU2MzZmIHwgMCxcbiAgICAweDg0Yzg3ODE0IHwgMCxcbiAgICAweDhjYzcwMjA4IHwgMCxcbiAgICAweDkwYmVmZmZhIHwgMCxcbiAgICAweGE0NTA2Y2ViIHwgMCxcbiAgICAweGJlZjlhM2Y3IHwgMCxcbiAgICAweGM2NzE3OGYyIHwgMCxcbl07XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIHdoZW4gZGVjb2RpbmcgYSBiYXNlNTggZW5jb2RpbmdcbiAqL1xuY2xhc3MgQmFzZTU4RGVjb2RpbmdFcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmFzZTU4RGVjb2RpbmdFcnJvcic7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzYyMzRcbmZ1bmN0aW9uIHNoYTI1Nihtc2cpIHtcbiAgICAvLyBwYWQgdGhlIG1lc3NhZ2VcbiAgICBjb25zdCByID0gKG1zZy5sZW5ndGggKyA5KSAlIDY0O1xuICAgIGNvbnN0IHBhZCA9IHIgPT09IDAgPyAwIDogNjQgLSByO1xuICAgIGlmIChtc2cubGVuZ3RoID4gMjY4NDM1NDU1KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZUVycm9yKCcnLCBgOiBJbnZhbGlkIGxlbmd0aCAke21zZy5sZW5ndGh9IGlzIHRvbyBiaWcgLS0gU0hBLTI1Ni5gKTtcbiAgICB9XG4gICAgY29uc3QgbCA9IG1zZy5sZW5ndGggPDwgMztcbiAgICBjb25zdCBidWZmZXIgPSBbXG4gICAgICAgIC4uLm1zZyxcbiAgICAgICAgMHg4MCxcbiAgICAgICAgLi4ubmV3IEFycmF5KHBhZCkuZmlsbCgwKSxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgMCxcbiAgICAgICAgKGwgPj4gMjQpICYgMHhmZixcbiAgICAgICAgKGwgPj4gMTYpICYgMHhmZixcbiAgICAgICAgKGwgPj4gOCkgJiAweGZmLFxuICAgICAgICBsICYgMHhmZixcbiAgICBdO1xuICAgIGZ1bmN0aW9uIHJvcih4LCBuKSB7XG4gICAgICAgIHJldHVybiAoeCA+Pj4gbikgfCAoeCA8PCAoMzIgLSBuKSk7XG4gICAgfVxuICAgIGNvbnN0IGggPSBbLi4uSF07XG4gICAgY29uc3QgdyA9IG5ldyBBcnJheSg2NCk7XG4gICAgY29uc3QgdiA9IG5ldyBBcnJheSg4KTtcbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCBidWZmZXIubGVuZ3RoOyBvZmZzZXQgKz0gNjQpIHtcbiAgICAgICAgbGV0IHEgPSBvZmZzZXQ7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCAxNikge1xuICAgICAgICAgICAgd1tpXSA9IChidWZmZXJbcV0gPDwgMjQpIHwgKGJ1ZmZlcltxICsgMV0gPDwgMTYpIHwgKGJ1ZmZlcltxICsgMl0gPDwgOCkgfCBidWZmZXJbcSArIDNdO1xuICAgICAgICAgICAgcSArPSA0O1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChpIDwgNjQpIHtcbiAgICAgICAgICAgIGNvbnN0IHMwID0gcm9yKHdbaSAtIDE1XSwgNykgXiByb3Iod1tpIC0gMTVdLCAxOCkgXiAod1tpIC0gMTVdID4+PiAzKTtcbiAgICAgICAgICAgIGNvbnN0IHMxID0gcm9yKHdbaSAtIDJdLCAxNykgXiByb3Iod1tpIC0gMl0sIDE5KSBeICh3W2kgLSAyXSA+Pj4gMTApO1xuICAgICAgICAgICAgd1tpXSA9ICgoczEgfCAwKSArIHdbaSAtIDddICsgczAgKyB3W2kgLSAxNl0pIHwgMDtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgdltpXSA9IGhbaV07XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBiMCA9IHJvcih2WzBdLCAyKSBeIHJvcih2WzBdLCAxMykgXiByb3IodlswXSwgMjIpO1xuICAgICAgICAgICAgY29uc3QgYjEgPSByb3Iodls0XSwgNikgXiByb3Iodls0XSwgMTEpIF4gcm9yKHZbNF0sIDI1KTtcbiAgICAgICAgICAgIGNvbnN0IHQxID0gKHZbN10gKyBiMSArICgodls0XSAmIHZbNV0pIF4gKH52WzRdICYgdls2XSkpICsgS1tpXSArIHdbaV0pIHwgMDtcbiAgICAgICAgICAgIGNvbnN0IHQyID0gKGIwICsgKCh2WzBdICYgdlsxXSkgXiAodlswXSAmIHZbMl0pIF4gKHZbMV0gJiB2WzJdKSkpIHwgMDtcbiAgICAgICAgICAgIHZbN10gPSB2WzZdO1xuICAgICAgICAgICAgdls2XSA9IHZbNV07XG4gICAgICAgICAgICB2WzVdID0gdls0XTtcbiAgICAgICAgICAgIHZbNF0gPSAodlszXSArIHQxKSB8IDA7XG4gICAgICAgICAgICB2WzNdID0gdlsyXTtcbiAgICAgICAgICAgIHZbMl0gPSB2WzFdO1xuICAgICAgICAgICAgdlsxXSA9IHZbMF07XG4gICAgICAgICAgICB2WzBdID0gKHQxICsgdDIpIHwgMDtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDg7IGkrKykge1xuICAgICAgICAgICAgaFtpXSA9IChoW2ldICsgdltpXSkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGRpZ2VzdCA9IFtdO1xuICAgIGZvciAoY29uc3QgdiBvZiBoKSB7XG4gICAgICAgIGRpZ2VzdC5wdXNoKCh2ID4+IDI0KSAmIDB4ZmYpO1xuICAgICAgICBkaWdlc3QucHVzaCgodiA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgZGlnZXN0LnB1c2goKHYgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgZGlnZXN0LnB1c2godiAmIDB4ZmYpO1xuICAgIH1cbiAgICByZXR1cm4gZGlnZXN0O1xufVxuY29uc3QgYmFzZTU4YWxwaGFiZXRGd2QgPSBbXG4gICAgMCwgMSwgMiwgMywgNCwgNSwgNiwgNywgOCwgLTEsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsIDE2LCAtMSwgMTcsIDE4LFxuICAgIDE5LCAyMCwgMjEsIC0xLCAyMiwgMjMsIDI0LCAyNSwgMjYsIDI3LCAyOCwgMjksIDMwLCAzMSwgMzIsIC0xLCAtMSwgLTEsIC0xLCAtMSwgLTEsIDMzLCAzNCwgMzUsXG4gICAgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDIsIDQzLCAtMSwgNDQsIDQ1LCA0NiwgNDcsIDQ4LCA0OSwgNTAsIDUxLCA1MiwgNTMsIDU0LCA1NSwgNTYsIDU3LFxuXTtcbmNvbnN0IGJhc2U1OGFscGhhYmV0QndkID0gW1xuICAgIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDE2LCAxNywgMTgsIDE5LCAyMCwgMjEsIDIyLCAyMywgMjUsIDI2LCAyNywgMjgsIDI5LCAzMSwgMzIsIDMzLCAzNCwgMzUsXG4gICAgMzYsIDM3LCAzOCwgMzksIDQwLCA0MSwgNDgsIDQ5LCA1MCwgNTEsIDUyLCA1MywgNTQsIDU1LCA1NiwgNTcsIDU4LCA2MCwgNjEsIDYyLCA2MywgNjQsIDY1LCA2NixcbiAgICA2NywgNjgsIDY5LCA3MCwgNzEsIDcyLCA3Myxcbl07XG5mdW5jdGlvbiBieXRlQXQoc3JjLCBpKSB7XG4gICAgY29uc3QgYyA9IHNyYy5jaGFyQ29kZUF0KGkpIC0gNDk7XG4gICAgaWYgKGMgPj0gYmFzZTU4YWxwaGFiZXRGd2QubGVuZ3RoIHx8IGJhc2U1OGFscGhhYmV0RndkW2NdID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgQmFzZTU4RGVjb2RpbmdFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gJHtpfTogJHtzcmNbaV19YCk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlNThhbHBoYWJldEZ3ZFtjXTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJhc2U1OChzcmMpIHtcbiAgICBjb25zdCBhY2MgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gY291bnQgYW5kIHNraXAgbGVhZGluZyB6ZXJvc1xuICAgIHdoaWxlIChpIDwgc3JjLmxlbmd0aCAmJiBieXRlQXQoc3JjLCBpKSA9PT0gMCkge1xuICAgICAgICBpKys7XG4gICAgfVxuICAgIGxldCB6ZXJvcyA9IGk7XG4gICAgd2hpbGUgKGkgPCBzcmMubGVuZ3RoKSB7XG4gICAgICAgIGxldCBjYXJyeSA9IGJ5dGVBdChzcmMsIGkrKyk7XG4gICAgICAgIC8qXG4gICAgICAgICAgICBmb3IgZXZlcnkgc3ltYm9sIHhcbiAgICAgICAgICAgIGFjYyA9IGFjYyAqIDU4ICsgeFxuICAgICAgICAgICAgd2hlcmUgYWNjIGlzIGEgbGl0dGxlIGVuZGlhbiBhcmJpdHJhcnkgbGVuZ3RoIGludGVnZXJcbiAgICAgICAgICAgICovXG4gICAgICAgIGxldCBpaSA9IDA7XG4gICAgICAgIHdoaWxlIChjYXJyeSAhPT0gMCB8fCBpaSA8IGFjYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAoYWNjW2lpXSB8fCAwKSAqIDU4ICsgY2Fycnk7XG4gICAgICAgICAgICBhY2NbaWkrK10gPSBtICUgMjU2O1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKG0gLyAyNTYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdoaWxlICh6ZXJvcy0tID4gMCkge1xuICAgICAgICBhY2MucHVzaCgwKTtcbiAgICB9XG4gICAgcmV0dXJuIGFjYy5yZXZlcnNlKCk7XG59XG5mdW5jdGlvbiBlbmNvZGVCYXNlNTgoc3JjKSB7XG4gICAgY29uc3QgYWNjID0gW107XG4gICAgbGV0IGkgPSAwO1xuICAgIC8vIGNvdW50IGFuZCBza2lwIGxlYWRpbmcgemVyb3NcbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGggJiYgc3JjW2ldID09PSAwKSB7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgbGV0IHplcm9zID0gaTtcbiAgICB3aGlsZSAoaSA8IHNyYy5sZW5ndGgpIHtcbiAgICAgICAgbGV0IGNhcnJ5ID0gc3JjW2krK107XG4gICAgICAgIGxldCBpaSA9IDA7XG4gICAgICAgIHdoaWxlIChjYXJyeSAhPT0gMCB8fCBpaSA8IGFjYy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IG0gPSAoYWNjW2lpXSB8fCAwKSAqIDI1NiArIGNhcnJ5O1xuICAgICAgICAgICAgYWNjW2lpKytdID0gbSAlIDU4O1xuICAgICAgICAgICAgY2FycnkgPSBNYXRoLmZsb29yKG0gLyA1OCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKHplcm9zLS0gPiAwKSB7XG4gICAgICAgIGFjYy5wdXNoKDApO1xuICAgIH1cbiAgICBhY2MucmV2ZXJzZSgpO1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKC4uLmFjYy5tYXAoKHYpID0+IGJhc2U1OGFscGhhYmV0QndkW3ZdICsgNDkpKTtcbn1cbmZ1bmN0aW9uIGRlY29kZUJhc2U1OENoZWNrKHNyYykge1xuICAgIGNvbnN0IGJ1ZmZlciA9IGRlY29kZUJhc2U1OChzcmMpO1xuICAgIGlmIChidWZmZXIubGVuZ3RoIDwgNCkge1xuICAgICAgICB0aHJvdyBuZXcgQmFzZTU4RGVjb2RpbmdFcnJvcihgRGF0YSBpcyB0b28gc2hvcnQgJHtidWZmZXIubGVuZ3RofWApO1xuICAgIH1cbiAgICBjb25zdCBkYXRhID0gYnVmZmVyLnNsaWNlKDAsIGJ1ZmZlci5sZW5ndGggLSA0KTtcbiAgICBjb25zdCBzdW0gPSBidWZmZXIuc2xpY2UoYnVmZmVyLmxlbmd0aCAtIDQpO1xuICAgIGNvbnN0IGNvbXB1dGVkID0gc2hhMjU2KHNoYTI1NihkYXRhKSk7XG4gICAgaWYgKHN1bVswXSAhPT0gY29tcHV0ZWRbMF0gfHxcbiAgICAgICAgc3VtWzFdICE9PSBjb21wdXRlZFsxXSB8fFxuICAgICAgICBzdW1bMl0gIT09IGNvbXB1dGVkWzJdIHx8XG4gICAgICAgIHN1bVszXSAhPT0gY29tcHV0ZWRbM10pIHtcbiAgICAgICAgdGhyb3cgbmV3IEJhc2U1OERlY29kaW5nRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG5mdW5jdGlvbiBlbmNvZGVCYXNlNThDaGVjayhzcmMpIHtcbiAgICBjb25zdCBzdW0gPSBzaGEyNTYoc2hhMjU2KHNyYykpO1xuICAgIHJldHVybiBlbmNvZGVCYXNlNTgoWy4uLnNyYywgLi4uc3VtLnNsaWNlKDAsIDQpXSk7XG59XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIE1pY2hlbHNvbiBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkTWljaGVsc29uRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRNaWNoZWxzb25FcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgdHlwZSBleHByZXNzaW9uIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRUeXBlRXhwcmVzc2lvbkVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkVHlwZUV4cHJlc3Npb25FcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgZGF0YSBleHByZXNzaW9uIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWREYXRhRXhwcmVzc2lvbkVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkRGF0YUV4cHJlc3Npb25FcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgY29udHJhY3QgZW50cnlwb2ludCBiZWluZyByZWZlcmVuY2VkIG9yIHBhc3NlZFxuICovXG5jbGFzcyBJbnZhbGlkRW50cnlwb2ludEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihlbnRyeXBvaW50KSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZW50cnlwb2ludCA9IGVudHJ5cG9pbnQ7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkRW50cnlwb2ludEVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYENvbnRyYWN0IGhhcyBubyBlbnRyeXBvaW50IG5hbWVkOiBcIiR7ZW50cnlwb2ludH1cImA7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiB0cnlpbmcgdG8gZW5jb2RlIFRlem9zIElEXG4gKi9cbmNsYXNzIFRlem9zSWRFbmNvZGVFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVGV6b3NJZEVuY29kZUVycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBnZW5lcmFsIGVycm9yIGhhcHBlbmluZyB3aGVuIHRyeWluZyB0byBjcmVhdGUgYSBMb25nSW50ZWdlclxuICovXG5jbGFzcyBMb25nSW50ZWdlckVycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdMb25nSW50ZWdlckVycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIG9jY3VycmluZyB3aGVuIHRyeWluZyB0byBwYXJzZSBhIGhleCBieXRlXG4gKi9cbmNsYXNzIEhleFBhcnNlRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKGhleEJ5dGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5oZXhCeXRlID0gaGV4Qnl0ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0hleFBhcnNlRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgVW5hYmxlIHRvIHBhcnNlIGhleCBieXRlIFwiJHtoZXhCeXRlfVwiYDtcbiAgICB9XG59XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIE1pY2hlbHNvbiBmYWlsdXJlIG9jY3VycmluZ1xuICovXG5jbGFzcyBNaWNoZWxzb25FcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZhbCBWYWx1ZSBvZiBhIEFTVCBub2RlIGNhdXNlZCB0aGUgZXJyb3JcbiAgICAgKiBAcGFyYW0gcGF0aCBQYXRoIHRvIGEgbm9kZSBjYXVzZWQgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgQW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01pY2hlbHNvbkVycm9yJztcbiAgICB9XG59XG5mdW5jdGlvbiBpc01pY2hlbHNvbkVycm9yKGVycikge1xuICAgIHJldHVybiBlcnIgaW5zdGFuY2VvZiBNaWNoZWxzb25FcnJvcjtcbn1cbmNsYXNzIE1pY2hlbHNvblR5cGVFcnJvciBleHRlbmRzIE1pY2hlbHNvbkVycm9yIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsIFZhbHVlIG9mIGEgdHlwZSBub2RlIGNhdXNlZCB0aGUgZXJyb3JcbiAgICAgKiBAcGFyYW0gZGF0YSBWYWx1ZSBvZiBhIGRhdGEgbm9kZSBjYXVzZWQgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgQW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgbWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcih2YWwsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01pY2hlbHNvblR5cGVFcnJvcic7XG4gICAgICAgIGlmIChkYXRhICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICB9XG59XG4vLyBBZCBob2MgYmlnIGludGVnZXIgcGFyc2VyXG5jbGFzcyBMb25nSW50ZWdlciB7XG4gICAgYXBwZW5kKGMpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICB3aGlsZSAoYyAhPT0gMCB8fCBpIDwgdGhpcy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBtID0gKHRoaXMuYnVmW2ldIHx8IDApICogMTAgKyBjO1xuICAgICAgICAgICAgdGhpcy5idWZbaSsrXSA9IG0gJSAyNTY7XG4gICAgICAgICAgICBjID0gTWF0aC5mbG9vcihtIC8gMjU2KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdHJ1Y3RvcihhcmcpIHtcbiAgICAgICAgdGhpcy5uZWcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5idWYgPSBbXTtcbiAgICAgICAgaWYgKGFyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBhcmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCAmJiBjID09PSAweDJkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmVnID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjIDwgMHgzMCB8fCBjID4gMHgzOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IExvbmdJbnRlZ2VyRXJyb3IoYHVuZXhwZWN0ZWQgY2hhcmFjdGVyIGluIGludGVnZXIgY29uc3RhbnQgXCIke2FyZ1tpXX1cImApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwZW5kKGMgLSAweDMwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXJnIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5uZWcgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5hcHBlbmQoLWFyZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmFwcGVuZChhcmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNtcChhcmcpIHtcbiAgICAgICAgaWYgKHRoaXMubmVnICE9PSBhcmcubmVnKSB7XG4gICAgICAgICAgICByZXR1cm4gKGFyZy5uZWcgPyAxIDogMCkgLSAodGhpcy5uZWcgPyAxIDogMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZXQgcmV0ID0gMDtcbiAgICAgICAgICAgIGlmICh0aGlzLmJ1Zi5sZW5ndGggIT09IGFyZy5idWYubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5idWYubGVuZ3RoIDwgYXJnLmJ1Zi5sZW5ndGggPyAtMSA6IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmJ1Zi5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgaSA9IGFyZy5idWYubGVuZ3RoIC0gMTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaSA+PSAwICYmIHRoaXMuYnVmW2ldID09PSBhcmcuYnVmW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGktLTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0ID0gaSA8IDAgPyAwIDogdGhpcy5idWZbaV0gPCBhcmcuYnVmW2ldID8gLTEgOiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuICF0aGlzLm5lZyA/IHJldCA6IHJldCA9PT0gMCA/IDAgOiAtcmV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBzaWduKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYubGVuZ3RoID09PSAwID8gMCA6IHRoaXMubmVnID8gLTEgOiAxO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHBhcnNlQnl0ZXMocykge1xuICAgIGNvbnN0IHJldCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB4ID0gcGFyc2VJbnQocy5zbGljZShpLCBpICsgMiksIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTih4KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0LnB1c2goeCk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG5mdW5jdGlvbiBpc0RlY2ltYWwoeCkge1xuICAgIHRyeSB7XG4gICAgICAgIG5ldyBMb25nSW50ZWdlcih4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNOYXR1cmFsKHgpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gbmV3IExvbmdJbnRlZ2VyKHgpLnNpZ24gPj0gMDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5jb25zdCBhbm5SZSA9IC9eKEAlfEAlJXwlQHxbQDolXShbXzAtOWEtekEtWl1bXzAtOWEtekEtWi4lQF0qKT8pJC87XG5mdW5jdGlvbiB1bnBhY2tBbm5vdGF0aW9ucyhwLCBvcHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShwKSkge1xuICAgICAgICByZXR1cm4ge307XG4gICAgfVxuICAgIGxldCBmaWVsZDtcbiAgICBsZXQgdHlwZTtcbiAgICBsZXQgdmFycztcbiAgICBpZiAocC5hbm5vdHMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgcC5hbm5vdHMpIHtcbiAgICAgICAgICAgIGlmICh2Lmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmICghYW5uUmUudGVzdCh2KSB8fFxuICAgICAgICAgICAgICAgICAgICAoIShvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuc3BlY2lhbFZhcikgJiYgKHYgPT09ICdAJScgfHwgdiA9PT0gJ0AlJScpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoIShvcHQgPT09IG51bGwgfHwgb3B0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHQuc3BlY2lhbEZpZWxkcykgJiYgdiA9PT0gJyVAJykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkVycm9yKHAsIGAke3AucHJpbX06IHVuZXhwZWN0ZWQgYW5ub3RhdGlvbjogJHt2fWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKHZbMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnJSc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoKG9wdCA9PT0gbnVsbCB8fCBvcHQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdC5lbXB0eUZpZWxkcykgfHwgdi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBmaWVsZCB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaWVsZC5wdXNoKHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJzonOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSB0eXBlIHx8IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUucHVzaCh2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdAJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgob3B0ID09PSBudWxsIHx8IG9wdCA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0LmVtcHR5VmFyKSB8fCB2Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzID0gdmFycyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXJzLnB1c2godik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHsgZjogZmllbGQsIHQ6IHR5cGUsIHY6IHZhcnMgfTtcbn1cbmNvbnN0IHRlem9zUHJlZml4ID0ge1xuICAgIEJsb2NrSGFzaDogWzMyLCBbMSwgNTJdXSxcbiAgICBPcGVyYXRpb25IYXNoOiBbMzIsIFs1LCAxMTZdXSxcbiAgICBPcGVyYXRpb25MaXN0SGFzaDogWzMyLCBbMTMzLCAyMzNdXSxcbiAgICBPcGVyYXRpb25MaXN0TGlzdEhhc2g6IFszMiwgWzI5LCAxNTksIDEwOV1dLFxuICAgIFByb3RvY29sSGFzaDogWzMyLCBbMiwgMTcwXV0sXG4gICAgQ29udGV4dEhhc2g6IFszMiwgWzc5LCAxOTldXSxcbiAgICBFRDI1NTE5UHVibGljS2V5SGFzaDogWzIwLCBbNiwgMTYxLCAxNTldXSxcbiAgICBTRUNQMjU2SzFQdWJsaWNLZXlIYXNoOiBbMjAsIFs2LCAxNjEsIDE2MV1dLFxuICAgIFAyNTZQdWJsaWNLZXlIYXNoOiBbMjAsIFs2LCAxNjEsIDE2NF1dLFxuICAgIENvbnRyYWN0SGFzaDogWzIwLCBbMiwgOTAsIDEyMV1dLFxuICAgIENyeXB0b2JveFB1YmxpY0tleUhhc2g6IFsxNiwgWzE1MywgMTAzXV0sXG4gICAgRUQyNTUxOVNlZWQ6IFszMiwgWzEzLCAxNSwgNTgsIDddXSxcbiAgICBFRDI1NTE5UHVibGljS2V5OiBbMzIsIFsxMywgMTUsIDM3LCAyMTddXSxcbiAgICBTRUNQMjU2SzFTZWNyZXRLZXk6IFszMiwgWzE3LCAxNjIsIDIyNCwgMjAxXV0sXG4gICAgUDI1NlNlY3JldEtleTogWzMyLCBbMTYsIDgxLCAyMzgsIDE4OV1dLFxuICAgIEVEMjU1MTlFbmNyeXB0ZWRTZWVkOiBbNTYsIFs3LCA5MCwgNjAsIDE3OSwgNDFdXSxcbiAgICBTRUNQMjU2SzFFbmNyeXB0ZWRTZWNyZXRLZXk6IFs1NiwgWzksIDIzNywgMjQxLCAxNzQsIDE1MF1dLFxuICAgIFAyNTZFbmNyeXB0ZWRTZWNyZXRLZXk6IFs1NiwgWzksIDQ4LCA1NywgMTE1LCAxNzFdXSxcbiAgICBTRUNQMjU2SzFQdWJsaWNLZXk6IFszMywgWzMsIDI1NCwgMjI2LCA4Nl1dLFxuICAgIFAyNTZQdWJsaWNLZXk6IFszMywgWzMsIDE3OCwgMTM5LCAxMjddXSxcbiAgICBTRUNQMjU2SzFTY2FsYXI6IFszMywgWzM4LCAyNDgsIDEzNl1dLFxuICAgIFNFQ1AyNTZLMUVsZW1lbnQ6IFszMywgWzUsIDkyLCAwXV0sXG4gICAgRUQyNTUxOVNlY3JldEtleTogWzY0LCBbNDMsIDI0NiwgNzgsIDddXSxcbiAgICBFRDI1NTE5U2lnbmF0dXJlOiBbNjQsIFs5LCAyNDUsIDIwNSwgMTM0LCAxOF1dLFxuICAgIFNFQ1AyNTZLMVNpZ25hdHVyZTogWzY0LCBbMTMsIDExNSwgMTAxLCAxOSwgNjNdXSxcbiAgICBQMjU2U2lnbmF0dXJlOiBbNjQsIFs1NCwgMjQwLCA0NCwgNTJdXSxcbiAgICBHZW5lcmljU2lnbmF0dXJlOiBbNjQsIFs0LCAxMzAsIDQzXV0sXG4gICAgQ2hhaW5JRDogWzQsIFs4NywgODIsIDBdXSxcbiAgICBSb2xsdXBBZGRyZXNzOiBbMjAsIFsxLCAxMjgsIDEyMCwgMzFdXSxcbn07XG5mdW5jdGlvbiBjaGVja0RlY29kZVRlem9zSUQoaWQsIC4uLnR5cGVzKSB7XG4gICAgY29uc3QgYnVmID0gZGVjb2RlQmFzZTU4Q2hlY2soaWQpO1xuICAgIGZvciAoY29uc3QgdCBvZiB0eXBlcykge1xuICAgICAgICBjb25zdCBbcGxlbiwgcF0gPSB0ZXpvc1ByZWZpeFt0XTtcbiAgICAgICAgaWYgKGJ1Zi5sZW5ndGggPT09IHBsZW4gKyBwLmxlbmd0aCkge1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGkgPCBwLmxlbmd0aCAmJiBidWZbaV0gPT09IHBbaV0pIHtcbiAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaSA9PT0gcC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW3QsIGJ1Zi5zbGljZShwLmxlbmd0aCldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZW5jb2RlVGV6b3NJRChpZCwgZGF0YSkge1xuICAgIGNvbnN0IFtwbGVuLCBwXSA9IHRlem9zUHJlZml4W2lkXTtcbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IHBsZW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFRlem9zSWRFbmNvZGVFcnJvcihgSW5jb3JyZWN0IGRhdGEgbGVuZ3RoIGZvciAke2lkfTogJHtkYXRhLmxlbmd0aH1gKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZUJhc2U1OENoZWNrKFsuLi5wLCAuLi5kYXRhXSk7XG59XG5mdW5jdGlvbiB1bnBhY2tDb21iKGlkLCB2KSB7XG4gICAgY29uc3QgdnYgPSB2O1xuICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5pc0FycmF5KHZ2KSA/IHZ2IDogdnYuYXJncztcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gaXQncyBhIHdheSB0byBtYWtlIGEgdW5pb24gb2YgdHdvIGludGVyZmFjZXMgbm90IGFuIGludGVyZmFjZSB3aXRoIHR3byBpbmRlcGVuZGVudCBwcm9wZXJ0aWVzIG9mIHVuaW9uIHR5cGVzXG4gICAgICAgIGNvbnN0IHJldCA9IGlkID09PSAncGFpcidcbiAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgIHByaW06ICdwYWlyJyxcbiAgICAgICAgICAgICAgICBhcmdzLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgcHJpbTogJ1BhaXInLFxuICAgICAgICAgICAgICAgIGFyZ3MsXG4gICAgICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCAoQXJyYXkuaXNBcnJheSh2dikgPyB7IHByaW06IGlkIH0gOiB2dikpLCB7IGFyZ3M6IFtcbiAgICAgICAgICAgIGFyZ3NbMF0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJpbTogaWQsXG4gICAgICAgICAgICAgICAgYXJnczogYXJncy5zbGljZSgxKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0gfSk7XG59XG5mdW5jdGlvbiBpc1BhaXJUeXBlKHQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSB8fCB0LnByaW0gPT09ICdwYWlyJztcbn1cbmZ1bmN0aW9uIGlzUGFpckRhdGEoZCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGQpIHx8ICgncHJpbScgaW4gZCAmJiBkLnByaW0gPT09ICdQYWlyJyk7XG59XG5jb25zdCByZmMzMzM5UmUgPSAvXlswLTldezR9LSgwWzEtOV18MVswLTJdKS0oMFsxLTldfFsxMl1bMC05XXwzWzAxXSlbVCBdKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKTooWzAtNV1bMC05XXw2MCkoXFwuWzAtOV0rKT8oWnxbKy1dKFswMV1bMC05XXwyWzAtM10pOihbMC01XVswLTldKSkkLztcbmZ1bmN0aW9uIHBhcnNlRGF0ZShhKSB7XG4gICAgaWYgKCdzdHJpbmcnIGluIGEpIHtcbiAgICAgICAgaWYgKGlzTmF0dXJhbChhLnN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgRGF0ZShwYXJzZUludChhLnN0cmluZywgMTApKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZmMzMzM5UmUudGVzdChhLnN0cmluZykpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSBuZXcgRGF0ZShhLnN0cmluZyk7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc05hTih4LnZhbHVlT2YpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoaXNEZWNpbWFsKGEuaW50KSkge1xuICAgICAgICByZXR1cm4gbmV3IERhdGUocGFyc2VJbnQoYS5pbnQsIDEwKSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gcGFyc2VIZXgocykge1xuICAgIGNvbnN0IHJlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCBzcyA9IHMuc2xpY2UoaSwgaSArIDIpO1xuICAgICAgICBjb25zdCB4ID0gcGFyc2VJbnQoc3MsIDE2KTtcbiAgICAgICAgaWYgKE51bWJlci5pc05hTih4KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEhleFBhcnNlRXJyb3Ioc3MpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKHgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuZnVuY3Rpb24gaGV4Qnl0ZXMoYnl0ZXMpIHtcbiAgICByZXR1cm4gYnl0ZXMubWFwKCh4KSA9PiAoKHggPj4gNCkgJiAweGYpLnRvU3RyaW5nKDE2KSArICh4ICYgMHhmKS50b1N0cmluZygxNikpLmpvaW4oJycpO1xufVxuXG4vLyBNaWNoZWxzb24gdmFsaWRhdG9yXG5jb25zdCBtYXhWaWV3TmFtZUxlbmd0aCA9IDMxO1xuY29uc3Qgbm9BcmdJbnN0cnVjdGlvbklEcyA9IHtcbiAgICBBQlM6IHRydWUsXG4gICAgQUREOiB0cnVlLFxuICAgIEFERFJFU1M6IHRydWUsXG4gICAgQU1PVU5UOiB0cnVlLFxuICAgIEFORDogdHJ1ZSxcbiAgICBBUFBMWTogdHJ1ZSxcbiAgICBCQUxBTkNFOiB0cnVlLFxuICAgIEJMQUtFMkI6IHRydWUsXG4gICAgQ0FSOiB0cnVlLFxuICAgIENEUjogdHJ1ZSxcbiAgICBDSEFJTl9JRDogdHJ1ZSxcbiAgICBDSEVDS19TSUdOQVRVUkU6IHRydWUsXG4gICAgQ09NUEFSRTogdHJ1ZSxcbiAgICBDT05DQVQ6IHRydWUsXG4gICAgQ09OUzogdHJ1ZSxcbiAgICBFRElWOiB0cnVlLFxuICAgIEVROiB0cnVlLFxuICAgIEVYRUM6IHRydWUsXG4gICAgRkFJTFdJVEg6IHRydWUsXG4gICAgR0U6IHRydWUsXG4gICAgR0VUX0FORF9VUERBVEU6IHRydWUsXG4gICAgR1Q6IHRydWUsXG4gICAgSEFTSF9LRVk6IHRydWUsXG4gICAgSU1QTElDSVRfQUNDT1VOVDogdHJ1ZSxcbiAgICBJTlQ6IHRydWUsXG4gICAgSVNOQVQ6IHRydWUsXG4gICAgSk9JTl9USUNLRVRTOiB0cnVlLFxuICAgIEtFQ0NBSzogdHJ1ZSxcbiAgICBMRTogdHJ1ZSxcbiAgICBMRVZFTDogdHJ1ZSxcbiAgICBMU0w6IHRydWUsXG4gICAgTFNSOiB0cnVlLFxuICAgIExUOiB0cnVlLFxuICAgIE1FTTogdHJ1ZSxcbiAgICBNVUw6IHRydWUsXG4gICAgTkVHOiB0cnVlLFxuICAgIE5FUTogdHJ1ZSxcbiAgICBORVZFUjogdHJ1ZSxcbiAgICBOT1Q6IHRydWUsXG4gICAgTk9XOiB0cnVlLFxuICAgIE9SOiB0cnVlLFxuICAgIFBBQ0s6IHRydWUsXG4gICAgUEFJUklOR19DSEVDSzogdHJ1ZSxcbiAgICBSRUFEX1RJQ0tFVDogdHJ1ZSxcbiAgICBTQVBMSU5HX1ZFUklGWV9VUERBVEU6IHRydWUsXG4gICAgU0VMRjogdHJ1ZSxcbiAgICBTRUxGX0FERFJFU1M6IHRydWUsXG4gICAgU0VOREVSOiB0cnVlLFxuICAgIFNFVF9ERUxFR0FURTogdHJ1ZSxcbiAgICBTSEEyNTY6IHRydWUsXG4gICAgU0hBMzogdHJ1ZSxcbiAgICBTSEE1MTI6IHRydWUsXG4gICAgU0laRTogdHJ1ZSxcbiAgICBTTElDRTogdHJ1ZSxcbiAgICBTT01FOiB0cnVlLFxuICAgIFNPVVJDRTogdHJ1ZSxcbiAgICBTUExJVF9USUNLRVQ6IHRydWUsXG4gICAgU1VCOiB0cnVlLFxuICAgIFNXQVA6IHRydWUsXG4gICAgVElDS0VUOiB0cnVlLFxuICAgIFRJQ0tFVF9ERVBSRUNBVEVEOiB0cnVlLFxuICAgIFRPVEFMX1ZPVElOR19QT1dFUjogdHJ1ZSxcbiAgICBUUkFOU0ZFUl9UT0tFTlM6IHRydWUsXG4gICAgVU5JVDogdHJ1ZSxcbiAgICBWT1RJTkdfUE9XRVI6IHRydWUsXG4gICAgWE9SOiB0cnVlLFxuICAgIFJFTkFNRTogdHJ1ZSxcbiAgICBPUEVOX0NIRVNUOiB0cnVlLFxuICAgIFNVQl9NVVRFWjogdHJ1ZSxcbiAgICBNSU5fQkxPQ0tfVElNRTogdHJ1ZSxcbiAgICBCWVRFUzogdHJ1ZSxcbiAgICBOQVQ6IHRydWUsXG59O1xuY29uc3QgaW5zdHJ1Y3Rpb25JRHMgPSBPYmplY3QuYXNzaWduKHt9LCBub0FyZ0luc3RydWN0aW9uSURzLCB7XG4gICAgQ09OVFJBQ1Q6IHRydWUsXG4gICAgQ1JFQVRFX0NPTlRSQUNUOiB0cnVlLFxuICAgIERJRzogdHJ1ZSxcbiAgICBESVA6IHRydWUsXG4gICAgRFJPUDogdHJ1ZSxcbiAgICBEVUc6IHRydWUsXG4gICAgRFVQOiB0cnVlLFxuICAgIEVNSVQ6IHRydWUsXG4gICAgRU1QVFlfQklHX01BUDogdHJ1ZSxcbiAgICBFTVBUWV9NQVA6IHRydWUsXG4gICAgRU1QVFlfU0VUOiB0cnVlLFxuICAgIEdFVDogdHJ1ZSxcbiAgICBJRjogdHJ1ZSxcbiAgICBJRl9DT05TOiB0cnVlLFxuICAgIElGX0xFRlQ6IHRydWUsXG4gICAgSUZfTk9ORTogdHJ1ZSxcbiAgICBJVEVSOiB0cnVlLFxuICAgIExBTUJEQTogdHJ1ZSxcbiAgICBMQU1CREFfUkVDOiB0cnVlLFxuICAgIExFRlQ6IHRydWUsXG4gICAgTE9PUDogdHJ1ZSxcbiAgICBMT09QX0xFRlQ6IHRydWUsXG4gICAgTUFQOiB0cnVlLFxuICAgIE5JTDogdHJ1ZSxcbiAgICBOT05FOiB0cnVlLFxuICAgIFBBSVI6IHRydWUsXG4gICAgUFVTSDogdHJ1ZSxcbiAgICBSSUdIVDogdHJ1ZSxcbiAgICBTQVBMSU5HX0VNUFRZX1NUQVRFOiB0cnVlLFxuICAgIFVOUEFDSzogdHJ1ZSxcbiAgICBVTlBBSVI6IHRydWUsXG4gICAgVVBEQVRFOiB0cnVlLFxuICAgIENBU1Q6IHRydWUsXG4gICAgVklFVzogdHJ1ZSxcbn0pO1xuY29uc3Qgc2ltcGxlQ29tcGFyYWJsZVR5cGVJRHMgPSB7XG4gICAgdW5pdDogdHJ1ZSxcbiAgICBuZXZlcjogdHJ1ZSxcbiAgICBib29sOiB0cnVlLFxuICAgIGludDogdHJ1ZSxcbiAgICBuYXQ6IHRydWUsXG4gICAgc3RyaW5nOiB0cnVlLFxuICAgIGNoYWluX2lkOiB0cnVlLFxuICAgIGJ5dGVzOiB0cnVlLFxuICAgIG11dGV6OiB0cnVlLFxuICAgIGtleV9oYXNoOiB0cnVlLFxuICAgIGtleTogdHJ1ZSxcbiAgICBzaWduYXR1cmU6IHRydWUsXG4gICAgdGltZXN0YW1wOiB0cnVlLFxuICAgIGFkZHJlc3M6IHRydWUsXG4gICAgdHhfcm9sbHVwX2wyX2FkZHJlc3M6IHRydWUsXG59O1xuY29uc3QgdHlwZUlEcyA9IE9iamVjdC5hc3NpZ24oe30sIHNpbXBsZUNvbXBhcmFibGVUeXBlSURzLCB7XG4gICAgb3I6IHRydWUsXG4gICAgcGFpcjogdHJ1ZSxcbiAgICBzZXQ6IHRydWUsXG4gICAgYmlnX21hcDogdHJ1ZSxcbiAgICBjb250cmFjdDogdHJ1ZSxcbiAgICBsYW1iZGE6IHRydWUsXG4gICAgbGlzdDogdHJ1ZSxcbiAgICBtYXA6IHRydWUsXG4gICAgb3BlcmF0aW9uOiB0cnVlLFxuICAgIG9wdGlvbjogdHJ1ZSxcbiAgICBibHMxMl8zODFfZzE6IHRydWUsXG4gICAgYmxzMTJfMzgxX2cyOiB0cnVlLFxuICAgIGJsczEyXzM4MV9mcjogdHJ1ZSxcbiAgICBzYXBsaW5nX3RyYW5zYWN0aW9uOiB0cnVlLFxuICAgIHNhcGxpbmdfdHJhbnNhY3Rpb25fZGVwcmVjYXRlZDogdHJ1ZSxcbiAgICBzYXBsaW5nX3N0YXRlOiB0cnVlLFxuICAgIHRpY2tldDogdHJ1ZSxcbiAgICBjaGVzdF9rZXk6IHRydWUsXG4gICAgY2hlc3Q6IHRydWUsXG59KTtcbmNsYXNzIE1pY2hlbHNvblZhbGlkYXRpb25FcnJvciBleHRlbmRzIE1pY2hlbHNvbkVycm9yIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsIFZhbHVlIG9mIGEgbm9kZSBjYXVzZWQgdGhlIGVycm9yXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgQW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWwsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01pY2hlbHNvblZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNQcmltKGV4KSB7XG4gICAgcmV0dXJuICdwcmltJyBpbiBleDtcbn1cbmZ1bmN0aW9uIGlzUHJpbU9yU2VxKGV4KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoZXgpIHx8ICdwcmltJyBpbiBleDtcbn1cbmZ1bmN0aW9uIGFzc2VydFByaW0oZXgpIHtcbiAgICBpZiAoaXNQcmltKGV4KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgJ3ByaW0gZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYXNzZXJ0U2VxKGV4KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXgpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCAnc2VxdWVuY2UgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYXNzZXJ0UHJpbU9yU2VxKGV4KSB7XG4gICAgaWYgKGlzUHJpbU9yU2VxKGV4KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgJ3ByaW0gb3Igc2VxdWVuY2UgZXhwcmVzc2lvbiBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYXNzZXJ0TmF0dXJhbChpKSB7XG4gICAgaWYgKGkuaW50WzBdID09PSAnLScpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihpLCAnbmF0dXJhbCBudW1iZXIgZXhwZWN0ZWQnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhc3NlcnRJbnRMaXRlcmFsKGV4KSB7XG4gICAgaWYgKCdpbnQnIGluIGV4KSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCAnaW50IGxpdGVyYWwgZXhwZWN0ZWQnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFN0cmluZ0xpdGVyYWwoZXgpIHtcbiAgICBpZiAoJ3N0cmluZycgaW4gZXgpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBNaWNoZWxzb25WYWxpZGF0aW9uRXJyb3IoZXgsICdzdHJpbmcgbGl0ZXJhbCBleHBlY3RlZCcpO1xufVxuZnVuY3Rpb24gYXNzZXJ0QXJncyhleCwgbikge1xuICAgIHZhciBfYTtcbiAgICBpZiAoKG4gPT09IDAgJiYgZXguYXJncyA9PT0gdW5kZWZpbmVkKSB8fCAoKF9hID0gZXguYXJncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPT09IG4pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRocm93IG5ldyBNaWNoZWxzb25WYWxpZGF0aW9uRXJyb3IoZXgsIGAke259IGFyZ3VtZW50cyBleHBlY3RlZGApO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYSB2YWxpZCBNaWNoZWxzb24gY29kZSAoc2VxdWVuY2Ugb2YgaW5zdHJ1Y3Rpb25zKS5cbiAqIFRoaXMgaXMgYSB0eXBlIGd1YXJkIGZ1bmN0aW9uIHdoaWNoIGVpdGhlciByZXR1cm5zIHRydWUgb2YgdGhyb3dzIGFuIGV4Y2VwdGlvbi5cbiAqIEBwYXJhbSBleCBBbiBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBhc3NlcnRNaWNoZWxzb25JbnN0cnVjdGlvbihleCkge1xuICAgIHZhciBfYSwgX2I7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXgpKSB7XG4gICAgICAgIGZvciAoY29uc3QgbiBvZiBleCkge1xuICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG4pICYmICFpc1ByaW0obikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCAnc2VxdWVuY2Ugb3IgcHJpbSBleHBlY3RlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24obik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChhc3NlcnRQcmltKGV4KSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5vQXJnSW5zdHJ1Y3Rpb25JRHMsIGV4LnByaW0pKSB7XG4gICAgICAgICAgICBhc3NlcnRBcmdzKGV4LCAwKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoZXgucHJpbSkge1xuICAgICAgICAgICAgY2FzZSAnRFJPUCc6XG4gICAgICAgICAgICBjYXNlICdQQUlSJzpcbiAgICAgICAgICAgIGNhc2UgJ1VOUEFJUic6XG4gICAgICAgICAgICBjYXNlICdEVVAnOlxuICAgICAgICAgICAgY2FzZSAnVVBEQVRFJzpcbiAgICAgICAgICAgIGNhc2UgJ0dFVCc6XG4gICAgICAgICAgICAgICAgaWYgKGV4LmFyZ3MgIT09IHVuZGVmaW5lZCAmJiBhc3NlcnRBcmdzKGV4LCAxKSkge1xuICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0SW50TGl0ZXJhbChleC5hcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TmF0dXJhbChleC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0RJRyc6XG4gICAgICAgICAgICBjYXNlICdEVUcnOlxuICAgICAgICAgICAgY2FzZSAnU0FQTElOR19FTVBUWV9TVEFURSc6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydEludExpdGVyYWwoZXguYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE5hdHVyYWwoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdOT05FJzpcbiAgICAgICAgICAgIGNhc2UgJ0xFRlQnOlxuICAgICAgICAgICAgY2FzZSAnUklHSFQnOlxuICAgICAgICAgICAgY2FzZSAnTklMJzpcbiAgICAgICAgICAgIGNhc2UgJ0NBU1QnOlxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MoZXgsIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvblR5cGUoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnVU5QQUNLJzpcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKGV4LCAxKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25QYWNrYWJsZVR5cGUoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ09OVFJBQ1QnOlxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MoZXgsIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvblBhc3NhYmxlVHlwZShleC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdJRl9OT05FJzpcbiAgICAgICAgICAgIGNhc2UgJ0lGX0xFRlQnOlxuICAgICAgICAgICAgY2FzZSAnSUZfQ09OUyc6XG4gICAgICAgICAgICBjYXNlICdJRic6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydFNlcShleC5hcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydFNlcShleC5hcmdzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oZXguYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNQVAnOlxuICAgICAgICAgICAgY2FzZSAnSVRFUic6XG4gICAgICAgICAgICBjYXNlICdMT09QJzpcbiAgICAgICAgICAgIGNhc2UgJ0xPT1BfTEVGVCc6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnQ1JFQVRFX0NPTlRSQUNUJzpcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKGV4LCAxKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25Db250cmFjdChleC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdESVAnOlxuICAgICAgICAgICAgICAgIGlmICgoKF9hID0gZXguYXJncykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxlbmd0aCkgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydEludExpdGVyYWwoZXguYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE5hdHVyYWwoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydFNlcShleC5hcmdzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oZXguYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKChfYiA9IGV4LmFyZ3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3NlcnRTZXEoZXguYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvbkluc3RydWN0aW9uKGV4LmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCAnMSBvciAyIGFyZ3VtZW50cyBleHBlY3RlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BVU0gnOlxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MoZXgsIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvblB1c2hhYmxlVHlwZShleC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uRGF0YShleC5hcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdFTVBUWV9TRVQnOlxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MoZXgsIDEpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvbkNvbXBhcmFibGVUeXBlKGV4LmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0VNUFRZX01BUCc6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uQ29tcGFyYWJsZVR5cGUoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvblR5cGUoZXguYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRU1QVFlfQklHX01BUCc6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMikpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uQ29tcGFyYWJsZVR5cGUoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvbkJpZ01hcFN0b3JhYmxlVHlwZShleC5hcmdzWzFdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdMQU1CREFfUkVDJzpcbiAgICAgICAgICAgIGNhc2UgJ0xBTUJEQSc6XG4gICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMykpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uVHlwZShleC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uVHlwZShleC5hcmdzWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydFNlcShleC5hcmdzWzJdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oZXguYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdWSUVXJzpcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKGV4LCAyKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0U3RyaW5nTGl0ZXJhbChleC5hcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Vmlld05hbWVWYWxpZChleC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0TWljaGVsc29uVHlwZShleC5hcmdzWzFdKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uUHVzaGFibGVUeXBlKGV4LmFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnRU1JVCc6XG4gICAgICAgICAgICAgICAgaWYgKGV4LmFyZ3MgJiYgZXguYXJncy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydEFyZ3MoZXgsIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0QXJncyhleCwgMCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCAnaW5zdHJ1Y3Rpb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1pY2hlbHNvbkNvbXBhcmFibGVUeXBlKGV4KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoYXNzZXJ0UHJpbU9yU2VxKGV4KSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShleCkgfHwgZXgucHJpbSA9PT0gJ3BhaXInIHx8IGV4LnByaW0gPT09ICdvcicgfHwgZXgucHJpbSA9PT0gJ29wdGlvbicpIHtcbiAgICAgICAgICAgIHRyYXZlcnNlVHlwZShleCwgKGV4KSA9PiBhc3NlcnRNaWNoZWxzb25Db21wYXJhYmxlVHlwZShleCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoc2ltcGxlQ29tcGFyYWJsZVR5cGVJRHMsIGV4LnByaW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCBgJHtleC5wcmltfTogdHlwZSBpcyBub3QgY29tcGFyYWJsZWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gYXNzZXJ0TWljaGVsc29uUGFja2FibGVUeXBlKGV4KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoYXNzZXJ0UHJpbU9yU2VxKGV4KSkge1xuICAgICAgICBpZiAoaXNQcmltKGV4KSkge1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodHlwZUlEcywgZXgucHJpbSkgfHxcbiAgICAgICAgICAgICAgICBleC5wcmltID09PSAnYmlnX21hcCcgfHxcbiAgICAgICAgICAgICAgICBleC5wcmltID09PSAnb3BlcmF0aW9uJyB8fFxuICAgICAgICAgICAgICAgIGV4LnByaW0gPT09ICdzYXBsaW5nX3N0YXRlJyB8fFxuICAgICAgICAgICAgICAgIGV4LnByaW0gPT09ICd0aWNrZXQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgYCR7ZXgucHJpbX06IHR5cGUgY2FuJ3QgYmUgdXNlZCBpbnNpZGUgUEFDSy9VTlBBQ0sgaW5zdHJ1Y3Rpb25zYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmF2ZXJzZVR5cGUoZXgsIChleCkgPT4gYXNzZXJ0TWljaGVsc29uUGFja2FibGVUeXBlKGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhc3NlcnRNaWNoZWxzb25QdXNoYWJsZVR5cGUoZXgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChhc3NlcnRQcmltT3JTZXEoZXgpKSB7XG4gICAgICAgIGlmIChpc1ByaW0oZXgpKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlSURzLCBleC5wcmltKSB8fFxuICAgICAgICAgICAgICAgIGV4LnByaW0gPT09ICdiaWdfbWFwJyB8fFxuICAgICAgICAgICAgICAgIGV4LnByaW0gPT09ICdvcGVyYXRpb24nIHx8XG4gICAgICAgICAgICAgICAgZXgucHJpbSA9PT0gJ3NhcGxpbmdfc3RhdGUnIHx8XG4gICAgICAgICAgICAgICAgZXgucHJpbSA9PT0gJ3RpY2tldCcgfHxcbiAgICAgICAgICAgICAgICBleC5wcmltID09PSAnY29udHJhY3QnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgYCR7ZXgucHJpbX06IHR5cGUgY2FuJ3QgYmUgcHVzaGVkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmF2ZXJzZVR5cGUoZXgsIChleCkgPT4gYXNzZXJ0TWljaGVsc29uUHVzaGFibGVUeXBlKGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhc3NlcnRNaWNoZWxzb25TdG9yYWJsZVR5cGUoZXgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChhc3NlcnRQcmltT3JTZXEoZXgpKSB7XG4gICAgICAgIGlmIChpc1ByaW0oZXgpKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlSURzLCBleC5wcmltKSB8fFxuICAgICAgICAgICAgICAgIGV4LnByaW0gPT09ICdvcGVyYXRpb24nIHx8XG4gICAgICAgICAgICAgICAgZXgucHJpbSA9PT0gJ2NvbnRyYWN0Jykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25WYWxpZGF0aW9uRXJyb3IoZXgsIGAke2V4LnByaW19OiB0eXBlIGNhbid0IGJlIHVzZWQgYXMgcGFydCBvZiBhIHN0b3JhZ2VgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYXZlcnNlVHlwZShleCwgKGV4KSA9PiBhc3NlcnRNaWNoZWxzb25TdG9yYWJsZVR5cGUoZXgpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGFzc2VydE1pY2hlbHNvblBhc3NhYmxlVHlwZShleCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGFzc2VydFByaW1PclNlcShleCkpIHtcbiAgICAgICAgaWYgKGlzUHJpbShleCkpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGVJRHMsIGV4LnByaW0pIHx8IGV4LnByaW0gPT09ICdvcGVyYXRpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgYCR7ZXgucHJpbX06IHR5cGUgY2FuJ3QgYmUgdXNlZCBhcyBwYXJ0IG9mIGEgcGFyYW1ldGVyYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmF2ZXJzZVR5cGUoZXgsIChleCkgPT4gYXNzZXJ0TWljaGVsc29uUGFzc2FibGVUeXBlKGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhc3NlcnRNaWNoZWxzb25CaWdNYXBTdG9yYWJsZVR5cGUoZXgpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChhc3NlcnRQcmltT3JTZXEoZXgpKSB7XG4gICAgICAgIGlmIChpc1ByaW0oZXgpKSB7XG4gICAgICAgICAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0eXBlSURzLCBleC5wcmltKSB8fFxuICAgICAgICAgICAgICAgIGV4LnByaW0gPT09ICdiaWdfbWFwJyB8fFxuICAgICAgICAgICAgICAgIGV4LnByaW0gPT09ICdvcGVyYXRpb24nIHx8XG4gICAgICAgICAgICAgICAgZXgucHJpbSA9PT0gJ3NhcGxpbmdfc3RhdGUnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgYCR7ZXgucHJpbX06IHR5cGUgY2FuJ3QgYmUgdXNlZCBpbnNpZGUgYSBiaWdfbWFwYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cmF2ZXJzZVR5cGUoZXgsIChleCkgPT4gYXNzZXJ0TWljaGVsc29uQmlnTWFwU3RvcmFibGVUeXBlKGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5jb25zdCB2aWV3UmUgPSBuZXcgUmVnRXhwKCdeW2EtekEtWjAtOV8uJUBdKiQnKTtcbmZ1bmN0aW9uIGFzc2VydFZpZXdOYW1lVmFsaWQobmFtZSkge1xuICAgIGlmIChuYW1lLnN0cmluZy5sZW5ndGggPiBtYXhWaWV3TmFtZUxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKG5hbWUsIGB2aWV3IG5hbWUgdG9vIGxvbmc6ICR7bmFtZS5zdHJpbmd9YCk7XG4gICAgfVxuICAgIGlmICghdmlld1JlLnRlc3QobmFtZS5zdHJpbmcpKSB7XG4gICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25WYWxpZGF0aW9uRXJyb3IobmFtZSwgYGludmFsaWQgY2hhcmFjdGVyKHMpIGluIHZpZXcgbmFtZTogJHtuYW1lLnN0cmluZ31gKTtcbiAgICB9XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBhIHZhbGlkIE1pY2hlbHNvbiB0eXBlIGV4cHJlc3Npb24uXG4gKiBUaGlzIGlzIGEgdHlwZSBndWFyZCBmdW5jdGlvbiB3aGljaCBlaXRoZXIgcmV0dXJucyB0cnVlIG9mIHRocm93cyBhbiBleGNlcHRpb24uXG4gKiBAcGFyYW0gZXggQW4gQVNUIG5vZGVcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0TWljaGVsc29uVHlwZShleCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgaWYgKGFzc2VydFByaW1PclNlcShleCkpIHtcbiAgICAgICAgaWYgKGlzUHJpbShleCkpIHtcbiAgICAgICAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHR5cGVJRHMsIGV4LnByaW0pKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgJ3R5cGUgZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRyYXZlcnNlVHlwZShleCwgKGV4KSA9PiBhc3NlcnRNaWNoZWxzb25UeXBlKGV4KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiB0cmF2ZXJzZVR5cGUoZXgsIGNiKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXgpIHx8IGV4LnByaW0gPT09ICdwYWlyJykge1xuICAgICAgICBjb25zdCBhcmdzID0gQXJyYXkuaXNBcnJheShleCkgPyBleCA6IGV4LmFyZ3M7XG4gICAgICAgIGlmIChhcmdzID09PSB1bmRlZmluZWQgfHwgYXJncy5sZW5ndGggPCAyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCAnYXQgbGVhc3QgMiBhcmd1bWVudHMgZXhwZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBhcmdzLmZvckVhY2goKGEpID0+IHtcbiAgICAgICAgICAgIGlmIChhc3NlcnRQcmltT3JTZXEoYSkpIHtcbiAgICAgICAgICAgICAgICBjYihhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBzd2l0Y2ggKGV4LnByaW0pIHtcbiAgICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgY2FzZSAnbGlzdCc6XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MoZXgsIDEpICYmIGFzc2VydFByaW1PclNlcShleC5hcmdzWzBdKSkge1xuICAgICAgICAgICAgICAgIGNiKGV4LmFyZ3NbMF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2NvbnRyYWN0JzpcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMSkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25QYXNzYWJsZVR5cGUoZXguYXJnc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKGV4LCAyKSAmJiBhc3NlcnRQcmltT3JTZXEoZXguYXJnc1swXSkgJiYgYXNzZXJ0UHJpbU9yU2VxKGV4LmFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAgICAgY2IoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgY2IoZXguYXJnc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbGFtYmRhJzpcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMikpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25UeXBlKGV4LmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvblR5cGUoZXguYXJnc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMSkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25Db21wYXJhYmxlVHlwZShleC5hcmdzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKGV4LCAyKSAmJiBhc3NlcnRQcmltT3JTZXEoZXguYXJnc1swXSkgJiYgYXNzZXJ0UHJpbU9yU2VxKGV4LmFyZ3NbMV0pKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uQ29tcGFyYWJsZVR5cGUoZXguYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgY2IoZXguYXJnc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnYmlnX21hcCc6XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MoZXgsIDIpICYmIGFzc2VydFByaW1PclNlcShleC5hcmdzWzBdKSAmJiBhc3NlcnRQcmltT3JTZXEoZXguYXJnc1sxXSkpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25Db21wYXJhYmxlVHlwZShleC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25CaWdNYXBTdG9yYWJsZVR5cGUoZXguYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgY2IoZXguYXJnc1sxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndGlja2V0JzpcbiAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhleCwgMSkgJiYgYXNzZXJ0UHJpbU9yU2VxKGV4LmFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uQ29tcGFyYWJsZVR5cGUoZXguYXJnc1swXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnc2FwbGluZ19zdGF0ZSc6XG4gICAgICAgIGNhc2UgJ3NhcGxpbmdfdHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3MoZXgsIDEpKSB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0SW50TGl0ZXJhbChleC5hcmdzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgYXNzZXJ0QXJncyhleCwgMCk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYSB2YWxpZCBNaWNoZWxzb24gZGF0YSBsaXRlcmFsIHN1Y2ggYXMgYChQYWlyIHtFbHQgXCIwXCIgMH0gMClgLlxuICogVGhpcyBpcyBhIHR5cGUgZ3VhcmQgZnVuY3Rpb24gd2hpY2ggZWl0aGVyIHJldHVybnMgdHJ1ZSBvZiB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICogQHBhcmFtIGV4IEFuIEFTVCBub2RlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE1pY2hlbHNvbkRhdGEoZXgpIHtcbiAgICBpZiAoJ2ludCcgaW4gZXggfHwgJ3N0cmluZycgaW4gZXggfHwgJ2J5dGVzJyBpbiBleCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXgpKSB7XG4gICAgICAgIGxldCBtYXBFbHRzID0gMDtcbiAgICAgICAgZm9yIChjb25zdCBuIG9mIGV4KSB7XG4gICAgICAgICAgICBpZiAoaXNQcmltKG4pICYmIG4ucHJpbSA9PT0gJ0VsdCcpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKG4sIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvbkRhdGEobi5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uRGF0YShuLmFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBtYXBFbHRzKys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25EYXRhKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChtYXBFbHRzICE9PSAwICYmIG1hcEVsdHMgIT09IGV4Lmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgXCJkYXRhIGVudHJpZXMgYW5kIG1hcCBlbGVtZW50cyBjYW4ndCBiZSBpbnRlcm1peGVkXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoaXNQcmltKGV4KSkge1xuICAgICAgICBzd2l0Y2ggKGV4LnByaW0pIHtcbiAgICAgICAgICAgIGNhc2UgJ1VuaXQnOlxuICAgICAgICAgICAgY2FzZSAnVHJ1ZSc6XG4gICAgICAgICAgICBjYXNlICdGYWxzZSc6XG4gICAgICAgICAgICBjYXNlICdOb25lJzpcbiAgICAgICAgICAgICAgICBhc3NlcnRBcmdzKGV4LCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BhaXInOlxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgaWYgKGV4LmFyZ3MgPT09IHVuZGVmaW5lZCB8fCBleC5hcmdzLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgJ2F0IGxlYXN0IDIgYXJndW1lbnRzIGV4cGVjdGVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiBleC5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvbkRhdGEoYSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnTGVmdCc6XG4gICAgICAgICAgICBjYXNlICdSaWdodCc6XG4gICAgICAgICAgICBjYXNlICdTb21lJzpcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKGV4LCAxKSkge1xuICAgICAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25EYXRhKGV4LmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xhbWJkYV9yZWMnOlxuICAgICAgICAgICAgICAgIGlmIChleC5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvbkluc3RydWN0aW9uKGV4LmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnN0cnVjdGlvbklEcywgZXgucHJpbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgJ2RhdGEgZW50cnkgb3IgaW5zdHJ1Y3Rpb24gZXhwZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25WYWxpZGF0aW9uRXJyb3IoZXgsICdkYXRhIGVudHJ5IGV4cGVjdGVkJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYSB2YWxpZCBNaWNoZWxzb24gc21hcnQgY29udHJhY3Qgc291cmNlIGNvbnRhaW5pbmcgYWxsIHJlcXVpcmVkIGFuZCB2YWxpZCBwcm9wZXJ0aWVzIHN1Y2ggYXMgYHBhcmFtZXRlcmAsIGBzdG9yYWdlYCBhbmQgYGNvZGVgLlxuICogVGhpcyBpcyBhIHR5cGUgZ3VhcmQgZnVuY3Rpb24gd2hpY2ggZWl0aGVyIHJldHVybnMgdHJ1ZSBvZiB0aHJvd3MgYW4gZXhjZXB0aW9uLlxuICogQHBhcmFtIGV4IEFuIEFTVCBub2RlXG4gKi9cbmZ1bmN0aW9uIGFzc2VydE1pY2hlbHNvbkNvbnRyYWN0KGV4KSB7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICBpZiAoYXNzZXJ0U2VxKGV4KSkge1xuICAgICAgICBjb25zdCB0b3BsZXZlbFNlYyA9IHt9O1xuICAgICAgICBjb25zdCB2aWV3cyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IHNlYyBvZiBleCkge1xuICAgICAgICAgICAgaWYgKGFzc2VydFByaW0oc2VjKSkge1xuICAgICAgICAgICAgICAgIGlmIChzZWMucHJpbSAhPT0gJ3ZpZXcnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZWMucHJpbSBpbiB0b3BsZXZlbFNlYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgYGR1cGxpY2F0ZSBjb250cmFjdCBzZWN0aW9uOiAke3NlYy5wcmltfWApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvcGxldmVsU2VjW3NlYy5wcmltXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXG4gICAgICAgICAgICAgICAgc3dpdGNoIChzZWMucHJpbSkge1xuICAgICAgICAgICAgICAgICAgICBjYXNlICdjb2RlJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKHNlYywgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3NlcnRTZXEoc2VjLmFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvbkluc3RydWN0aW9uKHNlYy5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAncGFyYW1ldGVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhc3NlcnRBcmdzKHNlYywgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25QYXNzYWJsZVR5cGUoc2VjLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlYy5hbm5vdHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKHNlYywgJ0Fubm90YXRpb24gbXVzdCBiZSBwYXJ0IG9mIHRoZSBwYXJhbWV0ZXIgdHlwZScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N0b3JhZ2UnOlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydEFyZ3Moc2VjLCAxKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvblN0b3JhYmxlVHlwZShzZWMuYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAndmlldyc6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNzZXJ0QXJncyhzZWMsIDQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydFN0cmluZ0xpdGVyYWwoc2VjLmFyZ3NbMF0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBzZWMuYXJnc1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5hbWUuc3RyaW5nIGluIHZpZXdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yKGV4LCBgZHVwbGljYXRlIHZpZXcgbmFtZTogJHtuYW1lLnN0cmluZ31gKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3c1tuYW1lLnN0cmluZ10gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRWaWV3TmFtZVZhbGlkKG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhc3NlcnRNaWNoZWxzb25QdXNoYWJsZVR5cGUoc2VjLmFyZ3NbMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzc2VydE1pY2hlbHNvblB1c2hhYmxlVHlwZShzZWMuYXJnc1syXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFzc2VydFNlcShzZWMuYXJnc1szXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oc2VjLmFyZ3NbM10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblZhbGlkYXRpb25FcnJvcihleCwgYHVuZXhwZWN0ZWQgY29udHJhY3Qgc2VjdGlvbjogJHtzZWMucHJpbX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIENoZWNrcyBpZiB0aGUgbm9kZSBpcyBhIHZhbGlkIE1pY2hlbHNvbiBzbWFydCBjb250cmFjdCBzb3VyY2UgY29udGFpbmluZyBhbGwgcmVxdWlyZWQgYW5kIHZhbGlkIHByb3BlcnRpZXMgc3VjaCBhcyBgcGFyYW1ldGVyYCwgYHN0b3JhZ2VgIGFuZCBgY29kZWAuXG4gKiBAcGFyYW0gZXggQW4gQVNUIG5vZGVcbiAqL1xuZnVuY3Rpb24gaXNNaWNoZWxzb25TY3JpcHQoZXgpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnRNaWNoZWxzb25Db250cmFjdChleCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIGEgdmFsaWQgTWljaGVsc29uIGRhdGEgbGl0ZXJhbCBzdWNoIGFzIGAoUGFpciB7RWx0IFwiMFwiIDB9IDApYC5cbiAqIEBwYXJhbSBleCBBbiBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBpc01pY2hlbHNvbkRhdGEoZXgpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnRNaWNoZWxzb25EYXRhKGV4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDaGVja3MgaWYgdGhlIG5vZGUgaXMgYSB2YWxpZCBNaWNoZWxzb24gY29kZSAoc2VxdWVuY2Ugb2YgaW5zdHJ1Y3Rpb25zKS5cbiAqIEBwYXJhbSBleCBBbiBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBpc01pY2hlbHNvbkNvZGUoZXgpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnRNaWNoZWxzb25JbnN0cnVjdGlvbihleCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQ2hlY2tzIGlmIHRoZSBub2RlIGlzIGEgdmFsaWQgTWljaGVsc29uIHR5cGUgZXhwcmVzc2lvbi5cbiAqIEBwYXJhbSBleCBBbiBBU1Qgbm9kZVxuICovXG5mdW5jdGlvbiBpc01pY2hlbHNvblR5cGUoZXgpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnRNaWNoZWxzb25UeXBlKGV4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNJbnN0cnVjdGlvbihwKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpbnN0cnVjdGlvbklEcywgcC5wcmltKTtcbn1cbmZ1bmN0aW9uIGFzc2VydERhdGFMaXN0SWZBbnkoZCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShkKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdiBvZiBkKSB7XG4gICAgICAgIGlmICgncHJpbScgaW4gdikge1xuICAgICAgICAgICAgaWYgKGlzSW5zdHJ1Y3Rpb24odikpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uRXJyb3IoZCwgYEluc3RydWN0aW9uIG91dHNpZGUgb2YgYSBsYW1iZGE6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2LnByaW0gPT09ICdFbHQnKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkVycm9yKGQsIGBFbHQgaXRlbSBvdXRzaWRlIG9mIGEgbWFwIGxpdGVyYWw6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG4vLyBUaGUgb3JkZXIgaXMgaW1wb3J0YW50IVxuLy8gVGhlIHBvc2l0aW9uIHJlcHJlc2VudCB0aGUgZW5jb2RpbmcgdmFsdWUuXG5jb25zdCBwcmltaXRpdmVzID0gW1xuICAgICdwYXJhbWV0ZXInLFxuICAgICdzdG9yYWdlJyxcbiAgICAnY29kZScsXG4gICAgJ0ZhbHNlJyxcbiAgICAnRWx0JyxcbiAgICAnTGVmdCcsXG4gICAgJ05vbmUnLFxuICAgICdQYWlyJyxcbiAgICAnUmlnaHQnLFxuICAgICdTb21lJyxcbiAgICAnVHJ1ZScsXG4gICAgJ1VuaXQnLFxuICAgICdQQUNLJyxcbiAgICAnVU5QQUNLJyxcbiAgICAnQkxBS0UyQicsXG4gICAgJ1NIQTI1NicsXG4gICAgJ1NIQTUxMicsXG4gICAgJ0FCUycsXG4gICAgJ0FERCcsXG4gICAgJ0FNT1VOVCcsXG4gICAgJ0FORCcsXG4gICAgJ0JBTEFOQ0UnLFxuICAgICdDQVInLFxuICAgICdDRFInLFxuICAgICdDSEVDS19TSUdOQVRVUkUnLFxuICAgICdDT01QQVJFJyxcbiAgICAnQ09OQ0FUJyxcbiAgICAnQ09OUycsXG4gICAgJ0NSRUFURV9BQ0NPVU5UJyxcbiAgICAnQ1JFQVRFX0NPTlRSQUNUJyxcbiAgICAnSU1QTElDSVRfQUNDT1VOVCcsXG4gICAgJ0RJUCcsXG4gICAgJ0RST1AnLFxuICAgICdEVVAnLFxuICAgICdFRElWJyxcbiAgICAnRU1QVFlfTUFQJyxcbiAgICAnRU1QVFlfU0VUJyxcbiAgICAnRVEnLFxuICAgICdFWEVDJyxcbiAgICAnRkFJTFdJVEgnLFxuICAgICdHRScsXG4gICAgJ0dFVCcsXG4gICAgJ0dUJyxcbiAgICAnSEFTSF9LRVknLFxuICAgICdJRicsXG4gICAgJ0lGX0NPTlMnLFxuICAgICdJRl9MRUZUJyxcbiAgICAnSUZfTk9ORScsXG4gICAgJ0lOVCcsXG4gICAgJ0xBTUJEQScsXG4gICAgJ0xFJyxcbiAgICAnTEVGVCcsXG4gICAgJ0xPT1AnLFxuICAgICdMU0wnLFxuICAgICdMU1InLFxuICAgICdMVCcsXG4gICAgJ01BUCcsXG4gICAgJ01FTScsXG4gICAgJ01VTCcsXG4gICAgJ05FRycsXG4gICAgJ05FUScsXG4gICAgJ05JTCcsXG4gICAgJ05PTkUnLFxuICAgICdOT1QnLFxuICAgICdOT1cnLFxuICAgICdPUicsXG4gICAgJ1BBSVInLFxuICAgICdQVVNIJyxcbiAgICAnUklHSFQnLFxuICAgICdTSVpFJyxcbiAgICAnU09NRScsXG4gICAgJ1NPVVJDRScsXG4gICAgJ1NFTkRFUicsXG4gICAgJ1NFTEYnLFxuICAgICdTVEVQU19UT19RVU9UQScsXG4gICAgJ1NVQicsXG4gICAgJ1NXQVAnLFxuICAgICdUUkFOU0ZFUl9UT0tFTlMnLFxuICAgICdTRVRfREVMRUdBVEUnLFxuICAgICdVTklUJyxcbiAgICAnVVBEQVRFJyxcbiAgICAnWE9SJyxcbiAgICAnSVRFUicsXG4gICAgJ0xPT1BfTEVGVCcsXG4gICAgJ0FERFJFU1MnLFxuICAgICdDT05UUkFDVCcsXG4gICAgJ0lTTkFUJyxcbiAgICAnQ0FTVCcsXG4gICAgJ1JFTkFNRScsXG4gICAgJ2Jvb2wnLFxuICAgICdjb250cmFjdCcsXG4gICAgJ2ludCcsXG4gICAgJ2tleScsXG4gICAgJ2tleV9oYXNoJyxcbiAgICAnbGFtYmRhJyxcbiAgICAnbGlzdCcsXG4gICAgJ21hcCcsXG4gICAgJ2JpZ19tYXAnLFxuICAgICduYXQnLFxuICAgICdvcHRpb24nLFxuICAgICdvcicsXG4gICAgJ3BhaXInLFxuICAgICdzZXQnLFxuICAgICdzaWduYXR1cmUnLFxuICAgICdzdHJpbmcnLFxuICAgICdieXRlcycsXG4gICAgJ211dGV6JyxcbiAgICAndGltZXN0YW1wJyxcbiAgICAndW5pdCcsXG4gICAgJ29wZXJhdGlvbicsXG4gICAgJ2FkZHJlc3MnLFxuICAgICdTTElDRScsXG4gICAgJ0RJRycsXG4gICAgJ0RVRycsXG4gICAgJ0VNUFRZX0JJR19NQVAnLFxuICAgICdBUFBMWScsXG4gICAgJ2NoYWluX2lkJyxcbiAgICAnQ0hBSU5fSUQnLFxuICAgICdMRVZFTCcsXG4gICAgJ1NFTEZfQUREUkVTUycsXG4gICAgJ25ldmVyJyxcbiAgICAnTkVWRVInLFxuICAgICdVTlBBSVInLFxuICAgICdWT1RJTkdfUE9XRVInLFxuICAgICdUT1RBTF9WT1RJTkdfUE9XRVInLFxuICAgICdLRUNDQUsnLFxuICAgICdTSEEzJyxcbiAgICAnUEFJUklOR19DSEVDSycsXG4gICAgJ2JsczEyXzM4MV9nMScsXG4gICAgJ2JsczEyXzM4MV9nMicsXG4gICAgJ2JsczEyXzM4MV9mcicsXG4gICAgJ3NhcGxpbmdfc3RhdGUnLFxuICAgICdzYXBsaW5nX3RyYW5zYWN0aW9uX2RlcHJlY2F0ZWQnLFxuICAgICdTQVBMSU5HX0VNUFRZX1NUQVRFJyxcbiAgICAnU0FQTElOR19WRVJJRllfVVBEQVRFJyxcbiAgICAndGlja2V0JyxcbiAgICAnVElDS0VUX0RFUFJFQ0FURUQnLFxuICAgICdSRUFEX1RJQ0tFVCcsXG4gICAgJ1NQTElUX1RJQ0tFVCcsXG4gICAgJ0pPSU5fVElDS0VUUycsXG4gICAgJ0dFVF9BTkRfVVBEQVRFJyxcbiAgICAnY2hlc3QnLFxuICAgICdjaGVzdF9rZXknLFxuICAgICdPUEVOX0NIRVNUJyxcbiAgICAnVklFVycsXG4gICAgJ3ZpZXcnLFxuICAgICdjb25zdGFudCcsXG4gICAgJ1NVQl9NVVRFWicsXG4gICAgJ3R4X3JvbGx1cF9sMl9hZGRyZXNzJyxcbiAgICAnTUlOX0JMT0NLX1RJTUUnLFxuICAgICdzYXBsaW5nX3RyYW5zYWN0aW9uJyxcbiAgICAnRU1JVCcsXG4gICAgJ0xhbWJkYV9yZWMnLFxuICAgICdMQU1CREFfUkVDJyxcbiAgICAnVElDS0VUJyxcbiAgICAnQllURVMnLFxuICAgICdOQVQnLFxuXTtcbmNvbnN0IHByaW1UYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgLi4ucHJpbWl0aXZlcy5tYXAoKHYsIGkpID0+ICh7IFt2XTogaSB9KSkpO1xudmFyIFRhZztcbihmdW5jdGlvbiAoVGFnKSB7XG4gICAgVGFnW1RhZ1tcIkludFwiXSA9IDBdID0gXCJJbnRcIjtcbiAgICBUYWdbVGFnW1wiU3RyaW5nXCJdID0gMV0gPSBcIlN0cmluZ1wiO1xuICAgIFRhZ1tUYWdbXCJTZXF1ZW5jZVwiXSA9IDJdID0gXCJTZXF1ZW5jZVwiO1xuICAgIFRhZ1tUYWdbXCJQcmltMFwiXSA9IDNdID0gXCJQcmltMFwiO1xuICAgIFRhZ1tUYWdbXCJQcmltMEFubm90XCJdID0gNF0gPSBcIlByaW0wQW5ub3RcIjtcbiAgICBUYWdbVGFnW1wiUHJpbTFcIl0gPSA1XSA9IFwiUHJpbTFcIjtcbiAgICBUYWdbVGFnW1wiUHJpbTFBbm5vdFwiXSA9IDZdID0gXCJQcmltMUFubm90XCI7XG4gICAgVGFnW1RhZ1tcIlByaW0yXCJdID0gN10gPSBcIlByaW0yXCI7XG4gICAgVGFnW1RhZ1tcIlByaW0yQW5ub3RcIl0gPSA4XSA9IFwiUHJpbTJBbm5vdFwiO1xuICAgIFRhZ1tUYWdbXCJQcmltXCJdID0gOV0gPSBcIlByaW1cIjtcbiAgICBUYWdbVGFnW1wiQnl0ZXNcIl0gPSAxMF0gPSBcIkJ5dGVzXCI7XG59KShUYWcgfHwgKFRhZyA9IHt9KSk7XG5jbGFzcyBXcml0ZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5idWZmZXIubGVuZ3RoO1xuICAgIH1cbiAgICB3cml0ZUJ5dGVzKHZhbCkge1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKC4uLnZhbC5tYXAoKHYpID0+IHYgJiAweGZmKSk7XG4gICAgfVxuICAgIHdyaXRlVWludDgodmFsKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWwgfCAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKHYgJiAweGZmKTtcbiAgICB9XG4gICAgd3JpdGVVaW50MTYodmFsKSB7XG4gICAgICAgIGNvbnN0IHYgPSB2YWwgfCAwO1xuICAgICAgICB0aGlzLmJ1ZmZlci5wdXNoKCh2ID4+IDgpICYgMHhmZik7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2godiAmIDB4ZmYpO1xuICAgIH1cbiAgICB3cml0ZVVpbnQzMih2YWwpIHtcbiAgICAgICAgY29uc3QgdiA9IHZhbCB8IDA7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goKHYgPj4gMjQpICYgMHhmZik7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goKHYgPj4gMTYpICYgMHhmZik7XG4gICAgICAgIHRoaXMuYnVmZmVyLnB1c2goKHYgPj4gOCkgJiAweGZmKTtcbiAgICAgICAgdGhpcy5idWZmZXIucHVzaCh2ICYgMHhmZik7XG4gICAgfVxuICAgIHdyaXRlSW50OCh2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQ4KHZhbCk7XG4gICAgfVxuICAgIHdyaXRlSW50MTYodmFsKSB7XG4gICAgICAgIHRoaXMud3JpdGVVaW50MTYodmFsKTtcbiAgICB9XG4gICAgd3JpdGVJbnQzMih2YWwpIHtcbiAgICAgICAgdGhpcy53cml0ZVVpbnQzMih2YWwpO1xuICAgIH1cbn1cbmNvbnN0IGJvdW5kc0VyciA9IG5ldyBFcnJvcignYm91bmRzIG91dCBvZiByYW5nZScpO1xuY2xhc3MgUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihidWZmZXIsIGlkeCA9IDAsIGNhcCA9IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy5idWZmZXIgPSBidWZmZXI7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmNhcCA9IGNhcDtcbiAgICB9XG4gICAgLyoqIFJlbWFpbmluZyBsZW5ndGggKi9cbiAgICBnZXQgbGVuZ3RoKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYXAgLSB0aGlzLmlkeDtcbiAgICB9XG4gICAgcmVhZEJ5dGVzKGxlbikge1xuICAgICAgICBpZiAodGhpcy5jYXAgLSB0aGlzLmlkeCA8IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgYm91bmRzRXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IHRoaXMuYnVmZmVyLnNsaWNlKHRoaXMuaWR4LCB0aGlzLmlkeCArIGxlbik7XG4gICAgICAgIHRoaXMuaWR4ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgcmVhZGVyKGxlbikge1xuICAgICAgICBpZiAodGhpcy5jYXAgLSB0aGlzLmlkeCA8IGxlbikge1xuICAgICAgICAgICAgdGhyb3cgYm91bmRzRXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldCA9IG5ldyBSZWFkZXIodGhpcy5idWZmZXIsIHRoaXMuaWR4LCB0aGlzLmlkeCArIGxlbik7XG4gICAgICAgIHRoaXMuaWR4ICs9IGxlbjtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgY29weSgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIodGhpcy5idWZmZXIsIHRoaXMuaWR4LCB0aGlzLmNhcCk7XG4gICAgfVxuICAgIHJlYWRVaW50OCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FwIC0gdGhpcy5pZHggPCAxKSB7XG4gICAgICAgICAgICB0aHJvdyBib3VuZHNFcnI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYnVmZmVyW3RoaXMuaWR4KytdID4+PiAwO1xuICAgIH1cbiAgICByZWFkVWludDE2KCkge1xuICAgICAgICBpZiAodGhpcy5jYXAgLSB0aGlzLmlkeCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IGJvdW5kc0VycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4MCA9IHRoaXMuYnVmZmVyW3RoaXMuaWR4KytdO1xuICAgICAgICBjb25zdCB4MSA9IHRoaXMuYnVmZmVyW3RoaXMuaWR4KytdO1xuICAgICAgICByZXR1cm4gKCh4MCA8PCA4KSB8IHgxKSA+Pj4gMDtcbiAgICB9XG4gICAgcmVhZFVpbnQzMigpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FwIC0gdGhpcy5pZHggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBib3VuZHNFcnI7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeDAgPSB0aGlzLmJ1ZmZlclt0aGlzLmlkeCsrXTtcbiAgICAgICAgY29uc3QgeDEgPSB0aGlzLmJ1ZmZlclt0aGlzLmlkeCsrXTtcbiAgICAgICAgY29uc3QgeDIgPSB0aGlzLmJ1ZmZlclt0aGlzLmlkeCsrXTtcbiAgICAgICAgY29uc3QgeDMgPSB0aGlzLmJ1ZmZlclt0aGlzLmlkeCsrXTtcbiAgICAgICAgcmV0dXJuICgoeDAgPDwgMjQpIHwgKHgxIDw8IDE2KSB8ICh4MiA8PCA4KSB8IHgzKSA+Pj4gMDtcbiAgICB9XG4gICAgcmVhZEludDgoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhcCAtIHRoaXMuaWR4IDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgYm91bmRzRXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHggPSB0aGlzLmJ1ZmZlclt0aGlzLmlkeCsrXTtcbiAgICAgICAgcmV0dXJuICh4IDw8IDI0KSA+PiAyNDtcbiAgICB9XG4gICAgcmVhZEludDE2KCkge1xuICAgICAgICBpZiAodGhpcy5jYXAgLSB0aGlzLmlkeCA8IDIpIHtcbiAgICAgICAgICAgIHRocm93IGJvdW5kc0VycjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB4MCA9IHRoaXMuYnVmZmVyW3RoaXMuaWR4KytdO1xuICAgICAgICBjb25zdCB4MSA9IHRoaXMuYnVmZmVyW3RoaXMuaWR4KytdO1xuICAgICAgICByZXR1cm4gKCgoeDAgPDwgOCkgfCB4MSkgPDwgMTYpID4+IDE2O1xuICAgIH1cbiAgICByZWFkSW50MzIoKSB7XG4gICAgICAgIGlmICh0aGlzLmNhcCAtIHRoaXMuaWR4IDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgYm91bmRzRXJyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHgwID0gdGhpcy5idWZmZXJbdGhpcy5pZHgrK107XG4gICAgICAgIGNvbnN0IHgxID0gdGhpcy5idWZmZXJbdGhpcy5pZHgrK107XG4gICAgICAgIGNvbnN0IHgyID0gdGhpcy5idWZmZXJbdGhpcy5pZHgrK107XG4gICAgICAgIGNvbnN0IHgzID0gdGhpcy5idWZmZXJbdGhpcy5pZHgrK107XG4gICAgICAgIHJldHVybiAoeDAgPDwgMjQpIHwgKHgxIDw8IDE2KSB8ICh4MiA8PCA4KSB8IHgzO1xuICAgIH1cbn1cbnZhciBDb250cmFjdElEO1xuKGZ1bmN0aW9uIChDb250cmFjdElEKSB7XG4gICAgQ29udHJhY3RJRFtDb250cmFjdElEW1wiSW1wbGljaXRcIl0gPSAwXSA9IFwiSW1wbGljaXRcIjtcbiAgICBDb250cmFjdElEW0NvbnRyYWN0SURbXCJPcmlnaW5hdGVkXCJdID0gMV0gPSBcIk9yaWdpbmF0ZWRcIjtcbn0pKENvbnRyYWN0SUQgfHwgKENvbnRyYWN0SUQgPSB7fSkpO1xudmFyIFB1YmxpY0tleUhhc2hJRDtcbihmdW5jdGlvbiAoUHVibGljS2V5SGFzaElEKSB7XG4gICAgUHVibGljS2V5SGFzaElEW1B1YmxpY0tleUhhc2hJRFtcIkVEMjU1MTlcIl0gPSAwXSA9IFwiRUQyNTUxOVwiO1xuICAgIFB1YmxpY0tleUhhc2hJRFtQdWJsaWNLZXlIYXNoSURbXCJTRUNQMjU2SzFcIl0gPSAxXSA9IFwiU0VDUDI1NksxXCI7XG4gICAgUHVibGljS2V5SGFzaElEW1B1YmxpY0tleUhhc2hJRFtcIlAyNTZcIl0gPSAyXSA9IFwiUDI1NlwiO1xufSkoUHVibGljS2V5SGFzaElEIHx8IChQdWJsaWNLZXlIYXNoSUQgPSB7fSkpO1xuZnVuY3Rpb24gcmVhZFB1YmxpY0tleUhhc2gocmQpIHtcbiAgICBsZXQgdHlwZTtcbiAgICBjb25zdCB0YWcgPSByZC5yZWFkVWludDgoKTtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIFB1YmxpY0tleUhhc2hJRC5FRDI1NTE5OlxuICAgICAgICAgICAgdHlwZSA9ICdFRDI1NTE5UHVibGljS2V5SGFzaCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQdWJsaWNLZXlIYXNoSUQuU0VDUDI1NksxOlxuICAgICAgICAgICAgdHlwZSA9ICdTRUNQMjU2SzFQdWJsaWNLZXlIYXNoJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFB1YmxpY0tleUhhc2hJRC5QMjU2OlxuICAgICAgICAgICAgdHlwZSA9ICdQMjU2UHVibGljS2V5SGFzaCc7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwdWJsaWMga2V5IGhhc2ggdGFnOiAke3RhZ31gKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZSwgaGFzaDogcmQucmVhZEJ5dGVzKDIwKSB9O1xufVxuZnVuY3Rpb24gcmVhZEFkZHJlc3MocmQpIHtcbiAgICBsZXQgYWRkcmVzcztcbiAgICBjb25zdCB0YWcgPSByZC5yZWFkVWludDgoKTtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIENvbnRyYWN0SUQuSW1wbGljaXQ6XG4gICAgICAgICAgICBhZGRyZXNzID0gcmVhZFB1YmxpY0tleUhhc2gocmQpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQ29udHJhY3RJRC5PcmlnaW5hdGVkOlxuICAgICAgICAgICAgYWRkcmVzcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnQ29udHJhY3RIYXNoJyxcbiAgICAgICAgICAgICAgICBoYXNoOiByZC5yZWFkQnl0ZXMoMjApLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJkLnJlYWRCeXRlcygxKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGB1bmtub3duIGFkZHJlc3MgdGFnOiAke3RhZ31gKTtcbiAgICB9XG4gICAgaWYgKHJkLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBlbnRyeSBwb2ludFxuICAgICAgICBjb25zdCBkZWMgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgYWRkcmVzcy5lbnRyeVBvaW50ID0gZGVjLmRlY29kZShuZXcgVWludDhBcnJheShyZC5yZWFkQnl0ZXMocmQubGVuZ3RoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzcztcbn1cbmZ1bmN0aW9uIHdyaXRlUHVibGljS2V5SGFzaChhLCB3KSB7XG4gICAgbGV0IHRhZztcbiAgICBzd2l0Y2ggKGEudHlwZSkge1xuICAgICAgICBjYXNlICdFRDI1NTE5UHVibGljS2V5SGFzaCc6XG4gICAgICAgICAgICB0YWcgPSBQdWJsaWNLZXlIYXNoSUQuRUQyNTUxOTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdTRUNQMjU2SzFQdWJsaWNLZXlIYXNoJzpcbiAgICAgICAgICAgIHRhZyA9IFB1YmxpY0tleUhhc2hJRC5TRUNQMjU2SzE7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUDI1NlB1YmxpY0tleUhhc2gnOlxuICAgICAgICAgICAgdGFnID0gUHVibGljS2V5SGFzaElELlAyNTY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBhZGRyZXNzIHR5cGU6ICR7YS50eXBlfWApO1xuICAgIH1cbiAgICB3LndyaXRlVWludDgodGFnKTtcbiAgICB3LndyaXRlQnl0ZXMoQXJyYXkuZnJvbShhLmhhc2gpKTtcbn1cbmZ1bmN0aW9uIHdyaXRlQWRkcmVzcyhhLCB3KSB7XG4gICAgaWYgKGEudHlwZSA9PT0gJ0NvbnRyYWN0SGFzaCcpIHtcbiAgICAgICAgdy53cml0ZVVpbnQ4KENvbnRyYWN0SUQuT3JpZ2luYXRlZCk7XG4gICAgICAgIHcud3JpdGVCeXRlcyhBcnJheS5mcm9tKGEuaGFzaCkpO1xuICAgICAgICB3LndyaXRlVWludDgoMCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3LndyaXRlVWludDgoQ29udHJhY3RJRC5JbXBsaWNpdCk7XG4gICAgICAgIHdyaXRlUHVibGljS2V5SGFzaChhLCB3KTtcbiAgICB9XG4gICAgaWYgKGEuZW50cnlQb2ludCAhPT0gdW5kZWZpbmVkICYmIGEuZW50cnlQb2ludCAhPT0gJycgJiYgYS5lbnRyeVBvaW50ICE9PSAnZGVmYXVsdCcpIHtcbiAgICAgICAgY29uc3QgZW5jID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gZW5jLmVuY29kZShhLmVudHJ5UG9pbnQpO1xuICAgICAgICB3LndyaXRlQnl0ZXMoQXJyYXkuZnJvbShieXRlcykpO1xuICAgIH1cbn1cbnZhciBQdWJsaWNLZXlJRDtcbihmdW5jdGlvbiAoUHVibGljS2V5SUQpIHtcbiAgICBQdWJsaWNLZXlJRFtQdWJsaWNLZXlJRFtcIkVEMjU1MTlcIl0gPSAwXSA9IFwiRUQyNTUxOVwiO1xuICAgIFB1YmxpY0tleUlEW1B1YmxpY0tleUlEW1wiU0VDUDI1NksxXCJdID0gMV0gPSBcIlNFQ1AyNTZLMVwiO1xuICAgIFB1YmxpY0tleUlEW1B1YmxpY0tleUlEW1wiUDI1NlwiXSA9IDJdID0gXCJQMjU2XCI7XG59KShQdWJsaWNLZXlJRCB8fCAoUHVibGljS2V5SUQgPSB7fSkpO1xuZnVuY3Rpb24gcmVhZFB1YmxpY0tleShyZCkge1xuICAgIGxldCBsbjtcbiAgICBsZXQgdHlwZTtcbiAgICBjb25zdCB0YWcgPSByZC5yZWFkVWludDgoKTtcbiAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIFB1YmxpY0tleUlELkVEMjU1MTk6XG4gICAgICAgICAgICB0eXBlID0gJ0VEMjU1MTlQdWJsaWNLZXknO1xuICAgICAgICAgICAgbG4gPSAzMjtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFB1YmxpY0tleUlELlNFQ1AyNTZLMTpcbiAgICAgICAgICAgIHR5cGUgPSAnU0VDUDI1NksxUHVibGljS2V5JztcbiAgICAgICAgICAgIGxuID0gMzM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQdWJsaWNLZXlJRC5QMjU2OlxuICAgICAgICAgICAgdHlwZSA9ICdQMjU2UHVibGljS2V5JztcbiAgICAgICAgICAgIGxuID0gMzM7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5rbm93biBwdWJsaWMga2V5IHRhZzogJHt0YWd9YCk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGUsIHB1YmxpY0tleTogcmQucmVhZEJ5dGVzKGxuKSB9O1xufVxuZnVuY3Rpb24gd3JpdGVQdWJsaWNLZXkocGssIHcpIHtcbiAgICBsZXQgdGFnO1xuICAgIHN3aXRjaCAocGsudHlwZSkge1xuICAgICAgICBjYXNlICdFRDI1NTE5UHVibGljS2V5JzpcbiAgICAgICAgICAgIHRhZyA9IFB1YmxpY0tleUlELkVEMjU1MTk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnU0VDUDI1NksxUHVibGljS2V5JzpcbiAgICAgICAgICAgIHRhZyA9IFB1YmxpY0tleUlELlNFQ1AyNTZLMTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdQMjU2UHVibGljS2V5JzpcbiAgICAgICAgICAgIHRhZyA9IFB1YmxpY0tleUlELlAyNTY7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgdW5leHBlY3RlZCBwdWJsaWMga2V5IHR5cGU6ICR7cGsudHlwZX1gKTtcbiAgICB9XG4gICAgdy53cml0ZVVpbnQ4KHRhZyk7XG4gICAgdy53cml0ZUJ5dGVzKEFycmF5LmZyb20ocGsucHVibGljS2V5KSk7XG59XG5mdW5jdGlvbiB3cml0ZUV4cHIoZXhwciwgd3IsIHRmKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICBjb25zdCBbZSwgYXJnc10gPSB0ZihleHByKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShlKSkge1xuICAgICAgICBjb25zdCB3ID0gbmV3IFdyaXRlcigpO1xuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgZSkge1xuICAgICAgICAgICAgY29uc3QgYSA9IGFyZ3MubmV4dCgpO1xuICAgICAgICAgICAgaWYgKGEuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUkVQT1JUIE1FOiBpdGVyYXRvciBpcyBkb25lJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3cml0ZUV4cHIodiwgdywgYS52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgd3Iud3JpdGVVaW50OChUYWcuU2VxdWVuY2UpO1xuICAgICAgICB3ci53cml0ZVVpbnQzMih3Lmxlbmd0aCk7XG4gICAgICAgIHdyLndyaXRlQnl0ZXMody5idWZmZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICgnc3RyaW5nJyBpbiBlKSB7XG4gICAgICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuYy5lbmNvZGUoZS5zdHJpbmcpO1xuICAgICAgICB3ci53cml0ZVVpbnQ4KFRhZy5TdHJpbmcpO1xuICAgICAgICB3ci53cml0ZVVpbnQzMihieXRlcy5sZW5ndGgpO1xuICAgICAgICB3ci53cml0ZUJ5dGVzKEFycmF5LmZyb20oYnl0ZXMpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJ2ludCcgaW4gZSkge1xuICAgICAgICB3ci53cml0ZVVpbnQ4KFRhZy5JbnQpO1xuICAgICAgICBsZXQgdmFsID0gQmlnSW50KGUuaW50KTtcbiAgICAgICAgY29uc3Qgc2lnbiA9IHZhbCA8IDA7XG4gICAgICAgIGlmIChzaWduKSB7XG4gICAgICAgICAgICB2YWwgPSAtdmFsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgICAgY29uc3QgYml0cyA9IGkgPT09IDAgPyBCaWdJbnQoNikgOiBCaWdJbnQoNyk7XG4gICAgICAgICAgICBsZXQgYnl0ZSA9IHZhbCAmICgoQmlnSW50KDEpIDw8IGJpdHMpIC0gQmlnSW50KDEpKTtcbiAgICAgICAgICAgIHZhbCA+Pj0gYml0cztcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBieXRlIHw9IEJpZ0ludCgweDgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAwICYmIHNpZ24pIHtcbiAgICAgICAgICAgICAgICBieXRlIHw9IEJpZ0ludCgweDQwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdyLndyaXRlVWludDgoTnVtYmVyKGJ5dGUpKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfSB3aGlsZSAodmFsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoJ2J5dGVzJyBpbiBlKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gcGFyc2VIZXgoZS5ieXRlcyk7XG4gICAgICAgIHdyLndyaXRlVWludDgoVGFnLkJ5dGVzKTtcbiAgICAgICAgd3Iud3JpdGVVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgd3Iud3JpdGVCeXRlcyhieXRlcyk7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcHJpbSA9IHByaW1UYWdzW2UucHJpbV07XG4gICAgaWYgKHByaW0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBDYW4ndCBlbmNvZGUgcHJpbWFyeTogJHtlLnByaW19YCk7XG4gICAgfVxuICAgIGNvbnN0IHRhZyA9ICgoKF9hID0gZS5hcmdzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB8fCAwKSA8IDNcbiAgICAgICAgPyBUYWcuUHJpbTAgK1xuICAgICAgICAgICAgKCgoX2IgPSBlLmFyZ3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5sZW5ndGgpIHx8IDApICogMiArXG4gICAgICAgICAgICAoZS5hbm5vdHMgPT09IHVuZGVmaW5lZCB8fCBlLmFubm90cy5sZW5ndGggPT09IDAgPyAwIDogMSlcbiAgICAgICAgOiBUYWcuUHJpbTtcbiAgICB3ci53cml0ZVVpbnQ4KHRhZyk7XG4gICAgd3Iud3JpdGVVaW50OChwcmltKTtcbiAgICBpZiAoZS5hcmdzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGUuYXJncy5sZW5ndGggPCAzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGFyZ3MubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChhLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSRVBPUlQgTUU6IGl0ZXJhdG9yIGlzIGRvbmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVFeHByKHYsIHdyLCBhLnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSBuZXcgV3JpdGVyKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHYgb2YgZS5hcmdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYSA9IGFyZ3MubmV4dCgpO1xuICAgICAgICAgICAgICAgIGlmIChhLmRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSRVBPUlQgTUU6IGl0ZXJhdG9yIGlzIGRvbmUnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd3JpdGVFeHByKHYsIHcsIGEudmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd3Iud3JpdGVVaW50MzIody5sZW5ndGgpO1xuICAgICAgICAgICAgd3Iud3JpdGVCeXRlcyh3LmJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGUuYW5ub3RzICE9PSB1bmRlZmluZWQgJiYgZS5hbm5vdHMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGVuYyA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICAgICAgICBjb25zdCBieXRlcyA9IGVuYy5lbmNvZGUoZS5hbm5vdHMuam9pbignICcpKTtcbiAgICAgICAgd3Iud3JpdGVVaW50MzIoYnl0ZXMubGVuZ3RoKTtcbiAgICAgICAgd3Iud3JpdGVCeXRlcyhBcnJheS5mcm9tKGJ5dGVzKSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGUuYXJncyAhPT0gdW5kZWZpbmVkICYmIGUuYXJncy5sZW5ndGggPj0gMykge1xuICAgICAgICB3ci53cml0ZVVpbnQzMigwKTtcbiAgICB9XG59XG5mdW5jdGlvbiByZWFkRXhwcihyZCwgdGYpIHtcbiAgICBmdW5jdGlvbiogcGFzc1Rocm91Z2goKSB7XG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICB5aWVsZCByZWFkUGFzc1Rocm91Z2g7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgW2FyZ3MsIHRyXSA9IHRmO1xuICAgIGNvbnN0IHRhZyA9IHJkLnJlYWRVaW50OCgpO1xuICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgVGFnLkludDoge1xuICAgICAgICAgICAgY29uc3QgYnVmID0gW107XG4gICAgICAgICAgICBsZXQgYnl0ZTtcbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICBieXRlID0gcmQucmVhZEludDgoKTtcbiAgICAgICAgICAgICAgICBidWYucHVzaChieXRlKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKChieXRlICYgMHg4MCkgIT09IDApO1xuICAgICAgICAgICAgbGV0IHZhbCA9IEJpZ0ludCgwKTtcbiAgICAgICAgICAgIGxldCBzaWduID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gYnVmLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYml0cyA9IGkgPT09IDAgPyBCaWdJbnQoNikgOiBCaWdJbnQoNyk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnl0ZSA9IEJpZ0ludChidWZbaV0pO1xuICAgICAgICAgICAgICAgIHZhbCA8PD0gYml0cztcbiAgICAgICAgICAgICAgICB2YWwgfD0gYnl0ZSAmICgoQmlnSW50KDEpIDw8IGJpdHMpIC0gQmlnSW50KDEpKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWduID0gISEoYnl0ZSAmIEJpZ0ludCgweDQwKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNpZ24pIHtcbiAgICAgICAgICAgICAgICB2YWwgPSAtdmFsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRyKHsgaW50OiBTdHJpbmcodmFsKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRhZy5TdHJpbmc6IHtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHJkLnJlYWRVaW50MzIoKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcmQucmVhZEJ5dGVzKGxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBkZWMgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgICAgICAgICAgIHJldHVybiB0cih7IHN0cmluZzogZGVjLmRlY29kZShuZXcgVWludDhBcnJheShieXRlcykpIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgVGFnLkJ5dGVzOiB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSByZC5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IHJkLnJlYWRCeXRlcyhsZW5ndGgpO1xuICAgICAgICAgICAgY29uc3QgaGV4ID0gaGV4Qnl0ZXMoQXJyYXkuZnJvbShieXRlcykpO1xuICAgICAgICAgICAgcmV0dXJuIHRyKHsgYnl0ZXM6IGhleCB9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFRhZy5TZXF1ZW5jZToge1xuICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcmQucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgbGV0IHJlcyA9IFtdO1xuICAgICAgICAgICAgbGV0IHNhdmVkcmQgPSByZC5jb3B5KCk7XG4gICAgICAgICAgICAvLyBtYWtlIHR3byBwYXNzZXNcbiAgICAgICAgICAgIGxldCBpdCA9IHBhc3NUaHJvdWdoKCk7XG4gICAgICAgICAgICBmb3IgKGxldCBuID0gMDsgbiA8IDI7IG4rKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBzYXZlZHJkLnJlYWRlcihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIHJlcyA9IFtdO1xuICAgICAgICAgICAgICAgIHdoaWxlIChyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYSA9IGl0Lm5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSRVBPUlQgTUU6IGl0ZXJhdG9yIGlzIGRvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXMucHVzaChyZWFkRXhwcihyLCBhLnZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIG1ha2UgYSBzZWNvbmQgcGFzcyB3aXRoIGluamVjdGVkIHNpZGUgZWZmZWN0c1xuICAgICAgICAgICAgICAgIGl0ID0gYXJncyhyZXMpO1xuICAgICAgICAgICAgICAgIHNhdmVkcmQgPSByZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cihyZXMpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGlmICh0YWcgPiA5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHRhZzogJHt0YWd9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwID0gcmQucmVhZFVpbnQ4KCk7XG4gICAgICAgICAgICBpZiAocCA+PSBwcmltaXRpdmVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwcmltaXRpdmUgdGFnOiAke3B9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmltID0gcHJpbWl0aXZlc1twXTtcbiAgICAgICAgICAgIGNvbnN0IGFyZ24gPSAodGFnIC0gMykgPj4gMTtcbiAgICAgICAgICAgIGxldCByZXMgPSB7IHByaW0gfTtcbiAgICAgICAgICAgIC8vIG1ha2UgdHdvIHBhc3Nlc1xuICAgICAgICAgICAgbGV0IGl0ID0gcGFzc1Rocm91Z2goKTtcbiAgICAgICAgICAgIGxldCBzYXZlZHJkID0gcmQuY29weSgpO1xuICAgICAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCAyOyBuKyspIHtcbiAgICAgICAgICAgICAgICByZXMgPSB7IHByaW0gfTtcbiAgICAgICAgICAgICAgICBpZiAoYXJnbiA8IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcmduOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGEgPSBpdC5uZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYS5kb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSRVBPUlQgTUU6IGl0ZXJhdG9yIGlzIGRvbmUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5hcmdzID0gcmVzLmFyZ3MgfHwgW107XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuYXJncy5wdXNoKHJlYWRFeHByKHNhdmVkcmQsIGEudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmFyZ3MgPSByZXMuYXJncyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gc2F2ZWRyZC5yZWFkVWludDMyKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHIgPSBzYXZlZHJkLnJlYWRlcihsZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoci5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhID0gaXQubmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGEuZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUkVQT1JUIE1FOiBpdGVyYXRvciBpcyBkb25lJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuYXJncy5wdXNoKHJlYWRFeHByKHIsIGEudmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBtYWtlIGEgc2Vjb25kIHBhc3Mgd2l0aCBpbmplY3RlZCBzaWRlIGVmZmVjdHNcbiAgICAgICAgICAgICAgICBpdCA9IGFyZ3MocmVzKTtcbiAgICAgICAgICAgICAgICBzYXZlZHJkID0gcmQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKCh0YWcgLSAzKSAmIDEpID09PSAxIHx8IGFyZ24gPT09IDMpIHtcbiAgICAgICAgICAgICAgICAvLyByZWFkIGFubm90YXRpb25zXG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcmQucmVhZFVpbnQzMigpO1xuICAgICAgICAgICAgICAgIGlmIChsZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSByZC5yZWFkQnl0ZXMobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVjID0gbmV3IFRleHREZWNvZGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5hbm5vdHMgPSBkZWMuZGVjb2RlKG5ldyBVaW50OEFycmF5KGJ5dGVzKSkuc3BsaXQoJyAnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHIocmVzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmNvbnN0IGlzT3JEYXRhID0gKGUpID0+ICdwcmltJyBpbiBlICYmIChlLnByaW0gPT09ICdMZWZ0JyB8fCBlLnByaW0gPT09ICdSaWdodCcpO1xuY29uc3QgaXNPcHRpb25EYXRhID0gKGUpID0+ICdwcmltJyBpbiBlICYmIChlLnByaW0gPT09ICdTb21lJyB8fCBlLnByaW0gPT09ICdOb25lJyk7XG5jb25zdCBnZXRXcml0ZVRyYW5zZm9ybUZ1bmMgPSAodCkgPT4ge1xuICAgIGlmIChpc1BhaXJUeXBlKHQpKSB7XG4gICAgICAgIHJldHVybiAoZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFpc1BhaXJEYXRhKGQpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgcGFpciBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGFzc2VydERhdGFMaXN0SWZBbnkoZCk7XG4gICAgICAgICAgICAvLyBjb21icyBhcmVuJ3QgdXNlZCBpbiBwYWNrIGZvcm1hdFxuICAgICAgICAgICAgY29uc3QgdGMgPSB1bnBhY2tDb21iKCdwYWlyJywgdCk7XG4gICAgICAgICAgICBjb25zdCBkYyA9IHVucGFja0NvbWIoJ1BhaXInLCBkKTtcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgZGMsXG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiB0Yy5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBnZXRXcml0ZVRyYW5zZm9ybUZ1bmMoYSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgc3dpdGNoICh0LnByaW0pIHtcbiAgICAgICAgY2FzZSAnb3InOlxuICAgICAgICAgICAgcmV0dXJuIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc09yRGF0YShkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBvciBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBnZXRXcml0ZVRyYW5zZm9ybUZ1bmModC5hcmdzW2QucHJpbSA9PT0gJ0xlZnQnID8gMCA6IDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnb3B0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiAoZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghaXNPcHRpb25EYXRhKGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYG9wdGlvbiBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgZCxcbiAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkZCA9IGQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiByZWZhY3RvciBhbmQgcmVtb3ZlIHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9iYW4tdHMtY29tbWVudFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRkLnByaW0gPT09ICdTb21lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGdldFdyaXRlVHJhbnNmb3JtRnVuYyh0LmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgIHJldHVybiAoZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShkKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGAke3QucHJpbX0gZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGQsXG4gICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBfdiBvZiBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZ2V0V3JpdGVUcmFuc2Zvcm1GdW5jKHQuYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgICAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgbWFwIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBkLFxuICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgX2VsdCBvZiBkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgKGVsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoISgncHJpbScgaW4gZWx0KSB8fCBlbHQucHJpbSAhPT0gJ0VsdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYG1hcCBlbGVtZW50IGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGVsdCl9YCwgZWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhIG9mIHQuYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBnZXRXcml0ZVRyYW5zZm9ybUZ1bmMoYSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdjaGFpbl9pZCc6XG4gICAgICAgICAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoISgnYnl0ZXMnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgY2hhaW4gaWQgZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgaW4gZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpZCA9IGNoZWNrRGVjb2RlVGV6b3NJRChkLnN0cmluZywgJ0NoYWluSUQnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBjaGFpbiBpZCBiYXNlNTggZXhwZWN0ZWQ6ICR7ZC5zdHJpbmd9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSB7IGJ5dGVzOiBoZXhCeXRlcyhpZFsxXSkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtieXRlcywgW11bU3ltYm9sLml0ZXJhdG9yXSgpXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3NpZ25hdHVyZSc6XG4gICAgICAgICAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoISgnYnl0ZXMnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgc2lnbmF0dXJlIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYnl0ZXM7XG4gICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnIGluIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2lnID0gY2hlY2tEZWNvZGVUZXpvc0lEKGQuc3RyaW5nLCAnRUQyNTUxOVNpZ25hdHVyZScsICdTRUNQMjU2SzFTaWduYXR1cmUnLCAnUDI1NlNpZ25hdHVyZScsICdHZW5lcmljU2lnbmF0dXJlJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaWcgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYHNpZ25hdHVyZSBiYXNlNTggZXhwZWN0ZWQ6ICR7ZC5zdHJpbmd9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSB7IGJ5dGVzOiBoZXhCeXRlcyhzaWdbMV0pIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbYnl0ZXMsIFtdW1N5bWJvbC5pdGVyYXRvcl0oKV07XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlICdrZXlfaGFzaCc6XG4gICAgICAgICAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoISgnYnl0ZXMnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBga2V5IGhhc2ggZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBieXRlcztcbiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgaW4gZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwa2ggPSBjaGVja0RlY29kZVRlem9zSUQoZC5zdHJpbmcsICdFRDI1NTE5UHVibGljS2V5SGFzaCcsICdTRUNQMjU2SzFQdWJsaWNLZXlIYXNoJywgJ1AyNTZQdWJsaWNLZXlIYXNoJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwa2ggPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYGtleSBoYXNoIGJhc2U1OCBleHBlY3RlZDogJHtkLnN0cmluZ31gLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB3ID0gbmV3IFdyaXRlcigpO1xuICAgICAgICAgICAgICAgICAgICB3cml0ZVB1YmxpY0tleUhhc2goeyB0eXBlOiBwa2hbMF0sIGhhc2g6IHBraFsxXSB9LCB3KTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSB7IGJ5dGVzOiBoZXhCeXRlcyh3LmJ1ZmZlcikgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtieXRlcywgW11bU3ltYm9sLml0ZXJhdG9yXSgpXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgICAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoISgnYnl0ZXMnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgcHVibGljIGtleSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyBpbiBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IGNoZWNrRGVjb2RlVGV6b3NJRChkLnN0cmluZywgJ0VEMjU1MTlQdWJsaWNLZXknLCAnU0VDUDI1NksxUHVibGljS2V5JywgJ1AyNTZQdWJsaWNLZXknKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGtleSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgcHVibGljIGtleSBiYXNlNTggZXhwZWN0ZWQ6ICR7ZC5zdHJpbmd9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdyA9IG5ldyBXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVQdWJsaWNLZXkoeyB0eXBlOiBrZXlbMF0sIHB1YmxpY0tleToga2V5WzFdIH0sIHcpO1xuICAgICAgICAgICAgICAgICAgICBieXRlcyA9IHsgYnl0ZXM6IGhleEJ5dGVzKHcuYnVmZmVyKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSBkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW2J5dGVzLCBbXVtTeW1ib2wuaXRlcmF0b3JdKCldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSAnYWRkcmVzcyc6XG4gICAgICAgICAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoISgnYnl0ZXMnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgYWRkcmVzcyBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJ5dGVzO1xuICAgICAgICAgICAgICAgIGlmICgnc3RyaW5nJyBpbiBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBkLnN0cmluZy5zcGxpdCgnJScpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gY2hlY2tEZWNvZGVUZXpvc0lEKHNbMF0sICdFRDI1NTE5UHVibGljS2V5SGFzaCcsICdTRUNQMjU2SzFQdWJsaWNLZXlIYXNoJywgJ1AyNTZQdWJsaWNLZXlIYXNoJywgJ0NvbnRyYWN0SGFzaCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYWRkcmVzcyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgYWRkcmVzcyBiYXNlNTggZXhwZWN0ZWQ6ICR7ZC5zdHJpbmd9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdyA9IG5ldyBXcml0ZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgd3JpdGVBZGRyZXNzKHsgdHlwZTogYWRkcmVzc1swXSwgaGFzaDogYWRkcmVzc1sxXSwgZW50cnlQb2ludDogcy5sZW5ndGggPiAxID8gc1sxXSA6IHVuZGVmaW5lZCB9LCB3KTtcbiAgICAgICAgICAgICAgICAgICAgYnl0ZXMgPSB7IGJ5dGVzOiBoZXhCeXRlcyh3LmJ1ZmZlcikgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzID0gZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtieXRlcywgW11bU3ltYm9sLml0ZXJhdG9yXSgpXTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgICAgICByZXR1cm4gKGQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoISgnc3RyaW5nJyBpbiBkKSAmJiAhKCdpbnQnIGluIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYHRpbWVzdGFtcCBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGludDtcbiAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgaW4gZCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwID0gcGFyc2VEYXRlKGQpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgY2FuJ3QgcGFyc2UgZGF0ZTogJHtkLnN0cmluZ31gLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbnQgPSB7IGludDogU3RyaW5nKE1hdGguZmxvb3IocC5nZXRUaW1lKCkgLyAxMDAwKSkgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGludCA9IGQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbaW50LCBbXVtTeW1ib2wuaXRlcmF0b3JdKCldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiB3cml0ZVBhc3NUaHJvdWdoO1xuICAgIH1cbn07XG5jb25zdCBpc1B1c2hJbnN0cnVjdGlvbiA9IChlKSA9PiAncHJpbScgaW4gZSAmJiBlLnByaW0gPT09ICdQVVNIJztcbmNvbnN0IHdyaXRlUGFzc1Rocm91Z2ggPSAoZSkgPT4ge1xuICAgIGlmIChpc1B1c2hJbnN0cnVjdGlvbihlKSkge1xuICAgICAgICBhc3NlcnRNaWNoZWxzb25JbnN0cnVjdGlvbihlKTtcbiAgICAgICAgLy8gY2FwdHVyZSBpbmxpbmVkIHR5cGUgZGVmaW5pdGlvblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgZSxcbiAgICAgICAgICAgIChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHdyaXRlUGFzc1Rocm91Z2g7XG4gICAgICAgICAgICAgICAgeWllbGQgZ2V0V3JpdGVUcmFuc2Zvcm1GdW5jKGUuYXJnc1swXSk7XG4gICAgICAgICAgICB9KSgpLFxuICAgICAgICBdO1xuICAgIH1cbiAgICByZXR1cm4gW1xuICAgICAgICBlLFxuICAgICAgICAoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgd3JpdGVQYXNzVGhyb3VnaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKSxcbiAgICBdO1xufTtcbi8qKlxuICogU2VyaWFsaXplcyBhbnkgdmFsdWUgb2YgcGFja2FibGUgdHlwZSB0byBpdHMgb3B0aW1pemVkIGJpbmFyeSByZXByZXNlbnRhdGlvblxuICogaWRlbnRpY2FsIHRvIHRoZSBvbmUgdXNlZCBieSBQQUNLIGFuZCBVTlBBQ0sgTWljaGVsc29uIGluc3RydWN0aW9ucy5cbiAqIFdpdGhvdXQgYSB0eXBlIGRlZmluaXRpb24gKG5vdCByZWNvbW1lbmRlZCkgdGhlIGRhdGEgd2lsbCBiZSBlbmNvZGVkIGFzIGEgYmluYXJ5IGZvcm0gb2YgYSBnZW5lcmljIE1pY2hlbHNvbiBleHByZXNzaW9uLlxuICogVHlwZSBkZWZpbml0aW9uIGFsbG93cyBzb21lIHR5cGVzIGxpa2UgYHRpbWVzdGFtcGAgYW5kIGBhZGRyZXNzYCBhbmQgb3RoZXIgYmFzZTU4IHJlcHJlc2VudGFibGUgdHlwZXMgdG8gYmUgZW5jb2RlZCB0b1xuICogY29ycmVzcG9uZGluZyBvcHRpbWl6ZWQgYmluYXJ5IGZvcm1zIGJvcnJvd2VkIGZyb20gdGhlIFRlem9zIHByb3RvY29sXG4gKlxuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZGF0YTogTWljaGVsc29uRGF0YSA9IHtcbiAqICAgICBzdHJpbmc6IFwiS1QxUnZrd0Y0RjdwejFnQ294a3lackcxUmtyeFF5M2dtRlR2JWZvb1wiXG4gKiB9O1xuICpcbiAqIGNvbnN0IHR5cDogTWljaGVsc29uVHlwZSA9IHtcbiAqICAgICBwcmltOiBcImFkZHJlc3NcIlxuICogfTtcbiAqXG4gKiBjb25zdCBwYWNrZWQgPSBwYWNrRGF0YShkYXRhLCB0eXApO1xuICpcbiAqIC8vIDA1MGEwMDAwMDAxOTAxYmU0MWVlOTIyZGRkMmNmMzMyMDFlNDlkMzJkYTBhZmVjNTcxZGNlMzAwNjY2ZjZmXG4gKiBgYGBcbiAqXG4gKiBXaXRob3V0IGEgdHlwZSBkZWZpbml0aW9uIHRoZSBiYXNlNTggZW5jb2RlZCBhZGRyZXNzIHdpbGwgYmUgdHJlYXRlZCBhcyBhIHN0cmluZ1xuICogYGBgdHlwZXNjcmlwdFxuICogY29uc3QgZGF0YTogTWljaGVsc29uRGF0YSA9IHtcbiAqICAgICBzdHJpbmc6IFwiS1QxUnZrd0Y0RjdwejFnQ294a3lackcxUmtyeFF5M2dtRlR2JWZvb1wiXG4gKiB9O1xuICpcbiAqIGNvbnN0IHBhY2tlZCA9IHBhY2tEYXRhKGRhdGEpO1xuICpcbiAqIC8vIDA1MDEwMDAwMDAyODRiNTQzMTUyNzY2Yjc3NDYzNDQ2Mzc3MDdhMzE2NzQzNmY3ODZiNzk1YTcyNDczMTUyNmI3Mjc4NTE3OTMzNjc2ZDQ2NTQ3NjI1NjY2ZjZmXG4gKiBgYGBcbiAqIEBwYXJhbSBkIERhdGEgb2JqZWN0XG4gKiBAcGFyYW0gdCBPcHRpb25hbCB0eXBlIGRlZmluaXRpb25cbiAqIEByZXR1cm5zIEJpbmFyeSByZXByZXNlbnRhdGlvbiBhcyBudW1lcmljIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHBhY2tEYXRhKGQsIHQpIHtcbiAgICBjb25zdCB3ID0gbmV3IFdyaXRlcigpO1xuICAgIHcud3JpdGVVaW50OCg1KTtcbiAgICB3cml0ZUV4cHIoZCwgdywgdCAhPT0gdW5kZWZpbmVkID8gZ2V0V3JpdGVUcmFuc2Zvcm1GdW5jKHQpIDogd3JpdGVQYXNzVGhyb3VnaCk7XG4gICAgcmV0dXJuIHcuYnVmZmVyO1xufVxuLyoqXG4gKiBTZXJpYWxpemVzIGFueSB2YWx1ZSBvZiBwYWNrYWJsZSB0eXBlIHRvIGl0cyBvcHRpbWl6ZWQgYmluYXJ5IHJlcHJlc2VudGF0aW9uXG4gKiBpZGVudGljYWwgdG8gdGhlIG9uZSB1c2VkIGJ5IFBBQ0sgYW5kIFVOUEFDSyBNaWNoZWxzb24gaW5zdHJ1Y3Rpb25zLlxuICogU2FtZSBhcyB7QGxpbmsgcGFja0RhdGF9IGJ1dCByZXR1cm5zIGEgYGJ5dGVzYCBNaWNoZWxzb24gZGF0YSBsaXRlcmFsIGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBkYXRhOiBNaWNoZWxzb25EYXRhID0ge1xuICogICAgIHN0cmluZzogXCIyMDE5LTA5LTI2VDEwOjU5OjUxWlwiXG4gKiB9O1xuICpcbiAqIGNvbnN0IHR5cDogTWljaGVsc29uVHlwZSA9IHtcbiAqICAgICBwcmltOiBcInRpbWVzdGFtcFwiXG4gKiB9O1xuICpcbiAqIGNvbnN0IHBhY2tlZCA9IHBhY2tEYXRhQnl0ZXMoZGF0YSwgdHlwKTtcbiAqXG4gKiAvLyB7IGJ5dGVzOiBcIjA1MDBhN2U4ZTRkODBiXCIgfVxuICogYGBgXG4gKiBAcGFyYW0gZCBEYXRhIG9iamVjdFxuICogQHBhcmFtIHQgT3B0aW9uYWwgdHlwZSBkZWZpbml0aW9uXG4gKiBAcmV0dXJucyBCaW5hcnkgcmVwcmVzZW50YXRpb24gYXMgYSBieXRlcyBsaXRlcmFsXG4gKi9cbmZ1bmN0aW9uIHBhY2tEYXRhQnl0ZXMoZCwgdCkge1xuICAgIHJldHVybiB7IGJ5dGVzOiBoZXhCeXRlcyhwYWNrRGF0YShkLCB0KSkgfTtcbn1cbmNvbnN0IGdldFJlYWRUcmFuc2Zvcm1GdW5jcyA9ICh0KSA9PiB7XG4gICAgaWYgKGlzUGFpclR5cGUodCkpIHtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1BhaXJEYXRhKGQpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYHBhaXIgZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHRjID0gdW5wYWNrQ29tYigncGFpcicsIHQpO1xuICAgICAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBhIG9mIHRjLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGdldFJlYWRUcmFuc2Zvcm1GdW5jcyhhKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgKGQpID0+IGQsXG4gICAgICAgIF07XG4gICAgfVxuICAgIHN3aXRjaCAodC5wcmltKSB7XG4gICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFpc09yRGF0YShkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgb3IgZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgZ2V0UmVhZFRyYW5zZm9ybUZ1bmNzKHQuYXJnc1tkLnByaW0gPT09ICdMZWZ0JyA/IDAgOiAxXSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKCk7XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAoZCkgPT4gZCxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXNPcHRpb25EYXRhKGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBvcHRpb24gZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogcmVmYWN0b3IgYW5kIHJlbW92ZSB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkLnByaW0gPT09ICdTb21lJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGdldFJlYWRUcmFuc2Zvcm1GdW5jcyh0LmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGQpID0+IGQsXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlICdsaXN0JzpcbiAgICAgICAgY2FzZSAnc2V0JzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGAke3QucHJpbX0gZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBnZXRSZWFkVHJhbnNmb3JtRnVuY3ModC5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChkKSA9PiBkLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSAnbWFwJzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBtYXAgZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKCdwcmltJyBpbiBlbHQpIHx8IGVsdC5wcmltICE9PSAnRWx0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYG1hcCBlbGVtZW50IGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGVsdCl9YCwgZWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGEgb2YgdC5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIGdldFJlYWRUcmFuc2Zvcm1GdW5jcyhhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZWx0KSA9PiBlbHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIChkKSA9PiBkLFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSAnY2hhaW5faWQnOlxuICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAoKSA9PiBbXVtTeW1ib2wuaXRlcmF0b3JdKCksXG4gICAgICAgICAgICAgICAgKGQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ2J5dGVzJyBpbiBkKSAmJiAhKCdzdHJpbmcnIGluIGQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBjaGFpbiBpZCBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgaW4gZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBwYXJzZUJ5dGVzKGQuYnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYGNhbid0IHBhcnNlIGJ5dGVzOiAke2QuYnl0ZXN9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RyaW5nOiBlbmNvZGVUZXpvc0lEKCdDaGFpbklEJywgYnl0ZXMpIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgJ3NpZ25hdHVyZSc6XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICgpID0+IFtdW1N5bWJvbC5pdGVyYXRvcl0oKSxcbiAgICAgICAgICAgICAgICAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgnYnl0ZXMnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYHNpZ25hdHVyZSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgaW4gZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBwYXJzZUJ5dGVzKGQuYnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYGNhbid0IHBhcnNlIGJ5dGVzOiAke2QuYnl0ZXN9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgc3RyaW5nOiBlbmNvZGVUZXpvc0lEKCdHZW5lcmljU2lnbmF0dXJlJywgYnl0ZXMpIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgJ2tleV9oYXNoJzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKCkgPT4gW11bU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICAgICAgICAgIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKCdieXRlcycgaW4gZCkgJiYgISgnc3RyaW5nJyBpbiBkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBga2V5IGhhc2ggZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnIGluIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcGFyc2VCeXRlcyhkLmJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBjYW4ndCBwYXJzZSBieXRlczogJHtkLmJ5dGVzfWAsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJkID0gbmV3IFJlYWRlcihuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhZGRyID0gcmVhZFB1YmxpY0tleUhhc2gocmQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nOiBlbmNvZGVUZXpvc0lEKGFkZHIudHlwZSwgYWRkci5oYXNoKSArIChhZGRyLmVudHJ5UG9pbnQgPyAnJScgKyBhZGRyLmVudHJ5UG9pbnQgOiAnJyksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIF07XG4gICAgICAgIGNhc2UgJ2tleSc6XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICgpID0+IFtdW1N5bWJvbC5pdGVyYXRvcl0oKSxcbiAgICAgICAgICAgICAgICAoZCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoISgnYnl0ZXMnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYHB1YmxpYyBrZXkgZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnIGluIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gcGFyc2VCeXRlcyhkLmJ5dGVzKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJ5dGVzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBjYW4ndCBwYXJzZSBieXRlczogJHtkLmJ5dGVzfWAsIGQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJkID0gbmV3IFJlYWRlcihuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwayA9IHJlYWRQdWJsaWNLZXkocmQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBzdHJpbmc6IGVuY29kZVRlem9zSUQocGsudHlwZSwgcGsucHVibGljS2V5KSB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKCkgPT4gW11bU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICAgICAgICAgIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKCdieXRlcycgaW4gZCkgJiYgISgnc3RyaW5nJyBpbiBkKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgYWRkcmVzcyBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoJ3N0cmluZycgaW4gZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBwYXJzZUJ5dGVzKGQuYnl0ZXMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYGNhbid0IHBhcnNlIGJ5dGVzOiAke2QuYnl0ZXN9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmQgPSBuZXcgUmVhZGVyKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHIgPSByZWFkQWRkcmVzcyhyZCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmc6IGVuY29kZVRlem9zSUQoYWRkci50eXBlLCBhZGRyLmhhc2gpICsgKGFkZHIuZW50cnlQb2ludCA/ICclJyArIGFkZHIuZW50cnlQb2ludCA6ICcnKSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXTtcbiAgICAgICAgY2FzZSAndGltZXN0YW1wJzpcbiAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgKCkgPT4gW11bU3ltYm9sLml0ZXJhdG9yXSgpLFxuICAgICAgICAgICAgICAgIChkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKCdpbnQnIGluIGQpICYmICEoJ3N0cmluZycgaW4gZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYGFkZHJlc3MgZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCdzdHJpbmcnIGluIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBuZXcgRGF0ZShwYXJzZUludChkLmludCwgMTApICogMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IHN0cmluZzogZGF0ZS50b0lTT1N0cmluZygpLnNsaWNlKDAsIDE5KSArICdaJyB9O1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBdO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIHJlYWRQYXNzVGhyb3VnaDtcbiAgICB9XG59O1xuY29uc3QgcmVhZFBhc3NUaHJvdWdoID0gW1xuICAgIChlKSA9PiB7XG4gICAgICAgIGlmIChpc1B1c2hJbnN0cnVjdGlvbihlKSkge1xuICAgICAgICAgICAgYXNzZXJ0TWljaGVsc29uSW5zdHJ1Y3Rpb24oZSk7XG4gICAgICAgICAgICAvLyBjYXB0dXJlIGlubGluZWQgdHlwZSBkZWZpbml0aW9uXG4gICAgICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgcmVhZFBhc3NUaHJvdWdoO1xuICAgICAgICAgICAgICAgIHlpZWxkIGdldFJlYWRUcmFuc2Zvcm1GdW5jcyhlLmFyZ3NbMF0pO1xuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIHlpZWxkIHJlYWRQYXNzVGhyb3VnaDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICB9LFxuICAgIChlKSA9PiBlLFxuXTtcbi8qKlxuICogRGVzZXJpYWxpemUgYSBieXRlIGFycmF5IGludG8gdGhlIGNvcnJlc3BvbmRpbmcgTWljaGVsc29uIHZhbHVlLlxuICogV2l0aG91dCBhIHR5cGUgZGVmaW5pdGlvbiAobm90IHJlY29tbWVuZGVkKSB0aGUgYmluYXJ5IGRhdGEgd2lsbCBiZSB0cmVhdGVkIGFzIGEgYmluYXJ5IGZvcm0gb2YgYSBnZW5lcmljIE1pY2hlbHNvbiBleHByZXNzaW9uIGFuZCByZXR1cm5lZCBhcyBpcy5cbiAqIFR5cGUgZGVmaW5pdGlvbiBhbGxvd3Mgc29tZSB0eXBlcyBsaWtlIGB0aW1lc3RhbXBgIGFuZCBgYWRkcmVzc2AgYW5kIG90aGVyIHR5cGVzIHVzdWFsbHkgZW5jb2RlZCBpbiBvcHRpbWl6ZWQgYmluYXJ5IGZvcm1zIHRvIGJlIHRyYW5zZm9ybWVkXG4gKiBiYWNrIHRvIHRoZWlyIHN0cmluZyByZXByZXNlbnRhdGlvbnMgbGlrZSBiYXNlNTggYW5kIElTTyB0aW1lc3RhbXBzLlxuICpcbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHNyYyA9IFsweDA1LCAweDAwLCAweGE3LCAweGU4LCAweGU0LCAweGQ4LCAweDBiXTtcbiAqXG4gKiBjb25zdCB0eXA6IE1pY2hlbHNvblR5cGUgPSB7XG4gKiAgICAgcHJpbTogXCJ0aW1lc3RhbXBcIlxuICogfTtcbiAqXG4gKiBjb25zdCBkYXRhID0gdW5wYWNrRGF0YShzcmMsIHR5cCk7XG4gKlxuICogLy8geyBzdHJpbmc6IFwiMjAxOS0wOS0yNlQxMDo1OTo1MVpcIiB9XG4gKiBgYGBcbiAqXG4gKiBTYW1lIGJpbmFyeSBkYXRhIHdpdGhvdXQgYSB0eXBlIGRlZmluaXRpb25cbiAqIGBgYHR5cGVzY3JpcHRcbiAqIGNvbnN0IHNyYyA9IFsweDA1LCAweDAwLCAweGE3LCAweGU4LCAweGU0LCAweGQ4LCAweDBiXTtcbiAqXG4gKiBjb25zdCBkYXRhID0gdW5wYWNrRGF0YShzcmMpO1xuICpcbiAqIC8vIHsgaW50OiBcIjE1Njk0OTU1OTFcIiB9XG4gKiBgYGBcbiAqIEBwYXJhbSBzcmMgQnl0ZSBhcnJheVxuICogQHBhcmFtIHQgT3B0aW9uYWwgdHlwZSBkZWZpbml0aW9uXG4gKiBAcmV0dXJucyBEZXNlcmlhbGl6ZWQgZGF0YVxuICovXG5mdW5jdGlvbiB1bnBhY2tEYXRhKHNyYywgdCkge1xuICAgIGNvbnN0IHIgPSBuZXcgUmVhZGVyKHNyYyk7XG4gICAgaWYgKHIucmVhZFVpbnQ4KCkgIT09IDUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbmNvcnJlY3QgcGFja2VkIGRhdGEgbWFnaWMgbnVtYmVyJyk7XG4gICAgfVxuICAgIGNvbnN0IGV4ID0gcmVhZEV4cHIociwgdCAhPT0gdW5kZWZpbmVkID8gZ2V0UmVhZFRyYW5zZm9ybUZ1bmNzKHQpIDogcmVhZFBhc3NUaHJvdWdoKTtcbiAgICBpZiAoYXNzZXJ0TWljaGVsc29uRGF0YShleCkpIHtcbiAgICAgICAgcmV0dXJuIGV4O1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoKTsgLy8gbmV2ZXJcbn1cbi8qKlxuICogRGVzZXJpYWxpemUgYSBieXRlIGFycmF5IGludG8gdGhlIGNvcnJlc3BvbmRpbmcgTWljaGVsc29uIHZhbHVlLlxuICogU2FtZSBhcyB7QGxpbmsgdW5wYWNrRGF0YX0gYnV0IHRha2VzIGEgYGJ5dGVzYCBNaWNoZWxzb24gZGF0YSBsaXRlcmFsIGluc3RlYWQgb2YgYW4gYXJyYXlcbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCBzcmMgPSB7IGJ5dGVzOiBcIjA1MDBhN2U4ZTRkODBiXCIgfTtcbiAqXG4gKiBjb25zdCB0eXA6IE1pY2hlbHNvblR5cGUgPSB7XG4gKiAgICAgcHJpbTogXCJ0aW1lc3RhbXBcIlxuICogfTtcbiAqXG4gKiBjb25zdCBkYXRhID0gdW5wYWNrRGF0YUJ5dGVzKHNyYywgdHlwKTtcbiAqXG4gKiAvLyB7IHN0cmluZzogXCIyMDE5LTA5LTI2VDEwOjU5OjUxWlwiIH1cbiAqIGBgYFxuICogQHBhcmFtIHNyYyBCeXRlcyBvYmplY3RcbiAqIEBwYXJhbSB0IE9wdGlvbmFsIHR5cGUgZGVmaW5pdGlvblxuICogQHJldHVybnMgRGVzZXJpYWxpemVkIGRhdGFcbiAqL1xuZnVuY3Rpb24gdW5wYWNrRGF0YUJ5dGVzKHNyYywgdCkge1xuICAgIGNvbnN0IGJ5dGVzID0gcGFyc2VCeXRlcyhzcmMuYnl0ZXMpO1xuICAgIGlmIChieXRlcyA9PT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGNhbid0IHBhcnNlIGJ5dGVzOiBcIiR7c3JjLmJ5dGVzfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiB1bnBhY2tEYXRhKGJ5dGVzLCB0KTtcbn1cbi8vIGhlbHBlciBmdW5jdGlvbnMgYWxzbyB1c2VkIGJ5IHZhbGlkYXRvclxuZnVuY3Rpb24gZGVjb2RlQWRkcmVzc0J5dGVzKGIpIHtcbiAgICBjb25zdCBieXRlcyA9IHBhcnNlQnl0ZXMoYi5ieXRlcyk7XG4gICAgaWYgKGJ5dGVzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2FuJ3QgcGFyc2UgYnl0ZXM6IFwiJHtiLmJ5dGVzfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHJkID0gbmV3IFJlYWRlcihuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIHJldHVybiByZWFkQWRkcmVzcyhyZCk7XG59XG5mdW5jdGlvbiBkZWNvZGVQdWJsaWNLZXlIYXNoQnl0ZXMoYikge1xuICAgIGNvbnN0IGJ5dGVzID0gcGFyc2VCeXRlcyhiLmJ5dGVzKTtcbiAgICBpZiAoYnl0ZXMgPT09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBjYW4ndCBwYXJzZSBieXRlczogXCIke2IuYnl0ZXN9XCJgKTtcbiAgICB9XG4gICAgY29uc3QgcmQgPSBuZXcgUmVhZGVyKG5ldyBVaW50OEFycmF5KGJ5dGVzKSk7XG4gICAgcmV0dXJuIHJlYWRQdWJsaWNLZXlIYXNoKHJkKTtcbn1cbmZ1bmN0aW9uIGRlY29kZVB1YmxpY0tleUJ5dGVzKGIpIHtcbiAgICBjb25zdCBieXRlcyA9IHBhcnNlQnl0ZXMoYi5ieXRlcyk7XG4gICAgaWYgKGJ5dGVzID09PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgY2FuJ3QgcGFyc2UgYnl0ZXM6IFwiJHtiLmJ5dGVzfVwiYCk7XG4gICAgfVxuICAgIGNvbnN0IHJkID0gbmV3IFJlYWRlcihuZXcgVWludDhBcnJheShieXRlcykpO1xuICAgIHJldHVybiByZWFkUHVibGljS2V5KHJkKTtcbn1cblxuY2xhc3MgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvciBleHRlbmRzIE1pY2hlbHNvbkVycm9yIHtcbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmFsIFZhbHVlIG9mIGEgdHlwZSBub2RlIGNhdXNlZCB0aGUgZXJyb3JcbiAgICAgKiBAcGFyYW0gc3RhY2tTdGF0ZSBDdXJyZW50IHN0YWNrIHN0YXRlXG4gICAgICogQHBhcmFtIG1lc3NhZ2UgQW4gZXJyb3IgbWVzc2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgc3RhY2tTdGF0ZSwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWwsIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5zdGFja1N0YXRlID0gc3RhY2tTdGF0ZTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01pY2hlbHNvbkluc3RydWN0aW9uRXJyb3InO1xuICAgIH1cbn1cbi8vICdzZXF1ZW5jZSBhcyBhIHBhaXInIGVkbyBzeW50YXggaGVscGVyc1xuZnVuY3Rpb24gdHlwZUlEKHQpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0KSA/ICdwYWlyJyA6IHQucHJpbTtcbn1cbmZ1bmN0aW9uIHR5cGVBcmdzKHQpIHtcbiAgICByZXR1cm4gKCdwcmltJyBpbiB0ID8gdC5hcmdzIDogdCk7XG59XG5mdW5jdGlvbiBhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKGEsIGIsIGZpZWxkID0gZmFsc2UpIHtcbiAgICBpZiAodHlwZUlEKGEpICE9PSB0eXBlSUQoYikpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcihhLCBgdHlwZXMgbWlzbWF0Y2g6ICR7dHlwZUlEKGEpfSAhPSAke3R5cGVJRChiKX1gLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBjb25zdCBhbm4gPSBbdW5wYWNrQW5ub3RhdGlvbnMoYSksIHVucGFja0Fubm90YXRpb25zKGIpXTtcbiAgICBpZiAoYW5uWzBdLnQgJiYgYW5uWzFdLnQgJiYgYW5uWzBdLnRbMF0gIT09IGFublsxXS50WzBdKSB7XG4gICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IoYSwgYCR7dHlwZUlEKGEpfTogdHlwZSBuYW1lcyBtaXNtYXRjaDogJHthbm5bMF0udFswXX0gIT0gJHthbm5bMV0udFswXX1gLCB1bmRlZmluZWQpO1xuICAgIH1cbiAgICBpZiAoZmllbGQgJiYgYW5uWzBdLmYgJiYgYW5uWzFdLmYgJiYgYW5uWzBdLmZbMF0gIT09IGFublsxXS5mWzBdKSB7XG4gICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IoYSwgYCR7dHlwZUlEKGEpfTogZmllbGQgbmFtZXMgbWlzbWF0Y2g6ICR7YW5uWzBdLmZbMF19ICE9ICR7YW5uWzFdLmZ9YCwgdW5kZWZpbmVkKTtcbiAgICB9XG4gICAgaWYgKGlzUGFpclR5cGUoYSkpIHtcbiAgICAgICAgY29uc3QgYUFyZ3MgPSB1bnBhY2tDb21iKCdwYWlyJywgYSk7XG4gICAgICAgIGNvbnN0IGJBcmdzID0gdW5wYWNrQ29tYigncGFpcicsIGIpO1xuICAgICAgICBhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKGFBcmdzLmFyZ3NbMF0sIGJBcmdzLmFyZ3NbMF0sIHRydWUpO1xuICAgICAgICBhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKGFBcmdzLmFyZ3NbMV0sIGJBcmdzLmFyZ3NbMV0sIHRydWUpO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAoYS5wcmltKSB7XG4gICAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdjb250cmFjdCc6XG4gICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgIGNhc2UgJ3RpY2tldCc6XG4gICAgICAgICAgICBhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKGEuYXJnc1swXSwgYi5hcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdvcic6XG4gICAgICAgICAgICBhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKGEuYXJnc1swXSwgYi5hcmdzWzBdLCB0cnVlKTtcbiAgICAgICAgICAgIGFzc2VydFNjYWxhclR5cGVzRXF1YWwoYS5hcmdzWzFdLCBiLmFyZ3NbMV0sIHRydWUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2xhbWJkYSc6XG4gICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgIGNhc2UgJ2JpZ19tYXAnOlxuICAgICAgICAgICAgYXNzZXJ0U2NhbGFyVHlwZXNFcXVhbChhLmFyZ3NbMF0sIGIuYXJnc1swXSk7XG4gICAgICAgICAgICBhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKGEuYXJnc1sxXSwgYi5hcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdzYXBsaW5nX3N0YXRlJzpcbiAgICAgICAgY2FzZSAnc2FwbGluZ190cmFuc2FjdGlvbic6XG4gICAgICAgICAgICBpZiAocGFyc2VJbnQoYS5hcmdzWzBdLmludCwgMTApICE9PSBwYXJzZUludChiLmFyZ3NbMF0uaW50LCAxMCkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKGEsIGAke3R5cGVJRChhKX06IHR5cGUgYXJndW1lbnQgbWlzbWF0Y2g6ICR7YS5hcmdzWzBdLmludH0gIT0gJHtiLmFyZ3NbMF0uaW50fWAsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXNzZXJ0U3RhY2tzRXF1YWwoYSwgYikge1xuICAgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcihhLCBgc3RhY2sgbGVuZ3RoIG1pc21hdGNoOiAke2EubGVuZ3RofSAhPSAke2IubGVuZ3RofWAsIHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICBhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKGFbaV0sIGJbaV0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKHQsIGZpZWxkID0gZmFsc2UpIHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodCkpIHtcbiAgICAgICAgY29uc3QgYW5uID0gdW5wYWNrQW5ub3RhdGlvbnModCk7XG4gICAgICAgIGlmICgoKChfYSA9IGFubi50KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubGVuZ3RoKSB8fCAwKSA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYCR7dC5wcmltfTogYXQgbW9zdCBvbmUgdHlwZSBhbm5vdGF0aW9uIGFsbG93ZWQ6ICR7dC5hbm5vdHN9YCwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGlmICgoKChfYiA9IGFubi5mKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IubGVuZ3RoKSB8fCAwKSA+IDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGAke3QucHJpbX06IGF0IG1vc3Qgb25lIGZpZWxkIGFubm90YXRpb24gYWxsb3dlZDogJHt0LmFubm90c31gLCB1bmRlZmluZWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKCgoKF9jID0gYW5uLmYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5sZW5ndGgpIHx8IDApID4gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYCR7dC5wcmltfTogZmllbGQgYW5ub3RhdGlvbnMgYXJlbid0IGFsbG93ZWQ6ICR7dC5hbm5vdHN9YCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNQYWlyVHlwZSh0KSkge1xuICAgICAgICBjb25zdCBhcmdzID0gdHlwZUFyZ3ModCk7XG4gICAgICAgIGZvciAoY29uc3QgYSBvZiBhcmdzKSB7XG4gICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZChhLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHN3aXRjaCAodC5wcmltKSB7XG4gICAgICAgIGNhc2UgJ29wdGlvbic6XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdjb250cmFjdCc6XG4gICAgICAgIGNhc2UgJ3NldCc6XG4gICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZCh0LmFyZ3NbMF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ29yJzpcbiAgICAgICAgICAgIGZvciAoY29uc3QgYSBvZiB0LmFyZ3MpIHtcbiAgICAgICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZChhLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsYW1iZGEnOlxuICAgICAgICBjYXNlICdtYXAnOlxuICAgICAgICBjYXNlICdiaWdfbWFwJzpcbiAgICAgICAgICAgIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKHQuYXJnc1swXSk7XG4gICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZCh0LmFyZ3NbMV0pO1xuICAgIH1cbn1cbi8vIFNpbXBsaWZpZWQgdmVyc2lvbiBvZiBhc3NlcnRNaWNoZWxzb25JbnN0cnVjdGlvbigpIGZvciBwcmV2aW91c2x5IHZhbGlkYXRlZCBkYXRhXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGQpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZCkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHYgb2YgZCkge1xuICAgICAgICBpZiAoISgoQXJyYXkuaXNBcnJheSh2KSAmJiBpc0Z1bmN0aW9uKHYpKSB8fCAoJ3ByaW0nIGluIHYgJiYgaXNJbnN0cnVjdGlvbih2KSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBhc3NlcnREYXRhVmFsaWRJbnRlcm5hbChkLCB0LCBjdHgpIHtcbiAgICBpZiAoaXNQYWlyVHlwZSh0KSkge1xuICAgICAgICBpZiAoaXNQYWlyRGF0YShkKSkge1xuICAgICAgICAgICAgYXNzZXJ0RGF0YUxpc3RJZkFueShkKTtcbiAgICAgICAgICAgIGNvbnN0IGRjID0gdW5wYWNrQ29tYignUGFpcicsIGQpO1xuICAgICAgICAgICAgY29uc3QgdGMgPSB1bnBhY2tDb21iKCdwYWlyJywgdCk7XG4gICAgICAgICAgICBhc3NlcnREYXRhVmFsaWRJbnRlcm5hbChkYy5hcmdzWzBdLCB0Yy5hcmdzWzBdLCBjdHgpO1xuICAgICAgICAgICAgYXNzZXJ0RGF0YVZhbGlkSW50ZXJuYWwoZGMuYXJnc1sxXSwgdGMuYXJnc1sxXSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBwYWlyIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHQucHJpbSkge1xuICAgICAgICAvLyBBdG9taWMgbGl0ZXJhbHNcbiAgICAgICAgY2FzZSAnaW50JzpcbiAgICAgICAgICAgIGlmICgnaW50JyBpbiBkICYmIGlzRGVjaW1hbChkLmludCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBpbnRlZ2VyIHZhbHVlIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICduYXQnOlxuICAgICAgICBjYXNlICdtdXRleic6XG4gICAgICAgICAgICBpZiAoJ2ludCcgaW4gZCAmJiBpc05hdHVyYWwoZC5pbnQpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgbmF0dXJhbCB2YWx1ZSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyBpbiBkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgc3RyaW5nIHZhbHVlIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICdieXRlcyc6XG4gICAgICAgIGNhc2UgJ2JsczEyXzM4MV9nMSc6XG4gICAgICAgIGNhc2UgJ2JsczEyXzM4MV9nMic6XG4gICAgICAgICAgICBpZiAoJ2J5dGVzJyBpbiBkICYmIHBhcnNlQnl0ZXMoZC5ieXRlcykgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBieXRlcyB2YWx1ZSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgY2FzZSAnYm9vbCc6XG4gICAgICAgICAgICBpZiAoJ3ByaW0nIGluIGQgJiYgKGQucHJpbSA9PT0gJ1RydWUnIHx8IGQucHJpbSA9PT0gJ0ZhbHNlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBib29sZWFuIHZhbHVlIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICdrZXlfaGFzaCc6XG4gICAgICAgICAgICBpZiAoJ3N0cmluZycgaW4gZCAmJlxuICAgICAgICAgICAgICAgIGNoZWNrRGVjb2RlVGV6b3NJRChkLnN0cmluZywgJ0VEMjU1MTlQdWJsaWNLZXlIYXNoJywgJ1NFQ1AyNTZLMVB1YmxpY0tleUhhc2gnLCAnUDI1NlB1YmxpY0tleUhhc2gnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKCdieXRlcycgaW4gZCkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGRlY29kZVB1YmxpY0tleUhhc2hCeXRlcyhkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBga2V5IGhhc2ggZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgICAgICBpZiAoKCdzdHJpbmcnIGluIGQgfHwgJ2ludCcgaW4gZCkgJiYgcGFyc2VEYXRlKGQpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgdGltZXN0YW1wIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICdhZGRyZXNzJzpcbiAgICAgICAgICAgIGlmICgnc3RyaW5nJyBpbiBkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGFkZHJlc3MgPSBkLnN0cmluZztcbiAgICAgICAgICAgICAgICBjb25zdCBlcCA9IGQuc3RyaW5nLmluZGV4T2YoJyUnKTtcbiAgICAgICAgICAgICAgICBpZiAoZXAgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0cmltIGVudHJ5IHBvaW50XG4gICAgICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBkLnN0cmluZy5zbGljZSgwLCBlcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja0RlY29kZVRlem9zSUQoYWRkcmVzcywgJ0VEMjU1MTlQdWJsaWNLZXlIYXNoJywgJ1NFQ1AyNTZLMVB1YmxpY0tleUhhc2gnLCAnUDI1NlB1YmxpY0tleUhhc2gnLCAnQ29udHJhY3RIYXNoJywgJ1JvbGx1cEFkZHJlc3MnKSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoJ2J5dGVzJyBpbiBkKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgZGVjb2RlQWRkcmVzc0J5dGVzKGQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaWdub3JlIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBhZGRyZXNzIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICdrZXknOlxuICAgICAgICAgICAgaWYgKCdzdHJpbmcnIGluIGQgJiZcbiAgICAgICAgICAgICAgICBjaGVja0RlY29kZVRlem9zSUQoZC5zdHJpbmcsICdFRDI1NTE5UHVibGljS2V5JywgJ1NFQ1AyNTZLMVB1YmxpY0tleScsICdQMjU2UHVibGljS2V5JykgIT09XG4gICAgICAgICAgICAgICAgICAgIG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgnYnl0ZXMnIGluIGQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBkZWNvZGVQdWJsaWNLZXlCeXRlcyhkKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBtZXNzYWdlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgcHVibGljIGtleSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgY2FzZSAndW5pdCc6XG4gICAgICAgICAgICBpZiAoJ3ByaW0nIGluIGQgJiYgZC5wcmltID09PSAnVW5pdCcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGB1bml0IHZhbHVlIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICdzaWduYXR1cmUnOlxuICAgICAgICAgICAgaWYgKCdieXRlcycgaW4gZCB8fFxuICAgICAgICAgICAgICAgICgnc3RyaW5nJyBpbiBkICYmXG4gICAgICAgICAgICAgICAgICAgIGNoZWNrRGVjb2RlVGV6b3NJRChkLnN0cmluZywgJ0VEMjU1MTlTaWduYXR1cmUnLCAnU0VDUDI1NksxU2lnbmF0dXJlJywgJ1AyNTZTaWduYXR1cmUnLCAnR2VuZXJpY1NpZ25hdHVyZScpICE9PSBudWxsKSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYHNpZ25hdHVyZSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgY2FzZSAnY2hhaW5faWQnOlxuICAgICAgICAgICAgaWYgKCdieXRlcycgaW4gZCB8fCAnc3RyaW5nJyBpbiBkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9ICdzdHJpbmcnIGluIGQgPyBkZWNvZGVCYXNlNThDaGVjayhkLnN0cmluZykgOiBwYXJzZUJ5dGVzKGQuYnl0ZXMpO1xuICAgICAgICAgICAgICAgIGlmICh4ICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBjaGFpbiBpZCBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgLy8gQ29tcGxleCB0eXBlc1xuICAgICAgICBjYXNlICdvcHRpb24nOlxuICAgICAgICAgICAgaWYgKCdwcmltJyBpbiBkKSB7XG4gICAgICAgICAgICAgICAgaWYgKGQucHJpbSA9PT0gJ05vbmUnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZC5wcmltID09PSAnU29tZScpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0RGF0YVZhbGlkSW50ZXJuYWwoZC5hcmdzWzBdLCB0LmFyZ3NbMF0sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBvcHRpb24gZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgIGNhc2UgJ2xpc3QnOlxuICAgICAgICBjYXNlICdzZXQnOlxuICAgICAgICAgICAgaWYgKGFzc2VydERhdGFMaXN0SWZBbnkoZCkpIHtcbiAgICAgICAgICAgICAgICAvL2xldCBwcmV2OiBNaWNoZWxzb25EYXRhIHwgdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgdiBvZiBkKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydERhdGFWYWxpZEludGVybmFsKHYsIHQuYXJnc1swXSwgY3R4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgJHt0LnByaW19IGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICdvcic6XG4gICAgICAgICAgICBpZiAoJ3ByaW0nIGluIGQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZC5wcmltID09PSAnTGVmdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0RGF0YVZhbGlkSW50ZXJuYWwoZC5hcmdzWzBdLCB0LmFyZ3NbMF0sIGN0eCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZC5wcmltID09PSAnUmlnaHQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGFzc2VydERhdGFWYWxpZEludGVybmFsKGQuYXJnc1swXSwgdC5hcmdzWzFdLCBjdHgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgdW5pb24gKG9yKSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgY2FzZSAnbGFtYmRhJzpcbiAgICAgICAgICAgIGlmIChpc0Z1bmN0aW9uKGQpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0ID0gZnVuY3Rpb25UeXBlSW50ZXJuYWwoZCwgW3QuYXJnc1swXV0sIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKCdmYWlsZWQnIGluIHJldCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBmdW5jdGlvbiBpcyBmYWlsZWQgd2l0aCBlcnJvciB0eXBlOiAke3JldC5mYWlsZWR9YCwgZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChyZXQubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGEgdmFsdWUnLCBkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYXNzZXJ0U2NhbGFyVHlwZXNFcXVhbCh0LmFyZ3NbMV0sIHJldFswXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgZnVuY3Rpb24gZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgIGNhc2UgJ21hcCc6XG4gICAgICAgIGNhc2UgJ2JpZ19tYXAnOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZCkpIHtcbiAgICAgICAgICAgICAgICAvL2xldCBwcmV2OiBNaWNoZWxzb25NYXBFbHQgfCB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB2IG9mIGQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3ByaW0nIGluIHYpIHx8IHYucHJpbSAhPT0gJ0VsdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYG1hcCBlbGVtZW50cyBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBhc3NlcnREYXRhVmFsaWRJbnRlcm5hbCh2LmFyZ3NbMF0sIHQuYXJnc1swXSwgY3R4KTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0RGF0YVZhbGlkSW50ZXJuYWwodi5hcmdzWzFdLCB0LmFyZ3NbMV0sIGN0eCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYCR7dC5wcmltfSBleHBlY3RlZDogJHtKU09OLnN0cmluZ2lmeShkKX1gLCBkKTtcbiAgICAgICAgY2FzZSAnYmxzMTJfMzgxX2ZyJzpcbiAgICAgICAgICAgIGlmICgoJ2ludCcgaW4gZCAmJiBpc0RlY2ltYWwoZC5pbnQpKSB8fCAoJ2J5dGVzJyBpbiBkICYmIHBhcnNlQnl0ZXMoZC5ieXRlcykgIT09IG51bGwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvblR5cGVFcnJvcih0LCBgQkxTMTItMzgxIGVsZW1lbnQgZXhwZWN0ZWQ6ICR7SlNPTi5zdHJpbmdpZnkoZCl9YCwgZCk7XG4gICAgICAgIGNhc2UgJ3NhcGxpbmdfc3RhdGUnOlxuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uVHlwZUVycm9yKHQsIGBzYXBsaW5nIHN0YXRlIGV4cGVjdGVkOiAke0pTT04uc3RyaW5naWZ5KGQpfWAsIGQpO1xuICAgICAgICBjYXNlICd0aWNrZXQnOlxuICAgICAgICAgICAgYXNzZXJ0RGF0YVZhbGlkSW50ZXJuYWwoZCwge1xuICAgICAgICAgICAgICAgIHByaW06ICdwYWlyJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbeyBwcmltOiAnYWRkcmVzcycgfSwgdC5hcmdzWzBdLCB7IHByaW06ICduYXQnIH1dLFxuICAgICAgICAgICAgfSwgY3R4KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25UeXBlRXJyb3IodCwgYHR5cGUgJHt0eXBlSUQodCl9IGRvbid0IGhhdmUgTWljaGVsc29uIGxpdGVyYWwgcmVwcmVzZW50YXRpb25gLCBkKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnN0cnVjdGlvbkxpc3RUeXBlKGluc3QsIHN0YWNrLCBjdHgpIHtcbiAgICBsZXQgcmV0ID0gc3RhY2s7XG4gICAgbGV0IHMgPSBzdGFjaztcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChjb25zdCBvcCBvZiBpbnN0KSB7XG4gICAgICAgIGNvbnN0IGZ0ID0gZnVuY3Rpb25UeXBlSW50ZXJuYWwob3AsIHMsIGN0eCk7XG4gICAgICAgIHJldCA9IGZ0O1xuICAgICAgICBpZiAoJ2ZhaWxlZCcgaW4gZnQpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHMgPSBmdDtcbiAgICAgICAgaSsrO1xuICAgIH1cbiAgICBpZiAoJ2ZhaWxlZCcgaW4gcmV0ICYmXG4gICAgICAgIHJldC5sZXZlbCA9PSAwICYmXG4gICAgICAgICghKCdwcmltJyBpbiByZXQuZmFpbGVkKSB8fCByZXQuZmFpbGVkLnByaW0gIT09ICduZXZlcicpICYmXG4gICAgICAgIGkgIT09IGluc3QubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0LCByZXQsICdGQUlMIG11c3QgYXBwZWFyIGluIGEgdGFpbCBwb3NpdGlvbicpO1xuICAgIH1cbiAgICBpZiAoKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC50cmFjZUNhbGxiYWNrKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRyYWNlID0ge1xuICAgICAgICAgICAgb3A6IGluc3QsXG4gICAgICAgICAgICBpbjogc3RhY2ssXG4gICAgICAgICAgICBvdXQ6IHJldCxcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LnRyYWNlQ2FsbGJhY2sodHJhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gJ2ZhaWxlZCcgaW4gcmV0ID8geyBmYWlsZWQ6IHJldC5mYWlsZWQsIGxldmVsOiByZXQubGV2ZWwgKyAxIH0gOiByZXQ7XG59XG5mdW5jdGlvbiBmdW5jdGlvblR5cGVJbnRlcm5hbChpbnN0LCBzdGFjaywgY3R4KSB7XG4gICAgY29uc3QgcHJvdG8gPSAoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LnByb3RvY29sKSB8fCBEZWZhdWx0UHJvdG9jb2w7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zdCkpIHtcbiAgICAgICAgcmV0dXJuIGluc3RydWN0aW9uTGlzdFR5cGUoaW5zdCwgc3RhY2ssIGN0eCk7XG4gICAgfVxuICAgIGNvbnN0IGluc3RydWN0aW9uID0gaW5zdDsgLy8gTWFrZSBpdCBjb25zdCBmb3IgdHlwZSBndWFyZGluZ1xuICAgIC8vIG1ha2Ugc3VyZSB0aGUgc3RhY2sgaGFzIGVub3VnaCBudW1iZXIgb2YgYXJndW1lbnRzIG9mIHNwZWNpZmljIHR5cGVzXG4gICAgZnVuY3Rpb24gYXJncyhuLCAuLi50eXBlSWRzKSB7XG4gICAgICAgIGlmIChzdGFjay5sZW5ndGggPCB0eXBlSWRzLmxlbmd0aCArIG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IHN0YWNrIG11c3QgaGF2ZSBhdCBsZWFzdCAke3R5cGVJZHMubGVuZ3RofSBlbGVtZW50KHMpYCk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGkgPSBuO1xuICAgICAgICBmb3IgKGNvbnN0IGlkcyBvZiB0eXBlSWRzKSB7XG4gICAgICAgICAgICBpZiAoaWRzICE9PSBudWxsICYmIGlkcy5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgICAgICBsZXQgaWkgPSAwO1xuICAgICAgICAgICAgICAgIHdoaWxlIChpaSA8IGlkcy5sZW5ndGggJiYgaWRzW2lpXSAhPT0gdHlwZUlEKHN0YWNrW2ldKSkge1xuICAgICAgICAgICAgICAgICAgICBpaSsrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaWkgPT09IGlkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfTogc3RhY2sgdHlwZSBtaXNtYXRjaDogWyR7aX1dIGV4cGVjdGVkIHRvIGJlICR7aWRzfSwgZ290ICR7dHlwZUlEKHN0YWNrW2ldKX0gaW5zdGVhZGApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhY2suc2xpY2UobiwgdHlwZUlkcy5sZW5ndGggKyBuKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmV0aHJvdyhmbikge1xuICAgICAgICByZXR1cm4gKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKC4uLmFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBNaWNoZWxzb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuICAgIGZ1bmN0aW9uIHJldGhyb3dUeXBlR3VhcmQoZm4pIHtcbiAgICAgICAgcmV0dXJuIChhcmcpID0+IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIE1pY2hlbHNvbkVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgYXJnQW5uID0gcmV0aHJvdyh1bnBhY2tBbm5vdGF0aW9ucyk7XG4gICAgY29uc3QgZW5zdXJlU3RhY2tzRXF1YWwgPSByZXRocm93KGFzc2VydFN0YWNrc0VxdWFsKTtcbiAgICBjb25zdCBlbnN1cmVUeXBlc0VxdWFsID0gcmV0aHJvdyhhc3NlcnRTY2FsYXJUeXBlc0VxdWFsKTtcbiAgICBjb25zdCBlbnN1cmVDb21wYXJhYmxlVHlwZSA9IHJldGhyb3dUeXBlR3VhcmQoYXNzZXJ0TWljaGVsc29uQ29tcGFyYWJsZVR5cGUpO1xuICAgIGNvbnN0IGVuc3VyZVBhY2thYmxlVHlwZSA9IHJldGhyb3dUeXBlR3VhcmQoYXNzZXJ0TWljaGVsc29uUGFja2FibGVUeXBlKTtcbiAgICBjb25zdCBlbnN1cmVTdG9yYWJsZVR5cGUgPSByZXRocm93VHlwZUd1YXJkKGFzc2VydE1pY2hlbHNvblN0b3JhYmxlVHlwZSk7XG4gICAgY29uc3QgZW5zdXJlUHVzaGFibGVUeXBlID0gcmV0aHJvd1R5cGVHdWFyZChhc3NlcnRNaWNoZWxzb25QdXNoYWJsZVR5cGUpO1xuICAgIGNvbnN0IGVuc3VyZUJpZ01hcFN0b3JhYmxlVHlwZSA9IHJldGhyb3dUeXBlR3VhcmQoYXNzZXJ0TWljaGVsc29uQmlnTWFwU3RvcmFibGVUeXBlKTtcbiAgICAvLyB1bnBhY2sgaW5zdHJ1Y3Rpb24gYW5ub3RhdGlvbnMgYW5kIGFzc2VydCB0aGVpciBtYXhpbXVtIG51bWJlclxuICAgIGZ1bmN0aW9uIGluc3RydWN0aW9uQW5uKG51bSwgb3B0KSB7XG4gICAgICAgIGNvbnN0IGEgPSBhcmdBbm4oaW5zdHJ1Y3Rpb24sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3B0KSwgeyBlbXB0eUZpZWxkczogbnVtLmYgIT09IHVuZGVmaW5lZCAmJiBudW0uZiA+IDEsIGVtcHR5VmFyOiBudW0udiAhPT0gdW5kZWZpbmVkICYmIG51bS52ID4gMSB9KSk7XG4gICAgICAgIGNvbnN0IGFzc2VydE51bSA9IChhLCBuLCB0eXBlKSA9PiB7XG4gICAgICAgICAgICBpZiAoYSAmJiBhLmxlbmd0aCA+IChuIHx8IDApKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfTogYXQgbW9zdCAke24gfHwgMH0gJHt0eXBlfSBhbm5vdGF0aW9ucyBhbGxvd2VkYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGFzc2VydE51bShhLmYsIG51bS5mLCAnZmllbGQnKTtcbiAgICAgICAgYXNzZXJ0TnVtKGEudCwgbnVtLnQsICd0eXBlJyk7XG4gICAgICAgIGFzc2VydE51bShhLnYsIG51bS52LCAndmFyaWFibGUnKTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgfVxuICAgIC8vIGFsc28ga2VlcHMgYW5ub3RhdGlvbiBjbGFzcyBpZiBudWxsIGlzIHByb3ZpZGVkXG4gICAgZnVuY3Rpb24gYW5ub3RhdGUodHQsIGEpIHtcbiAgICAgICAgY29uc3QgdHggPSB0dDtcbiAgICAgICAgY29uc3QgdCA9IEFycmF5LmlzQXJyYXkodHgpID8geyBwcmltOiAncGFpcicsIGFyZ3M6IHR4IH0gOiB0eDtcbiAgICAgICAgY29uc3Qgc3JjID0gYXJnQW5uKHQpO1xuICAgICAgICBjb25zdCBhbm4gPSBhLnYgIT09IHVuZGVmaW5lZCB8fCBhLnQgIT09IHVuZGVmaW5lZCB8fCBhLmYgIT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgLi4uKChhLnYgPT09IG51bGwgPyBzcmMudiA6IGEudikgfHwgW10pLFxuICAgICAgICAgICAgICAgIC4uLigoYS50ID09PSBudWxsID8gc3JjLnQgOiBhLnQpIHx8IFtdKSxcbiAgICAgICAgICAgICAgICAuLi4oKGEuZiA9PT0gbnVsbCA/IHNyYy5mIDogYS5mKSB8fCBbXSksXG4gICAgICAgICAgICBdXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3QgcmVzdCA9IF9fcmVzdCh0LCBbXCJhbm5vdHNcIl0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgKGFubiAmJiBhbm4ubGVuZ3RoICE9PSAwICYmIHsgYW5ub3RzOiBhbm4gfSkpO1xuICAgIH1cbiAgICAvLyBzaG9ydGN1dCB0byBjb3B5IGF0IG1vc3Qgb25lIHZhcmlhYmxlIGFubm90YXRpb24gZnJvbSB0aGUgaW5zdHJ1Y3Rpb24gdG8gdGhlIHR5cGVcbiAgICBmdW5jdGlvbiBhbm5vdGF0ZVZhcih0LCBkZWYpIHtcbiAgICAgICAgY29uc3QgaWEgPSBpbnN0cnVjdGlvbkFubih7IHY6IDEgfSk7XG4gICAgICAgIHJldHVybiBhbm5vdGF0ZSh0LCB7XG4gICAgICAgICAgICB2OiBpYS52ICE9PSB1bmRlZmluZWQgPyBpYS52IDogZGVmICE9PSB1bmRlZmluZWQgPyBbZGVmXSA6IG51bGwsXG4gICAgICAgICAgICB0OiBudWxsLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gYW5ub3RhdGUgQ0FSL0NEUi9VTlBBSVIvR0VUXG4gICAgZnVuY3Rpb24gYW5ub3RhdGVGaWVsZChhcmcsIGZpZWxkLCBpbnNBbm4sIG4sIGRlZkZpZWxkKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgY29uc3QgZmllbGRBbm4gPSAoX2EgPSBhcmdBbm4oZmllbGQpLmYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTsgLy8gZmllbGQncyBmaWVsZCBhbm5vdGF0aW9uXG4gICAgICAgIGNvbnN0IGluc0ZpZWxkQW5uID0gKF9iID0gaW5zQW5uLmYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltuXTtcbiAgICAgICAgaWYgKGluc0ZpZWxkQW5uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGluc0ZpZWxkQW5uICE9PSAnJScgJiZcbiAgICAgICAgICAgIGZpZWxkQW5uICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgIGluc0ZpZWxkQW5uICE9PSBmaWVsZEFubikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfTogZmllbGQgbmFtZXMgZG9lc24ndCBtYXRjaDogJHtpbnNGaWVsZEFubn0gIT09ICR7ZmllbGRBbm59YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5zVmFyQW5uID0gKF9jID0gaW5zQW5uLnYpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfY1tuXTsgLy8gbnRoIGluc3RydWN0aW9uJ3MgdmFyaWFibGUgYW5ub3RhdGlvblxuICAgICAgICBjb25zdCB2YXJBbm4gPSAoX2QgPSBhcmdBbm4oYXJnKS52KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RbMF07IC8vIGluc3RydWN0aW9uIGFyZ3VtZW50J3MgdmFyaWFibGUgYW5ub3RhdGlvblxuICAgICAgICByZXR1cm4gYW5ub3RhdGUoZmllbGQsIHtcbiAgICAgICAgICAgIHQ6IG51bGwsXG4gICAgICAgICAgICB2OiBpbnNWYXJBbm5cbiAgICAgICAgICAgICAgICA/IGluc1ZhckFubiA9PT0gJ0AlJ1xuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkQW5uXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFsnQCcgKyBmaWVsZEFubi5zbGljZSgxKV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogaW5zVmFyQW5uID09PSAnQCUlJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB2YXJBbm5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IFsnQCcgKyB2YXJBbm4uc2xpY2UoMSkgKyAnLicgKyAoZmllbGRBbm4gPyBmaWVsZEFubi5zbGljZSgxKSA6IGRlZkZpZWxkKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkQW5uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gWydAJyArIGZpZWxkQW5uLnNsaWNlKDEpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBbaW5zVmFyQW5uXVxuICAgICAgICAgICAgICAgIDogbnVsbCxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGNvbWIgaGVscGVyIGZ1bmN0aW9uc1xuICAgIGZ1bmN0aW9uIGdldE4oc3JjLCBuLCBpID0gbikge1xuICAgICAgICBjb25zdCBwID0gdW5wYWNrQ29tYigncGFpcicsIHNyYyk7XG4gICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gW3AuYXJnc1swXV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIHAuYXJncztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodCA9IHAuYXJnc1sxXTtcbiAgICAgICAgaWYgKGlzUGFpclR5cGUocmlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gW3AuYXJnc1swXSwgLi4uZ2V0TihyaWdodCwgbiwgaSAtIDEpXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGF0IGxlYXN0ICR7bn0gZmllbGRzIGFyZSBleHBlY3RlZGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIGdldE50aChzcmMsIG4sIGkgPSBuKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHAgPSB1bnBhY2tDb21iKCdwYWlyJywgc3JjKTtcbiAgICAgICAgaWYgKGkgPT09IDEpIHtcbiAgICAgICAgICAgIHJldHVybiBwLmFyZ3NbMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmlnaHQgPSBwLmFyZ3NbMV07XG4gICAgICAgIGlmIChpc1BhaXJUeXBlKHJpZ2h0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGdldE50aChyaWdodCwgbiwgaSAtIDIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGkgPT09IDIpIHtcbiAgICAgICAgICAgIHJldHVybiByaWdodDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGAke2luc3RydWN0aW9uLnByaW19OiBhdCBsZWFzdCAke24gKyAxfSBmaWVsZHMgYXJlIGV4cGVjdGVkYCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZU50aChzcmMsIHgsIG4sIGkgPSBuKSB7XG4gICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4geDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwID0gdW5wYWNrQ29tYigncGFpcicsIHNyYyk7XG4gICAgICAgIGlmIChpID09PSAxKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwKSwgeyBhcmdzOiBbeCwgcC5hcmdzWzFdXSB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodCA9IHAuYXJnc1sxXTtcbiAgICAgICAgaWYgKGlzUGFpclR5cGUocmlnaHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwKSwgeyBhcmdzOiBbcC5hcmdzWzBdLCB1cGRhdGVOdGgocmlnaHQsIHgsIG4sIGkgLSAyKV0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaSA9PT0gMikge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcCksIHsgYXJnczogW3AuYXJnc1swXSwgeF0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfTogYXQgbGVhc3QgJHtuICsgMX0gZmllbGRzIGFyZSBleHBlY3RlZGApO1xuICAgIH1cbiAgICBjb25zdCB2YXJTdWZmaXggPSAoYSwgc3VmZml4KSA9PiBbXG4gICAgICAgICdAJyArIChhLnYgPyBhLnZbMF0uc2xpY2UoMSkgKyAnLicgOiAnJykgKyBzdWZmaXgsXG4gICAgXTtcbiAgICBmdW5jdGlvbiBicmFuY2hUeXBlKGJyMCwgYnIxKSB7XG4gICAgICAgIGlmICgnZmFpbGVkJyBpbiBicjAgfHwgJ2ZhaWxlZCcgaW4gYnIxKSB7XG4gICAgICAgICAgICByZXR1cm4gJ2ZhaWxlZCcgaW4gYnIwID8gYnIxIDogYnIwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZW5zdXJlU3RhY2tzRXF1YWwoYnIwLCBicjEpO1xuICAgICAgICAgICAgcmV0dXJuIGJyMDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXRTdGFjayA9ICgoaW5zdHJ1Y3Rpb24pID0+IHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcbiAgICAgICAgc3dpdGNoIChpbnN0cnVjdGlvbi5wcmltKSB7XG4gICAgICAgICAgICBjYXNlICdEVVAnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IGluc3RydWN0aW9uLmFyZ3MgPyBwYXJzZUludChpbnN0cnVjdGlvbi5hcmdzWzBdLmludCwgMTApIDogMTtcbiAgICAgICAgICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssICdEVVAgMCBpcyBmb3JiaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MobiAtIDEsIG51bGwpWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlSUQocykgPT09ICd0aWNrZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgXCJ0aWNrZXQgY2FuJ3QgYmUgRFVQZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbcywgLi4uc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnU1dBUCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbkFubih7fSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtzWzFdLCBzWzBdLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTT01FJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZSh7IHByaW06ICdvcHRpb24nLCBhcmdzOiBbYXJncygwLCBudWxsKVswXV0gfSwgaW5zdHJ1Y3Rpb25Bbm4oeyB0OiAxLCB2OiAxIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgJ1VOSVQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGUoeyBwcmltOiAndW5pdCcgfSwgaW5zdHJ1Y3Rpb25Bbm4oeyB2OiAxLCB0OiAxIH0pKSwgLi4uc3RhY2tdO1xuICAgICAgICAgICAgY2FzZSAnUEFJUic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gaW5zdHJ1Y3Rpb24uYXJncyA/IHBhcnNlSW50KGluc3RydWN0aW9uLmFyZ3NbMF0uaW50LCAxMCkgOiAyO1xuICAgICAgICAgICAgICAgIGlmIChuIDwgMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGBQQUlSICR7bn0gaXMgZm9yYmlkZGVuYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIC4uLm5ldyBBcnJheShuKS5maWxsKG51bGwpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpYSA9IGluc3RydWN0aW9uQW5uKHsgZjogbiwgdDogMSwgdjogMSB9LCB7IHNwZWNpYWxGaWVsZHM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJpbSA9IChzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGkgPSBzLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzLnNsaWNlKGkgPiAwID8gaSArIDEgOiAxKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldEFyZ3MgPSBzLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZhID0gYXJnQW5uKHYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBmID0gaWEuZiAmJiBpYS5mLmxlbmd0aCA+IGkgJiYgaWEuZltpXSAhPT0gJyUnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlhLmZbaV0gPT09ICclQCdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IHZhLnZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbJyUnICsgdHJpbSgoKF9hID0gdmEudikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hWzBdKSB8fCAnJyldXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBbaWEuZltpXV1cbiAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYW5ub3RhdGUodiwgeyB2OiBudWxsLCB0OiBudWxsLCBmIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdwYWlyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IHJldEFyZ3MsXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgdDogaWEudCwgdjogaWEudiB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UobiksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1VOUEFJUic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gaW5zdHJ1Y3Rpb24uYXJncyA/IHBhcnNlSW50KGluc3RydWN0aW9uLmFyZ3NbMF0uaW50LCAxMCkgOiAyO1xuICAgICAgICAgICAgICAgIGlmIChuIDwgMikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGBVTlBBSVIgJHtufSBpcyBmb3JiaWRkZW5gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgWydwYWlyJ10pWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlhID0gaW5zdHJ1Y3Rpb25Bbm4oeyBmOiAyLCB2OiAyIH0sIHsgc3BlY2lhbFZhcjogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZHMgPSBnZXROKHMsIG4pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkcy5tYXAoKGZpZWxkLCBpKSA9PiBhbm5vdGF0ZUZpZWxkKHMsIGZpZWxkLCBpYSwgaSwgaSA9PT0gMCA/ICdjYXInIDogJ2NkcicpKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0NBUic6XG4gICAgICAgICAgICBjYXNlICdDRFInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IHVucGFja0NvbWIoJ3BhaXInLCBhcmdzKDAsIFsncGFpciddKVswXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBzLmFyZ3NbaW5zdHJ1Y3Rpb24ucHJpbSA9PT0gJ0NBUicgPyAwIDogMV07XG4gICAgICAgICAgICAgICAgY29uc3QgaWEgPSBpbnN0cnVjdGlvbkFubih7IGY6IDEsIHY6IDEgfSwgeyBzcGVjaWFsVmFyOiB0cnVlIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlRmllbGQocywgZmllbGQsIGlhLCAwLCBpbnN0cnVjdGlvbi5wcmltLnRvTG9jYWxlTG93ZXJDYXNlKCkpLFxuICAgICAgICAgICAgICAgICAgICAuLi5zdGFjay5zbGljZSgxKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQ09OUyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsLCBbJ2xpc3QnXSk7XG4gICAgICAgICAgICAgICAgZW5zdXJlVHlwZXNFcXVhbChzWzBdLCBzWzFdLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnbGlzdCcsIGFyZ3M6IFtzWzFdLmFyZ3NbMF1dIH0pLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTSVpFJzpcbiAgICAgICAgICAgICAgICBhcmdzKDAsIFsnc3RyaW5nJywgJ2xpc3QnLCAnc2V0JywgJ21hcCcsICdieXRlcyddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ25hdCcgfSksIC4uLnN0YWNrLnNsaWNlKDEpXTtcbiAgICAgICAgICAgIGNhc2UgJ01FTSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsLCBbJ3NldCcsICdtYXAnLCAnYmlnX21hcCddKTtcbiAgICAgICAgICAgICAgICBlbnN1cmVDb21wYXJhYmxlVHlwZShzWzBdKTtcbiAgICAgICAgICAgICAgICBlbnN1cmVUeXBlc0VxdWFsKHNbMF0sIHNbMV0uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICdib29sJyB9KSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnR0VUJzpcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uYXJncykge1xuICAgICAgICAgICAgICAgICAgICAvLyBjb21iIG9wZXJhdGlvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoaW5zdHJ1Y3Rpb24uYXJnc1swXS5pbnQsIDEwKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgWydwYWlyJ10pWzBdO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKGdldE50aChzLCBuKSksIC4uLnN0YWNrLnNsaWNlKDEpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1hcCBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgbnVsbCwgWydtYXAnLCAnYmlnX21hcCddKTtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlQ29tcGFyYWJsZVR5cGUoc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIGVuc3VyZVR5cGVzRXF1YWwoc1swXSwgc1sxXS5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICdvcHRpb24nLCBhcmdzOiBbc1sxXS5hcmdzWzFdXSB9KSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1VQREFURSc6XG4gICAgICAgICAgICAgICAgaWYgKGluc3RydWN0aW9uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29tYiBvcGVyYXRpb25cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGluc3RydWN0aW9uLmFyZ3NbMF0uaW50LCAxMCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIG51bGwsIFsncGFpciddKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih1cGRhdGVOdGgoc1sxXSwgc1swXSwgbikpLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBtYXAgb3BlcmF0aW9uXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMwID0gYXJncygwLCBudWxsLCBbJ2Jvb2wnLCAnb3B0aW9uJ10pO1xuICAgICAgICAgICAgICAgICAgICBlbnN1cmVDb21wYXJhYmxlVHlwZShzMFswXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzMFsxXS5wcmltID09PSAnYm9vbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHMxID0gYXJncygyLCBbJ3NldCddKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuc3VyZVR5cGVzRXF1YWwoczBbMF0sIHMxWzBdLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZVZhcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYW5ub3RhdGUoczBbMF0sIHsgdDogbnVsbCB9KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMyksXG4gICAgICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHMxID0gYXJncygyLCBbJ21hcCcsICdiaWdfbWFwJ10pO1xuICAgICAgICAgICAgICAgICAgICBlbnN1cmVUeXBlc0VxdWFsKHMwWzBdLCBzMVswXS5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHMxWzBdLnByaW0gPT09ICdtYXAnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlVmFyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ21hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthbm5vdGF0ZShzMFswXSwgeyB0OiBudWxsIH0pLCBhbm5vdGF0ZShzMFsxXS5hcmdzWzBdLCB7IHQ6IG51bGwgfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbnN1cmVCaWdNYXBTdG9yYWJsZVR5cGUoczBbMV0uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZVZhcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ2JpZ19tYXAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthbm5vdGF0ZShzMFswXSwgeyB0OiBudWxsIH0pLCBhbm5vdGF0ZShzMFsxXS5hcmdzWzBdLCB7IHQ6IG51bGwgfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGFjay5zbGljZSgzKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdHRVRfQU5EX1VQREFURSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpYSA9IGluc3RydWN0aW9uQW5uKHsgdjogMiB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsLCBbJ29wdGlvbiddLCBbJ21hcCcsICdiaWdfbWFwJ10pO1xuICAgICAgICAgICAgICAgIGVuc3VyZUNvbXBhcmFibGVUeXBlKHNbMF0pO1xuICAgICAgICAgICAgICAgIGVuc3VyZVR5cGVzRXF1YWwoc1swXSwgc1syXS5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBlbnN1cmVUeXBlc0VxdWFsKHNbMV0uYXJnc1swXSwgc1syXS5hcmdzWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCB2YSA9IChfYSA9IGlhLnYpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tYXAoKHYpID0+ICh2ICE9PSAnQCcgPyBbdl0gOiB1bmRlZmluZWQpKTtcbiAgICAgICAgICAgICAgICBpZiAoc1syXS5wcmltID09PSAnbWFwJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoeyBwcmltOiAnb3B0aW9uJywgYXJnczogW3NbMl0uYXJnc1sxXV0gfSwgeyB2OiB2YSA9PT0gbnVsbCB8fCB2YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFbMF0gfSksXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ21hcCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2Fubm90YXRlKHNbMF0sIHsgdDogbnVsbCB9KSwgYW5ub3RhdGUoc1sxXS5hcmdzWzBdLCB7IHQ6IG51bGwgfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgeyB2OiB2YSA9PT0gbnVsbCB8fCB2YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFbMV0gfSksXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5zdGFjay5zbGljZSgzKSxcbiAgICAgICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5zdXJlQmlnTWFwU3RvcmFibGVUeXBlKHNbMV0uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoeyBwcmltOiAnb3B0aW9uJywgYXJnczogW3NbMl0uYXJnc1sxXV0gfSwgeyB2OiB2YSA9PT0gbnVsbCB8fCB2YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFbMF0gfSksXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdiaWdfbWFwJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthbm5vdGF0ZShzWzBdLCB7IHQ6IG51bGwgfSksIGFubm90YXRlKHNbMV0uYXJnc1swXSwgeyB0OiBudWxsIH0pXSxcbiAgICAgICAgICAgICAgICAgICAgfSwgeyB2OiB2YSA9PT0gbnVsbCB8fCB2YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFbMV0gfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDMpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdFWEVDJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIG51bGwsIFsnbGFtYmRhJ10pO1xuICAgICAgICAgICAgICAgIGVuc3VyZVR5cGVzRXF1YWwoc1swXSwgc1sxXS5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHNbMV0uYXJnc1sxXSksIC4uLnN0YWNrLnNsaWNlKDIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0FQUExZJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIG51bGwsIFsnbGFtYmRhJ10pO1xuICAgICAgICAgICAgICAgIGVuc3VyZVN0b3JhYmxlVHlwZShzWzBdKTtcbiAgICAgICAgICAgICAgICBlbnN1cmVQdXNoYWJsZVR5cGUoc1swXSk7XG4gICAgICAgICAgICAgICAgaWYgKCFpc1BhaXJUeXBlKHNbMV0uYXJnc1swXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfTogZnVuY3Rpb24ncyBhcmd1bWVudCBtdXN0IGJlIGEgcGFpcjogJHt0eXBlSUQoc1sxXS5hcmdzWzBdKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHQgPSBzWzFdLmFyZ3NbMF07XG4gICAgICAgICAgICAgICAgZW5zdXJlVHlwZXNFcXVhbChzWzBdLCB0eXBlQXJncyhwdClbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlVmFyKHsgcHJpbTogJ2xhbWJkYScsIGFyZ3M6IFt0eXBlQXJncyhwdClbMV0sIHNbMV0uYXJnc1sxXV0gfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDIpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdGQUlMV0lUSCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsKVswXTtcbiAgICAgICAgICAgICAgICBpZiAoIVByb3RvSW5mZXJpb3JUbyhwcm90bywgUHJvdG9jb2wuUHRFZG8yWmspKSB7XG4gICAgICAgICAgICAgICAgICAgIGVuc3VyZVBhY2thYmxlVHlwZShzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbGVkOiBzLCBsZXZlbDogMCB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTkVWRVInOlxuICAgICAgICAgICAgICAgIGFyZ3MoMCwgWyduZXZlciddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsZWQ6IHsgcHJpbTogJ25ldmVyJyB9LCBsZXZlbDogMCB9O1xuICAgICAgICAgICAgY2FzZSAnUkVOQU1FJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKGFyZ3MoMCwgbnVsbClbMF0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICBjYXNlICdDT05DQVQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgczAgPSBhcmdzKDAsIFsnc3RyaW5nJywgJ2xpc3QnLCAnYnl0ZXMnXSk7XG4gICAgICAgICAgICAgICAgaWYgKHMwWzBdLnByaW0gPT09ICdsaXN0Jykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZUlEKHMwWzBdLmFyZ3NbMF0pICE9PSAnc3RyaW5nJyAmJiB0eXBlSUQoczBbMF0uYXJnc1swXSkgIT09ICdieXRlcycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGNhbid0IGNvbmNhdGVuYXRlIGxpc3Qgb2YgJHt0eXBlSUQoczBbMF0uYXJnc1swXSl9J3NgKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHMwWzBdLmFyZ3NbMF0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHMxID0gYXJncygxLCBbJ3N0cmluZycsICdieXRlcyddKTtcbiAgICAgICAgICAgICAgICBpZiAoczBbMF0ucHJpbSAhPT0gczFbMF0ucHJpbSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGAke2luc3RydWN0aW9uLnByaW19OiBjYW4ndCBjb25jYXRlbmF0ZSAke3MwWzBdLnByaW19IHdpdGggJHtzMVswXS5wcmltfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHMxWzBdKSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnU0xJQ0UnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlVmFyKHsgcHJpbTogJ29wdGlvbicsIGFyZ3M6IFthcmdzKDAsIFsnbmF0J10sIFsnbmF0J10sIFsnc3RyaW5nJywgJ2J5dGVzJ10pWzJdXSB9LCAnQHNsaWNlJyksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDMpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjYXNlICdQQUNLJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIG51bGwpWzBdO1xuICAgICAgICAgICAgICAgIGVuc3VyZVBhY2thYmxlVHlwZShzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2J5dGVzJyB9LCAnQHBhY2tlZCcpLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBREQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgWyduYXQnLCAnaW50JywgJ3RpbWVzdGFtcCcsICdtdXRleicsICdibHMxMl8zODFfZzEnLCAnYmxzMTJfMzgxX2cyJywgJ2JsczEyXzM4MV9mciddLCBbJ25hdCcsICdpbnQnLCAndGltZXN0YW1wJywgJ211dGV6JywgJ2JsczEyXzM4MV9nMScsICdibHMxMl8zODFfZzInLCAnYmxzMTJfMzgxX2ZyJ10pO1xuICAgICAgICAgICAgICAgIGlmICgoc1swXS5wcmltID09PSAnbmF0JyAmJiBzWzFdLnByaW0gPT09ICdpbnQnKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc1swXS5wcmltID09PSAnaW50JyAmJiBzWzFdLnByaW0gPT09ICduYXQnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2ludCcgfSksIC4uLnN0YWNrLnNsaWNlKDIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHNbMF0ucHJpbSA9PT0gJ2ludCcgJiYgc1sxXS5wcmltID09PSAndGltZXN0YW1wJykgfHxcbiAgICAgICAgICAgICAgICAgICAgKHNbMF0ucHJpbSA9PT0gJ3RpbWVzdGFtcCcgJiYgc1sxXS5wcmltID09PSAnaW50JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICd0aW1lc3RhbXAnIH0pLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKChzWzBdLnByaW0gPT09ICdpbnQnIHx8XG4gICAgICAgICAgICAgICAgICAgIHNbMF0ucHJpbSA9PT0gJ25hdCcgfHxcbiAgICAgICAgICAgICAgICAgICAgc1swXS5wcmltID09PSAnbXV0ZXonIHx8XG4gICAgICAgICAgICAgICAgICAgIHNbMF0ucHJpbSA9PT0gJ2JsczEyXzM4MV9nMScgfHxcbiAgICAgICAgICAgICAgICAgICAgc1swXS5wcmltID09PSAnYmxzMTJfMzgxX2cyJyB8fFxuICAgICAgICAgICAgICAgICAgICBzWzBdLnByaW0gPT09ICdibHMxMl8zODFfZnInKSAmJlxuICAgICAgICAgICAgICAgICAgICBzWzBdLnByaW0gPT09IHNbMV0ucHJpbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHNbMF0pLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGNhbid0IGFkZCAke3NbMF0ucHJpbX0gdG8gJHtzWzFdLnByaW19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTVUInOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IFByb3RvSW5mZXJpb3JUbyhwcm90bywgUHJvdG9jb2wuUHNpVGhhQ2EpXG4gICAgICAgICAgICAgICAgICAgID8gYXJncygwLCBbJ25hdCcsICdpbnQnLCAndGltZXN0YW1wJywgJ211dGV6J10sIFsnbmF0JywgJ2ludCcsICd0aW1lc3RhbXAnLCAnbXV0ZXonXSlcbiAgICAgICAgICAgICAgICAgICAgOiBhcmdzKDAsIFsnbmF0JywgJ2ludCcsICd0aW1lc3RhbXAnXSwgWyduYXQnLCAnaW50JywgJ3RpbWVzdGFtcCddKTtcbiAgICAgICAgICAgICAgICBpZiAoKChzWzBdLnByaW0gPT09ICduYXQnIHx8IHNbMF0ucHJpbSA9PT0gJ2ludCcpICYmXG4gICAgICAgICAgICAgICAgICAgIChzWzFdLnByaW0gPT09ICduYXQnIHx8IHNbMV0ucHJpbSA9PT0gJ2ludCcpKSB8fFxuICAgICAgICAgICAgICAgICAgICAoc1swXS5wcmltID09PSAndGltZXN0YW1wJyAmJiBzWzFdLnByaW0gPT09ICd0aW1lc3RhbXAnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2ludCcgfSksIC4uLnN0YWNrLnNsaWNlKDIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1swXS5wcmltID09PSAndGltZXN0YW1wJyAmJiBzWzFdLnByaW0gPT09ICdpbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAndGltZXN0YW1wJyB9KSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzBdLnByaW0gPT09ICdtdXRleicgJiYgc1sxXS5wcmltID09PSAnbXV0ZXonKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnbXV0ZXonIH0pLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGNhbid0IHN1YnRyYWN0ICR7c1swXS5wcmltfSBmcm9tICR7c1sxXS5wcmltfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnU1VCX01VVEVaJzoge1xuICAgICAgICAgICAgICAgIGFyZ3MoMCwgWydtdXRleiddLCBbJ211dGV6J10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnb3B0aW9uJywgYXJnczogW3sgcHJpbTogJ211dGV6JyB9XSB9KSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTVVMJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnbmF0JywgJ2ludCcsICdtdXRleicsICdibHMxMl8zODFfZzEnLCAnYmxzMTJfMzgxX2cyJywgJ2JsczEyXzM4MV9mciddLCBbJ25hdCcsICdpbnQnLCAnbXV0ZXonLCAnYmxzMTJfMzgxX2cxJywgJ2JsczEyXzM4MV9nMicsICdibHMxMl8zODFfZnInXSk7XG4gICAgICAgICAgICAgICAgaWYgKChzWzBdLnByaW0gPT09ICduYXQnICYmIHNbMV0ucHJpbSA9PT0gJ2ludCcpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzWzBdLnByaW0gPT09ICdpbnQnICYmIHNbMV0ucHJpbSA9PT0gJ25hdCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnaW50JyB9KSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoc1swXS5wcmltID09PSAnbmF0JyAmJiBzWzFdLnByaW0gPT09ICdtdXRleicpIHx8XG4gICAgICAgICAgICAgICAgICAgIChzWzBdLnByaW0gPT09ICdtdXRleicgJiYgc1sxXS5wcmltID09PSAnbmF0JykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICdtdXRleicgfSksIC4uLnN0YWNrLnNsaWNlKDIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKChzWzBdLnByaW0gPT09ICdibHMxMl8zODFfZzEnIHx8XG4gICAgICAgICAgICAgICAgICAgIHNbMF0ucHJpbSA9PT0gJ2JsczEyXzM4MV9nMicgfHxcbiAgICAgICAgICAgICAgICAgICAgc1swXS5wcmltID09PSAnYmxzMTJfMzgxX2ZyJykgJiZcbiAgICAgICAgICAgICAgICAgICAgc1sxXS5wcmltID09PSAnYmxzMTJfMzgxX2ZyJykgfHxcbiAgICAgICAgICAgICAgICAgICAgKChzWzBdLnByaW0gPT09ICduYXQnIHx8IHNbMF0ucHJpbSA9PT0gJ2ludCcpICYmIHNbMF0ucHJpbSA9PT0gc1sxXS5wcmltKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHNbMF0pLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKCgoc1swXS5wcmltID09PSAnbmF0JyB8fCBzWzBdLnByaW0gPT09ICdpbnQnKSAmJiBzWzFdLnByaW0gPT09ICdibHMxMl8zODFfZnInKSB8fFxuICAgICAgICAgICAgICAgICAgICAoKHNbMV0ucHJpbSA9PT0gJ25hdCcgfHwgc1sxXS5wcmltID09PSAnaW50JykgJiYgc1swXS5wcmltID09PSAnYmxzMTJfMzgxX2ZyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICdibHMxMl8zODFfZnInIH0pLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGNhbid0IG11bHRpcGx5ICR7c1swXS5wcmltfSBieSAke3NbMV0ucHJpbX1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0VESVYnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzID0gKGEsIGIpID0+ICh7XG4gICAgICAgICAgICAgICAgICAgIHByaW06ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiBbeyBwcmltOiAncGFpcicsIGFyZ3M6IFt7IHByaW06IGEgfSwgeyBwcmltOiBiIH1dIH1dLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnbmF0JywgJ2ludCcsICdtdXRleiddLCBbJ25hdCcsICdpbnQnLCAnbXV0ZXonXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNbMF0ucHJpbSA9PT0gJ25hdCcgJiYgc1sxXS5wcmltID09PSAnbmF0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHJlcygnbmF0JywgJ25hdCcpKSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgoc1swXS5wcmltID09PSAnbmF0JyB8fCBzWzBdLnByaW0gPT09ICdpbnQnKSAmJlxuICAgICAgICAgICAgICAgICAgICAoc1sxXS5wcmltID09PSAnbmF0JyB8fCBzWzFdLnByaW0gPT09ICdpbnQnKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHJlcygnaW50JywgJ25hdCcpKSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChzWzBdLnByaW0gPT09ICdtdXRleicgJiYgc1sxXS5wcmltID09PSAnbmF0Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHJlcygnbXV0ZXonLCAnbXV0ZXonKSksIC4uLnN0YWNrLnNsaWNlKDIpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoc1swXS5wcmltID09PSAnbXV0ZXonICYmIHNbMV0ucHJpbSA9PT0gJ211dGV6Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHJlcygnbmF0JywgJ211dGV6JykpLCAuLi5zdGFjay5zbGljZSgyKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGNhbid0IGV1Y2xpZGVhbGx5IGRpdmlkZSAke3NbMF0ucHJpbX0gYnkgJHtzWzFdLnByaW19YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdBQlMnOlxuICAgICAgICAgICAgICAgIGFyZ3MoMCwgWydpbnQnXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICduYXQnIH0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICBjYXNlICdJU05BVCc6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2ludCddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ29wdGlvbicsIGFyZ3M6IFt7IHByaW06ICduYXQnIH1dIH0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICBjYXNlICdJTlQnOlxuICAgICAgICAgICAgICAgIGFyZ3MoMCwgWyduYXQnLCAnYmxzMTJfMzgxX2ZyJywgJ2J5dGVzJ10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnaW50JyB9KSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgY2FzZSAnQllURVMnOlxuICAgICAgICAgICAgICAgIGFyZ3MoMCwgWyduYXQnLCAnaW50J10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnYnl0ZXMnIH0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICBjYXNlICdOQVQnOlxuICAgICAgICAgICAgICAgIGFyZ3MoMCwgWydieXRlcyddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ25hdCcgfSksIC4uLnN0YWNrLnNsaWNlKDEpXTtcbiAgICAgICAgICAgIGNhc2UgJ05FRyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBbJ25hdCcsICdpbnQnLCAnYmxzMTJfMzgxX2cxJywgJ2JsczEyXzM4MV9nMicsICdibHMxMl8zODFfZnInXSlbMF07XG4gICAgICAgICAgICAgICAgaWYgKHMucHJpbSA9PT0gJ25hdCcgfHwgcy5wcmltID09PSAnaW50Jykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2ludCcgfSksIC4uLnN0YWNrLnNsaWNlKDEpXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcihzKSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTFNMJzpcbiAgICAgICAgICAgIGNhc2UgJ0xTUic6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ25hdCcsICdieXRlcyddLCBbJ25hdCcsICdieXRlcyddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ25hdCcgfSksIC4uLnN0YWNrLnNsaWNlKDIpXTtcbiAgICAgICAgICAgIGNhc2UgJ09SJzpcbiAgICAgICAgICAgIGNhc2UgJ1hPUic6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBbJ25hdCcsICdieXRlcycsICdib29sJ10sIFsnbmF0JywgJ2J5dGVzJywgJ2Jvb2wnXSk7XG4gICAgICAgICAgICAgICAgaWYgKHNbMF0ucHJpbSAhPT0gc1sxXS5wcmltKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGJvdGggYXJndW1lbnRzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZTogJHtzWzBdLnByaW19LCAke3NbMV0ucHJpbX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcihzWzFdKSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQU5EJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnbmF0JywgJ2J5dGVzJywgJ2Jvb2wnLCAnaW50J10sIFsnbmF0JywgJ2J5dGVzJywgJ2Jvb2wnXSk7XG4gICAgICAgICAgICAgICAgaWYgKChzWzBdLnByaW0gIT09ICdpbnQnIHx8IHNbMV0ucHJpbSAhPT0gJ25hdCcpICYmIHNbMF0ucHJpbSAhPT0gc1sxXS5wcmltKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGJvdGggYXJndW1lbnRzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZTogJHtzWzBdLnByaW19LCAke3NbMV0ucHJpbX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcihzWzFdKSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTk9UJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnbmF0JywgJ2J5dGVzJywgJ2Jvb2wnLCAnaW50J10pWzBdO1xuICAgICAgICAgICAgICAgIGlmIChzLnByaW0gPT09ICdib29sJykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2Jvb2wnIH0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnaW50JyB9KSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQ09NUEFSRSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICBlbnN1cmVDb21wYXJhYmxlVHlwZShzWzBdKTtcbiAgICAgICAgICAgICAgICBlbnN1cmVDb21wYXJhYmxlVHlwZShzWzFdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2ludCcgfSksIC4uLnN0YWNrLnNsaWNlKDIpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0VRJzpcbiAgICAgICAgICAgIGNhc2UgJ05FUSc6XG4gICAgICAgICAgICBjYXNlICdMVCc6XG4gICAgICAgICAgICBjYXNlICdHVCc6XG4gICAgICAgICAgICBjYXNlICdMRSc6XG4gICAgICAgICAgICBjYXNlICdHRSc6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2ludCddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2Jvb2wnIH0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICBjYXNlICdTRUxGJzoge1xuICAgICAgICAgICAgICAgIGlmICgoY3R4ID09PSBudWxsIHx8IGN0eCA9PT0gdm9pZCAwID8gdm9pZCAwIDogY3R4LmNvbnRyYWN0KSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGNvbnRyYWN0IHJlcXVpcmVkYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGlhID0gaW5zdHJ1Y3Rpb25Bbm4oeyBmOiAxLCB2OiAxIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVwID0gY29udHJhY3RFbnRyeVBvaW50KGN0eC5jb250cmFjdCwgKF9iID0gaWEuZikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAoZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfTogY29udHJhY3QgaGFzIG5vIGVudHJ5cG9pbnQgJHtlcH1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoeyBwcmltOiAnY29udHJhY3QnLCBhcmdzOiBbZXBdIH0sIHsgdjogaWEudiA/IGlhLnYgOiBbJ0BzZWxmJ10gfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdUUkFOU0ZFUl9UT0tFTlMnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgbnVsbCwgWydtdXRleiddLCBbJ2NvbnRyYWN0J10pO1xuICAgICAgICAgICAgICAgIGVuc3VyZVR5cGVzRXF1YWwoc1swXSwgc1syXS5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ29wZXJhdGlvbicgfSksIC4uLnN0YWNrLnNsaWNlKDMpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NFVF9ERUxFR0FURSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBbJ29wdGlvbiddKVswXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUlEKHMuYXJnc1swXSkgIT09ICdrZXlfaGFzaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfToga2V5IGhhc2ggZXhwZWN0ZWQ6ICR7dHlwZUlEKHMuYXJnc1swXSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnb3BlcmF0aW9uJyB9KSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnSU1QTElDSVRfQUNDT1VOVCc6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2tleV9oYXNoJ10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnY29udHJhY3QnLCBhcmdzOiBbeyBwcmltOiAndW5pdCcgfV0gfSksIC4uLnN0YWNrLnNsaWNlKDEpXTtcbiAgICAgICAgICAgIGNhc2UgJ05PVyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICd0aW1lc3RhbXAnIH0sICdAbm93JyksIC4uLnN0YWNrXTtcbiAgICAgICAgICAgIGNhc2UgJ0FNT1VOVCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICdtdXRleicgfSwgJ0BhbW91bnQnKSwgLi4uc3RhY2tdO1xuICAgICAgICAgICAgY2FzZSAnQkFMQU5DRSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICdtdXRleicgfSwgJ0BiYWxhbmNlJyksIC4uLnN0YWNrXTtcbiAgICAgICAgICAgIGNhc2UgJ0NIRUNLX1NJR05BVFVSRSc6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2tleSddLCBbJ3NpZ25hdHVyZSddLCBbJ2J5dGVzJ10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnYm9vbCcgfSksIC4uLnN0YWNrLnNsaWNlKDMpXTtcbiAgICAgICAgICAgIGNhc2UgJ0JMQUtFMkInOlxuICAgICAgICAgICAgY2FzZSAnU0hBMjU2JzpcbiAgICAgICAgICAgIGNhc2UgJ1NIQTUxMic6XG4gICAgICAgICAgICBjYXNlICdLRUNDQUsnOlxuICAgICAgICAgICAgY2FzZSAnU0hBMyc6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2J5dGVzJ10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnYnl0ZXMnIH0pLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICBjYXNlICdIQVNIX0tFWSc6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2tleSddKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2tleV9oYXNoJyB9KSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgY2FzZSAnU09VUkNFJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2FkZHJlc3MnIH0sICdAc291cmNlJyksIC4uLnN0YWNrXTtcbiAgICAgICAgICAgIGNhc2UgJ1NFTkRFUic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICdhZGRyZXNzJyB9LCAnQHNlbmRlcicpLCAuLi5zdGFja107XG4gICAgICAgICAgICBjYXNlICdBRERSRVNTJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnY29udHJhY3QnXSlbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgaWEgPSBpbnN0cnVjdGlvbkFubih7IHY6IDEgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoeyBwcmltOiAnYWRkcmVzcycsIFtyZWZDb250cmFjdF06IHMgfSwgeyB2OiBpYS52ID8gaWEudiA6IHZhclN1ZmZpeChhcmdBbm4ocyksICdhZGRyZXNzJykgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdTRUxGX0FERFJFU1MnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkciA9IHsgcHJpbTogJ2FkZHJlc3MnIH07XG4gICAgICAgICAgICAgICAgaWYgKChjdHggPT09IG51bGwgfHwgY3R4ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdHguY29udHJhY3QpICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgYWRkcltyZWZDb250cmFjdF0gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmltOiAnY29udHJhY3QnLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2NvbnRyYWN0U2VjdGlvbihjdHguY29udHJhY3QsICdwYXJhbWV0ZXInKS5hcmdzWzBdXSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcihhZGRyLCAnQGFkZHJlc3MnKSwgLi4uc3RhY2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnQ0hBSU5fSUQnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnY2hhaW5faWQnIH0pLCAuLi5zdGFja107XG4gICAgICAgICAgICBjYXNlICdEUk9QJzoge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uQW5uKHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gaW5zdHJ1Y3Rpb24uYXJncyAhPT0gdW5kZWZpbmVkID8gcGFyc2VJbnQoaW5zdHJ1Y3Rpb24uYXJnc1swXS5pbnQsIDEwKSA6IDE7XG4gICAgICAgICAgICAgICAgYXJncyhuIC0gMSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0YWNrLnNsaWNlKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnRElHJzoge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uQW5uKHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoaW5zdHJ1Y3Rpb24uYXJnc1swXS5pbnQsIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2FyZ3MobiwgbnVsbClbMF0sIC4uLnN0YWNrLnNsaWNlKDAsIG4pLCAuLi5zdGFjay5zbGljZShuICsgMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnRFVHJzoge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uQW5uKHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoaW5zdHJ1Y3Rpb24uYXJnc1swXS5pbnQsIDEwKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gWy4uLnN0YWNrLnNsaWNlKDEsIG4gKyAxKSwgYXJncygwLCBudWxsKVswXSwgLi4uc3RhY2suc2xpY2UobiArIDEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ05PTkUnOlxuICAgICAgICAgICAgICAgIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKGluc3RydWN0aW9uLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHsgcHJpbTogJ29wdGlvbicsIGFyZ3M6IFtpbnN0cnVjdGlvbi5hcmdzWzBdXSB9LCBpbnN0cnVjdGlvbkFubih7IHQ6IDEsIHY6IDEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAuLi5zdGFjayxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgY2FzZSAnTEVGVCc6XG4gICAgICAgICAgICBjYXNlICdSSUdIVCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsKVswXTtcbiAgICAgICAgICAgICAgICBjb25zdCBpYSA9IGluc3RydWN0aW9uQW5uKHsgZjogMiwgdDogMSwgdjogMSB9LCB7IHNwZWNpYWxGaWVsZHM6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdmEgPSBhcmdBbm4ocyk7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hpbGRyZW4gPSBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHMsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgZjogaWEuZiAmJiBpYS5mLmxlbmd0aCA+IDAgJiYgaWEuZlswXSAhPT0gJyUnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpYS5mWzBdID09PSAnJUAnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdmEudlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBbJyUnICsgdmEudlswXS5zbGljZSgxKV1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogaWEuZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoaW5zdHJ1Y3Rpb24uYXJnc1swXSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgdDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGY6IGlhLmYgJiYgaWEuZi5sZW5ndGggPiAxICYmIGlhLmZbMV0gIT09ICclJyA/IGlhLmYgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ29yJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IGluc3RydWN0aW9uLnByaW0gPT09ICdMRUZUJyA/IGNoaWxkcmVuIDogW2NoaWxkcmVuWzFdLCBjaGlsZHJlblswXV0sXG4gICAgICAgICAgICAgICAgICAgIH0sIHsgdDogaWEudCwgdjogaWEudiB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ05JTCc6XG4gICAgICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoaW5zdHJ1Y3Rpb24uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoeyBwcmltOiAnbGlzdCcsIGFyZ3M6IFtpbnN0cnVjdGlvbi5hcmdzWzBdXSB9LCBpbnN0cnVjdGlvbkFubih7IHQ6IDEsIHY6IDEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAuLi5zdGFjayxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgY2FzZSAnVU5QQUNLJzpcbiAgICAgICAgICAgICAgICBhcmdzKDAsIFsnYnl0ZXMnXSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoaW5zdHJ1Y3Rpb24uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVWYXIoeyBwcmltOiAnb3B0aW9uJywgYXJnczogW2luc3RydWN0aW9uLmFyZ3NbMF1dIH0sICdAdW5wYWNrZWQnKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgJ0NPTlRSQUNUJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnYWRkcmVzcyddKVswXTtcbiAgICAgICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZChpbnN0cnVjdGlvbi5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpYSA9IGluc3RydWN0aW9uQW5uKHsgdjogMSwgZjogMSB9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250cmFjdCA9IHNbcmVmQ29udHJhY3RdO1xuICAgICAgICAgICAgICAgIGlmIChjb250cmFjdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVwID0gY29udHJhY3RFbnRyeVBvaW50KGNvbnRyYWN0LCAoX2MgPSBpYS5mKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2NbMF0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGNvbnRyYWN0IGhhcyBubyBlbnRyeXBvaW50ICR7ZXB9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlVHlwZXNFcXVhbChlcCwgaW5zdHJ1Y3Rpb24uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHsgcHJpbTogJ29wdGlvbicsIGFyZ3M6IFt7IHByaW06ICdjb250cmFjdCcsIGFyZ3M6IFtpbnN0cnVjdGlvbi5hcmdzWzBdXSB9XSB9LCB7IHY6IGlhLnYgPyBpYS52IDogdmFyU3VmZml4KGFyZ0FubihzKSwgJ2NvbnRyYWN0JykgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDQVNUJzoge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uQW5uKHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsKVswXTtcbiAgICAgICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZChpbnN0cnVjdGlvbi5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBlbnN1cmVUeXBlc0VxdWFsKGluc3RydWN0aW9uLmFyZ3NbMF0sIHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBbaW5zdHJ1Y3Rpb24uYXJnc1swXSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnSUZfTk9ORSc6IHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbkFubih7fSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgWydvcHRpb24nXSlbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFpbCA9IHN0YWNrLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyMCA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMF0sIHRhaWwsIGN0eCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnIxID0gZnVuY3Rpb25UeXBlSW50ZXJuYWwoaW5zdHJ1Y3Rpb24uYXJnc1sxXSwgW2Fubm90YXRlKHMuYXJnc1swXSwgeyB0OiBudWxsLCB2OiB2YXJTdWZmaXgoYXJnQW5uKHMpLCAnc29tZScpIH0pLCAuLi50YWlsXSwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJhbmNoVHlwZShicjAsIGJyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdJRl9MRUZUJzoge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uQW5uKHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBbJ29yJ10pWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhID0gYXJnQW5uKHMpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlZnRhID0gYXJnQW5uKHMuYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmlnaHRhID0gYXJnQW5uKHMuYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFpbCA9IHN0YWNrLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyMCA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMF0sIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUocy5hcmdzWzBdLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0OiBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgdjogdmFyU3VmZml4KHZhLCBsZWZ0YS5mID8gbGVmdGEuZlswXS5zbGljZSgxKSA6ICdsZWZ0JyksXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi50YWlsLFxuICAgICAgICAgICAgICAgIF0sIGN0eCk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnIxID0gZnVuY3Rpb25UeXBlSW50ZXJuYWwoaW5zdHJ1Y3Rpb24uYXJnc1sxXSwgW1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZShzLmFyZ3NbMV0sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQ6IG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICB2OiB2YXJTdWZmaXgodmEsIHJpZ2h0YS5mID8gcmlnaHRhLmZbMF0uc2xpY2UoMSkgOiAncmlnaHQnKSxcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnRhaWwsXG4gICAgICAgICAgICAgICAgXSwgY3R4KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYnJhbmNoVHlwZShicjAsIGJyMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdJRl9DT05TJzoge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uQW5uKHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBbJ2xpc3QnXSlbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmEgPSBhcmdBbm4ocyk7XG4gICAgICAgICAgICAgICAgY29uc3QgdGFpbCA9IHN0YWNrLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyMCA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMF0sIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUocy5hcmdzWzBdLCB7IHQ6IG51bGwsIHY6IHZhclN1ZmZpeCh2YSwgJ2hkJykgfSksXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHMsIHsgdDogbnVsbCwgdjogdmFyU3VmZml4KHZhLCAndGwnKSB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4udGFpbCxcbiAgICAgICAgICAgICAgICBdLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyMSA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMV0sIHRhaWwsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyYW5jaFR5cGUoYnIwLCBicjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnSUYnOiB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25Bbm4oe30pO1xuICAgICAgICAgICAgICAgIGFyZ3MoMCwgWydib29sJ10pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBzdGFjay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBicjAgPSBmdW5jdGlvblR5cGVJbnRlcm5hbChpbnN0cnVjdGlvbi5hcmdzWzBdLCB0YWlsLCBjdHgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJyMSA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMV0sIHRhaWwsIGN0eCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGJyYW5jaFR5cGUoYnIwLCBicjEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTUFQJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnbGlzdCcsICdtYXAnLCAnb3B0aW9uJ10pWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBzdGFjay5zbGljZSgxKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlbHQgPSBzLnByaW0gPT09ICdtYXAnID8geyBwcmltOiAncGFpcicsIGFyZ3M6IHMuYXJncyB9IDogcy5hcmdzWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBmdW5jdGlvblR5cGVJbnRlcm5hbChpbnN0cnVjdGlvbi5hcmdzWzBdLCBbYW5ub3RhdGUoZWx0LCB7IHQ6IG51bGwsIHY6IHZhclN1ZmZpeChhcmdBbm4ocyksICdlbHQnKSB9KSwgLi4udGFpbF0sIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKCdmYWlsZWQnIGluIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEoJ3ByaW0nIGluIGJvZHkuZmFpbGVkKSB8fCBib2R5LmZhaWxlZC5wcmltICE9PSAnbmV2ZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGAke2luc3RydWN0aW9uLnByaW19OiBGQUlMIGlzIG5vdCBhbGxvd2VkIGluIE1BUGApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWxlZDogYm9keS5mYWlsZWQsIGxldmVsOiBib2R5LmxldmVsICsgMSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoYm9keS5sZW5ndGggPCAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdmFsdWVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5zdXJlU3RhY2tzRXF1YWwoYm9keS5zbGljZSgxKSwgdGFpbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHMucHJpbSA9PT0gJ2xpc3QnXG4gICAgICAgICAgICAgICAgICAgID8gW2Fubm90YXRlVmFyKHsgcHJpbTogJ2xpc3QnLCBhcmdzOiBbYm9keVswXV0gfSksIC4uLnRhaWxdXG4gICAgICAgICAgICAgICAgICAgIDogcy5wcmltID09PSAnbWFwJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBbYW5ub3RhdGVWYXIoeyBwcmltOiAnbWFwJywgYXJnczogW3MuYXJnc1swXSwgYm9keVswXV0gfSksIC4uLnRhaWxdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFthbm5vdGF0ZVZhcih7IHByaW06ICdvcHRpb24nLCBhcmdzOiBbYm9keVswXV0gfSksIC4uLnRhaWxdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnSVRFUic6IHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbkFubih7fSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgWydzZXQnLCAnbGlzdCcsICdtYXAnXSlbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFpbCA9IHN0YWNrLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVsdCA9IHMucHJpbSA9PT0gJ21hcCcgPyB7IHByaW06ICdwYWlyJywgYXJnczogcy5hcmdzIH0gOiBzLmFyZ3NbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMF0sIFthbm5vdGF0ZShlbHQsIHsgdDogbnVsbCwgdjogdmFyU3VmZml4KGFyZ0FubihzKSwgJ2VsdCcpIH0pLCAuLi50YWlsXSwgY3R4KTtcbiAgICAgICAgICAgICAgICBpZiAoJ2ZhaWxlZCcgaW4gYm9keSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsZWQ6IGJvZHkuZmFpbGVkLCBsZXZlbDogYm9keS5sZXZlbCArIDEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5zdXJlU3RhY2tzRXF1YWwoYm9keSwgdGFpbCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdMT09QJzoge1xuICAgICAgICAgICAgICAgIGluc3RydWN0aW9uQW5uKHt9KTtcbiAgICAgICAgICAgICAgICBhcmdzKDAsIFsnYm9vbCddKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0YWlsID0gc3RhY2suc2xpY2UoMSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMF0sIHRhaWwsIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKCdmYWlsZWQnIGluIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbGVkOiBib2R5LmZhaWxlZCwgbGV2ZWw6IGJvZHkubGV2ZWwgKyAxIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVuc3VyZVN0YWNrc0VxdWFsKGJvZHksIFt7IHByaW06ICdib29sJyB9LCAuLi50YWlsXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhaWw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdMT09QX0xFRlQnOiB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25Bbm4oe30pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIFsnb3InXSlbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdGFpbCA9IHN0YWNrLnNsaWNlKDEpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvZHkgPSBmdW5jdGlvblR5cGVJbnRlcm5hbChpbnN0cnVjdGlvbi5hcmdzWzBdLCBbYW5ub3RhdGUocy5hcmdzWzBdLCB7IHQ6IG51bGwsIHY6IHZhclN1ZmZpeChhcmdBbm4ocyksICdsZWZ0JykgfSksIC4uLnRhaWxdLCBjdHgpO1xuICAgICAgICAgICAgICAgIGlmICgnZmFpbGVkJyBpbiBib2R5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGZhaWxlZDogYm9keS5mYWlsZWQsIGxldmVsOiBib2R5LmxldmVsICsgMSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbnN1cmVTdGFja3NFcXVhbChib2R5LCBbcywgLi4udGFpbF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGUocy5hcmdzWzFdLCB7IHQ6IG51bGwsIHY6IGluc3RydWN0aW9uQW5uKHsgdjogMSB9KS52IH0pLCAuLi50YWlsXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0RJUCc6IHtcbiAgICAgICAgICAgICAgICBpbnN0cnVjdGlvbkFubih7fSk7XG4gICAgICAgICAgICAgICAgY29uc3QgbiA9IGluc3RydWN0aW9uLmFyZ3MubGVuZ3RoID09PSAyID8gcGFyc2VJbnQoaW5zdHJ1Y3Rpb24uYXJnc1swXS5pbnQsIDEwKSA6IDE7XG4gICAgICAgICAgICAgICAgYXJncyhuIC0gMSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgY29uc3QgaGVhZCA9IHN0YWNrLnNsaWNlKDAsIG4pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhaWwgPSBzdGFjay5zbGljZShuKTtcbiAgICAgICAgICAgICAgICAvLyB0ZXJuYXJ5IG9wZXJhdG9yIGlzIGEgdHlwZSBndWFyZCBzbyB1c2UgaXQgaW5zdGVhZCBvZiBqdXN0IGBpbnN0cnVjdGlvbi5hcmdzLmxlbmd0aCAtIDFgXG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGluc3RydWN0aW9uLmFyZ3MubGVuZ3RoID09PSAyXG4gICAgICAgICAgICAgICAgICAgID8gZnVuY3Rpb25UeXBlSW50ZXJuYWwoaW5zdHJ1Y3Rpb24uYXJnc1sxXSwgdGFpbCwgY3R4KVxuICAgICAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMF0sIHRhaWwsIGN0eCk7XG4gICAgICAgICAgICAgICAgaWYgKCdmYWlsZWQnIGluIGJvZHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgZmFpbGVkOiBib2R5LmZhaWxlZCwgbGV2ZWw6IGJvZHkubGV2ZWwgKyAxIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbLi4uaGVhZCwgLi4uYm9keV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdDUkVBVEVfQ09OVFJBQ1QnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWEgPSBpbnN0cnVjdGlvbkFubih7IHY6IDIgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgWydvcHRpb24nXSwgWydtdXRleiddLCBudWxsKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUlEKHNbMF0uYXJnc1swXSkgIT09ICdrZXlfaGFzaCcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IoaW5zdHJ1Y3Rpb24sIHN0YWNrLCBgJHtpbnN0cnVjdGlvbi5wcmltfToga2V5IGhhc2ggZXhwZWN0ZWQ6ICR7dHlwZUlEKHNbMF0uYXJnc1swXSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlbnN1cmVTdG9yYWJsZVR5cGUoc1syXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0Q29udHJhY3RWYWxpZChpbnN0cnVjdGlvbi5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgYXNzZXJ0U2NhbGFyVHlwZXNFcXVhbChjb250cmFjdFNlY3Rpb24oaW5zdHJ1Y3Rpb24uYXJnc1swXSwgJ3N0b3JhZ2UnKS5hcmdzWzBdLCBzWzJdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmEgPSAoX2QgPSBpYS52KSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QubWFwKCh2KSA9PiAodiAhPT0gJ0AnID8gW3ZdIDogdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoeyBwcmltOiAnb3BlcmF0aW9uJyB9LCB7IHY6IHZhID09PSBudWxsIHx8IHZhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YVswXSB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ2FkZHJlc3MnLFxuICAgICAgICAgICAgICAgICAgICAgICAgW3JlZkNvbnRyYWN0XToge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdjb250cmFjdCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW2NvbnRyYWN0U2VjdGlvbihpbnN0cnVjdGlvbi5hcmdzWzBdLCAncGFyYW1ldGVyJykuYXJnc1swXV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9LCB7IHY6IHZhID09PSBudWxsIHx8IHZhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YVsxXSB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMyksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1BVU0gnOlxuICAgICAgICAgICAgICAgIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKGluc3RydWN0aW9uLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGFzc2VydERhdGFWYWxpZEludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMV0sIGluc3RydWN0aW9uLmFyZ3NbMF0sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3R4KSwgeyBjb250cmFjdDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKGluc3RydWN0aW9uLmFyZ3NbMF0pLCAuLi5zdGFja107XG4gICAgICAgICAgICBjYXNlICdFTVBUWV9TRVQnOlxuICAgICAgICAgICAgICAgIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKGluc3RydWN0aW9uLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIGVuc3VyZUNvbXBhcmFibGVUeXBlKGluc3RydWN0aW9uLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHsgcHJpbTogJ3NldCcsIGFyZ3M6IGluc3RydWN0aW9uLmFyZ3MgfSwgaW5zdHJ1Y3Rpb25Bbm4oeyB0OiAxLCB2OiAxIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2ssXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgJ0VNUFRZX01BUCc6XG4gICAgICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoaW5zdHJ1Y3Rpb24uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgZW5zdXJlQ29tcGFyYWJsZVR5cGUoaW5zdHJ1Y3Rpb24uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoaW5zdHJ1Y3Rpb24uYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoeyBwcmltOiAnbWFwJywgYXJnczogaW5zdHJ1Y3Rpb24uYXJncyB9LCBpbnN0cnVjdGlvbkFubih7IHQ6IDEsIHY6IDEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAuLi5zdGFjayxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgY2FzZSAnRU1QVFlfQklHX01BUCc6XG4gICAgICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoaW5zdHJ1Y3Rpb24uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgZW5zdXJlQ29tcGFyYWJsZVR5cGUoaW5zdHJ1Y3Rpb24uYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoaW5zdHJ1Y3Rpb24uYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgZW5zdXJlQmlnTWFwU3RvcmFibGVUeXBlKGluc3RydWN0aW9uLmFyZ3NbMF0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHsgcHJpbTogJ2JpZ19tYXAnLCBhcmdzOiBpbnN0cnVjdGlvbi5hcmdzIH0sIGluc3RydWN0aW9uQW5uKHsgdDogMSwgdjogMSB9KSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICBjYXNlICdMQU1CREFfUkVDJzpcbiAgICAgICAgICAgIGNhc2UgJ0xBTUJEQSc6IHtcbiAgICAgICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZChpbnN0cnVjdGlvbi5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZChpbnN0cnVjdGlvbi5hcmdzWzFdKTtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gW2luc3RydWN0aW9uLmFyZ3NbMF1dO1xuICAgICAgICAgICAgICAgIGlmIChpbnN0cnVjdGlvbi5wcmltID09PSAnTEFNQkRBX1JFQycpIHtcbiAgICAgICAgICAgICAgICAgICAgcy5wdXNoKHsgcHJpbTogJ2xhbWJkYScsIGFyZ3M6IFtpbnN0cnVjdGlvbi5hcmdzWzBdLCBpbnN0cnVjdGlvbi5hcmdzWzFdXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYm9keSA9IGZ1bmN0aW9uVHlwZUludGVybmFsKGluc3RydWN0aW9uLmFyZ3NbMl0sIHMsIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3R4KSwgeyBjb250cmFjdDogdW5kZWZpbmVkIH0pKTtcbiAgICAgICAgICAgICAgICBpZiAoJ2ZhaWxlZCcgaW4gYm9keSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBmYWlsZWQ6IGJvZHkuZmFpbGVkLCBsZXZlbDogYm9keS5sZXZlbCArIDEgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGJvZHkubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGZ1bmN0aW9uIG11c3QgcmV0dXJuIGEgdmFsdWVgKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5zdXJlVHlwZXNFcXVhbChpbnN0cnVjdGlvbi5hcmdzWzFdLCBib2R5WzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZVZhcih7IHByaW06ICdsYW1iZGEnLCBhcmdzOiBbaW5zdHJ1Y3Rpb24uYXJnc1swXSwgaW5zdHJ1Y3Rpb24uYXJnc1sxXV0gfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdMRVZFTCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZVZhcih7IHByaW06ICduYXQnIH0sICdAbGV2ZWwnKSwgLi4uc3RhY2tdO1xuICAgICAgICAgICAgY2FzZSAnVE9UQUxfVk9USU5HX1BPV0VSJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ25hdCcgfSksIC4uLnN0YWNrXTtcbiAgICAgICAgICAgIGNhc2UgJ1ZPVElOR19QT1dFUic6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2tleV9oYXNoJ10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnbmF0JyB9KSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgY2FzZSAnVElDS0VUJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHMgPSBhcmdzKDAsIG51bGwsIFsnbmF0J10pWzBdO1xuICAgICAgICAgICAgICAgIGVuc3VyZUNvbXBhcmFibGVUeXBlKHMpO1xuICAgICAgICAgICAgICAgIGlmIChQcm90b0luZmVyaW9yVG8ocHJvdG8sIFByb3RvY29sLlB0TGltYVB0TCkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHsgcHJpbTogJ3RpY2tldCcsIGFyZ3M6IFtzXSB9LCBpbnN0cnVjdGlvbkFubih7IHQ6IDEsIHY6IDEgfSkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMiksXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVWYXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthbm5vdGF0ZSh7IHByaW06ICd0aWNrZXQnLCBhcmdzOiBbc10gfSwgaW5zdHJ1Y3Rpb25Bbm4oeyB0OiAxLCB2OiAxIH0pKV0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDIpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ0pPSU5fVElDS0VUUyc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gdW5wYWNrQ29tYigncGFpcicsIGFyZ3MoMCwgWydwYWlyJ10pWzBdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUlEKHMuYXJnc1swXSkgIT09ICd0aWNrZXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IHRpY2tldCBleHBlY3RlZDogJHt0eXBlSUQocy5hcmdzWzBdKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5zdXJlVHlwZXNFcXVhbChzLmFyZ3NbMF0sIHMuYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVWYXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbYW5ub3RhdGUocy5hcmdzWzBdLCB7IHQ6IG51bGwgfSldLFxuICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMSksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NQTElUX1RJQ0tFVCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBbJ3RpY2tldCddLCBbJ3BhaXInXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcCA9IHVucGFja0NvbWIoJ3BhaXInLCBzWzFdKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUlEKHAuYXJnc1swXSkgIT09ICduYXQnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IG5hdCBleHBlY3RlZDogJHt0eXBlSUQocC5hcmdzWzBdKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZW5zdXJlVHlwZXNFcXVhbChwLmFyZ3NbMF0sIHAuYXJnc1sxXSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVWYXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltOiAncGFpcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFthbm5vdGF0ZShzWzBdLCB7IHQ6IG51bGwgfSksIGFubm90YXRlKHNbMF0sIHsgdDogbnVsbCB9KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICAuLi5zdGFjay5zbGljZSgyKSxcbiAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnUkVBRF9USUNLRVQnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWEgPSBpbnN0cnVjdGlvbkFubih7IHY6IDIgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgWyd0aWNrZXQnXSlbMF07XG4gICAgICAgICAgICAgICAgY29uc3QgdmEgPSAoX2UgPSBpYS52KSA9PT0gbnVsbCB8fCBfZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2UubWFwKCh2KSA9PiAodiAhPT0gJ0AnID8gW3ZdIDogdW5kZWZpbmVkKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ3BhaXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW3sgcHJpbTogJ2FkZHJlc3MnIH0sIGFubm90YXRlKHMuYXJnc1swXSwgeyB0OiBudWxsIH0pLCB7IHByaW06ICduYXQnIH1dLFxuICAgICAgICAgICAgICAgICAgICB9LCB7IHY6IHZhID09PSBudWxsIHx8IHZhID09PSB2b2lkIDAgPyB2b2lkIDAgOiB2YVswXSB9KSxcbiAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGUocywgeyB2OiB2YSA9PT0gbnVsbCB8fCB2YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogdmFbMV0sIHQ6IG51bGwgfSksXG4gICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDEpLFxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdQQUlSSU5HX0NIRUNLJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSBhcmdzKDAsIFsnbGlzdCddKVswXS5hcmdzWzBdO1xuICAgICAgICAgICAgICAgIGlmICghaXNQYWlyVHlwZShwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGAke2luc3RydWN0aW9uLnByaW19OiBwYWlyIGV4cGVjdGVkOiAke3R5cGVJRChwKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHVucGFja0NvbWIoJ3BhaXInLCBwKTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZUlEKGMuYXJnc1swXSkgIT09ICdibHMxMl8zODFfZzEnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGluc3RydWN0aW9uLCBzdGFjaywgYCR7aW5zdHJ1Y3Rpb24ucHJpbX06IGJsczEyXzM4MV9nMSBleHBlY3RlZDogJHt0eXBlSUQoYy5hcmdzWzBdKX1gKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVJRChjLmFyZ3NbMV0pICE9PSAnYmxzMTJfMzgxX2cyJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGAke2luc3RydWN0aW9uLnByaW19OiBibHMxMl8zODFfZzIgZXhwZWN0ZWQ6ICR7dHlwZUlEKGMuYXJnc1sxXSl9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnYm9vbCcgfSksIC4uLnN0YWNrLnNsaWNlKDEpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ1NBUExJTkdfRU1QVFlfU1RBVEUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlKHsgcHJpbTogJ3NhcGxpbmdfc3RhdGUnLCBhcmdzOiBbaW5zdHJ1Y3Rpb24uYXJnc1swXV0gfSwgaW5zdHJ1Y3Rpb25Bbm4oeyB2OiAxLCB0OiAxIH0pKSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2ssXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgJ1NBUExJTkdfVkVSSUZZX1VQREFURSc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBbJ3NhcGxpbmdfdHJhbnNhY3Rpb24nXSwgWydzYXBsaW5nX3N0YXRlJ10pO1xuICAgICAgICAgICAgICAgIGlmIChwYXJzZUludChzWzBdLmFyZ3NbMF0uaW50LCAxMCkgIT09IHBhcnNlSW50KHNbMV0uYXJnc1swXS5pbnQsIDEwKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWljaGVsc29uSW5zdHJ1Y3Rpb25FcnJvcihpbnN0cnVjdGlvbiwgc3RhY2ssIGAke2luc3RydWN0aW9uLnByaW19OiBzYXBsaW5nIG1lbW8gc2l6ZSBtaXNtYXRjaDogJHtzWzBdLmFyZ3NbMF0uaW50fSAhPSAke3NbMV0uYXJnc1swXS5pbnR9YCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBQcm90b0luZmVyaW9yVG8ocHJvdG8sIFByb3RvY29sLlB0SmFrYXJ0YSlcbiAgICAgICAgICAgICAgICAgICAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICBhbm5vdGF0ZVZhcih7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ29wdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmltOiAncGFpcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbeyBwcmltOiAnaW50JyB9LCBhbm5vdGF0ZShzWzFdLCB7IHQ6IG51bGwgfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDIpLFxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIDogW1xuICAgICAgICAgICAgICAgICAgICAgICAgYW5ub3RhdGVWYXIoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdvcHRpb24nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ3BhaXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJnczogW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ2J5dGVzJyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogJ3BhaXInLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBbeyBwcmltOiAnaW50JyB9LCBhbm5vdGF0ZShzWzFdLCB7IHQ6IG51bGwgfSldLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnN0YWNrLnNsaWNlKDIpLFxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnT1BFTl9DSEVTVCc6XG4gICAgICAgICAgICAgICAgYXJncygwLCBbJ2NoZXN0X2tleSddLCBbJ2NoZXN0J10sIFsnbmF0J10pO1xuICAgICAgICAgICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAgICAgICAgIGFubm90YXRlVmFyKHsgcHJpbTogJ29yJywgYXJnczogW3sgcHJpbTogJ2J5dGVzJyB9LCB7IHByaW06ICdib29sJyB9XSB9KSxcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RhY2suc2xpY2UoMyksXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIGNhc2UgJ1ZJRVcnOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcyA9IGFyZ3MoMCwgbnVsbCwgWydhZGRyZXNzJ10pO1xuICAgICAgICAgICAgICAgIGVuc3VyZVB1c2hhYmxlVHlwZShzWzBdKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlVmFyKHsgcHJpbTogJ29wdGlvbicsIGFyZ3M6IFtpbnN0cnVjdGlvbi5hcmdzWzFdXSB9KSwgLi4uc3RhY2suc2xpY2UoMildO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnTUlOX0JMT0NLX1RJTUUnOlxuICAgICAgICAgICAgICAgIHJldHVybiBbYW5ub3RhdGVWYXIoeyBwcmltOiAnbmF0JyB9KSwgLi4uc3RhY2tdO1xuICAgICAgICAgICAgY2FzZSAnRU1JVCc6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpYSA9IGluc3RydWN0aW9uQW5uKHsgZjogMSwgdDogMSB9KTtcbiAgICAgICAgICAgICAgICBpZiAoaW5zdHJ1Y3Rpb24uYXJncykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzID0gYXJncygwLCBudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgZW5zdXJlVHlwZXNFcXVhbChzWzBdLCBpbnN0cnVjdGlvbi5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFthbm5vdGF0ZSh7IHByaW06ICdvcGVyYXRpb24nIH0sIGlhKSwgLi4uc3RhY2suc2xpY2UoMSldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW2Fubm90YXRlKHsgcHJpbTogJ29wZXJhdGlvbicgfSwgaWEpLCAuLi5zdGFjay5zbGljZSgxKV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25FcnJvcihpbnN0cnVjdGlvbiwgYHVuZXhwZWN0ZWQgaW5zdHJ1Y3Rpb246ICR7aW5zdHJ1Y3Rpb24ucHJpbX1gKTtcbiAgICAgICAgfVxuICAgIH0pKGluc3RydWN0aW9uKTtcbiAgICBpZiAoKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC50cmFjZUNhbGxiYWNrKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IHRyYWNlID0ge1xuICAgICAgICAgICAgb3A6IGluc3RydWN0aW9uLFxuICAgICAgICAgICAgaW46IHN0YWNrLFxuICAgICAgICAgICAgb3V0OiByZXRTdGFjayxcbiAgICAgICAgfTtcbiAgICAgICAgY3R4LnRyYWNlQ2FsbGJhY2sodHJhY2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmV0U3RhY2s7XG59XG5mdW5jdGlvbiBjb250cmFjdFNlY3Rpb24oY29udHJhY3QsIHNlY3Rpb24pIHtcbiAgICBmb3IgKGNvbnN0IHMgb2YgY29udHJhY3QpIHtcbiAgICAgICAgaWYgKHMucHJpbSA9PT0gc2VjdGlvbikge1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IE1pY2hlbHNvbkVycm9yKGNvbnRyYWN0LCBgbWlzc2luZyBjb250cmFjdCBzZWN0aW9uOiAke3NlY3Rpb259YCk7XG59XG5mdW5jdGlvbiBjb250cmFjdFZpZXdzKGNvbnRyYWN0KSB7XG4gICAgY29uc3Qgdmlld3MgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHMgb2YgY29udHJhY3QpIHtcbiAgICAgICAgaWYgKHMucHJpbSA9PT0gJ3ZpZXcnKSB7XG4gICAgICAgICAgICB2aWV3c1tzLmFyZ3NbMF0uc3RyaW5nXSA9IHM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZpZXdzO1xufVxuZnVuY3Rpb24gaXNDb250cmFjdCh2KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodikpIHtcbiAgICAgICAgZm9yIChjb25zdCBzIG9mIHYpIHtcbiAgICAgICAgICAgIGlmICgncHJpbScgaW4gcyAmJiAocy5wcmltID09PSAncGFyYW1ldGVyJyB8fCBzLnByaW0gPT09ICdzdG9yYWdlJyB8fCBzLnByaW0gPT09ICdjb2RlJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBjb250cmFjdEVudHJ5UG9pbnQoc3JjLCBlcCkge1xuICAgIGVwID0gZXAgfHwgJyVkZWZhdWx0JztcbiAgICBjb25zdCBlbnRyeVBvaW50ID0gY29udHJhY3RFbnRyeVBvaW50cyhzcmMpLmZpbmQoKHgpID0+IHhbMF0gPT09IGVwKTtcbiAgICBpZiAoZW50cnlQb2ludCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlbnRyeVBvaW50WzFdO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcCA9PT0gJyVkZWZhdWx0Jykge1xuICAgICAgICByZXR1cm4gaXNDb250cmFjdChzcmMpID8gY29udHJhY3RTZWN0aW9uKHNyYywgJ3BhcmFtZXRlcicpLmFyZ3NbMF0gOiBzcmM7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gaXNPclR5cGUodCkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHQpIHx8IHQucHJpbSA9PT0gJ29yJztcbn1cbmZ1bmN0aW9uIGNvbnRyYWN0RW50cnlQb2ludHMoc3JjKSB7XG4gICAgaWYgKGlzQ29udHJhY3Qoc3JjKSkge1xuICAgICAgICBjb25zdCBwYXJhbSA9IGNvbnRyYWN0U2VjdGlvbihzcmMsICdwYXJhbWV0ZXInKTtcbiAgICAgICAgY29uc3QgY2ggPSBjb250cmFjdEVudHJ5UG9pbnRzKHBhcmFtLmFyZ3NbMF0pO1xuICAgICAgICBjb25zdCBhID0gdW5wYWNrQW5ub3RhdGlvbnMocGFyYW0pO1xuICAgICAgICByZXR1cm4gYS5mID8gW1thLmZbMF0sIHBhcmFtLmFyZ3NbMF1dLCAuLi5jaF0gOiBjaDtcbiAgICB9XG4gICAgaWYgKGlzT3JUeXBlKHNyYykpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHR5cGVBcmdzKHNyYyk7XG4gICAgICAgIGNvbnN0IGdldEFyZyA9IChuKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhID0gdW5wYWNrQW5ub3RhdGlvbnMoYXJnc1tuXSk7XG4gICAgICAgICAgICBpZiAodHlwZUlEKGFyZ3Nbbl0pID09PSAnb3InKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2ggPSBjb250cmFjdEVudHJ5UG9pbnRzKGFyZ3Nbbl0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBhLmYgPyBbW2EuZlswXSwgYXJnc1tuXV0sIC4uLmNoXSA6IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGEuZiA/IFtbYS5mWzBdLCBhcmdzW25dXV0gOiBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIFsuLi5nZXRBcmcoMCksIC4uLmdldEFyZygxKV07XG4gICAgfVxuICAgIHJldHVybiBbXTtcbn1cbi8vIENvbnRyYWN0IHZhbGlkYXRpb25cbmZ1bmN0aW9uIGFzc2VydENvbnRyYWN0VmFsaWQoY29udHJhY3QsIGN0eCkge1xuICAgIGNvbnN0IGFzc2VydFNlY3Rpb24gPSAocGFyYW1ldGVyLCBzdG9yYWdlLCByZXQsIGNvZGUpID0+IHtcbiAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQocGFyYW1ldGVyLCB0cnVlKTtcbiAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoc3RvcmFnZSk7XG4gICAgICAgIGNvbnN0IGFyZyA9IHtcbiAgICAgICAgICAgIHByaW06ICdwYWlyJyxcbiAgICAgICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtZXRlciksIHsgYW5ub3RzOiBbJ0BwYXJhbWV0ZXInXSB9KSxcbiAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0b3JhZ2UpLCB7IGFubm90czogWydAc3RvcmFnZSddIH0pLFxuICAgICAgICAgICAgXSxcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb3V0ID0gZnVuY3Rpb25UeXBlSW50ZXJuYWwoY29kZSwgW2FyZ10sIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgY3R4KSwgeyBjb250cmFjdCB9KSk7XG4gICAgICAgIGlmICgnZmFpbGVkJyBpbiBvdXQpIHtcbiAgICAgICAgICAgIHJldHVybiBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGFzc2VydFN0YWNrc0VxdWFsKG91dCwgW3JldF0pO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBNaWNoZWxzb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKGNvZGUsIG91dCwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXQ7XG4gICAgfTtcbiAgICBjb25zdCBwYXJhbWV0ZXIgPSBjb250cmFjdFNlY3Rpb24oY29udHJhY3QsICdwYXJhbWV0ZXInKS5hcmdzWzBdO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBjb250cmFjdFNlY3Rpb24oY29udHJhY3QsICdzdG9yYWdlJykuYXJnc1swXTtcbiAgICBjb25zdCBjb2RlID0gY29udHJhY3RTZWN0aW9uKGNvbnRyYWN0LCAnY29kZScpLmFyZ3NbMF07XG4gICAgY29uc3QgZXhwZWN0ZWQgPSB7XG4gICAgICAgIHByaW06ICdwYWlyJyxcbiAgICAgICAgYXJnczogW3sgcHJpbTogJ2xpc3QnLCBhcmdzOiBbeyBwcmltOiAnb3BlcmF0aW9uJyB9XSB9LCBzdG9yYWdlXSxcbiAgICB9O1xuICAgIGNvbnN0IHJldCA9IGFzc2VydFNlY3Rpb24ocGFyYW1ldGVyLCBzdG9yYWdlLCBleHBlY3RlZCwgY29kZSk7XG4gICAgZm9yIChjb25zdCB2aWV3IG9mIE9iamVjdC52YWx1ZXMoY29udHJhY3RWaWV3cyhjb250cmFjdCkpKSB7XG4gICAgICAgIGFzc2VydFNlY3Rpb24odmlldy5hcmdzWzFdLCBzdG9yYWdlLCB2aWV3LmFyZ3NbMl0sIHZpZXcuYXJnc1szXSk7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59XG4vLyBFeHBvcnRlZCB3cmFwcGVyIGZ1bmN0aW9uc1xuZnVuY3Rpb24gYXNzZXJ0RGF0YVZhbGlkKGQsIHQsIGN0eCkge1xuICAgIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKHQpO1xuICAgIGFzc2VydERhdGFWYWxpZEludGVybmFsKGQsIHQsIGN0eCB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGZ1bmN0aW9uVHlwZShpbnN0LCBzdGFjaywgY3R4KSB7XG4gICAgZm9yIChjb25zdCB0IG9mIHN0YWNrKSB7XG4gICAgICAgIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKHQpO1xuICAgIH1cbiAgICBpZiAoKGN0eCA9PT0gbnVsbCB8fCBjdHggPT09IHZvaWQgMCA/IHZvaWQgMCA6IGN0eC5jb250cmFjdCkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBmb3IgKGNvbnN0IHR5cGVzZWMgb2YgWydwYXJhbWV0ZXInLCAnc3RvcmFnZSddKSB7XG4gICAgICAgICAgICBjb25zdCBzZWMgPSBjb250cmFjdFNlY3Rpb24oY3R4LmNvbnRyYWN0LCB0eXBlc2VjKS5hcmdzWzBdO1xuICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoc2VjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb25UeXBlSW50ZXJuYWwoaW5zdCwgc3RhY2ssIGN0eCB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGFzc2VydFR5cGVzRXF1YWwoYSwgYiwgZmllbGQgPSBmYWxzZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGEpKSB7XG4gICAgICAgIC8vIHR5cGUgZ3VhcmRzIGRvbid0IHdvcmsgZm9yIHBhcmFtZXRyaXplZCBnZW5lcmljIHR5cGVzXG4gICAgICAgIGZvciAoY29uc3QgdiBvZiBhKSB7XG4gICAgICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZCh2KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHYgb2YgYikge1xuICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQodik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkKGEpO1xuICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZChiKTtcbiAgICB9XG4gICAgYXNzZXJ0U2NhbGFyVHlwZXNFcXVhbChhLCBiLCBmaWVsZCk7XG59XG5mdW5jdGlvbiBpc1R5cGVBbm5vdGF0aW9uc1ZhbGlkKHQsIGZpZWxkID0gZmFsc2UpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnRUeXBlQW5ub3RhdGlvbnNWYWxpZCh0LCBmaWVsZCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGlzQ29udHJhY3RWYWxpZChjb250cmFjdCwgY3R4KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIGFzc2VydENvbnRyYWN0VmFsaWQoY29udHJhY3QsIGN0eCk7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0RhdGFWYWxpZChkLCB0LCBjdHgpIHtcbiAgICB0cnkge1xuICAgICAgICBhc3NlcnREYXRhVmFsaWQoZCwgdCwgY3R4KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNhdGNoIChfYSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gaXNUeXBlRXF1YWwoYSwgYiwgZmllbGQgPSBmYWxzZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGFzc2VydFR5cGVzRXF1YWwoYSwgYiwgZmllbGQpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRyYWN0IHtcbiAgICBjb25zdHJ1Y3Rvcihjb250cmFjdCwgb3B0KSB7XG4gICAgICAgIHRoaXMuY29udHJhY3QgPSBjb250cmFjdDtcbiAgICAgICAgdGhpcy5jdHggPSBPYmplY3QuYXNzaWduKHsgY29udHJhY3QgfSwgb3B0KTtcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBhc3NlcnRDb250cmFjdFZhbGlkKGNvbnRyYWN0LCB0aGlzLmN0eCk7XG4gICAgfVxuICAgIHN0YXRpYyBwYXJzZShzcmMsIG9wdCkge1xuICAgICAgICBjb25zdCBwID0gbmV3IFBhcnNlcihvcHQpO1xuICAgICAgICBjb25zdCBleHByID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBwLnBhcnNlU2NyaXB0KHNyYykgOiBwLnBhcnNlSlNPTihzcmMpO1xuICAgICAgICBpZiAoZXhwciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNaWNoZWxzb25FcnJvcignZW1wdHkgTWljaGVsc29uJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFzc2VydE1pY2hlbHNvbkNvbnRyYWN0KGV4cHIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0KGV4cHIsIG9wdCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIHBhcnNlVHlwZUV4cHJlc3Npb24oc3JjLCBvcHQpIHtcbiAgICAgICAgY29uc3QgcCA9IG5ldyBQYXJzZXIob3B0KTtcbiAgICAgICAgY29uc3QgZXhwciA9IHR5cGVvZiBzcmMgPT09ICdzdHJpbmcnID8gcC5wYXJzZVNjcmlwdChzcmMpIDogcC5wYXJzZUpTT04oc3JjKTtcbiAgICAgICAgaWYgKGV4cHIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkVHlwZUV4cHJlc3Npb25FcnJvcignZW1wdHkgdHlwZSBleHByZXNzaW9uJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gcmVtb3ZlIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkIGZyb20gaWYgYmxvY2sgYmVjYXVzZTogKCkgPT4gdm9pZCB8fCB0aHJvdyBlcnJvclxuICAgICAgICBpZiAoYXNzZXJ0TWljaGVsc29uVHlwZShleHByKSkge1xuICAgICAgICAgICAgYXNzZXJ0VHlwZUFubm90YXRpb25zVmFsaWQoZXhwcik7XG4gICAgICAgICAgICByZXR1cm4gZXhwcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgcGFyc2VEYXRhRXhwcmVzc2lvbihzcmMsIG9wdCkge1xuICAgICAgICBjb25zdCBwID0gbmV3IFBhcnNlcihvcHQpO1xuICAgICAgICBjb25zdCBleHByID0gdHlwZW9mIHNyYyA9PT0gJ3N0cmluZycgPyBwLnBhcnNlU2NyaXB0KHNyYykgOiBwLnBhcnNlSlNPTihzcmMpO1xuICAgICAgICBpZiAoZXhwciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWREYXRhRXhwcmVzc2lvbkVycm9yKCdlbXB0eSBkYXRhIGV4cHJlc3Npb24nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXNzZXJ0TWljaGVsc29uRGF0YShleHByKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV4cHI7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzZWN0aW9uKHNlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIGNvbnRyYWN0U2VjdGlvbih0aGlzLmNvbnRyYWN0LCBzZWN0aW9uKTtcbiAgICB9XG4gICAgZW50cnlQb2ludHMoKSB7XG4gICAgICAgIHJldHVybiBjb250cmFjdEVudHJ5UG9pbnRzKHRoaXMuY29udHJhY3QpO1xuICAgIH1cbiAgICBlbnRyeVBvaW50KGVwKSB7XG4gICAgICAgIHJldHVybiBjb250cmFjdEVudHJ5UG9pbnQodGhpcy5jb250cmFjdCwgZXApO1xuICAgIH1cbiAgICBhc3NlcnREYXRhVmFsaWQoZCwgdCkge1xuICAgICAgICBhc3NlcnREYXRhVmFsaWQoZCwgdCwgdGhpcy5jdHgpO1xuICAgIH1cbiAgICBpc0RhdGFWYWxpZChkLCB0KSB7XG4gICAgICAgIHJldHVybiBpc0RhdGFWYWxpZChkLCB0LCB0aGlzLmN0eCk7XG4gICAgfVxuICAgIGFzc2VydFBhcmFtZXRlclZhbGlkKGVwLCBkKSB7XG4gICAgICAgIGNvbnN0IHQgPSB0aGlzLmVudHJ5UG9pbnQoZXAgfHwgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHQgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRW50cnlwb2ludEVycm9yKGVwID09PSBudWxsIHx8IGVwID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcC50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFzc2VydERhdGFWYWxpZChkLCB0KTtcbiAgICB9XG4gICAgaXNQYXJhbWV0ZXJWYWxpZChlcCwgZCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5hc3NlcnRQYXJhbWV0ZXJWYWxpZChlcCwgZCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoX2EpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvblR5cGUoaW5zdCwgc3RhY2spIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uVHlwZShpbnN0LCBzdGFjaywgdGhpcy5jdHgpO1xuICAgIH1cbn1cbi8vIFRPRE86IGR1bW15Q29udHJhY3Qgbm90IHVzZWQgYW55d2hlcmUgaW4gdGhlIGNvZGViYXNlIGNhbiBiZSBkZWxldGVkP1xuY29uc3QgZHVtbXlDb250cmFjdCA9IG5ldyBDb250cmFjdChbXG4gICAgeyBwcmltOiAncGFyYW1ldGVyJywgYXJnczogW3sgcHJpbTogJ3VuaXQnIH1dIH0sXG4gICAgeyBwcmltOiAnc3RvcmFnZScsIGFyZ3M6IFt7IHByaW06ICd1bml0JyB9XSB9LFxuICAgIHtcbiAgICAgICAgcHJpbTogJ2NvZGUnLFxuICAgICAgICBhcmdzOiBbW3sgcHJpbTogJ0NBUicgfSwgeyBwcmltOiAnTklMJywgYXJnczogW3sgcHJpbTogJ29wZXJhdGlvbicgfV0gfSwgeyBwcmltOiAnUEFJUicgfV1dLFxuICAgIH0sXG5dKTtcblxuZnVuY3Rpb24gZm9ybWF0U3RhY2socykge1xuICAgIGlmICgnZmFpbGVkJyBpbiBzKSB7XG4gICAgICAgIHJldHVybiBgW0ZBSUxFRDogJHtlbWl0TWljaGVsaW5lKHMuZmFpbGVkKX1dYDtcbiAgICB9XG4gICAgcmV0dXJuIHNcbiAgICAgICAgLm1hcCgodiwgaSkgPT4ge1xuICAgICAgICBjb25zdCBhbm4gPSB1bnBhY2tBbm5vdGF0aW9ucyh2KTtcbiAgICAgICAgcmV0dXJuIGBbJHtpfSR7YW5uLnYgPyAnLycgKyBhbm4udlswXSA6ICcnfV06ICR7ZW1pdE1pY2hlbGluZSh2KX1gO1xuICAgIH0pXG4gICAgICAgIC5qb2luKCdcXG4nKTtcbn1cbmZ1bmN0aW9uIHRyYWNlRHVtcEZ1bmMoYmxvY2tzLCBjYikge1xuICAgIHJldHVybiAodikgPT4ge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpICYmICFibG9ja3MpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtYWNybyA9IChfYSA9IHYub3Bbc291cmNlUmVmZXJlbmNlXSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLm1hY3JvO1xuICAgICAgICBjb25zdCBtc2cgPSBgJHttYWNybyA/ICdNYWNybycgOiAnT3AnfTogJHttYWNybyA/IGVtaXRNaWNoZWxpbmUobWFjcm8sIHVuZGVmaW5lZCwgdHJ1ZSkgKyAnIC8gJyA6ICcnfSR7ZW1pdE1pY2hlbGluZSh2Lm9wKX1cbklucHV0OlxuJHtmb3JtYXRTdGFjayh2LmluKX1cbk91dHB1dDpcbiR7Zm9ybWF0U3RhY2sodi5vdXQpfVxuYDtcbiAgICAgICAgY2IobXNnKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZm9ybWF0RXJyb3IoZXJyKSB7XG4gICAgdmFyIF9hO1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yKSB7XG4gICAgICAgIGNvbnN0IG1hY3JvID0gKF9hID0gZXJyLnZhbFtzb3VyY2VSZWZlcmVuY2VdKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWFjcm87XG4gICAgICAgIHJldHVybiBgJHttYWNybyA/ICdNYWNybycgOiAnT3AnfTogJHttYWNybyA/IGVtaXRNaWNoZWxpbmUobWFjcm8sIHVuZGVmaW5lZCwgdHJ1ZSkgKyAnIC8gJyA6ICcnfSR7ZW1pdE1pY2hlbGluZShlcnIudmFsKX1cblN0YWNrOlxuJHtmb3JtYXRTdGFjayhlcnIuc3RhY2tTdGF0ZSl9XG5gO1xuICAgIH1cbiAgICBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBNaWNoZWxzb25UeXBlRXJyb3IpIHtcbiAgICAgICAgY29uc3QgdHlwZSA9IEFycmF5LmlzQXJyYXkoZXJyLnZhbClcbiAgICAgICAgICAgID8gJ1snICsgZXJyLnZhbC5tYXAoKHYsIGkpID0+IGBbJHtpfV06ICR7ZW1pdE1pY2hlbGluZSh2KX1gKS5qb2luKCc7ICcpICsgJ10nXG4gICAgICAgICAgICA6IGVtaXRNaWNoZWxpbmUoZXJyLnZhbCk7XG4gICAgICAgIHJldHVybiBgVHlwZTogJHt0eXBlfVxuJHtlcnIuZGF0YVxuICAgICAgICAgICAgPyBgRGF0YTogJHtlbWl0TWljaGVsaW5lKGVyci5kYXRhKX1cbmBcbiAgICAgICAgICAgIDogJyd9XG5gO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGBWYWx1ZTogJHtlbWl0TWljaGVsaW5lKGVyci52YWwpfWA7XG4gICAgfVxufVxuXG4vLyBJTVBPUlRBTlQ6IFRISVMgRklMRSBJUyBBVVRPIEdFTkVSQVRFRCEgRE8gTk9UIE1BTlVBTExZIEVESVQgT1IgQ0hFQ0tJTiFcbmNvbnN0IFZFUlNJT04gPSB7XG4gICAgXCJjb21taXRIYXNoXCI6IFwiMTNhMTJhYjdjZjQ0MjA0MzUyNjc0NWRiMmJiZjRlZjNiMDg5YzM0YVwiLFxuICAgIFwidmVyc2lvblwiOiBcIjE5LjAuMlwiXG59O1xuXG5leHBvcnQgeyBDb250cmFjdCwgRGVmYXVsdFByb3RvY29sLCBKU09OUGFyc2VFcnJvciwgTWFjcm9FcnJvciwgTWljaGVsaW5lUGFyc2VFcnJvciwgTWljaGVsc29uRXJyb3IsIE1pY2hlbHNvbkluc3RydWN0aW9uRXJyb3IsIE1pY2hlbHNvblR5cGVFcnJvciwgTWljaGVsc29uVmFsaWRhdGlvbkVycm9yLCBQYXJzZXIsIFByb3RvR3JlYXRlck9yRXF1YWwsIFByb3RvSW5mZXJpb3JUbywgUHJvdG9jb2wsIFZFUlNJT04sIGFzc2VydENvbnRyYWN0VmFsaWQsIGFzc2VydERhdGFMaXN0SWZBbnksIGFzc2VydERhdGFWYWxpZCwgYXNzZXJ0TWljaGVsc29uQmlnTWFwU3RvcmFibGVUeXBlLCBhc3NlcnRNaWNoZWxzb25Db21wYXJhYmxlVHlwZSwgYXNzZXJ0TWljaGVsc29uQ29udHJhY3QsIGFzc2VydE1pY2hlbHNvbkRhdGEsIGFzc2VydE1pY2hlbHNvbkluc3RydWN0aW9uLCBhc3NlcnRNaWNoZWxzb25QYWNrYWJsZVR5cGUsIGFzc2VydE1pY2hlbHNvblBhc3NhYmxlVHlwZSwgYXNzZXJ0TWljaGVsc29uUHVzaGFibGVUeXBlLCBhc3NlcnRNaWNoZWxzb25TdG9yYWJsZVR5cGUsIGFzc2VydE1pY2hlbHNvblR5cGUsIGFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkLCBhc3NlcnRUeXBlc0VxdWFsLCBhc3NlcnRWaWV3TmFtZVZhbGlkLCBjb250cmFjdEVudHJ5UG9pbnQsIGNvbnRyYWN0RW50cnlQb2ludHMsIGNvbnRyYWN0U2VjdGlvbiwgY29udHJhY3RWaWV3cywgZGVjb2RlQWRkcmVzc0J5dGVzLCBkZWNvZGVQdWJsaWNLZXlCeXRlcywgZGVjb2RlUHVibGljS2V5SGFzaEJ5dGVzLCBkdW1teUNvbnRyYWN0LCBlbWl0TWljaGVsaW5lLCBmb3JtYXRFcnJvciwgZm9ybWF0U3RhY2ssIGZ1bmN0aW9uVHlwZSwgaW5zdHJ1Y3Rpb25JRHMsIGlzQ29udHJhY3RWYWxpZCwgaXNEYXRhVmFsaWQsIGlzSW5zdHJ1Y3Rpb24sIGlzTWljaGVsc29uQ29kZSwgaXNNaWNoZWxzb25EYXRhLCBpc01pY2hlbHNvbkVycm9yLCBpc01pY2hlbHNvblNjcmlwdCwgaXNNaWNoZWxzb25UeXBlLCBpc1R5cGVBbm5vdGF0aW9uc1ZhbGlkLCBpc1R5cGVFcXVhbCwgcGFja0RhdGEsIHBhY2tEYXRhQnl0ZXMsIHJlZkNvbnRyYWN0LCBzb3VyY2VSZWZlcmVuY2UsIHRyYWNlRHVtcEZ1bmMsIHVucGFja0RhdGEsIHVucGFja0RhdGFCeXRlcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFxdWl0by1taWNoZWwtY29kZWMuZXM2LmpzLm1hcFxuIl0sIm5hbWVzIjpbIlRhcXVpdG9FcnJvciIsIkludmFsaWRNZXNzYWdlRXJyb3IiLCJQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3IiLCJzb3VyY2VSZWZlcmVuY2UiLCJTeW1ib2wiLCJTY2FuRXJyb3IiLCJjb25zdHJ1Y3RvciIsInNyYyIsImlkeCIsIm1lc3NhZ2UiLCJuYW1lIiwiTGl0ZXJhbCIsImlzU3BhY2UiLCJSZWdFeHAiLCJpc0lkZW50U3RhcnQiLCJpc0lkZW50IiwiaXNEaWdpdCIsImlzSGV4Iiwic2NhbiIsInNjYW5Db21tZW50cyIsImkiLCJsZW5ndGgiLCJ0ZXN0IiwicyIsInN0YXJ0IiwidCIsIklkZW50IiwidiIsInNsaWNlIiwiZmlyc3QiLCJsYXN0Iiwic3Vic3RyaW5nIiwiQnl0ZXMiLCJpaSIsIk51bWJlciIsImVzYyIsIlN0cmluZyIsIkNvbW1lbnQiLCJyZWZDb250cmFjdCIsIlByb3RvY29sIiwiRGVmYXVsdFByb3RvY29sIiwiUHNpdGhhY2EyIiwicHJvdG9MZXZlbCIsIlBzOW1QbVhhUnptemszNWdiQVlOQ0F3NlVYZEUycW9BQlRIYk4yb0VFYzFxTTdDd1Q5UCIsIlB0Q0o3cHdveGU4SmFzbkhZOFlvbm5MWWpjVkhtaGlBUlBKdnFjQzZWZkhUNXM4azhzWSIsIlBzWUxWcFZ2Z2JMaEFob3FBa01GVW82Z3Vka0o5d2VOWGhVWUNpTER6Y1VwRnBrazhXdCIsIlBzZGRGS2kzMmNNSjJxUGpmNDNRdjVHRFdMRFBaYjNUM2JGNmZMS2lGNUh0dkhOVTdhUCIsIlB0MjRtNHhpUGJMRGhWZ1ZmQUJVamlyYm1kYTN5b2hkTjgyU3A5RmV1QVhKNGVWOW90ZCIsIlBzQkFCWTVIUVRTa0E0Mjk3ek5IZnNaTkt0eFVMZkwxOHk5NXFiM201M1FKaVhHbXJiVSIsIlBzQmFieU0xZVVYWnNlYUpkbVhGQXBEU0JxajhZQmZ3RUxveFpISFc3N0VNY0FiYndBUyIsIlBzQ0FSVEhBR2F6S2JIdG5LZkx6UWcza21zNTJrU1JwZ25EWTk4MmE5b1lzU1hSTFFFYiIsIlBzREVMUEgxS3hzeHQ4ZjllV2J4UWVSeGtqZmJ4b3FNNTJqdnM1WTVmQnhXV2g0aWZwbyIsIlB0RWRvVGV6ZDNSSFNDMzFtcHh4bzFucHhGam9XV2NGZ1F0eGFwaTUxWjhUTHU2djZVcSIsIlB0RWRvMlprVDlvS3BpbVRhaDZ4MmVtYkYyNW9zczU0bmpNdVB6a0pURWk1UnFmZFpGQSIsIlBzRkxvcmVuYVVVdWlrRFd2TURyNmZHQlJHOGt0M2UzRDNmSG9YSzFqMUJGUnhlU0g0aSIsIlB0R1JBTkFEc0RVOFI5ZGFZS0FnV25RWUFKNjRvbU4xbzNLTUdWQ3lrU2hBOTd2UWJ2ViIsIlB0SGFuZ3pIb2dva1N1aU1IZW1DdW93RWF2Z1lUUDhKNXFROWZRUzc5M01IWUZwQ1kzciIsIlB0SGFuZ3oyYVJuZ3l3bVNSR0d2cmNUeU1iYmRwV2RwRkt1UzR1TVd4ZzJSYUg5aTFxeCIsIlBzaVRoYUNhVDQ3WmJvYXc3MVFXU2NNOHNYZU1NN2JiUUZuY0s5RkxxWWM2RUtkcGpWUCIsIlBzaXRoYWNhMk1MUkZZYXJnaXZwbzdZdlVyN3dVRHF5eHJkaEM1Q1FxNzhtUnZpbXo2QSIsIlB0SmFrYXJ0YWlEejY5U2ZERExYSlNpdVpxVFNlU0tSRGJLVlpDOE1OekpudlJqdm5HdyIsIlB0SmFrYXJ0MnhWajdwWVhKQlhycUhnZDgycmRrTGV5NVplZUd3RGdQcDlyaFFVYlNxWSIsIlB0S2F0aG1hbmtTcExMREFMeld3N0NHRDJqMk10eXZlVHdib0VZb2txVUNQNGExTHhNZyIsIlB0TGltYVB0TE13Zk5pbkppOXJDZkRQV2VhOGRGZ1RaMU1lSjlmMW0yU1JpYzZheWl3VyIsIlB0TXVtYmFpaUZGRUdiZXcxclJqelNQeXpSYkE1MVRtM1JWWkw1c3VIUHhTWllEaENFYyIsIlB0TXVtYmFpMlRtc0pITkdSa0Q4djhZRGJ0YW83QkxVQzN3akFTbjFpbkFLTEZDamFIMSIsIlB0TmFpcm9iaXlzc0h1aDg3aEVoZlZCR0NWckszV25TOFoyRlQ0eW1CNXRBYTRyMW5RZiIsIlByb3hmb3JkWW1WZmpXblJjZ2pXSDM2Zlc2UEFyd3F5a1RGem90VXhSczZnbVRjWkR1SCIsIlByb3RvQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYURkcDN6SyIsIlByb3RvR3JlYXRlck9yRXF1YWwiLCJhIiwiYiIsIlByb3RvSW5mZXJpb3JUbyIsIk1hY3JvRXJyb3IiLCJwcmltIiwiYXNzZXJ0QXJncyQxIiwiZXgiLCJuIiwiX2EiLCJfYiIsImFyZ3MiLCJ1bmRlZmluZWQiLCJhc3NlcnROb0Fubm90cyIsImFubm90cyIsImFzc2VydEludEFyZyIsImFyZyIsInBhcnNlUGFpclVucGFpckV4cHIiLCJwIiwiZXhwciIsImFubm90YXRpb25zIiwiYWdnIiwiYWkiLCJhbm4iLCJsZXhwciIsImMiLCJyIiwiYW4iLCJyZXhwciIsIm1hcCIsInBhcnNlU2V0TWFwQ2FkciIsInZhbm4iLCJ0ZXJtIiwiZCIsInRyaW1MYXN0IiwibCIsImZpbHRlckFubm90YXRpb25zIiwiZmllbGRzIiwicmVzdCIsInB1c2giLCJta1ByaW0iLCJPYmplY3QiLCJhc3NpZ24iLCJwYWlyUmUiLCJ1bnBhaXJSZSIsImNhZHJSZSIsInNldENhZHJSZSIsIm1hcENhZHJSZSIsImRpaXBSZSIsImR1dXBSZSIsImV4cGFuZE1hY3JvcyIsIm9wdCIsInByb3RvIiwicHJvdG9jb2wiLCJtYXlSZW5hbWUiLCJwYXJzZUludCIsImludCIsInRvcCIsImxlYWYiLCJQdEVkbzJaayIsImNoIiwiZXhwYW5kR2xvYmFsQ29uc3RhbnRzIiwiaGFzaEFuZFZhbHVlIiwic3RyaW5nIiwiTWljaGVsaW5lUGFyc2VFcnJvciIsInRva2VuIiwiSlNPTlBhcnNlRXJyb3IiLCJub2RlIiwiZXJyRU9GIiwiaXNBbm5vdGF0aW9uIiwidG9rIiwiaW50UmUiLCJieXRlc1JlIiwiUGFyc2VyIiwiZXhwYW5kIiwiX2MiLCJleHBhbmRHbG9iYWxDb25zdGFudCIsInJldCIsImdsb2JhbENvbnN0YW50IiwibWFjcm8iLCJwYXJzZUxpc3RFeHByIiwic2Nhbm5lciIsInJlZiIsImV4cGVjdEJyYWNrZXQiLCJuZXh0IiwiZG9uZSIsInZhbHVlIiwicGFyc2VFeHByIiwicGFyc2VBcmdzIiwicGFyc2VTZXF1ZW5jZUV4cHIiLCJzZXEiLCJpdG0iLCJKU09OIiwicGFyc2UiLCJieXRlcyIsInBhcnNlU2VxdWVuY2UiLCJUeXBlRXJyb3IiLCJwYXJzZUxpc3QiLCJwYXJzZU1pY2hlbGluZUV4cHJlc3Npb24iLCJwYXJzZVNjcmlwdCIsInBhcnNlRGF0YSIsInBhcnNlSlNPTiIsIkFycmF5IiwiaXNBcnJheSIsIkZvcm1hdHRlciIsImxldiIsImluZGVudCIsImxmIiwibmV3bGluZSIsImxmc3AiLCJkb3duIiwiaGFzQXJncyIsImlzTXVsdGlsaW5lIiwiZW1pdEV4cHIiLCJmIiwiZm9sZE1hY3JvcyIsImVtaXRTZXEiLCJzdHJpbmdpZnkiLCJtdWx0aWxpbmUiLCJlbCIsImVtaXRNaWNoZWxpbmUiLCJIIiwiSyIsIkJhc2U1OERlY29kaW5nRXJyb3IiLCJzaGEyNTYiLCJtc2ciLCJwYWQiLCJidWZmZXIiLCJmaWxsIiwicm9yIiwieCIsImgiLCJ3Iiwib2Zmc2V0IiwicSIsInMwIiwiczEiLCJiMCIsImIxIiwidDEiLCJ0MiIsImRpZ2VzdCIsImJhc2U1OGFscGhhYmV0RndkIiwiYmFzZTU4YWxwaGFiZXRCd2QiLCJieXRlQXQiLCJjaGFyQ29kZUF0IiwiZGVjb2RlQmFzZTU4IiwiYWNjIiwiemVyb3MiLCJjYXJyeSIsIm0iLCJNYXRoIiwiZmxvb3IiLCJyZXZlcnNlIiwiZW5jb2RlQmFzZTU4IiwiZnJvbUNoYXJDb2RlIiwiZGVjb2RlQmFzZTU4Q2hlY2siLCJkYXRhIiwic3VtIiwiY29tcHV0ZWQiLCJlbmNvZGVCYXNlNThDaGVjayIsIkludmFsaWRNaWNoZWxzb25FcnJvciIsIkludmFsaWRUeXBlRXhwcmVzc2lvbkVycm9yIiwiSW52YWxpZERhdGFFeHByZXNzaW9uRXJyb3IiLCJJbnZhbGlkRW50cnlwb2ludEVycm9yIiwiZW50cnlwb2ludCIsIlRlem9zSWRFbmNvZGVFcnJvciIsIkxvbmdJbnRlZ2VyRXJyb3IiLCJIZXhQYXJzZUVycm9yIiwiaGV4Qnl0ZSIsIk1pY2hlbHNvbkVycm9yIiwidmFsIiwiaXNNaWNoZWxzb25FcnJvciIsImVyciIsIk1pY2hlbHNvblR5cGVFcnJvciIsIkxvbmdJbnRlZ2VyIiwiYXBwZW5kIiwiYnVmIiwibmVnIiwiY21wIiwic2lnbiIsInBhcnNlQnl0ZXMiLCJpc05hTiIsImlzRGVjaW1hbCIsImlzTmF0dXJhbCIsImFublJlIiwidW5wYWNrQW5ub3RhdGlvbnMiLCJmaWVsZCIsInR5cGUiLCJ2YXJzIiwic3BlY2lhbFZhciIsInNwZWNpYWxGaWVsZHMiLCJlbXB0eUZpZWxkcyIsImVtcHR5VmFyIiwidGV6b3NQcmVmaXgiLCJCbG9ja0hhc2giLCJPcGVyYXRpb25IYXNoIiwiT3BlcmF0aW9uTGlzdEhhc2giLCJPcGVyYXRpb25MaXN0TGlzdEhhc2giLCJQcm90b2NvbEhhc2giLCJDb250ZXh0SGFzaCIsIkVEMjU1MTlQdWJsaWNLZXlIYXNoIiwiU0VDUDI1NksxUHVibGljS2V5SGFzaCIsIlAyNTZQdWJsaWNLZXlIYXNoIiwiQ29udHJhY3RIYXNoIiwiQ3J5cHRvYm94UHVibGljS2V5SGFzaCIsIkVEMjU1MTlTZWVkIiwiRUQyNTUxOVB1YmxpY0tleSIsIlNFQ1AyNTZLMVNlY3JldEtleSIsIlAyNTZTZWNyZXRLZXkiLCJFRDI1NTE5RW5jcnlwdGVkU2VlZCIsIlNFQ1AyNTZLMUVuY3J5cHRlZFNlY3JldEtleSIsIlAyNTZFbmNyeXB0ZWRTZWNyZXRLZXkiLCJTRUNQMjU2SzFQdWJsaWNLZXkiLCJQMjU2UHVibGljS2V5IiwiU0VDUDI1NksxU2NhbGFyIiwiU0VDUDI1NksxRWxlbWVudCIsIkVEMjU1MTlTZWNyZXRLZXkiLCJFRDI1NTE5U2lnbmF0dXJlIiwiU0VDUDI1NksxU2lnbmF0dXJlIiwiUDI1NlNpZ25hdHVyZSIsIkdlbmVyaWNTaWduYXR1cmUiLCJDaGFpbklEIiwiUm9sbHVwQWRkcmVzcyIsImNoZWNrRGVjb2RlVGV6b3NJRCIsImlkIiwidHlwZXMiLCJwbGVuIiwiZW5jb2RlVGV6b3NJRCIsInVucGFja0NvbWIiLCJ2diIsImlzUGFpclR5cGUiLCJpc1BhaXJEYXRhIiwicmZjMzMzOVJlIiwicGFyc2VEYXRlIiwiRGF0ZSIsInZhbHVlT2YiLCJwYXJzZUhleCIsInJlcyIsInNzIiwiaGV4Qnl0ZXMiLCJ0b1N0cmluZyIsImpvaW4iLCJtYXhWaWV3TmFtZUxlbmd0aCIsIm5vQXJnSW5zdHJ1Y3Rpb25JRHMiLCJBQlMiLCJBREQiLCJBRERSRVNTIiwiQU1PVU5UIiwiQU5EIiwiQVBQTFkiLCJCQUxBTkNFIiwiQkxBS0UyQiIsIkNBUiIsIkNEUiIsIkNIQUlOX0lEIiwiQ0hFQ0tfU0lHTkFUVVJFIiwiQ09NUEFSRSIsIkNPTkNBVCIsIkNPTlMiLCJFRElWIiwiRVEiLCJFWEVDIiwiRkFJTFdJVEgiLCJHRSIsIkdFVF9BTkRfVVBEQVRFIiwiR1QiLCJIQVNIX0tFWSIsIklNUExJQ0lUX0FDQ09VTlQiLCJJTlQiLCJJU05BVCIsIkpPSU5fVElDS0VUUyIsIktFQ0NBSyIsIkxFIiwiTEVWRUwiLCJMU0wiLCJMU1IiLCJMVCIsIk1FTSIsIk1VTCIsIk5FRyIsIk5FUSIsIk5FVkVSIiwiTk9UIiwiTk9XIiwiT1IiLCJQQUNLIiwiUEFJUklOR19DSEVDSyIsIlJFQURfVElDS0VUIiwiU0FQTElOR19WRVJJRllfVVBEQVRFIiwiU0VMRiIsIlNFTEZfQUREUkVTUyIsIlNFTkRFUiIsIlNFVF9ERUxFR0FURSIsIlNIQTI1NiIsIlNIQTMiLCJTSEE1MTIiLCJTSVpFIiwiU0xJQ0UiLCJTT01FIiwiU09VUkNFIiwiU1BMSVRfVElDS0VUIiwiU1VCIiwiU1dBUCIsIlRJQ0tFVCIsIlRJQ0tFVF9ERVBSRUNBVEVEIiwiVE9UQUxfVk9USU5HX1BPV0VSIiwiVFJBTlNGRVJfVE9LRU5TIiwiVU5JVCIsIlZPVElOR19QT1dFUiIsIlhPUiIsIlJFTkFNRSIsIk9QRU5fQ0hFU1QiLCJTVUJfTVVURVoiLCJNSU5fQkxPQ0tfVElNRSIsIkJZVEVTIiwiTkFUIiwiaW5zdHJ1Y3Rpb25JRHMiLCJDT05UUkFDVCIsIkNSRUFURV9DT05UUkFDVCIsIkRJRyIsIkRJUCIsIkRST1AiLCJEVUciLCJEVVAiLCJFTUlUIiwiRU1QVFlfQklHX01BUCIsIkVNUFRZX01BUCIsIkVNUFRZX1NFVCIsIkdFVCIsIklGIiwiSUZfQ09OUyIsIklGX0xFRlQiLCJJRl9OT05FIiwiSVRFUiIsIkxBTUJEQSIsIkxBTUJEQV9SRUMiLCJMRUZUIiwiTE9PUCIsIkxPT1BfTEVGVCIsIk1BUCIsIk5JTCIsIk5PTkUiLCJQQUlSIiwiUFVTSCIsIlJJR0hUIiwiU0FQTElOR19FTVBUWV9TVEFURSIsIlVOUEFDSyIsIlVOUEFJUiIsIlVQREFURSIsIkNBU1QiLCJWSUVXIiwic2ltcGxlQ29tcGFyYWJsZVR5cGVJRHMiLCJ1bml0IiwibmV2ZXIiLCJib29sIiwibmF0IiwiY2hhaW5faWQiLCJtdXRleiIsImtleV9oYXNoIiwia2V5Iiwic2lnbmF0dXJlIiwidGltZXN0YW1wIiwiYWRkcmVzcyIsInR4X3JvbGx1cF9sMl9hZGRyZXNzIiwidHlwZUlEcyIsIm9yIiwicGFpciIsInNldCIsImJpZ19tYXAiLCJjb250cmFjdCIsImxhbWJkYSIsImxpc3QiLCJvcGVyYXRpb24iLCJvcHRpb24iLCJibHMxMl8zODFfZzEiLCJibHMxMl8zODFfZzIiLCJibHMxMl8zODFfZnIiLCJzYXBsaW5nX3RyYW5zYWN0aW9uIiwic2FwbGluZ190cmFuc2FjdGlvbl9kZXByZWNhdGVkIiwic2FwbGluZ19zdGF0ZSIsInRpY2tldCIsImNoZXN0X2tleSIsImNoZXN0IiwiTWljaGVsc29uVmFsaWRhdGlvbkVycm9yIiwiaXNQcmltIiwiaXNQcmltT3JTZXEiLCJhc3NlcnRQcmltIiwiYXNzZXJ0U2VxIiwiYXNzZXJ0UHJpbU9yU2VxIiwiYXNzZXJ0TmF0dXJhbCIsImFzc2VydEludExpdGVyYWwiLCJhc3NlcnRTdHJpbmdMaXRlcmFsIiwiYXNzZXJ0QXJncyIsImFzc2VydE1pY2hlbHNvbkluc3RydWN0aW9uIiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwiYXNzZXJ0TWljaGVsc29uVHlwZSIsImFzc2VydE1pY2hlbHNvblBhY2thYmxlVHlwZSIsImFzc2VydE1pY2hlbHNvblBhc3NhYmxlVHlwZSIsImFzc2VydE1pY2hlbHNvbkNvbnRyYWN0IiwiYXNzZXJ0TWljaGVsc29uUHVzaGFibGVUeXBlIiwiYXNzZXJ0TWljaGVsc29uRGF0YSIsImFzc2VydE1pY2hlbHNvbkNvbXBhcmFibGVUeXBlIiwiYXNzZXJ0TWljaGVsc29uQmlnTWFwU3RvcmFibGVUeXBlIiwiYXNzZXJ0Vmlld05hbWVWYWxpZCIsInRyYXZlcnNlVHlwZSIsImFzc2VydE1pY2hlbHNvblN0b3JhYmxlVHlwZSIsInZpZXdSZSIsImNiIiwiZm9yRWFjaCIsIm1hcEVsdHMiLCJ0b3BsZXZlbFNlYyIsInZpZXdzIiwic2VjIiwiaXNNaWNoZWxzb25TY3JpcHQiLCJpc01pY2hlbHNvbkRhdGEiLCJpc01pY2hlbHNvbkNvZGUiLCJpc01pY2hlbHNvblR5cGUiLCJpc0luc3RydWN0aW9uIiwiYXNzZXJ0RGF0YUxpc3RJZkFueSIsIl9fcmVzdCIsImUiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJTdXBwcmVzc2VkRXJyb3IiLCJlcnJvciIsInN1cHByZXNzZWQiLCJFcnJvciIsInByaW1pdGl2ZXMiLCJwcmltVGFncyIsIlRhZyIsIldyaXRlciIsIndyaXRlQnl0ZXMiLCJ3cml0ZVVpbnQ4Iiwid3JpdGVVaW50MTYiLCJ3cml0ZVVpbnQzMiIsIndyaXRlSW50OCIsIndyaXRlSW50MTYiLCJ3cml0ZUludDMyIiwiYm91bmRzRXJyIiwiUmVhZGVyIiwiY2FwIiwicmVhZEJ5dGVzIiwibGVuIiwicmVhZGVyIiwiY29weSIsInJlYWRVaW50OCIsInJlYWRVaW50MTYiLCJ4MCIsIngxIiwicmVhZFVpbnQzMiIsIngyIiwieDMiLCJyZWFkSW50OCIsInJlYWRJbnQxNiIsInJlYWRJbnQzMiIsIkNvbnRyYWN0SUQiLCJQdWJsaWNLZXlIYXNoSUQiLCJyZWFkUHVibGljS2V5SGFzaCIsInJkIiwidGFnIiwiRUQyNTUxOSIsIlNFQ1AyNTZLMSIsIlAyNTYiLCJoYXNoIiwicmVhZEFkZHJlc3MiLCJJbXBsaWNpdCIsIk9yaWdpbmF0ZWQiLCJkZWMiLCJUZXh0RGVjb2RlciIsImVudHJ5UG9pbnQiLCJkZWNvZGUiLCJVaW50OEFycmF5Iiwid3JpdGVQdWJsaWNLZXlIYXNoIiwiZnJvbSIsIndyaXRlQWRkcmVzcyIsImVuYyIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiUHVibGljS2V5SUQiLCJyZWFkUHVibGljS2V5IiwibG4iLCJwdWJsaWNLZXkiLCJ3cml0ZVB1YmxpY0tleSIsInBrIiwid3JpdGVFeHByIiwid3IiLCJ0ZiIsIlNlcXVlbmNlIiwiSW50IiwiQmlnSW50IiwiYml0cyIsImJ5dGUiLCJQcmltMCIsIlByaW0iLCJyZWFkRXhwciIsInBhc3NUaHJvdWdoIiwicmVhZFBhc3NUaHJvdWdoIiwidHIiLCJoZXgiLCJzYXZlZHJkIiwiaXQiLCJhcmduIiwic3BsaXQiLCJpc09yRGF0YSIsImlzT3B0aW9uRGF0YSIsImdldFdyaXRlVHJhbnNmb3JtRnVuYyIsInRjIiwiZGMiLCJkZCIsIl92IiwiX2VsdCIsImVsdCIsIml0ZXJhdG9yIiwic2lnIiwicGtoIiwiZ2V0VGltZSIsIndyaXRlUGFzc1Rocm91Z2giLCJpc1B1c2hJbnN0cnVjdGlvbiIsInBhY2tEYXRhIiwicGFja0RhdGFCeXRlcyIsImdldFJlYWRUcmFuc2Zvcm1GdW5jcyIsImFkZHIiLCJkYXRlIiwidG9JU09TdHJpbmciLCJ1bnBhY2tEYXRhIiwidW5wYWNrRGF0YUJ5dGVzIiwiZGVjb2RlQWRkcmVzc0J5dGVzIiwiZGVjb2RlUHVibGljS2V5SGFzaEJ5dGVzIiwiZGVjb2RlUHVibGljS2V5Qnl0ZXMiLCJNaWNoZWxzb25JbnN0cnVjdGlvbkVycm9yIiwic3RhY2tTdGF0ZSIsInR5cGVJRCIsInR5cGVBcmdzIiwiYXNzZXJ0U2NhbGFyVHlwZXNFcXVhbCIsImFBcmdzIiwiYkFyZ3MiLCJhc3NlcnRTdGFja3NFcXVhbCIsImFzc2VydFR5cGVBbm5vdGF0aW9uc1ZhbGlkIiwiaXNGdW5jdGlvbiIsImFzc2VydERhdGFWYWxpZEludGVybmFsIiwiY3R4IiwiZXAiLCJmdW5jdGlvblR5cGVJbnRlcm5hbCIsImZhaWxlZCIsImluc3RydWN0aW9uTGlzdFR5cGUiLCJpbnN0Iiwic3RhY2siLCJvcCIsImZ0IiwibGV2ZWwiLCJ0cmFjZUNhbGxiYWNrIiwidHJhY2UiLCJpbiIsIm91dCIsImluc3RydWN0aW9uIiwidHlwZUlkcyIsImlkcyIsInJldGhyb3ciLCJmbiIsInJldGhyb3dUeXBlR3VhcmQiLCJhcmdBbm4iLCJlbnN1cmVTdGFja3NFcXVhbCIsImVuc3VyZVR5cGVzRXF1YWwiLCJlbnN1cmVDb21wYXJhYmxlVHlwZSIsImVuc3VyZVBhY2thYmxlVHlwZSIsImVuc3VyZVN0b3JhYmxlVHlwZSIsImVuc3VyZVB1c2hhYmxlVHlwZSIsImVuc3VyZUJpZ01hcFN0b3JhYmxlVHlwZSIsImluc3RydWN0aW9uQW5uIiwibnVtIiwiYXNzZXJ0TnVtIiwiYW5ub3RhdGUiLCJ0dCIsInR4IiwiYW5ub3RhdGVWYXIiLCJkZWYiLCJpYSIsImFubm90YXRlRmllbGQiLCJpbnNBbm4iLCJkZWZGaWVsZCIsIl9kIiwiZmllbGRBbm4iLCJpbnNGaWVsZEFubiIsImluc1ZhckFubiIsInZhckFubiIsImdldE4iLCJyaWdodCIsImdldE50aCIsInVwZGF0ZU50aCIsInZhclN1ZmZpeCIsInN1ZmZpeCIsImJyYW5jaFR5cGUiLCJicjAiLCJicjEiLCJyZXRTdGFjayIsIl9lIiwidHJpbSIsImxhc3RJbmRleE9mIiwicmV0QXJncyIsInZhIiwidG9Mb2NhbGVMb3dlckNhc2UiLCJwdCIsIlBzaVRoYUNhIiwiY29udHJhY3RFbnRyeVBvaW50IiwiY29udHJhY3RTZWN0aW9uIiwiY2hpbGRyZW4iLCJ0YWlsIiwibGVmdGEiLCJyaWdodGEiLCJib2R5IiwiaGVhZCIsImFzc2VydENvbnRyYWN0VmFsaWQiLCJQdExpbWFQdEwiLCJQdEpha2FydGEiLCJzZWN0aW9uIiwiY29udHJhY3RWaWV3cyIsImlzQ29udHJhY3QiLCJjb250cmFjdEVudHJ5UG9pbnRzIiwiZmluZCIsImlzT3JUeXBlIiwicGFyYW0iLCJnZXRBcmciLCJhc3NlcnRTZWN0aW9uIiwicGFyYW1ldGVyIiwic3RvcmFnZSIsImNvZGUiLCJleHBlY3RlZCIsInZpZXciLCJ2YWx1ZXMiLCJhc3NlcnREYXRhVmFsaWQiLCJmdW5jdGlvblR5cGUiLCJ0eXBlc2VjIiwiYXNzZXJ0VHlwZXNFcXVhbCIsImlzVHlwZUFubm90YXRpb25zVmFsaWQiLCJpc0NvbnRyYWN0VmFsaWQiLCJpc0RhdGFWYWxpZCIsImlzVHlwZUVxdWFsIiwiQ29udHJhY3QiLCJvdXRwdXQiLCJwYXJzZVR5cGVFeHByZXNzaW9uIiwicGFyc2VEYXRhRXhwcmVzc2lvbiIsImVudHJ5UG9pbnRzIiwiYXNzZXJ0UGFyYW1ldGVyVmFsaWQiLCJpc1BhcmFtZXRlclZhbGlkIiwiZHVtbXlDb250cmFjdCIsImZvcm1hdFN0YWNrIiwidHJhY2VEdW1wRnVuYyIsImJsb2NrcyIsImZvcm1hdEVycm9yIiwiVkVSU0lPTiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es6.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es6.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AddressValidationError: () => (/* binding */ AddressValidationError),\n/* harmony export */   BigMapEncodingError: () => (/* binding */ BigMapEncodingError),\n/* harmony export */   BigMapValidationError: () => (/* binding */ BigMapValidationError),\n/* harmony export */   BytesValidationError: () => (/* binding */ BytesValidationError),\n/* harmony export */   ChainIDValidationError: () => (/* binding */ ChainIDValidationError),\n/* harmony export */   ContractValidationError: () => (/* binding */ ContractValidationError),\n/* harmony export */   EncodeTicketError: () => (/* binding */ EncodeTicketError),\n/* harmony export */   EventSchema: () => (/* binding */ EventSchema),\n/* harmony export */   IntValidationError: () => (/* binding */ IntValidationError),\n/* harmony export */   InvalidBigMapDiffError: () => (/* binding */ InvalidBigMapDiffError),\n/* harmony export */   InvalidBigMapSchemaError: () => (/* binding */ InvalidBigMapSchemaError),\n/* harmony export */   InvalidMapTypeError: () => (/* binding */ InvalidMapTypeError),\n/* harmony export */   InvalidRpcResponseError: () => (/* binding */ InvalidRpcResponseError),\n/* harmony export */   InvalidScriptError: () => (/* binding */ InvalidScriptError),\n/* harmony export */   KeyHashValidationError: () => (/* binding */ KeyHashValidationError),\n/* harmony export */   KeyValidationError: () => (/* binding */ KeyValidationError),\n/* harmony export */   ListValidationError: () => (/* binding */ ListValidationError),\n/* harmony export */   MapTypecheckError: () => (/* binding */ MapTypecheckError),\n/* harmony export */   MapValidationError: () => (/* binding */ MapValidationError),\n/* harmony export */   MichelsonMap: () => (/* binding */ MichelsonMap),\n/* harmony export */   MissingArgumentError: () => (/* binding */ MissingArgumentError),\n/* harmony export */   MutezValidationError: () => (/* binding */ MutezValidationError),\n/* harmony export */   NatValidationError: () => (/* binding */ NatValidationError),\n/* harmony export */   OrValidationError: () => (/* binding */ OrValidationError),\n/* harmony export */   ParameterEncodingError: () => (/* binding */ ParameterEncodingError),\n/* harmony export */   ParameterSchema: () => (/* binding */ ParameterSchema),\n/* harmony export */   SaplingStateValue: () => (/* binding */ SaplingStateValue),\n/* harmony export */   Schema: () => (/* binding */ Schema),\n/* harmony export */   SetValidationError: () => (/* binding */ SetValidationError),\n/* harmony export */   SignatureValidationError: () => (/* binding */ SignatureValidationError),\n/* harmony export */   StorageEncodingError: () => (/* binding */ StorageEncodingError),\n/* harmony export */   Token: () => (/* binding */ Token),\n/* harmony export */   TokenArgumentValidationError: () => (/* binding */ TokenArgumentValidationError),\n/* harmony export */   TokenComparisonError: () => (/* binding */ TokenComparisonError),\n/* harmony export */   UnitValue: () => (/* binding */ UnitValue),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   ViewSchema: () => (/* binding */ ViewSchema),\n/* harmony export */   deepEqual: () => (/* binding */ deepEqual)\n/* harmony export */ });\n/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-json-stable-stringify */ \"(ssr)/./node_modules/fast-json-stable-stringify/index.js\");\n/* harmony import */ var fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var _taquito_utils__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @taquito/utils */ \"(ssr)/./node_modules/@taquito/utils/dist/taquito-utils.es6.js\");\n\n\n\n\nvar _a$1;\n/**\n *  @category Error\n *  @description Error that indicates an invalid map type being passed or used\n */ class InvalidMapTypeError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(mapType, reason){\n        super();\n        this.mapType = mapType;\n        this.reason = reason;\n        this.message = `The map type '${JSON.stringify(mapType)}' is invalid. Reason: ${reason}.`;\n        this.name = \"InvalidMapTypeError\";\n    }\n}\n// Retrieve a unique symbol associated with the key from the environment\n// Used in order to identify all object that are of type MichelsonMap even if they come from different module\nconst michelsonMapTypeSymbol = Symbol.for(\"taquito-michelson-map-type-symbol\");\n/**\n *\n * @throws {@link InvalidMapTypeError} when the argument passed to mapType is not a valid map type\n */ function validateMapType(value) {\n    if (!(\"prim\" in value)) {\n        throw new InvalidMapTypeError(value, `Missing 'prim' field`);\n    }\n    if (![\n        \"map\",\n        \"big_map\"\n    ].includes(value.prim)) {\n        throw new InvalidMapTypeError(value, `The prim field should be 'map' or 'big_map'`);\n    }\n    if (!(\"args\" in value)) {\n        throw new InvalidMapTypeError(value, `Missing 'args' field`);\n    }\n    if (!Array.isArray(value.args)) {\n        throw new InvalidMapTypeError(value, `The 'args' field should be an array`);\n    }\n    if (value.args.length !== 2) {\n        throw new InvalidMapTypeError(value, `The 'args' field should have 2 elements`);\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a map type mismatch, where an attempt to set a key or value in a Map doesn't match the defined type of the Map\n */ class MapTypecheckError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(value, type, objectType, reason){\n        super();\n        this.value = value;\n        this.type = type;\n        this.reason = reason;\n        this.name = \"MapTypecheckError\";\n        this.message = `The ${objectType} provided: ${JSON.stringify(value)} is not compatible with the expected michelson type: ${JSON.stringify(type)}. Reason: ${JSON.stringify(reason)}.`;\n        this.name = \"MapTypecheckError\";\n    }\n}\n/**\n * @description Michelson Map is an abstraction over the michelson native map. It supports complex Pair as key\n */ class MichelsonMap {\n    // Used to check if an object is a michelson map.\n    // Using instanceof was not working for project that had multiple instance of taquito dependencies\n    // as the class constructor is different\n    static isMichelsonMap(obj) {\n        return obj && obj[michelsonMapTypeSymbol] === true;\n    }\n    /**\n     * @param mapType If specified key and value will be type-checked before being added to the map\n     *\n     * @example new MichelsonMap({ prim: \"map\", args: [{prim: \"string\"}, {prim: \"int\"}]})\n     */ constructor(mapType){\n        this.valueMap = new Map();\n        this.keyMap = new Map();\n        this[_a$1] = true;\n        if (mapType) {\n            this.setType(mapType);\n        }\n    }\n    setType(mapType) {\n        validateMapType(mapType);\n        this.keySchema = new Schema(mapType.args[0]);\n        this.valueSchema = new Schema(mapType.args[1]);\n    }\n    removeType() {\n        this.keySchema = undefined;\n        this.valueSchema = undefined;\n    }\n    static fromLiteral(obj, mapType) {\n        const map = new MichelsonMap(mapType);\n        Object.keys(obj).forEach((key)=>{\n            map.set(key, obj[key]);\n        });\n        return map;\n    }\n    typecheckKey(key) {\n        if (!this.keySchema) {\n            return;\n        }\n        this.keySchema.Typecheck(key);\n    }\n    typecheckValue(value) {\n        if (!this.valueSchema) {\n            return;\n        }\n        this.valueSchema.Typecheck(value);\n    }\n    /**\n     * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for value\n     */ assertTypecheckValue(value) {\n        try {\n            this.typecheckValue(value);\n        } catch (e) {\n            throw new MapTypecheckError(value, this.valueSchema, \"value\", e);\n        }\n    }\n    /**\n     * @throws {@link MapTypecheckError} when the argument passed does not match the expected schema for key\n     */ assertTypecheckKey(key) {\n        try {\n            this.typecheckKey(key);\n        } catch (e) {\n            throw new MapTypecheckError(key, this.keySchema, \"key\", e);\n        }\n    }\n    serializeDeterministically(key) {\n        return fast_json_stable_stringify__WEBPACK_IMPORTED_MODULE_0___default()(key);\n    }\n    *keys() {\n        for (const [key] of this.entries()){\n            yield key;\n        }\n    }\n    *values() {\n        for (const [, value] of this.entries()){\n            yield value;\n        }\n    }\n    *entries() {\n        for (const key of this.valueMap.keys()){\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            yield [\n                this.keyMap.get(key),\n                this.valueMap.get(key)\n            ];\n        }\n    }\n    get(key) {\n        this.assertTypecheckKey(key);\n        const strKey = this.serializeDeterministically(key);\n        return this.valueMap.get(strKey);\n    }\n    /**\n     *\n     * @description Set a key and a value in the MichelsonMap. If the key already exists, override the current value.\n     *\n     * @example map.set(\"myKey\", \"myValue\") // Using a string as key\n     *\n     * @example map.set({0: \"test\", 1: \"test1\"}, \"myValue\") // Using a pair as key\n     *\n     * @warn The same key can be represented in multiple ways, depending on the type of the key. This duplicate key situation will cause a runtime error (duplicate key) when sending the map data to the Tezos RPC node.\n     *\n     * For example, consider a contract with a map whose key is of type boolean.  If you set the following values in MichelsonMap: map.set(false, \"myValue\") and map.set(null, \"myValue\").\n     *\n     * You will get two unique entries in the MichelsonMap. These values will both be evaluated as falsy by the MichelsonEncoder and ultimately rejected by the Tezos RPC.\n     */ set(key, value) {\n        this.assertTypecheckKey(key);\n        this.assertTypecheckValue(value);\n        const strKey = this.serializeDeterministically(key);\n        this.keyMap.set(strKey, key);\n        this.valueMap.set(strKey, value);\n    }\n    delete(key) {\n        this.assertTypecheckKey(key);\n        this.keyMap.delete(this.serializeDeterministically(key));\n        this.valueMap.delete(this.serializeDeterministically(key));\n    }\n    has(key) {\n        this.assertTypecheckKey(key);\n        const strKey = this.serializeDeterministically(key);\n        return this.keyMap.has(strKey) && this.valueMap.has(strKey);\n    }\n    clear() {\n        this.keyMap.clear();\n        this.valueMap.clear();\n    }\n    get size() {\n        return this.keyMap.size;\n    }\n    forEach(cb) {\n        for (const [key, value] of this.entries()){\n            cb(value, key, this);\n        }\n    }\n}\n_a$1 = michelsonMapTypeSymbol;\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding invalid or incorrect data (e.g. if an address is expected but a number is received)\n */ class TokenValidationError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(value, token, baseMessage){\n        super();\n        this.value = value;\n        this.token = token;\n        this.name = \"TokenValidationError\";\n        const annot = this.token.annot();\n        const annotText = annot ? `[${annot}] ` : \"\";\n        this.message = `${annotText}${baseMessage}`;\n    }\n}\nclass Token {\n    constructor(val, idx, fac){\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n        this.createToken = this.fac;\n    }\n    typeWithoutAnnotations() {\n        const handleMichelsonExpression = (val)=>{\n            if (typeof val === \"object\") {\n                if (Array.isArray(val)) {\n                    const array = val;\n                    return array.map((item)=>handleMichelsonExpression(item));\n                }\n                const extended = val;\n                if (extended.args) {\n                    return {\n                        prim: extended.prim,\n                        args: extended.args.map((x)=>handleMichelsonExpression(x))\n                    };\n                } else {\n                    return {\n                        prim: extended.prim\n                    };\n                }\n            }\n            return val;\n        };\n        const handleMichelsonExtended = (val)=>{\n            if (val.args) {\n                return {\n                    prim: val.prim,\n                    args: val.args.map((x)=>handleMichelsonExpression(x))\n                };\n            } else {\n                return {\n                    prim: val.prim\n                };\n            }\n        };\n        return handleMichelsonExtended(this.val);\n    }\n    annot() {\n        return (Array.isArray(this.val.annots) && this.val.annots.length > 0 ? this.val.annots[0] : String(this.idx)).replace(/(%|:)(_Liq_entry_)?/, \"\");\n    }\n    hasAnnotations() {\n        return Array.isArray(this.val.annots) && this.val.annots.length;\n    }\n    get tokenVal() {\n        return this.val;\n    }\n    ExtractSignature() {\n        return [\n            [\n                this.ExtractSchema()\n            ]\n        ];\n    }\n}\nclass ComparableToken extends Token {\n    compare(o1, o2) {\n        if (o1 === o2) {\n            return 0;\n        }\n        return o1 < o2 ? -1 : 1;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Big Map types\n */ class BigMapValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"BigMapValidationError\";\n    }\n}\nclass BigMapToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    get ValueSchema() {\n        return this.createToken(this.val.args[1], 0);\n    }\n    get KeySchema() {\n        return this.createToken(this.val.args[0], 0);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            big_map: {\n                key: this.KeySchema.ExtractSchema(),\n                value: this.ValueSchema.ExtractSchema()\n            }\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: BigMapToken.prim,\n            schema: {\n                key: this.KeySchema.generateSchema(),\n                value: this.ValueSchema.generateSchema()\n            }\n        };\n    }\n    /**\n     * @throws {@link BigMapValidationError}\n     */ validate(value) {\n        if (!MichelsonMap.isMichelsonMap(value)) {\n            throw new BigMapValidationError(value, this, `Value ${JSON.stringify(value)} is not a MichelsonMap`);\n        }\n    }\n    objLitToMichelsonMap(val) {\n        if (val instanceof MichelsonMap) return val;\n        if (typeof val === \"object\") {\n            if (Object.keys(val).length === 0) {\n                return new MichelsonMap();\n            } else {\n                return MichelsonMap.fromLiteral(val);\n            }\n        }\n        return val;\n    }\n    /**\n     * @throws {@link BigMapValidationError}\n     */ Encode(args) {\n        const val = this.objLitToMichelsonMap(args.pop());\n        this.validate(val);\n        return Array.from(val.keys()).sort((a, b)=>this.KeySchema.compare(a, b)).map((key)=>{\n            return {\n                prim: \"Elt\",\n                args: [\n                    this.KeySchema.EncodeObject(key),\n                    this.ValueSchema.EncodeObject(val.get(key))\n                ]\n            };\n        });\n    }\n    /**\n     * @throws {@link BigMapValidationError}\n     */ EncodeObject(args, semantic) {\n        const val = this.objLitToMichelsonMap(args);\n        this.validate(val);\n        if (semantic && semantic[BigMapToken.prim]) {\n            return semantic[BigMapToken.prim](val, this.val);\n        }\n        return Array.from(val.keys()).sort((a, b)=>this.KeySchema.compare(a, b)).map((key)=>{\n            return {\n                prim: \"Elt\",\n                args: [\n                    this.KeySchema.EncodeObject(key),\n                    this.ValueSchema.EncodeObject(val.get(key))\n                ]\n            };\n        });\n    }\n    /**\n     * @throws {@link InvalidMapTypeError} when the argument passed to val is an array but not a valid map type\n     * @throws {@link BigMapValidationError} when the value is invalid\n     */ Execute(val, semantic) {\n        if (semantic && semantic[BigMapToken.prim]) {\n            return semantic[BigMapToken.prim](val, this.val);\n        }\n        if (Array.isArray(val)) {\n            // Athens is returning an empty array for big map in storage\n            // Internal: In taquito v5 it is still used to decode big map diff (as if they were a regular map)\n            const map = new MichelsonMap(this.val);\n            val.forEach((current)=>{\n                map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1]));\n            });\n            return map;\n        } else if (\"int\" in val) {\n            // Babylon is returning an int with the big map id in contract storage\n            return val.int;\n        } else {\n            throw new BigMapValidationError(val, this, `Big map is expecting either an array (Athens) or an object with an int property (Babylon). Got ${JSON.stringify(val)}`);\n        }\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (BigMapToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n        this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nBigMapToken.prim = \"big_map\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing an OrToken\n */ class OrValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"OrValidationError\";\n    }\n}\nclass OrToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Encode(args) {\n        const label = args[args.length - 1];\n        const leftToken = this.createToken(this.val.args[0], this.idx);\n        let keyCount = 1;\n        if (leftToken instanceof OrToken) {\n            keyCount = Object.keys(leftToken.ExtractSchema()).length;\n        }\n        const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n        if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n            args.pop();\n            return {\n                prim: \"Left\",\n                args: [\n                    leftToken.Encode(args)\n                ]\n            };\n        } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n            args.pop();\n            return {\n                prim: \"Right\",\n                args: [\n                    rightToken.Encode(args)\n                ]\n            };\n        } else {\n            if (leftToken instanceof OrToken) {\n                const val = leftToken.Encode(args);\n                if (val) {\n                    return {\n                        prim: \"Left\",\n                        args: [\n                            val\n                        ]\n                    };\n                }\n            }\n            if (rightToken instanceof OrToken) {\n                const val = rightToken.Encode(args);\n                if (val) {\n                    return {\n                        prim: \"Right\",\n                        args: [\n                            val\n                        ]\n                    };\n                }\n            }\n            return null;\n        }\n    }\n    ExtractSignature() {\n        const leftToken = this.createToken(this.val.args[0], this.idx);\n        let keyCount = 1;\n        if (leftToken instanceof OrToken) {\n            keyCount = Object.keys(leftToken.ExtractSchema()).length;\n        }\n        const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n        const newSig = [];\n        if (leftToken instanceof OrToken) {\n            newSig.push(...leftToken.ExtractSignature());\n        } else {\n            for (const sig of leftToken.ExtractSignature()){\n                newSig.push([\n                    leftToken.annot(),\n                    ...sig\n                ]);\n            }\n        }\n        if (rightToken instanceof OrToken) {\n            newSig.push(...rightToken.ExtractSignature());\n        } else {\n            for (const sig of rightToken.ExtractSignature()){\n                newSig.push([\n                    rightToken.annot(),\n                    ...sig\n                ]);\n            }\n        }\n        return newSig;\n    }\n    /**\n     * @throws {@link OrValidationError}\n     */ EncodeObject(args, semantic) {\n        this.validateJavascriptObject(args);\n        const label = Object.keys(args)[0];\n        const leftToken = this.createToken(this.val.args[0], this.idx);\n        let keyCount = 1;\n        if (leftToken instanceof OrToken) {\n            keyCount = Object.keys(leftToken.ExtractSchema()).length;\n        }\n        const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n        if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken)) {\n            return {\n                prim: \"Left\",\n                args: [\n                    leftToken.EncodeObject(args[label], semantic)\n                ]\n            };\n        } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken)) {\n            return {\n                prim: \"Right\",\n                args: [\n                    rightToken.EncodeObject(args[label], semantic)\n                ]\n            };\n        } else {\n            if (leftToken instanceof OrToken) {\n                const val = leftToken.EncodeObject(args, semantic);\n                if (val) {\n                    return {\n                        prim: \"Left\",\n                        args: [\n                            val\n                        ]\n                    };\n                }\n            }\n            if (rightToken instanceof OrToken) {\n                const val = rightToken.EncodeObject(args, semantic);\n                if (val) {\n                    return {\n                        prim: \"Right\",\n                        args: [\n                            val\n                        ]\n                    };\n                }\n            }\n            return null;\n        }\n    }\n    /**\n     * @throws {@link OrValidationError}\n     */ validateJavascriptObject(args) {\n        if (typeof args !== \"object\" || Array.isArray(args) || args === null || Object.keys(args).length !== 1) {\n            throw new OrValidationError(args, this, `EncodeObject expects an object with a single key but got: ${JSON.stringify(args)}`);\n        }\n    }\n    /**\n     * @throws {@link OrValidationError}\n     */ Execute(val, semantics) {\n        const leftToken = this.createToken(this.val.args[0], this.idx);\n        let keyCount = 1;\n        if (leftToken instanceof OrToken) {\n            keyCount = Object.keys(leftToken.ExtractSchema()).length;\n        }\n        const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n        if (val.prim === \"Right\") {\n            if (rightToken instanceof OrToken) {\n                return rightToken.Execute(val.args[0], semantics);\n            } else {\n                return {\n                    [rightToken.annot()]: rightToken.Execute(val.args[0], semantics)\n                };\n            }\n        } else if (val.prim === \"Left\") {\n            if (leftToken instanceof OrToken) {\n                return leftToken.Execute(val.args[0], semantics);\n            }\n            return {\n                [leftToken.annot()]: leftToken.Execute(val.args[0], semantics)\n            };\n        } else {\n            throw new OrValidationError(val, this, `Was expecting Left or Right prim but got: ${JSON.stringify(val.prim)}`);\n        }\n    }\n    traversal(getLeftValue, getRightValue, concat) {\n        const leftToken = this.createToken(this.val.args[0], this.idx);\n        let keyCount = 1;\n        let leftValue;\n        if (leftToken instanceof OrToken) {\n            leftValue = getLeftValue(leftToken);\n            keyCount = Object.keys(leftToken.ExtractSchema()).length;\n        } else {\n            leftValue = {\n                [leftToken.annot()]: getLeftValue(leftToken)\n            };\n        }\n        const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n        let rightValue;\n        if (rightToken instanceof OrToken) {\n            rightValue = getRightValue(rightToken);\n        } else {\n            rightValue = {\n                [rightToken.annot()]: getRightValue(rightToken)\n            };\n        }\n        const res = concat(leftValue, rightValue);\n        return res;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return this.traversal((leftToken)=>leftToken.ExtractSchema(), (rightToken)=>rightToken.ExtractSchema(), (leftValue, rightValue)=>Object.assign(Object.assign({}, leftValue), rightValue));\n    }\n    generateSchema() {\n        return {\n            __michelsonType: OrToken.prim,\n            schema: this.traversal((leftToken)=>{\n                if (leftToken instanceof OrToken) {\n                    return leftToken.generateSchema().schema;\n                } else {\n                    return leftToken.generateSchema();\n                }\n            }, (rightToken)=>{\n                if (rightToken instanceof OrToken) {\n                    return rightToken.generateSchema().schema;\n                } else {\n                    return rightToken.generateSchema();\n                }\n            }, (leftValue, rightValue)=>Object.assign(Object.assign({}, leftValue), rightValue))\n        };\n    }\n    findToken(label) {\n        const leftToken = this.createToken(this.val.args[0], this.idx);\n        let keyCount = 1;\n        if (leftToken instanceof OrToken) {\n            keyCount = Object.keys(leftToken.ExtractSchema()).length;\n        }\n        const rightToken = this.createToken(this.val.args[1], this.idx + keyCount);\n        if (String(leftToken.annot()) === String(label) && !(leftToken instanceof OrToken) && leftToken instanceof ComparableToken) {\n            return leftToken;\n        } else if (String(rightToken.annot()) === String(label) && !(rightToken instanceof OrToken) && rightToken instanceof ComparableToken) {\n            return rightToken;\n        } else {\n            if (leftToken instanceof OrToken) {\n                const tok = leftToken.findToken(label);\n                if (tok) {\n                    return tok;\n                }\n            }\n            if (rightToken instanceof OrToken) {\n                const tok = rightToken.findToken(label);\n                if (tok) {\n                    return tok;\n                }\n            }\n            return null;\n        }\n    }\n    compare(val1, val2) {\n        const labelVal1 = Object.keys(val1)[0];\n        const labelVal2 = Object.keys(val2)[0];\n        if (labelVal1 === labelVal2) {\n            const token = this.findToken(labelVal1);\n            if (token instanceof ComparableToken) {\n                return token.compare(val1[labelVal1], val2[labelVal1]);\n            }\n        } else {\n            const encoded1 = JSON.stringify(this.EncodeObject(val1));\n            const encoded2 = JSON.stringify(this.EncodeObject(val2));\n            return encoded1 < encoded2 ? -1 : 1;\n        }\n    }\n    ToKey(val) {\n        return this.Execute(val);\n    }\n    ToBigMapKey(val) {\n        return {\n            key: this.EncodeObject(val),\n            type: this.typeWithoutAnnotations()\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (OrToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.traversal((leftToken)=>leftToken.findAndReturnTokens(tokenToFind, tokens), (rightToken)=>rightToken.findAndReturnTokens(tokenToFind, tokens), (leftValue, rightValue)=>Object.assign(Object.assign({}, leftValue), rightValue));\n        return tokens;\n    }\n}\nOrToken.prim = \"or\";\n/**\n *  @category Error\n *  @description Error that indicates in invalid token argument being passed\n */ class TokenArgumentValidationError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(message){\n        super(message);\n        this.message = message;\n        this.name = \"TokenArgumentValidationError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure occurring when doing a comparison of tokens\n */ class TokenComparisonError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(val1, val2){\n        super();\n        this.val1 = val1;\n        this.val2 = val2;\n        this.name = \"TokenComparisonError\";\n        this.message = `Tokens ${JSON.stringify(val1)} and ${JSON.stringify(val2)} are not comparable`;\n    }\n}\n// collapse comb pair\n/**\n * @throws {@link TokenArgumentValidationError}\n */ function collapse$1(val, prim = PairToken.prim) {\n    if (Array.isArray(val)) {\n        return collapse$1({\n            prim: prim,\n            args: val\n        }, prim);\n    }\n    if (val.args === undefined) {\n        throw new TokenArgumentValidationError(`The value ${JSON.stringify(val)} is an invalid PairToken with no arguments, a pair must have two or more arguments.`);\n    }\n    if (val.args.length > 2) {\n        return [\n            val.args[0],\n            {\n                prim: prim,\n                args: val.args.slice(1)\n            }\n        ];\n    }\n    return [\n        val.args[0],\n        val.args[1]\n    ];\n}\nclass PairToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(Array.isArray(val) ? {\n            prim: PairToken.prim,\n            args: val\n        } : val.prim ? val : {\n            prim: PairToken.prim,\n            args: val\n        }, idx, fac);\n    }\n    args() {\n        // collapse comb pair\n        return collapse$1(this.val);\n    }\n    tokens() {\n        let cnt = 0;\n        return this.args().map((a)=>{\n            const tok = this.createToken(a, this.idx + cnt);\n            if (tok instanceof PairToken) {\n                cnt += Object.keys(tok.ExtractSchema()).length;\n            } else {\n                cnt++;\n            }\n            return tok;\n        });\n    }\n    Encode(args) {\n        return {\n            prim: \"Pair\",\n            args: this.tokens().map((t)=>t.Encode(args))\n        };\n    }\n    ExtractSignature() {\n        const args = this.args();\n        const leftToken = this.createToken(args[0], this.idx);\n        let keyCount = 1;\n        if (leftToken instanceof OrToken) {\n            keyCount = Object.keys(leftToken.ExtractSchema()).length;\n        }\n        const rightToken = this.createToken(args[1], this.idx + keyCount);\n        const newSig = [];\n        for (const leftSig of leftToken.ExtractSignature()){\n            for (const rightSig of rightToken.ExtractSignature()){\n                newSig.push([\n                    ...leftSig,\n                    ...rightSig\n                ]);\n            }\n        }\n        return newSig;\n    }\n    ToBigMapKey(val) {\n        return {\n            key: this.EncodeObject(val),\n            type: this.typeWithoutAnnotations()\n        };\n    }\n    ToKey(val) {\n        return this.Execute(val);\n    }\n    EncodeObject(args, semantic) {\n        const [leftToken, rightToken] = this.tokens();\n        let leftValue;\n        if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n            leftValue = args;\n        } else {\n            leftValue = args[leftToken.annot()];\n        }\n        let rightValue;\n        if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n            rightValue = args;\n        } else {\n            rightValue = args[rightToken.annot()];\n        }\n        return {\n            prim: \"Pair\",\n            args: [\n                leftToken.EncodeObject(leftValue, semantic),\n                rightToken.EncodeObject(rightValue, semantic)\n            ]\n        };\n    }\n    traversal(getLeftValue, getRightValue) {\n        const args = this.args();\n        const leftToken = this.createToken(args[0], this.idx);\n        let keyCount = 1;\n        let leftValue;\n        if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n            leftValue = getLeftValue(leftToken);\n            if (leftToken instanceof PairToken) {\n                keyCount = Object.keys(leftToken.ExtractSchema()).length;\n            }\n        } else {\n            leftValue = {\n                [leftToken.annot()]: getLeftValue(leftToken)\n            };\n        }\n        const rightToken = this.createToken(args[1], this.idx + keyCount);\n        let rightValue;\n        if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n            rightValue = getRightValue(rightToken);\n        } else {\n            rightValue = {\n                [rightToken.annot()]: getRightValue(rightToken)\n            };\n        }\n        const res = Object.assign(Object.assign({}, leftValue), rightValue);\n        return res;\n    }\n    Execute(val, semantics) {\n        const args = collapse$1(val, \"Pair\");\n        return this.traversal((leftToken)=>leftToken.Execute(args[0], semantics), (rightToken)=>rightToken.Execute(args[1], semantics));\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return this.traversal((leftToken)=>leftToken.ExtractSchema(), (rightToken)=>rightToken.ExtractSchema());\n    }\n    generateSchema() {\n        return {\n            __michelsonType: PairToken.prim,\n            schema: this.traversal((leftToken)=>{\n                if (leftToken instanceof PairToken && !leftToken.hasAnnotations()) {\n                    return leftToken.generateSchema().schema;\n                } else {\n                    return leftToken.generateSchema();\n                }\n            }, (rightToken)=>{\n                if (rightToken instanceof PairToken && !rightToken.hasAnnotations()) {\n                    return rightToken.generateSchema().schema;\n                } else {\n                    return rightToken.generateSchema();\n                }\n            })\n        };\n    }\n    /**\n     * @throws {@link TokenComparisonError}\n     */ compare(val1, val2) {\n        const [leftToken, rightToken] = this.tokens();\n        const getValue = (token, args)=>{\n            if (token instanceof PairToken && !token.hasAnnotations()) {\n                return args;\n            } else {\n                return args[token.annot()];\n            }\n        };\n        if (leftToken instanceof ComparableToken && rightToken instanceof ComparableToken) {\n            const result = leftToken.compare(getValue(leftToken, val1), getValue(leftToken, val2));\n            if (result === 0) {\n                return rightToken.compare(getValue(rightToken, val1), getValue(rightToken, val2));\n            }\n            return result;\n        }\n        throw new TokenComparisonError(val1, val2);\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (PairToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.tokens().map((t)=>t.findAndReturnTokens(tokenToFind, tokens));\n        return tokens;\n    }\n}\nPairToken.prim = \"pair\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Nat\n */ class NatValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"NatValidationError\";\n    }\n}\nclass NatToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val[Object.keys(val)[0]]);\n    }\n    /**\n     * @throws {@link NatValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            int: new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val).toFixed()\n        };\n    }\n    /**\n     * @throws {@link NatValidationError}\n     */ validate(val) {\n        const bigNumber = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val);\n        if (bigNumber.isNaN()) {\n            throw new NatValidationError(val, this, `Value is not a number: ${JSON.stringify(val)}`);\n        }\n        if (bigNumber.isNegative()) {\n            throw new NatValidationError(val, this, `Value cannot be negative: ${JSON.stringify(val)}`);\n        }\n    }\n    /**\n     * @throws {@link NatValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[NatToken.prim]) {\n            return semantic[NatToken.prim](val);\n        }\n        return {\n            int: new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val).toFixed()\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return NatToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: NatToken.prim,\n            schema: NatToken.prim\n        };\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                int: String(val)\n            },\n            type: {\n                prim: NatToken.prim\n            }\n        };\n    }\n    ToKey({ int }) {\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](int);\n    }\n    compare(nat1, nat2) {\n        const o1 = Number(nat1);\n        const o2 = Number(nat2);\n        if (o1 === o2) {\n            return 0;\n        }\n        return o1 < o2 ? -1 : 1;\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (NatToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nNatToken.prim = \"nat\";\nclass StringToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        return val[Object.keys(val)[0]];\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return StringToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: StringToken.prim,\n            schema: StringToken.prim\n        };\n    }\n    Encode(args) {\n        const val = args.pop();\n        return {\n            string: val\n        };\n    }\n    EncodeObject(val, semantic) {\n        if (semantic && semantic[StringToken.prim]) {\n            return semantic[StringToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    ToKey({ string }) {\n        return string;\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                string: val\n            },\n            type: {\n                prim: StringToken.prim\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (StringToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nStringToken.prim = \"string\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing an Address\n */ class AddressValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"AddressValidationError\";\n    }\n}\nclass AddressToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    ToBigMapKey(val) {\n        const decoded = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.b58decode)(val);\n        return {\n            key: {\n                bytes: decoded\n            },\n            type: {\n                prim: \"bytes\"\n            }\n        };\n    }\n    /**\n     * @throws {@link AddressValidationError}\n     */ validate(value) {\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.validateAddress)(value) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.ValidationResult.VALID) {\n            throw new AddressValidationError(value, this, `Address is not valid: ${JSON.stringify(value)}`);\n        }\n    }\n    /**\n     * @throws {@link AddressValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            string: val\n        };\n    }\n    /**\n     * @throws {@link AddressValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[AddressToken.prim]) {\n            return semantic[AddressToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    /**\n     * @throws {@link AddressValidationError}\n     */ Execute(val) {\n        if (val.string) {\n            return val.string;\n        }\n        if (!val.bytes) {\n            throw new AddressValidationError(val, this, `cannot be missing both string and bytes: ${JSON.stringify(val)}`);\n        }\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.encodePubKey)(val.bytes);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return AddressToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: AddressToken.prim,\n            schema: AddressToken.prim\n        };\n    }\n    /**\n     * @throws {@link AddressValidationError}\n     */ ToKey({ bytes, string }) {\n        if (string) {\n            return string;\n        }\n        if (!bytes) {\n            throw new AddressValidationError({\n                bytes,\n                string\n            }, this, `cannot be missing both string and bytes ${JSON.stringify({\n                string,\n                bytes\n            })}`);\n        }\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.encodePubKey)(bytes);\n    }\n    compare(address1, address2) {\n        const isImplicit = (address)=>{\n            return address.startsWith(\"tz\");\n        };\n        const implicit1 = isImplicit(address1);\n        const implicit2 = isImplicit(address2);\n        if (implicit1 && !implicit2) {\n            return -1;\n        } else if (implicit2 && !implicit1) {\n            return 1;\n        }\n        return super.compare(address1, address2);\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (AddressToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nAddressToken.prim = \"address\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Map\n */ class MapValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"MapValidationError\";\n    }\n}\nclass MapToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    get ValueSchema() {\n        return this.createToken(this.val.args[1], 0);\n    }\n    get KeySchema() {\n        return this.createToken(this.val.args[0], 0);\n    }\n    /**\n     * @throws {@link MapValidationError}\n     */ validate(value) {\n        if (!MichelsonMap.isMichelsonMap(value)) {\n            throw new MapValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid MichelsonMap`);\n        }\n    }\n    Execute(val, semantics) {\n        const map = new MichelsonMap(this.val);\n        val.forEach((current)=>{\n            map.set(this.KeySchema.ToKey(current.args[0]), this.ValueSchema.Execute(current.args[1], semantics));\n        });\n        return map;\n    }\n    objLitToMichelsonMap(val) {\n        if (val instanceof MichelsonMap) return val;\n        if (typeof val === \"object\") {\n            if (Object.keys(val).length === 0) {\n                return new MichelsonMap();\n            } else {\n                return MichelsonMap.fromLiteral(val);\n            }\n        }\n        return val;\n    }\n    /**\n     * @throws {@link MapValidationError}\n     */ Encode(args) {\n        const val = this.objLitToMichelsonMap(args.pop());\n        this.validate(val);\n        return Array.from(val.keys()).sort((a, b)=>this.KeySchema.compare(a, b)).map((key)=>{\n            return {\n                prim: \"Elt\",\n                args: [\n                    this.KeySchema.EncodeObject(key),\n                    this.ValueSchema.EncodeObject(val.get(key))\n                ]\n            };\n        });\n    }\n    /**\n     * @throws {@link MapValidationError}\n     */ EncodeObject(args, semantic) {\n        const val = this.objLitToMichelsonMap(args);\n        this.validate(val);\n        if (semantic && semantic[MapToken.prim]) {\n            return semantic[MapToken.prim](val);\n        }\n        return Array.from(val.keys()).sort((a, b)=>this.KeySchema.compare(a, b)).map((key)=>{\n            return {\n                prim: \"Elt\",\n                args: [\n                    this.KeySchema.EncodeObject(key),\n                    this.ValueSchema.EncodeObject(val.get(key))\n                ]\n            };\n        });\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            map: {\n                key: this.KeySchema.ExtractSchema(),\n                value: this.ValueSchema.ExtractSchema()\n            }\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: MapToken.prim,\n            schema: {\n                key: this.KeySchema.generateSchema(),\n                value: this.ValueSchema.generateSchema()\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (MapToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n        this.ValueSchema.findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nMapToken.prim = \"map\";\nclass BoolToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        return String(val.prim).toLowerCase() === \"true\" ? true : false;\n    }\n    Encode(args) {\n        const val = args.pop();\n        return {\n            prim: val ? \"True\" : \"False\"\n        };\n    }\n    EncodeObject(val, semantic) {\n        if (semantic && semantic[BoolToken.prim]) {\n            return semantic[BoolToken.prim](val);\n        }\n        return {\n            prim: val ? \"True\" : \"False\"\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return BoolToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: BoolToken.prim,\n            schema: BoolToken.prim\n        };\n    }\n    ToBigMapKey(val) {\n        return {\n            key: this.EncodeObject(val),\n            type: {\n                prim: BoolToken.prim\n            }\n        };\n    }\n    ToKey(val) {\n        return this.EncodeObject(val);\n    }\n    compare(val1, val2) {\n        if (val1 && val2 || !val1 && !val2) {\n            return 0;\n        } else if (val1) {\n            return 1;\n        } else {\n            return -1;\n        }\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (BoolToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nBoolToken.prim = \"bool\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Contract\n */ class ContractValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"ContractValidationError\";\n    }\n}\nclass ContractToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link ContractValidationError}\n     */ validate(value) {\n        // tz1,tz2 and tz3 seems to be valid contract values (for Unit contract)\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.validateAddress)(value) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.ValidationResult.VALID) {\n            throw new ContractValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid contract address.`);\n        }\n        return null;\n    }\n    /**\n     * @throws {@link ContractValidationError}\n     */ Execute(val) {\n        if (val.string) {\n            return val.string;\n        }\n        if (!val.bytes) {\n            throw new ContractValidationError(val, this, `Value ${JSON.stringify(val)} is not a valid contract address. must contain bytes or string.`);\n        }\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.encodePubKey)(val.bytes);\n    }\n    /**\n     * @throws {@link ContractValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            string: val\n        };\n    }\n    /**\n     * @throws {@link ContractValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[ContractToken.prim]) {\n            return semantic[ContractToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return ContractToken.prim;\n    }\n    generateSchema() {\n        const valueSchema = this.createToken(this.val.args[0], 0);\n        return {\n            __michelsonType: ContractToken.prim,\n            schema: {\n                parameter: this.val.args[0] ? valueSchema.generateSchema() : {}\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (ContractToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nContractToken.prim = \"contract\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a List\n */ class ListValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"ListValidationError\";\n    }\n}\nclass ListToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    get valueSchema() {\n        return this.createToken(this.val.args[0], this.idx);\n    }\n    /**\n     * @throws {@link ListValidationError}\n     */ validate(value) {\n        if (!Array.isArray(value)) {\n            throw new ListValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid array`);\n        }\n    }\n    /**\n     * @throws {@link ListValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        const schema = this.createToken(this.val.args[0], 0);\n        return val.reduce((prev, current)=>{\n            return [\n                ...prev,\n                schema.EncodeObject(current)\n            ];\n        }, []);\n    }\n    /**\n     * @throws {@link ListValidationError}\n     */ Execute(val, semantics) {\n        const schema = this.createToken(this.val.args[0], 0);\n        this.validate(val);\n        return val.reduce((prev, current)=>{\n            return [\n                ...prev,\n                schema.Execute(current, semantics)\n            ];\n        }, []);\n    }\n    /**\n     * @throws {@link ListValidationError}\n     */ EncodeObject(args, semantic) {\n        const schema = this.createToken(this.val.args[0], 0);\n        this.validate(args);\n        if (semantic && semantic[ListToken.prim]) {\n            return semantic[ListToken.prim](args);\n        }\n        return args.reduce((prev, current)=>{\n            return [\n                ...prev,\n                schema.EncodeObject(current)\n            ];\n        }, []);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            [ListToken.prim]: this.valueSchema.ExtractSchema()\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: ListToken.prim,\n            schema: this.valueSchema.generateSchema()\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (ListToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nListToken.prim = \"list\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Mutez\n */ class MutezValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"MutezValidationError\";\n    }\n}\nclass MutezToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val[Object.keys(val)[0]]);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return MutezToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: MutezToken.prim,\n            schema: MutezToken.prim\n        };\n    }\n    /**\n     * @throws {@link MutezValidationError}\n     */ validate(val) {\n        const bigNumber = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val);\n        if (bigNumber.isNaN()) {\n            throw new MutezValidationError(val, this, `Value is not a number: ${val}`);\n        }\n    }\n    /**\n     * @throws {@link MutezValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            int: String(val).toString()\n        };\n    }\n    /**\n     * @throws {@link MutezValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[MutezToken.prim]) {\n            return semantic[MutezToken.prim](val);\n        }\n        return {\n            int: String(val).toString()\n        };\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                int: String(val)\n            },\n            type: {\n                prim: MutezToken.prim\n            }\n        };\n    }\n    ToKey({ int }) {\n        return int;\n    }\n    compare(mutez1, mutez2) {\n        const o1 = Number(mutez1);\n        const o2 = Number(mutez2);\n        if (o1 === o2) {\n            return 0;\n        }\n        return o1 < o2 ? -1 : 1;\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (MutezToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nMutezToken.prim = \"mutez\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Bytes\n */ class BytesValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"BytesValidationError\";\n    }\n}\nclass BytesToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                bytes: val\n            },\n            type: {\n                prim: BytesToken.prim\n            }\n        };\n    }\n    /**\n     * @throws {@link BytesValidationError}\n     */ validate(val) {\n        if (typeof val === \"string\" && /^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n            return;\n        }\n        throw new BytesValidationError(val, this, `Invalid bytes: ${val}`);\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    /**\n     * @throws {@link BytesValidationError}\n     */ Encode(args) {\n        let val = args.pop();\n        val = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.stripHexPrefix)(this.convertUint8ArrayToHexString(val));\n        this.validate(val);\n        return {\n            bytes: String(val).toString()\n        };\n    }\n    /**\n     * @throws {@link BytesValidationError}\n     */ EncodeObject(val, semantic) {\n        val = this.convertUint8ArrayToHexString(val);\n        if (typeof val === \"string\") {\n            val = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.stripHexPrefix)(val);\n        }\n        this.validate(val);\n        if (semantic && semantic[BytesToken.prim]) {\n            return semantic[BytesToken.prim](val);\n        }\n        return {\n            bytes: String(val).toString()\n        };\n    }\n    Execute(val) {\n        return val.bytes;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return BytesToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: BytesToken.prim,\n            schema: BytesToken.prim\n        };\n    }\n    ToKey({ bytes, string }) {\n        if (string) {\n            return string;\n        }\n        return bytes;\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (BytesToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nBytesToken.prim = \"bytes\";\nclass OptionToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    subToken() {\n        return this.createToken(this.val.args[0], this.idx);\n    }\n    schema() {\n        return this.createToken(this.val.args[0], 0);\n    }\n    annot() {\n        return Array.isArray(this.val.annots) ? super.annot() : this.createToken(this.val.args[0], this.idx).annot();\n    }\n    Encode(args) {\n        const value = args;\n        if (value === undefined || value === null) {\n            return {\n                prim: \"None\"\n            };\n        } else if (Array.isArray(value) && (value[value.length - 1] === undefined || value[value.length - 1] === null)) {\n            value.pop();\n            return {\n                prim: \"None\"\n            };\n        }\n        return {\n            prim: \"Some\",\n            args: [\n                this.schema().Encode(args)\n            ]\n        };\n    }\n    EncodeObject(args, semantic) {\n        let value = args;\n        if (value === undefined || value === null) {\n            return {\n                prim: \"None\"\n            };\n        }\n        value = typeof value === \"object\" && \"Some\" in value ? value[\"Some\"] : value;\n        return {\n            prim: \"Some\",\n            args: [\n                this.schema().EncodeObject(value, semantic)\n            ]\n        };\n    }\n    Execute(val, semantics) {\n        if (val.prim === \"None\") {\n            return null;\n        }\n        return {\n            Some: this.schema().Execute(val.args[0], semantics)\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            Some: this.schema().ExtractSchema()\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: OptionToken.prim,\n            schema: this.schema().generateSchema()\n        };\n    }\n    ExtractSignature() {\n        return [\n            ...this.schema().ExtractSignature()\n        ];\n    }\n    get KeySchema() {\n        return this.schema();\n    }\n    compare(val1, val2) {\n        if (!val1) {\n            return -1;\n        } else if (!val2) {\n            return 1;\n        }\n        return this.KeySchema.compare(val1, val2);\n    }\n    ToKey(val) {\n        return this.Execute(val);\n    }\n    ToBigMapKey(val) {\n        return {\n            key: this.EncodeObject(val),\n            type: this.typeWithoutAnnotations()\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (OptionToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.subToken().findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nOptionToken.prim = \"option\";\nclass TimestampToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        if (val.string && /^\\d+$/.test(val.string)) {\n            return new Date(Number(val.string) * 1000).toISOString();\n        } else if (val.string) {\n            return new Date(val.string).toISOString();\n        } else if (val.int) {\n            return new Date(Number(val.int) * 1000).toISOString();\n        }\n    }\n    Encode(args) {\n        const val = args.pop();\n        if (typeof val === \"number\") {\n            return {\n                int: String(val)\n            };\n        } else {\n            return {\n                string: val\n            };\n        }\n    }\n    EncodeObject(val, semantic) {\n        if (semantic && semantic[TimestampToken.prim]) {\n            return semantic[TimestampToken.prim](val);\n        }\n        if (typeof val === \"number\") {\n            return {\n                int: String(val)\n            };\n        } else {\n            return {\n                string: val\n            };\n        }\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return TimestampToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: TimestampToken.prim,\n            schema: TimestampToken.prim\n        };\n    }\n    ToKey({ string }) {\n        return string;\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                string: val\n            },\n            type: {\n                prim: TimestampToken.prim\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (TimestampToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nTimestampToken.prim = \"timestamp\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Int\n */ class IntValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"IntValidationError\";\n    }\n}\nclass IntToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val[Object.keys(val)[0]]);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return IntToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: IntToken.prim,\n            schema: IntToken.prim\n        };\n    }\n    /**\n     * @throws {@link IntValidationError}\n     */ validate(val) {\n        const bigNumber = new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val);\n        if (bigNumber.isNaN()) {\n            throw new IntValidationError(val, this, `Value is not a number: ${JSON.stringify(val)}`);\n        }\n    }\n    /**\n     * @throws {@link IntValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            int: new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val).toFixed()\n        };\n    }\n    /**\n     * @throws {@link IntValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[IntToken.prim]) {\n            return semantic[IntToken.prim](val);\n        }\n        return {\n            int: new bignumber_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"](val).toFixed()\n        };\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                int: String(val)\n            },\n            type: {\n                prim: IntToken.prim\n            }\n        };\n    }\n    ToKey({ int }) {\n        return int;\n    }\n    compare(int1, int2) {\n        const o1 = Number(int1);\n        const o2 = Number(int2);\n        if (o1 === o2) {\n            return 0;\n        }\n        return o1 < o2 ? -1 : 1;\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (IntToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nIntToken.prim = \"int\";\nclass UnitToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Encode(args) {\n        args.pop();\n        return {\n            prim: \"Unit\"\n        };\n    }\n    EncodeObject(val, semantic) {\n        if (semantic && semantic[UnitToken.prim]) {\n            return semantic[UnitToken.prim](val);\n        }\n        return {\n            prim: \"Unit\"\n        };\n    }\n    Execute(_val) {\n        return UnitValue;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return UnitToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: UnitToken.prim,\n            schema: UnitToken.prim\n        };\n    }\n    compare(_val1, _val2) {\n        return 0;\n    }\n    ToKey(_val) {\n        return UnitValue;\n    }\n    ToBigMapKey(_val) {\n        return {\n            key: {\n                prim: \"Unit\"\n            },\n            type: {\n                prim: UnitToken.prim\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (UnitToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nUnitToken.prim = \"unit\";\nconst publicKeyPrefixLength = 4;\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Key\n */ class KeyValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"KeyValidationError\";\n    }\n}\nclass KeyToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        if (val.string) {\n            return val.string;\n        }\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.encodeKey)(val.bytes);\n    }\n    /**\n     * @throws {@link KeyValidationError}\n     */ validate(value) {\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.validatePublicKey)(value) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.ValidationResult.VALID) {\n            throw new KeyValidationError(value, this, \"Key is not valid\");\n        }\n    }\n    /**\n     * @throws {@link KeyValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            string: val\n        };\n    }\n    /**\n     * @throws {@link KeyValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[KeyToken.prim]) {\n            return semantic[KeyToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return KeyToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: KeyToken.prim,\n            schema: KeyToken.prim\n        };\n    }\n    ToKey(val) {\n        return this.Execute(val);\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                string: val\n            },\n            type: {\n                prim: KeyToken.prim\n            }\n        };\n    }\n    compare(key1, key2) {\n        const keyPrefix1 = this.getPrefix(key1);\n        const keyPrefix2 = this.getPrefix(key2);\n        if (keyPrefix1 === _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.EDPK && keyPrefix2 !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.EDPK) {\n            return -1;\n        } else if (keyPrefix1 === _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.SPPK && keyPrefix2 !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.SPPK) {\n            return keyPrefix2 === _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.EDPK ? 1 : -1;\n        } else if (keyPrefix1 === _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.P2PK) {\n            if (keyPrefix2 !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.P2PK) {\n                return 1;\n            }\n            const keyBytes1 = this.getP256PublicKeyComparableBytes(key1);\n            const keyBytes2 = this.getP256PublicKeyComparableBytes(key2);\n            return Buffer.compare(keyBytes1, keyBytes2);\n        }\n        return super.compare(key1, key2);\n    }\n    getPrefix(val) {\n        return val.substring(0, publicKeyPrefixLength);\n    }\n    getP256PublicKeyComparableBytes(p2pk) {\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.b58cdecode)(p2pk, _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.prefix[_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.Prefix.P2PK]).slice(1);\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (KeyToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nKeyToken.prim = \"key\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing Key Hash\n */ class KeyHashValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"KeyHashValidationError\";\n    }\n}\nclass KeyHashToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        if (val.string) {\n            return val.string;\n        }\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.encodeKeyHash)(val.bytes);\n    }\n    /**\n     * @throws {@link KeyHashValidationError}\n     */ validate(value) {\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.validateKeyHash)(value) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.ValidationResult.VALID) {\n            throw new KeyHashValidationError(value, this, `KeyHash is not valid: ${JSON.stringify(value)}`);\n        }\n    }\n    /**\n     * @throws {@link KeyHashValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            string: val\n        };\n    }\n    /**\n     * @throws {@link KeyHashValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[KeyHashToken.prim]) {\n            return semantic[KeyHashToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return KeyHashToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: KeyHashToken.prim,\n            schema: KeyHashToken.prim\n        };\n    }\n    ToKey({ string, bytes }) {\n        if (string) {\n            return string;\n        }\n        return (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.encodeKeyHash)(bytes);\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                string: val\n            },\n            type: {\n                prim: KeyHashToken.prim\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (KeyHashToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nKeyHashToken.prim = \"key_hash\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Signature\n */ class SignatureValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"SignatureValidationError\";\n    }\n}\nclass SignatureToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        if (val.string) {\n            return val.string;\n        }\n        // TODO decode the signature\n        return val.bytes;\n    }\n    /**\n     * @throws {@link SignatureValidationError}\n     */ validate(value) {\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.validateSignature)(value) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.ValidationResult.VALID) {\n            throw new SignatureValidationError(value, this, \"Signature is not valid\");\n        }\n    }\n    /**\n     * @throws {@link SignatureValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            string: val\n        };\n    }\n    /**\n     * @throws {@link SignatureValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[SignatureToken.prim]) {\n            return semantic[SignatureToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return SignatureToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: SignatureToken.prim,\n            schema: SignatureToken.prim\n        };\n    }\n    ToKey(val) {\n        return this.Execute(val);\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                string: val\n            },\n            type: {\n                prim: SignatureToken.prim\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (SignatureToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nSignatureToken.prim = \"signature\";\nclass LambdaToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    get paramSchema() {\n        return this.createToken(this.val.args[0], this.idx);\n    }\n    get returnSchema() {\n        return this.createToken(this.val.args[1], this.idx + 1);\n    }\n    Execute(val) {\n        if (val.string) {\n            return val.string;\n        } else {\n            return val;\n        }\n    }\n    Encode(args) {\n        const val = args.pop();\n        return val;\n    }\n    EncodeObject(val, semantic) {\n        if (semantic && semantic[LambdaToken.prim]) {\n            return semantic[LambdaToken.prim](val);\n        }\n        return val;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            [LambdaToken.prim]: {\n                parameters: this.paramSchema.ExtractSchema(),\n                returns: this.returnSchema.ExtractSchema()\n            }\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: LambdaToken.prim,\n            schema: {\n                parameters: this.paramSchema.generateSchema(),\n                returns: this.returnSchema.generateSchema()\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (LambdaToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.createToken(this.val.args[0], this.idx).findAndReturnTokens(tokenToFind, tokens);\n        this.createToken(this.val.args[1], this.idx).findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nLambdaToken.prim = \"lambda\";\nclass OperationToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    Execute(val) {\n        return val.string;\n    }\n    Encode(...args) {\n        const val = args.pop();\n        return {\n            string: val\n        };\n    }\n    EncodeObject(val, semantic) {\n        if (semantic && semantic[OperationToken.prim]) {\n            return semantic[OperationToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return OperationToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: OperationToken.prim,\n            schema: OperationToken.prim\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (OperationToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nOperationToken.prim = \"operation\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Set\n */ class SetValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"SetValidationError\";\n    }\n}\nclass SetToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    get KeySchema() {\n        return this.createToken(this.val.args[0], 0);\n    }\n    /**\n     * @throws {@link SetValidationError}\n     */ validate(value) {\n        if (!Array.isArray(value)) {\n            throw new SetValidationError(value, this, `Value ${JSON.stringify(value)} is not an array`);\n        }\n    }\n    /**\n     * @throws {@link SetValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return val.sort((a, b)=>this.KeySchema.compare(a, b)).reduce((prev, current)=>{\n            return [\n                ...prev,\n                this.KeySchema.EncodeObject(current)\n            ];\n        }, []);\n    }\n    Execute(val, semantics) {\n        return val.reduce((prev, current)=>{\n            return [\n                ...prev,\n                this.KeySchema.Execute(current, semantics)\n            ];\n        }, []);\n    }\n    /**\n     * @throws {@link SetValidationError}\n     */ EncodeObject(args, semantic) {\n        this.validate(args);\n        if (semantic && semantic[SetToken.prim]) {\n            return semantic[SetToken.prim](args);\n        }\n        return args.sort((a, b)=>this.KeySchema.compare(a, b)).reduce((prev, current)=>{\n            return [\n                ...prev,\n                this.KeySchema.EncodeObject(current)\n            ];\n        }, []);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return SetToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: SetToken.prim,\n            schema: this.KeySchema.generateSchema()\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (SetToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.KeySchema.findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nSetToken.prim = \"set\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a ChainID\n */ class ChainIDValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"ChainIDValidationError\";\n    }\n}\nclass ChainIDToken extends ComparableToken {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link ChainIDValidationError}\n     */ validate(value) {\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_3__.validateChain)(value) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_3__.ValidationResult.VALID) {\n            throw new ChainIDValidationError(value, this, `Value ${JSON.stringify(value)} is not a valid ChainID`);\n        }\n    }\n    Execute(val) {\n        return val[Object.keys(val)[0]];\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return ChainIDToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: ChainIDToken.prim,\n            schema: ChainIDToken.prim\n        };\n    }\n    /**\n     * @throws {@link ChainIDValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        this.validate(val);\n        return {\n            string: val\n        };\n    }\n    /**\n     * @throws {@link ChainIDValidationError}\n     */ EncodeObject(val, semantic) {\n        this.validate(val);\n        if (semantic && semantic[ChainIDToken.prim]) {\n            return semantic[ChainIDToken.prim](val);\n        }\n        return {\n            string: val\n        };\n    }\n    ToKey({ string }) {\n        return string;\n    }\n    ToBigMapKey(val) {\n        return {\n            key: {\n                string: val\n            },\n            type: {\n                prim: ChainIDToken.prim\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (ChainIDToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nChainIDToken.prim = \"chain_id\";\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain\n */ class EncodeTicketError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(){\n        super();\n        this.name = \"TicketEncodeError\";\n        this.message = \"Tickets cannot be sent to the blockchain; they are created on-chain\";\n    }\n}\nconst ticketerType$1 = {\n    prim: \"contract\"\n};\nconst amountType$1 = {\n    prim: \"int\"\n};\nclass TicketToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    get valueToken() {\n        return this.createToken(this.val.args[0], this.idx);\n    }\n    /**\n     * @throws {@link EncodeTicketError}\n     */ Encode(_args) {\n        throw new EncodeTicketError();\n    }\n    /**\n     * @throws {@link EncodeTicketError}\n     */ EncodeObject(args, semantic) {\n        if (semantic && semantic[TicketToken.prim]) {\n            return semantic[TicketToken.prim](args, this.val);\n        }\n        throw new EncodeTicketError();\n    }\n    Execute(val, semantics) {\n        if (semantics && semantics[TicketToken.prim]) {\n            return semantics[TicketToken.prim](val, this.val);\n        }\n        const ticketer = this.createToken(ticketerType$1, this.idx);\n        const value = this.valueToken;\n        const amount = this.createToken(amountType$1, this.idx);\n        if (undefined === val.args[2] && undefined !== val.args[1].args) {\n            return {\n                ticketer: ticketer.Execute(val.args[0], semantics),\n                value: value.Execute(val.args[1].args[0], semantics),\n                amount: amount.Execute(val.args[1].args[1], semantics)\n            };\n        }\n        return {\n            ticketer: ticketer.Execute(val.args[0], semantics),\n            value: value.Execute(val.args[1], semantics),\n            amount: amount.Execute(val.args[2], semantics)\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            ticketer: ContractToken.prim,\n            value: this.valueToken.ExtractSchema(),\n            amount: IntToken.prim\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: TicketToken.prim,\n            schema: {\n                value: this.valueToken.generateSchema(),\n                ticketer: {\n                    __michelsonType: ContractToken.prim,\n                    schema: ContractToken.prim\n                },\n                amount: {\n                    __michelsonType: IntToken.prim,\n                    schema: IntToken.prim\n                }\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (TicketToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.valueToken.findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nTicketToken.prim = \"ticket\";\n/**\n *  @category Error\n *  @description Error that indicates a failure when encoding and sending a ticket to the blockchain\n */ class EncodeTicketDeprecatedError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(){\n        super();\n        this.name = \"TicketDeprecatedEncodeError\";\n        this.message = \"Ticket_deprecated cannot be sent to the blockchain; they are created on-chain\";\n    }\n}\nconst ticketerType = {\n    prim: \"contract\"\n};\nconst amountType = {\n    prim: \"int\"\n};\nclass TicketDeprecatedToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    get valueToken() {\n        return this.createToken(this.val.args[0], this.idx);\n    }\n    /**\n     * @throws {@link EncodeTicketDeprecatedError}\n     */ Encode(_args) {\n        throw new EncodeTicketDeprecatedError();\n    }\n    /**\n     * @throws {@link EncodeTicketDeprecatedError}\n     */ EncodeObject(args, semantic) {\n        if (semantic && semantic[TicketDeprecatedToken.prim]) {\n            return semantic[TicketDeprecatedToken.prim](args, this.val);\n        }\n        throw new EncodeTicketDeprecatedError();\n    }\n    Execute(val, semantics) {\n        if (semantics && semantics[TicketDeprecatedToken.prim]) {\n            return semantics[TicketDeprecatedToken.prim](val, this.val);\n        }\n        const ticketer = this.createToken(ticketerType, this.idx);\n        const value = this.valueToken;\n        const amount = this.createToken(amountType, this.idx);\n        if (undefined === val.args[2] && undefined !== val.args[1].args) {\n            return {\n                ticketer: ticketer.Execute(val.args[0], semantics),\n                value: value.Execute(val.args[1].args[0], semantics),\n                amount: amount.Execute(val.args[1].args[1], semantics)\n            };\n        }\n        return {\n            ticketer: ticketer.Execute(val.args[0], semantics),\n            value: value.Execute(val.args[1], semantics),\n            amount: amount.Execute(val.args[2], semantics)\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            ticketer: ContractToken.prim,\n            value: this.valueToken.ExtractSchema(),\n            amount: IntToken.prim\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: TicketDeprecatedToken.prim,\n            schema: {\n                value: this.valueToken.generateSchema(),\n                ticketer: {\n                    __michelsonType: ContractToken.prim,\n                    schema: ContractToken.prim\n                },\n                amount: {\n                    __michelsonType: IntToken.prim,\n                    schema: IntToken.prim\n                }\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (TicketDeprecatedToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        this.valueToken.findAndReturnTokens(tokenToFind, tokens);\n        return tokens;\n    }\n}\nTicketDeprecatedToken.prim = \"ticket_deprecated\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Never Token\n */ class NeverTokenError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"NeverTokenError\";\n    }\n}\nclass NeverToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link NeverTokenError}\n     */ Encode(args) {\n        const val = args.pop();\n        throw new NeverTokenError(val, this, `Assigning a value to the type never is forbidden. Trying to assign ${JSON.stringify(val)}.`);\n    }\n    /**\n     * @throws {@link NeverTokenError}\n     */ EncodeObject(val, semantic) {\n        if (semantic && semantic[NeverToken.prim]) {\n            return semantic[NeverToken.prim](val);\n        }\n        throw new NeverTokenError(val, this, `Assigning a value to the type never is forbidden. Trying to assign ${JSON.stringify(val)}.`);\n    }\n    /**\n     * @throws {@link NeverTokenError}\n     */ Execute(val) {\n        throw new NeverTokenError(val, this, `There is no literal value for the type never. Trying to execute ${JSON.stringify(val)}.`);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return NeverToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: NeverToken.prim,\n            schema: NeverToken.prim\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (NeverToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nNeverToken.prim = \"never\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Sapling State\n */ class SaplingStateValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"SaplingStateValidationError\";\n    }\n}\nclass SaplingStateToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    isValid(val) {\n        return typeof val === \"object\" && Object.keys(val).length === 0;\n    }\n    /**\n     * @throws {@link SaplingStateValidationError}\n     */ Execute(val, semantic) {\n        if (semantic && semantic[SaplingStateToken.prim]) {\n            return semantic[SaplingStateToken.prim](val, this.val);\n        }\n        if (\"int\" in val) {\n            return val.int;\n        } else {\n            throw new SaplingStateValidationError(val, this, `Sapling state is expecting an object with an int property. Got ${JSON.stringify(val)}`);\n        }\n    }\n    /**\n     * @throws {@link SaplingStateValidationError}\n     */ Encode(args) {\n        const val = args.pop();\n        if (this.isValid(val)) {\n            return [];\n        } else {\n            throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${JSON.stringify(val)} while expecting: {}`);\n        }\n    }\n    /**\n     * @throws {@link SaplingStateValidationError}\n     */ EncodeObject(val, semantic) {\n        if (semantic && semantic[SaplingStateToken.prim]) {\n            return semantic[SaplingStateToken.prim](val);\n        }\n        if (this.isValid(val)) {\n            return [];\n        } else {\n            throw new SaplingStateValidationError(val, this, `Invalid sapling_state. Received: ${JSON.stringify(val)} while expecting: {}`);\n        }\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            [SaplingStateToken.prim]: {\n                \"memo-size\": Number(this.val.args[0][\"int\"])\n            }\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: SaplingStateToken.prim,\n            schema: {\n                memoSize: this.val.args[0][\"int\"]\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (SaplingStateToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nSaplingStateToken.prim = \"sapling_state\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Sapling Transaction\n */ class SaplingTransactionValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"SaplingTransactionValidationError\";\n    }\n}\nclass SaplingTransactionToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link SaplingTransactionValidationError}\n     */ Execute(_val) {\n        throw new SaplingTransactionValidationError(_val, this, `There is no literal value for the sapling_transaction type. Got: ${JSON.stringify(_val)}.`);\n    }\n    /**\n     * @throws {@link SaplingTransactionValidationError}\n     */ validateBytes(val) {\n        const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);\n        if (bytes && bytes[2].length % 2 === 0) {\n            return bytes[2];\n        } else {\n            throw new SaplingTransactionValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);\n        }\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    Encode(args) {\n        let val = args.pop();\n        val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n        return {\n            bytes: String(val).toString()\n        };\n    }\n    EncodeObject(val, semantic) {\n        val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n        if (semantic && semantic[SaplingTransactionToken.prim]) {\n            return semantic[SaplingTransactionToken.prim](val);\n        }\n        return {\n            bytes: String(val).toString()\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            [SaplingTransactionToken.prim]: {\n                \"memo-size\": Number(this.val.args[0][\"int\"])\n            }\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: SaplingTransactionToken.prim,\n            schema: {\n                memoSize: this.val.args[0][\"int\"]\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (SaplingTransactionToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nSaplingTransactionToken.prim = \"sapling_transaction\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Sapling Transaction Deprecated\n */ class SaplingTransactionDeprecatedValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"SaplingTransactionDeprecatedValidationError\";\n    }\n}\nclass SaplingTransactionDeprecatedToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link SaplingTransactionDeprecatedValidationError}\n     */ Execute(_val) {\n        throw new SaplingTransactionDeprecatedValidationError(_val, this, `There is no literal value for the sapling_transaction_deprecated type. Got: ${JSON.stringify(_val)}.`);\n    }\n    /**\n     * @throws {@link SaplingTransactionDeprecatedValidationError}\n     */ validateBytes(val) {\n        const bytes = /^(0x|0X)?([0-9a-fA-F]*$)/.exec(val);\n        if (bytes && bytes[2].length % 2 === 0) {\n            return bytes[2];\n        } else {\n            throw new SaplingTransactionDeprecatedValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);\n        }\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    Encode(args) {\n        let val = args.pop();\n        val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n        return {\n            bytes: String(val).toString()\n        };\n    }\n    EncodeObject(val, semantic) {\n        val = this.validateBytes(this.convertUint8ArrayToHexString(val));\n        if (semantic && semantic[SaplingTransactionDeprecatedToken.prim]) {\n            return semantic[SaplingTransactionDeprecatedToken.prim](val);\n        }\n        return {\n            bytes: String(val).toString()\n        };\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return {\n            [SaplingTransactionDeprecatedToken.prim]: {\n                \"memo-size\": Number(this.val.args[0][\"int\"])\n            }\n        };\n    }\n    generateSchema() {\n        return {\n            __michelsonType: SaplingTransactionDeprecatedToken.prim,\n            schema: {\n                memoSize: this.val.args[0][\"int\"]\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (SaplingTransactionDeprecatedToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nSaplingTransactionDeprecatedToken.prim = \"sapling_transaction_deprecated\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a BLS12-381 scalar field Fr\n */ class Bls12381frValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"Bls12381frValidationError\";\n    }\n}\nclass Bls12381frToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link Bls12381frValidationError}\n     */ validate(val) {\n        if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n            return;\n        }\n        throw new Bls12381frValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    /**\n     * @throws {@link Bls12381frValidationError}\n     */ Encode(args) {\n        let val = args.pop();\n        if (typeof val === \"number\") {\n            return {\n                int: val.toString()\n            };\n        } else {\n            val = this.convertUint8ArrayToHexString(val);\n            this.validate(val);\n            return {\n                bytes: val\n            };\n        }\n    }\n    /**\n     * @throws {@link Bls12381frValidationError}\n     */ EncodeObject(val, semantic) {\n        if (semantic && semantic[Bls12381frToken.prim]) {\n            return semantic[Bls12381frToken.prim](val);\n        }\n        if (typeof val === \"number\") {\n            return {\n                int: val.toString()\n            };\n        } else {\n            val = this.convertUint8ArrayToHexString(val);\n            this.validate(val);\n            return {\n                bytes: val\n            };\n        }\n    }\n    Execute(val) {\n        return val.bytes;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return Bls12381frToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: Bls12381frToken.prim,\n            schema: Bls12381frToken.prim\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (Bls12381frToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\n// An element of the BLS12-381 scalar field Fr\n// see https://tezos.gitlab.io/michelson-reference/#type-bls12_381_fr\nBls12381frToken.prim = \"bls12_381_fr\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a BLS12-381 curve G1\n */ class Bls12381g1ValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"Bls12381g1ValidationError\";\n    }\n}\nclass Bls12381g1Token extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link Bls12381g1ValidationError}\n     */ validate(val) {\n        if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n            return;\n        }\n        throw new Bls12381g1ValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    /**\n     * @throws {@link Bls12381g1ValidationError}\n     */ Encode(args) {\n        let val = args.pop();\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        return {\n            bytes: val\n        };\n    }\n    /**\n     * @throws {@link Bls12381g1ValidationError}\n     */ EncodeObject(val, semantic) {\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        if (semantic && semantic[Bls12381g1Token.prim]) {\n            return semantic[Bls12381g1Token.prim](val);\n        }\n        return {\n            bytes: val\n        };\n    }\n    Execute(val) {\n        return val.bytes;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return Bls12381g1Token.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: Bls12381g1Token.prim,\n            schema: Bls12381g1Token.prim\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (Bls12381g1Token.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\n// A point on the BLS12-381 curve G1\n// See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g1\nBls12381g1Token.prim = \"bls12_381_g1\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a BLS12-381 curve G2\n */ class Bls12381g2ValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"Bls12381g2ValidationError\";\n    }\n}\nclass Bls12381g2Token extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link Bls12381g2ValidationError}\n     */ validate(val) {\n        if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n            return;\n        }\n        throw new Bls12381g2ValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    /**\n     * @throws {@link Bls12381g2ValidationError}\n     */ Encode(args) {\n        let val = args.pop();\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        return {\n            bytes: val\n        };\n    }\n    /**\n     * @throws {@link Bls12381g2ValidationError}\n     */ EncodeObject(val, semantic) {\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        if (semantic && semantic[Bls12381g2Token.prim]) {\n            return semantic[Bls12381g2Token.prim](val);\n        }\n        return {\n            bytes: val\n        };\n    }\n    Execute(val) {\n        return val.bytes;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return Bls12381g2Token.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: Bls12381g2Token.prim,\n            schema: Bls12381g2Token.prim\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (Bls12381g2Token.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\n// A point on the BLS12-381 curve G2\n// See https://tezos.gitlab.io/michelson-reference/#type-bls12_381_g2\nBls12381g2Token.prim = \"bls12_381_g2\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Chest\n */ class ChestValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"ChestValidationError\";\n    }\n}\nclass ChestToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */ validate(val) {\n        if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 == 0) {\n            return;\n        }\n        throw new ChestValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */ Encode(args) {\n        let val = args.pop();\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        return {\n            bytes: val\n        };\n    }\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */ EncodeObject(val, semantic) {\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        if (semantic && semantic[ChestToken.prim]) {\n            return semantic[ChestToken.prim](val);\n        }\n        return {\n            bytes: val\n        };\n    }\n    Execute(val) {\n        return val.bytes;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return ChestToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: ChestToken.prim,\n            schema: ChestToken.prim\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (ChestToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nChestToken.prim = \"chest\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding/executing a Chest Key\n */ class ChestKeyValidationError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"ChestKeyValidationError\";\n    }\n}\nclass ChestKeyToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */ validate(val) {\n        if (/^[0-9a-fA-F]*$/.test(val) && val.length % 2 === 0) {\n            return;\n        }\n        throw new ChestKeyValidationError(val, this, `Invalid bytes: ${JSON.stringify(val)}`);\n    }\n    convertUint8ArrayToHexString(val) {\n        return val.constructor === Uint8Array ? Buffer.from(val).toString(\"hex\") : val;\n    }\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */ Encode(args) {\n        let val = args.pop();\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        return {\n            bytes: val\n        };\n    }\n    /**\n     * @throws {@link ChestKeyValidationError}\n     */ EncodeObject(val, semantic) {\n        val = this.convertUint8ArrayToHexString(val);\n        this.validate(val);\n        if (semantic && semantic[ChestKeyToken.prim]) {\n            return semantic[ChestKeyToken.prim](val);\n        }\n        return {\n            bytes: val\n        };\n    }\n    Execute(val) {\n        return val.bytes;\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return ChestKeyToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: ChestKeyToken.prim,\n            schema: ChestKeyToken.prim\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (ChestKeyToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nChestKeyToken.prim = \"chest_key\";\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing encoding a Global Constant\n */ class GlobalConstantEncodingError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"GlobalConstantEncodingError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure happening when parsing executing a Global Constant\n */ class GlobalConstantDecodingError extends TokenValidationError {\n    constructor(value, token, message){\n        super(value, token, message);\n        this.value = value;\n        this.token = token;\n        this.name = \"GlobalConstantDecodingError\";\n    }\n}\nclass GlobalConstantToken extends Token {\n    constructor(val, idx, fac){\n        super(val, idx, fac);\n        this.val = val;\n        this.idx = idx;\n        this.fac = fac;\n    }\n    /**\n     * @throws {@link GlobalConstantDecodingError}\n     */ Execute(val, semantic) {\n        if (semantic && semantic[GlobalConstantToken.prim]) {\n            return semantic[GlobalConstantToken.prim](val, this.val);\n        } else {\n            throw new GlobalConstantDecodingError(val, this, `Unable to decode a value represented by a global constants. Please provide an expanded script to the Michelson-Encoder or semantics for the decoding. The following global constant hash was encountered: ${this.val.args[0][\"string\"]}.`);\n        }\n    }\n    /**\n     * @throws {@link GlobalConstantEncodingError}\n     */ Encode(args) {\n        throw new GlobalConstantEncodingError(args, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0][\"string\"]}.`);\n    }\n    /**\n     * @throws {@link GlobalConstantEncodingError}\n     */ EncodeObject(val, semantic) {\n        if (semantic && semantic[GlobalConstantToken.prim]) {\n            return semantic[GlobalConstantToken.prim](val);\n        }\n        throw new GlobalConstantEncodingError(val, this, `Unable to encode a script containing global constants. Please provide an expanded script to the Michelson-Encoder. The following global constant hash was encountered: ${this.val.args[0][\"string\"]}.`);\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return GlobalConstantToken.prim;\n    }\n    generateSchema() {\n        return {\n            __michelsonType: GlobalConstantToken.prim,\n            schema: {\n                hash: this.val.args[0][\"string\"]\n            }\n        };\n    }\n    findAndReturnTokens(tokenToFind, tokens) {\n        if (GlobalConstantToken.prim === tokenToFind) {\n            tokens.push(this);\n        }\n        return tokens;\n    }\n}\nGlobalConstantToken.prim = \"constant\";\nconst tokens = [\n    PairToken,\n    NatToken,\n    StringToken,\n    BigMapToken,\n    AddressToken,\n    MapToken,\n    BoolToken,\n    OrToken,\n    ContractToken,\n    ListToken,\n    MutezToken,\n    BytesToken,\n    OptionToken,\n    TimestampToken,\n    IntToken,\n    UnitToken,\n    KeyToken,\n    KeyHashToken,\n    SignatureToken,\n    LambdaToken,\n    OperationToken,\n    SetToken,\n    ChainIDToken,\n    TicketToken,\n    TicketDeprecatedToken,\n    NeverToken,\n    SaplingStateToken,\n    SaplingTransactionToken,\n    SaplingTransactionDeprecatedToken,\n    Bls12381frToken,\n    Bls12381g1Token,\n    Bls12381g2Token,\n    ChestToken,\n    ChestKeyToken,\n    GlobalConstantToken\n];\n/**\n *  @category Error\n *  @description Error that indicates a script having an invalid type or it being unsupported by the Michelson Encoder. Note some protocol changes might affect this, we encourage users to open an issue so we can look into implementing support for said types.\n */ class InvalidTokenError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(message, data){\n        super(message);\n        this.message = message;\n        this.data = data;\n        this.name = \"Invalid token error\";\n    }\n}\n/**\n *\n * @description Create a token from a value\n * @throws {@link InvalidTokenError} If the value passed is not supported by the Michelson Encoder\n */ function createToken(val, idx) {\n    if (Array.isArray(val)) {\n        return new PairToken(val, idx, createToken);\n    }\n    const t = tokens.find((x)=>x.prim === val.prim);\n    if (!t) {\n        throw new InvalidTokenError(`Malformed data: ${JSON.stringify(val)}. Expected a value with a valid prim property`, val);\n    }\n    return new t(val, idx, createToken);\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n *  @category Error\n *  @description Error that indicates a failure when encoding (transforming JS parameter into JSON Michelson) the parameter of the view\n */ class ParameterEncodingError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.InvalidViewParameterError {\n    constructor(viewName, sigs, args, cause){\n        super(viewName, sigs, args, cause);\n        this.viewName = viewName;\n        this.sigs = sigs;\n        this.args = args;\n        this.cause = cause;\n        this.name = \"ParameterEncodingError\";\n        this.message = `Could not encode parameter ${JSON.stringify(args)} received for name \"${viewName}\" expecting one of the following signatures ${JSON.stringify(sigs)}`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid on-chain view found on the script\n */ class InvalidScriptError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(script, reason){\n        super();\n        this.script = script;\n        this.reason = reason;\n        this.name = \"InvalidScriptError\";\n        let message = `Invalid on-chain view found in the following script.`;\n        if (reason) {\n            message += ` Reason: ${reason}.`;\n        }\n        message += `Script: ${JSON.stringify(script)}`;\n        this.message = message;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid RPC response being passed or used\n */ class InvalidRpcResponseError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(script, reason){\n        super();\n        this.script = script;\n        this.reason = reason;\n        this.name = \"InvalidRpcResponseError\";\n        let message = `Invalid RPC response passed as argument(s).`;\n        if (reason) {\n            message += ` Reason: ${reason}.`;\n        }\n        message += ` Received: ${JSON.stringify(script)}`;\n        this.message = message;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid big map schema being passed or used\n */ class InvalidBigMapSchemaError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(message){\n        super(message);\n        this.message = message;\n        this.name = \"InvalidBigMapSchemaError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid big map diff being passed or used\n */ class InvalidBigMapDiffError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(message, value){\n        super(message);\n        this.message = message;\n        this.value = value;\n        this.name = \"InvalidBigMapDiffError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode big maps\n */ class BigMapEncodingError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(obj, details, schema, value){\n        super();\n        this.details = details;\n        this.schema = schema;\n        this.value = value;\n        this.name = \"BigMapEncodingError\";\n        this.message = `Unable to encode the big map ${obj}. Schema is: ${JSON.stringify(schema)}. The ${obj} is: ${JSON.stringify(value)}. Error details: ${details}`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when trying to encode storage\n */ class StorageEncodingError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(obj, details, schema, value, semantics){\n        super();\n        this.details = details;\n        this.schema = schema;\n        this.value = value;\n        this.semantics = semantics;\n        this.name = \"StorageEncodingError\";\n        this.message = `Unable to encode ${obj}. The schema is: ${JSON.stringify(schema)}, the value is: ${JSON.stringify(value)}.${semantics ? `And the semantic is: ${JSON.stringify(semantics)}` : \"\"}. Error details: ${details}`;\n    }\n}\n/**\n *  @category Error\n *  @description General error that indicates a function not being passed a necessary argument\n */ class MissingArgumentError extends _taquito_core__WEBPACK_IMPORTED_MODULE_1__.TaquitoError {\n    constructor(message){\n        super(message);\n        this.message = message;\n        this.name = \"MissingArgumentError\";\n    }\n}\nvar _a;\nconst schemaTypeSymbol = Symbol.for(\"taquito-schema-type-symbol\");\n// collapse comb pair\nfunction collapse(val, prim = PairToken.prim) {\n    var _b, _c;\n    if (Array.isArray(val)) {\n        return collapse({\n            prim: prim,\n            args: val\n        }, prim);\n    }\n    const extended = val;\n    if (extended.prim === prim && extended.args && extended.args.length > 2) {\n        return Object.assign(Object.assign({}, extended), {\n            args: [\n                (_b = extended.args) === null || _b === void 0 ? void 0 : _b[0],\n                {\n                    prim: prim,\n                    args: (_c = extended.args) === null || _c === void 0 ? void 0 : _c.slice(1)\n                }\n            ]\n        });\n    }\n    return extended;\n}\nfunction deepEqual(a, b) {\n    if (a === undefined || b === undefined) {\n        return a === b;\n    }\n    const ac = collapse(a);\n    const bc = collapse(b);\n    return ac.prim === bc.prim && (ac.args === undefined && bc.args === undefined || ac.args !== undefined && bc.args !== undefined && ac.args.length === bc.args.length && ac.args.every((v, i)=>{\n        var _b, _c;\n        return deepEqual(v, (_c = (_b = bc.args) === null || _b === void 0 ? void 0 : _b[i]) !== null && _c !== void 0 ? _c : {});\n    })) && (ac.annots === undefined && bc.annots === undefined || ac.annots !== undefined && bc.annots !== undefined && ac.annots.length === bc.annots.length && ac.annots.every((v, i)=>{\n        var _b;\n        return v === ((_b = bc.annots) === null || _b === void 0 ? void 0 : _b[i]);\n    }));\n}\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. Its API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */ class Schema {\n    static isSchema(obj) {\n        return obj && obj[schemaTypeSymbol] === true;\n    }\n    /**\n     * @throws {@link InvalidRpcResponseError}\n     */ static fromRPCResponse(val) {\n        if (!val) {\n            throw new InvalidRpcResponseError(val, \"the RPC response is empty\");\n        }\n        if (!val.script) {\n            throw new InvalidRpcResponseError(val, \"the RPC response has no script\");\n        }\n        if (!Array.isArray(val.script.code)) {\n            throw new InvalidRpcResponseError(val, \"The response.script.code should be an array\");\n        }\n        let code = val.script.code;\n        while(code.length === 1 && Array.isArray(code[0])){\n            code = code[0];\n        }\n        const storage = code.find((x)=>\"prim\" in x && x.prim === \"storage\");\n        if (!storage || !Array.isArray(storage.args)) {\n            throw new InvalidRpcResponseError(val, 'The response.script.code has an element of type {prim: \"storage\"}, but its args is not an array');\n        }\n        return new Schema(storage.args[0]);\n    }\n    isExpressionExtended(val) {\n        return \"prim\" in val && Array.isArray(val.args);\n    }\n    constructor(val){\n        this.val = val;\n        this[_a] = true;\n        this.root = createToken(val, 0);\n        if (this.root instanceof BigMapToken) {\n            this.bigMap = this.root;\n        } else if (this.isExpressionExtended(val) && val.prim === \"pair\") {\n            const exp = val.args[0];\n            if (this.isExpressionExtended(exp) && exp.prim === \"big_map\") {\n                this.bigMap = new BigMapToken(exp, 0, createToken);\n            }\n        }\n    }\n    removeTopLevelAnnotation(obj) {\n        // PairToken and OrToken can have redundant top level annotation in their storage\n        if (this.root instanceof PairToken || this.root instanceof OrToken) {\n            if (this.root.hasAnnotations() && typeof obj === \"object\" && Object.keys(obj).length === 1) {\n                return obj[Object.keys(obj)[0]];\n            }\n        }\n        return obj;\n    }\n    Execute(val, semantics) {\n        const storage = this.root.Execute(val, semantics);\n        return this.removeTopLevelAnnotation(storage);\n    }\n    Typecheck(val) {\n        if (this.root instanceof BigMapToken && Number.isInteger(Number(val))) {\n            return;\n        }\n        if (this.root instanceof TicketToken && val.ticketer && val.value && val.amount) {\n            return;\n        }\n        if (this.root instanceof TicketDeprecatedToken && val.ticketer && val.value && val.amount) {\n            return;\n        }\n        if (this.root instanceof MapToken && this.root.ValueSchema instanceof BigMapToken) {\n            return;\n        }\n        this.root.EncodeObject(val);\n    }\n    /**\n     * @throws {@link InvalidBigMapSchemaError}\n     * @throws {@link InvalidBigMapDiffError}\n     */ ExecuteOnBigMapDiff(diff, semantics) {\n        if (!this.bigMap) {\n            throw new InvalidBigMapSchemaError(\"Big map schema is undefined\");\n        }\n        if (!Array.isArray(diff)) {\n            throw new InvalidBigMapDiffError(`Big map diff must be an array, got: ${JSON.stringify(diff)}`, diff);\n        }\n        const eltFormat = diff.map(({ key, value })=>({\n                args: [\n                    key,\n                    value\n                ]\n            }));\n        return this.bigMap.Execute(eltFormat, semantics);\n    }\n    /**\n     * @throws {@link InvalidBigMapSchemaError}\n     */ ExecuteOnBigMapValue(key, semantics) {\n        if (!this.bigMap) {\n            throw new InvalidBigMapSchemaError(\"Big map schema is undefined\");\n        }\n        return this.bigMap.ValueSchema.Execute(key, semantics);\n    }\n    /**\n     * @throws {@link InvalidBigMapSchemaError}\n     * @throws {@link BigMapEncodingError}\n     */ EncodeBigMapKey(key) {\n        if (!this.bigMap) {\n            throw new InvalidBigMapSchemaError(\"Big map schema is undefined\");\n        }\n        try {\n            return this.bigMap.KeySchema.ToBigMapKey(key);\n        } catch (ex) {\n            throw new BigMapEncodingError(\"key\", ex, this.bigMap.KeySchema, key);\n        }\n    }\n    /**\n     * @throws {@link TokenValidationError}\n     * @throws {@link StorageEncodingError}\n     */ Encode(value, semantics) {\n        try {\n            return this.root.EncodeObject(value, semantics);\n        } catch (ex) {\n            if (ex instanceof TokenValidationError) {\n                throw ex;\n            }\n            throw new StorageEncodingError(\"storage object\", ex, this.root, value, semantics);\n        }\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return this.removeTopLevelAnnotation(this.root.ExtractSchema());\n    }\n    /**\n     * @description Produce a representation of the storage schema.\n     * Note: Provide guidance on how to write the storage object for the origination operation with Taquito.\n     */ generateSchema() {\n        return this.removeTopLevelAnnotation(this.root.generateSchema());\n    }\n    /**\n     * @deprecated\n     * @throws {@link InvalidBigMapSchemaError}\n     */ ComputeState(tx, state) {\n        if (!this.bigMap) {\n            throw new InvalidBigMapSchemaError(\"Big map schema is undefined\");\n        }\n        const bigMap = tx.reduce((prev, current)=>{\n            return Object.assign(Object.assign({}, prev), this.ExecuteOnBigMapDiff(current.contents[0].metadata.operation_result.big_map_diff));\n        }, {});\n        return Object.assign(Object.assign({}, this.Execute(state)), {\n            [this.bigMap.annot()]: bigMap\n        });\n    }\n    /**\n     * @description Look up in top-level pairs of the storage to find a value matching the specified type\n     *\n     * @returns The first value found that match the type or `undefined` if no value is found\n     *\n     * @param storage storage to parse to find the value\n     * @param valueType type of value to look for\n     *\n     */ FindFirstInTopLevelPair(storage, valueType) {\n        return this.findValue(this.root[\"val\"], storage, valueType);\n    }\n    // TODO check these type casts\n    /**\n     * @throws {@link MissingArgumentError}\n     */ findValue(schema, storage, valueToFind) {\n        if (deepEqual(valueToFind, schema)) {\n            return storage;\n        }\n        if (Array.isArray(schema) || schema.prim === \"pair\") {\n            const sch = collapse(schema);\n            const strg = collapse(storage, \"Pair\");\n            if (sch.args === undefined || strg.args === undefined) {\n                throw new MissingArgumentError(\"Tokens have no arguments\"); // unlikely\n            }\n            if (sch.args[0]) return(// unsafe\n            this.findValue(sch.args[0], strg.args[0], valueToFind) || this.findValue(sch.args[1], strg.args[1], valueToFind));\n        }\n    }\n    /**\n     * @description Look up the schema to find any occurrence of a particular token.\n     *\n     * @returns an array of tokens of the specified kind or an empty array if no token was found\n     *\n     * @param tokenToFind string representing the prim property of the token to find\n     *\n     * @example\n     * ```\n     * Useful to find all global constants in a script, an array of GlobalConstantToken is returned:\n     *\n     * const schema = new Schema(script);\n     * const allGlobalConstantTokens = schema.findToken('constant');\n     * ```\n     *\n     */ findToken(tokenToFind) {\n        const tokens = [];\n        return this.root.findAndReturnTokens(tokenToFind, tokens);\n    }\n}\n_a = schemaTypeSymbol;\n/**\n * @warn Our current smart contract abstraction feature is currently in preview. It's API is not final, and it may not cover every use case (yet). We will greatly appreciate any feedback on this feature.\n */ class ParameterSchema {\n    /**\n     *\n     * @description Create an instance of ParameterSchema from a contract script\n     *\n     * @param val contract script obtained from the RPC\n     * @returns ParameterSchema\n     * @throws {InvalidRpcResponseError} If the RPC response is invalid\n     */ static fromRPCResponse(val) {\n        if (!val) {\n            throw new InvalidRpcResponseError(val, \"the RPC response is empty\");\n        }\n        if (!val.script) {\n            throw new InvalidRpcResponseError(val, \"the RPC response has no script\");\n        }\n        if (!Array.isArray(val.script.code)) {\n            throw new InvalidRpcResponseError(val, \"The response.script.code should be an array\");\n        }\n        const parameter = val.script.code.find((x)=>\"prim\" in x && x.prim === \"parameter\");\n        if (!parameter) {\n            throw new InvalidRpcResponseError(val, `The response.script.code should have an element of type {prim: \"parameter\"}`);\n        }\n        if (!Array.isArray(parameter.args)) {\n            throw new InvalidRpcResponseError(val, `The response.script.code has an element of type {prim: \"parameter\"}, but its args is not an array`);\n        }\n        return new ParameterSchema(parameter.args[0]);\n    }\n    /**\n     * @description Check if the Contract parameter is multiple entry point or not\n     */ get isMultipleEntryPoint() {\n        return this.root instanceof OrToken || this.root instanceof OptionToken && this.root.subToken() instanceof OrToken;\n    }\n    /**\n     * @description Check if the Contract parameter has an annotation or not\n     */ get hasAnnotation() {\n        if (this.isMultipleEntryPoint) {\n            return Object.keys(this.ExtractSchema())[0] !== \"0\";\n        } else {\n            return true;\n        }\n    }\n    /**\n     * @description Return the schema of the parameter of a specific entry point\n     * @throws {@link InvalidTokenError}\n     */ constructor(val){\n        this.root = createToken(val, 0);\n    }\n    /**\n     * @description Returns the javascript object equivalent of the Micheline value provided\n     */ Execute(val, semantics) {\n        return this.root.Execute(val, semantics);\n    }\n    /**\n     * @description Returns a micheline formatted object for the values provided\n     * @throws {@link TokenValidationError}\n     * @throws {@link ParameterEncodingError}\n     */ Encode(...args) {\n        try {\n            return this.root.Encode(args.reverse());\n        } catch (ex) {\n            if (ex instanceof TokenValidationError) {\n                throw ex;\n            }\n            throw new ParameterEncodingError(\"Unable to encode parameter\", this.root, args, ex);\n        }\n    }\n    /**\n     * @description Returns a micheline formatted object for the javascript object provided\n     * @throws {@link TokenValidationError}\n     * @throws {@link ParameterEncodingError}\n     */ EncodeObject(value, semantics) {\n        try {\n            return this.root.EncodeObject(value, semantics);\n        } catch (ex) {\n            if (ex instanceof TokenValidationError) {\n                throw ex;\n            }\n            throw new ParameterEncodingError(\"Unable to encode parameter object\", this.root, value, ex);\n        }\n    }\n    /**\n     * @deprecated ExtractSchema has been deprecated in favor of generateSchema\n     *\n     */ ExtractSchema() {\n        return this.root.ExtractSchema();\n    }\n    /**\n     * @description Produce a schema grouping together all the entry points of a contract.\n     */ generateSchema() {\n        return this.root.generateSchema();\n    }\n    ExtractSignatures() {\n        return this.root.ExtractSignature();\n    }\n}\nclass ViewSchema {\n    /**\n     *\n     * @description Create an instance of ViewSchema for each view in a script\n     *\n     * @param val contract script obtained from the RPC\n     * @returns array of ViewSchema or empty array if there is no view in the contract\n     * @throws {@link InvalidScriptError}\n     */ static fromRPCResponse(val) {\n        const allViewSchema = [];\n        const views = val && val.script && Array.isArray(val.script.code) && val.script.code.filter((x)=>x.prim === \"view\");\n        if (views) {\n            views.forEach((view)=>{\n                allViewSchema.push(new ViewSchema(view.args));\n            });\n        }\n        return allViewSchema;\n    }\n    /**\n     * @throws {@link InvalidScriptError}\n     */ constructor(viewArgs){\n        if (!viewArgs) {\n            throw new InvalidScriptError(viewArgs, \"the args are not defined\");\n        }\n        if (viewArgs.length !== 4) {\n            throw new InvalidScriptError(viewArgs, `there should be exactly 4 arguments`);\n        }\n        if (!(\"string\" in viewArgs[0]) || !viewArgs[0][\"string\"]) {\n            throw new InvalidScriptError(viewArgs, `The first argument should be a string, representing the view name. It should be in the form: { string: 'viewName' }`);\n        }\n        this.viewName = viewArgs[0][\"string\"];\n        this.viewArgsType = viewArgs[1];\n        this.viewReturnType = viewArgs[2];\n        this.instructions = viewArgs[3];\n        this.rootArgsType = createToken(this.viewArgsType, 0);\n        this.rootReturnType = createToken(this.viewReturnType, 0);\n    }\n    /**\n     *\n     * @description Transform the view parameter into Michelson\n     *\n     * @param args parameter of the view in js format\n     * @returns parameter of the view in Michelson\n     * @throws {@link ParameterEncodingError}\n     */ encodeViewArgs(args) {\n        try {\n            return this.rootArgsType.EncodeObject(args);\n        } catch (ex) {\n            throw new ParameterEncodingError(this.viewName, undefined, args, ex);\n        }\n    }\n    /**\n     *\n     * @description Transform the view result from Michelson to readable data\n     *\n     * @param val result of the view in JSON Michelson\n     * @param semantics optional semantics to override the default decoding behavior\n     * @returns result of the view in a readable format\n     */ decodeViewResult(val, semantics) {\n        return this.rootReturnType.Execute(val, semantics);\n    }\n    /**\n     *\n     * @description Return the signature of the view parameter\n     */ extractArgsSchema() {\n        return this.rootArgsType.ExtractSchema();\n    }\n    /**\n     *\n     * @description Return the format of the view result\n     */ extractResultSchema() {\n        return this.rootReturnType.ExtractSchema();\n    }\n}\nclass EventSchema {\n    constructor(tag, type){\n        this.tag = tag;\n        this.type = type;\n    }\n    static fromMichelineValue(val) {\n        var _a, _b;\n        return new EventSchema((_a = val.annots) === null || _a === void 0 ? void 0 : _a[0], (_b = val.args) === null || _b === void 0 ? void 0 : _b[0]);\n    }\n    static fromRPCResponse(val) {\n        const allEventSchema = [];\n        val.script.code.forEach((code)=>{\n            if (!(\"prim\" in code) || code.prim !== \"code\" || !(\"args\" in code) || !code.args) {\n                return;\n            }\n            allEventSchema.push(...EventSchema.extractEventsRecursively(code.args));\n        });\n        return EventSchema.removeDuplicates(allEventSchema);\n    }\n    static removeDuplicates(events) {\n        const uniqueEvents = [];\n        events.forEach((event)=>{\n            const idx = uniqueEvents.findIndex((e)=>e.tag === event.tag && deepEqual(e.type, event.type));\n            if (idx === -1) {\n                uniqueEvents.push(event);\n            }\n        });\n        return uniqueEvents;\n    }\n    static extractEventsRecursively(code) {\n        if (Array.isArray(code)) {\n            return code.flatMap((c)=>EventSchema.extractEventsRecursively(c));\n        }\n        if (!(\"prim\" in code)) {\n            return [];\n        }\n        if (code.prim === \"EMIT\") {\n            return [\n                EventSchema.fromMichelineValue(code)\n            ];\n        }\n        if (!(\"args\" in code) || !code.args) {\n            return [];\n        }\n        return code.args.flatMap((c)=>EventSchema.extractEventsRecursively(c));\n    }\n}\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\n/**\n * @packageDocumentation\n * @module @taquito/michelson-encoder\n */ const UnitValue = Symbol();\nconst SaplingStateValue = {};\n //# sourceMappingURL=taquito-michelson-encoder.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vbWljaGVsc29uLWVuY29kZXIvZGlzdC90YXF1aXRvLW1pY2hlbHNvbi1lbmNvZGVyLmVzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQW1EO0FBQ3FCO0FBQ25DO0FBQ21NO0FBRXhPLElBQUlrQjtBQUNKOzs7Q0FHQyxHQUNELE1BQU1DLDRCQUE0QmxCLHVEQUFZQTtJQUMxQ21CLFlBQVlDLE9BQU8sRUFBRUMsTUFBTSxDQUFFO1FBQ3pCLEtBQUs7UUFDTCxJQUFJLENBQUNELE9BQU8sR0FBR0E7UUFDZixJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLE9BQU8sR0FBRyxDQUFDLGNBQWMsRUFBRUMsS0FBS3hCLFNBQVMsQ0FBQ3FCLFNBQVMsc0JBQXNCLEVBQUVDLE9BQU8sQ0FBQyxDQUFDO1FBQ3pGLElBQUksQ0FBQ0csSUFBSSxHQUFHO0lBQ2hCO0FBQ0o7QUFDQSx3RUFBd0U7QUFDeEUsNkdBQTZHO0FBQzdHLE1BQU1DLHlCQUF5QkMsT0FBT0MsR0FBRyxDQUFDO0FBQzFDOzs7Q0FHQyxHQUNELFNBQVNDLGdCQUFnQkMsS0FBSztJQUMxQixJQUFJLENBQUUsV0FBVUEsS0FBSSxHQUFJO1FBQ3BCLE1BQU0sSUFBSVgsb0JBQW9CVyxPQUFPLENBQUMsb0JBQW9CLENBQUM7SUFDL0Q7SUFDQSxJQUFJLENBQUM7UUFBQztRQUFPO0tBQVUsQ0FBQ0MsUUFBUSxDQUFDRCxNQUFNRSxJQUFJLEdBQUc7UUFDMUMsTUFBTSxJQUFJYixvQkFBb0JXLE9BQU8sQ0FBQywyQ0FBMkMsQ0FBQztJQUN0RjtJQUNBLElBQUksQ0FBRSxXQUFVQSxLQUFJLEdBQUk7UUFDcEIsTUFBTSxJQUFJWCxvQkFBb0JXLE9BQU8sQ0FBQyxvQkFBb0IsQ0FBQztJQUMvRDtJQUNBLElBQUksQ0FBQ0csTUFBTUMsT0FBTyxDQUFDSixNQUFNSyxJQUFJ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QixNQUFNQyxlQUFlLEVBQUU7UUFDdkJELE9BQU9qVSxPQUFPLENBQUMsQ0FBQ21VO1lBQ1osTUFBTXpTLE1BQU13UyxhQUFhRSxTQUFTLENBQUMsQ0FBQzdULElBQU1BLEVBQUVxVCxHQUFHLEtBQUtPLE1BQU1QLEdBQUcsSUFBSXhELFVBQVU3UCxFQUFFekIsSUFBSSxFQUFFcVYsTUFBTXJWLElBQUk7WUFDN0YsSUFBSTRDLFFBQVEsQ0FBQyxHQUFHO2dCQUNad1MsYUFBYTFQLElBQUksQ0FBQzJQO1lBQ3RCO1FBQ0o7UUFDQSxPQUFPRDtJQUNYO0lBQ0EsT0FBT0gseUJBQXlCbkQsSUFBSSxFQUFFO1FBQ2xDLElBQUluUyxNQUFNQyxPQUFPLENBQUNrUyxPQUFPO1lBQ3JCLE9BQU9BLEtBQUt5RCxPQUFPLENBQUMsQ0FBQ0MsSUFBTVgsWUFBWUksd0JBQXdCLENBQUNPO1FBQ3BFO1FBQ0EsSUFBSSxDQUFFLFdBQVUxRCxJQUFHLEdBQUk7WUFDbkIsT0FBTyxFQUFFO1FBQ2I7UUFDQSxJQUFJQSxLQUFLcFMsSUFBSSxLQUFLLFFBQVE7WUFDdEIsT0FBTztnQkFBQ21WLFlBQVlFLGtCQUFrQixDQUFDakQ7YUFBTTtRQUNqRDtRQUNBLElBQUksQ0FBRSxXQUFVQSxJQUFHLEtBQU0sQ0FBQ0EsS0FBS2pTLElBQUksRUFBRTtZQUNqQyxPQUFPLEVBQUU7UUFDYjtRQUNBLE9BQU9pUyxLQUFLalMsSUFBSSxDQUFDMFYsT0FBTyxDQUFDLENBQUNDLElBQU1YLFlBQVlJLHdCQUF3QixDQUFDTztJQUN6RTtBQUNKO0FBRUEsMkVBQTJFO0FBQzNFLE1BQU1DLFVBQVU7SUFDWixjQUFjO0lBQ2QsV0FBVztBQUNmO0FBRUE7OztDQUdDLEdBQ0QsTUFBTS9KLFlBQVlyTTtBQUNsQixNQUFNcVcsb0JBQW9CLENBQUM7QUFFeXRCLENBQ3B2Qix5REFBeUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd3JwZXJrcy8uL25vZGVfbW9kdWxlcy9AdGFxdWl0by9taWNoZWxzb24tZW5jb2Rlci9kaXN0L3RhcXVpdG8tbWljaGVsc29uLWVuY29kZXIuZXM2LmpzPzcyNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHN0cmluZ2lmeSBmcm9tICdmYXN0LWpzb24tc3RhYmxlLXN0cmluZ2lmeSc7XG5pbXBvcnQgeyBUYXF1aXRvRXJyb3IsIEludmFsaWRWaWV3UGFyYW1ldGVyRXJyb3IgfSBmcm9tICdAdGFxdWl0by9jb3JlJztcbmltcG9ydCBCaWdOdW1iZXIgZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IGI1OGRlY29kZSwgdmFsaWRhdGVBZGRyZXNzLCBWYWxpZGF0aW9uUmVzdWx0LCBlbmNvZGVQdWJLZXksIHN0cmlwSGV4UHJlZml4LCBlbmNvZGVLZXksIHZhbGlkYXRlUHVibGljS2V5LCBQcmVmaXgsIGI1OGNkZWNvZGUsIHByZWZpeCwgZW5jb2RlS2V5SGFzaCwgdmFsaWRhdGVLZXlIYXNoLCB2YWxpZGF0ZVNpZ25hdHVyZSwgdmFsaWRhdGVDaGFpbiB9IGZyb20gJ0B0YXF1aXRvL3V0aWxzJztcblxudmFyIF9hJDE7XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBtYXAgdHlwZSBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkTWFwVHlwZUVycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtYXBUeXBlLCByZWFzb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tYXBUeXBlID0gbWFwVHlwZTtcbiAgICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBUaGUgbWFwIHR5cGUgJyR7SlNPTi5zdHJpbmdpZnkobWFwVHlwZSl9JyBpcyBpbnZhbGlkLiBSZWFzb246ICR7cmVhc29ufS5gO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZE1hcFR5cGVFcnJvcic7XG4gICAgfVxufVxuLy8gUmV0cmlldmUgYSB1bmlxdWUgc3ltYm9sIGFzc29jaWF0ZWQgd2l0aCB0aGUga2V5IGZyb20gdGhlIGVudmlyb25tZW50XG4vLyBVc2VkIGluIG9yZGVyIHRvIGlkZW50aWZ5IGFsbCBvYmplY3QgdGhhdCBhcmUgb2YgdHlwZSBNaWNoZWxzb25NYXAgZXZlbiBpZiB0aGV5IGNvbWUgZnJvbSBkaWZmZXJlbnQgbW9kdWxlXG5jb25zdCBtaWNoZWxzb25NYXBUeXBlU3ltYm9sID0gU3ltYm9sLmZvcigndGFxdWl0by1taWNoZWxzb24tbWFwLXR5cGUtc3ltYm9sJyk7XG4vKipcbiAqXG4gKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkTWFwVHlwZUVycm9yfSB3aGVuIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gbWFwVHlwZSBpcyBub3QgYSB2YWxpZCBtYXAgdHlwZVxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU1hcFR5cGUodmFsdWUpIHtcbiAgICBpZiAoISgncHJpbScgaW4gdmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkTWFwVHlwZUVycm9yKHZhbHVlLCBgTWlzc2luZyAncHJpbScgZmllbGRgKTtcbiAgICB9XG4gICAgaWYgKCFbJ21hcCcsICdiaWdfbWFwJ10uaW5jbHVkZXModmFsdWUucHJpbSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNYXBUeXBlRXJyb3IodmFsdWUsIGBUaGUgcHJpbSBmaWVsZCBzaG91bGQgYmUgJ21hcCcgb3IgJ2JpZ19tYXAnYCk7XG4gICAgfVxuICAgIGlmICghKCdhcmdzJyBpbiB2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNYXBUeXBlRXJyb3IodmFsdWUsIGBNaXNzaW5nICdhcmdzJyBmaWVsZGApO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUuYXJncykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNYXBUeXBlRXJyb3IodmFsdWUsIGBUaGUgJ2FyZ3MnIGZpZWxkIHNob3VsZCBiZSBhbiBhcnJheWApO1xuICAgIH1cbiAgICBpZiAodmFsdWUuYXJncy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRNYXBUeXBlRXJyb3IodmFsdWUsIGBUaGUgJ2FyZ3MnIGZpZWxkIHNob3VsZCBoYXZlIDIgZWxlbWVudHNgKTtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBtYXAgdHlwZSBtaXNtYXRjaCwgd2hlcmUgYW4gYXR0ZW1wdCB0byBzZXQgYSBrZXkgb3IgdmFsdWUgaW4gYSBNYXAgZG9lc24ndCBtYXRjaCB0aGUgZGVmaW5lZCB0eXBlIG9mIHRoZSBNYXBcbiAqL1xuY2xhc3MgTWFwVHlwZWNoZWNrRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0eXBlLCBvYmplY3RUeXBlLCByZWFzb24pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01hcFR5cGVjaGVja0Vycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYFRoZSAke29iamVjdFR5cGV9IHByb3ZpZGVkOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gaXMgbm90IGNvbXBhdGlibGUgd2l0aCB0aGUgZXhwZWN0ZWQgbWljaGVsc29uIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkodHlwZSl9LiBSZWFzb246ICR7SlNPTi5zdHJpbmdpZnkocmVhc29uKX0uYDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01hcFR5cGVjaGVja0Vycm9yJztcbiAgICB9XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBNaWNoZWxzb24gTWFwIGlzIGFuIGFic3RyYWN0aW9uIG92ZXIgdGhlIG1pY2hlbHNvbiBuYXRpdmUgbWFwLiBJdCBzdXBwb3J0cyBjb21wbGV4IFBhaXIgYXMga2V5XG4gKi9cbmNsYXNzIE1pY2hlbHNvbk1hcCB7XG4gICAgLy8gVXNlZCB0byBjaGVjayBpZiBhbiBvYmplY3QgaXMgYSBtaWNoZWxzb24gbWFwLlxuICAgIC8vIFVzaW5nIGluc3RhbmNlb2Ygd2FzIG5vdCB3b3JraW5nIGZvciBwcm9qZWN0IHRoYXQgaGFkIG11bHRpcGxlIGluc3RhbmNlIG9mIHRhcXVpdG8gZGVwZW5kZW5jaWVzXG4gICAgLy8gYXMgdGhlIGNsYXNzIGNvbnN0cnVjdG9yIGlzIGRpZmZlcmVudFxuICAgIHN0YXRpYyBpc01pY2hlbHNvbk1hcChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmpbbWljaGVsc29uTWFwVHlwZVN5bWJvbF0gPT09IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBtYXBUeXBlIElmIHNwZWNpZmllZCBrZXkgYW5kIHZhbHVlIHdpbGwgYmUgdHlwZS1jaGVja2VkIGJlZm9yZSBiZWluZyBhZGRlZCB0byB0aGUgbWFwXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBuZXcgTWljaGVsc29uTWFwKHsgcHJpbTogXCJtYXBcIiwgYXJnczogW3twcmltOiBcInN0cmluZ1wifSwge3ByaW06IFwiaW50XCJ9XX0pXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWFwVHlwZSkge1xuICAgICAgICB0aGlzLnZhbHVlTWFwID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmtleU1hcCA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpc1tfYSQxXSA9IHRydWU7XG4gICAgICAgIGlmIChtYXBUeXBlKSB7XG4gICAgICAgICAgICB0aGlzLnNldFR5cGUobWFwVHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VHlwZShtYXBUeXBlKSB7XG4gICAgICAgIHZhbGlkYXRlTWFwVHlwZShtYXBUeXBlKTtcbiAgICAgICAgdGhpcy5rZXlTY2hlbWEgPSBuZXcgU2NoZW1hKG1hcFR5cGUuYXJnc1swXSk7XG4gICAgICAgIHRoaXMudmFsdWVTY2hlbWEgPSBuZXcgU2NoZW1hKG1hcFR5cGUuYXJnc1sxXSk7XG4gICAgfVxuICAgIHJlbW92ZVR5cGUoKSB7XG4gICAgICAgIHRoaXMua2V5U2NoZW1hID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLnZhbHVlU2NoZW1hID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUxpdGVyYWwob2JqLCBtYXBUeXBlKSB7XG4gICAgICAgIGNvbnN0IG1hcCA9IG5ldyBNaWNoZWxzb25NYXAobWFwVHlwZSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBtYXAuc2V0KGtleSwgb2JqW2tleV0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG1hcDtcbiAgICB9XG4gICAgdHlwZWNoZWNrS2V5KGtleSkge1xuICAgICAgICBpZiAoIXRoaXMua2V5U2NoZW1hKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5rZXlTY2hlbWEuVHlwZWNoZWNrKGtleSk7XG4gICAgfVxuICAgIHR5cGVjaGVja1ZhbHVlKHZhbHVlKSB7XG4gICAgICAgIGlmICghdGhpcy52YWx1ZVNjaGVtYSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmFsdWVTY2hlbWEuVHlwZWNoZWNrKHZhbHVlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgTWFwVHlwZWNoZWNrRXJyb3J9IHdoZW4gdGhlIGFyZ3VtZW50IHBhc3NlZCBkb2VzIG5vdCBtYXRjaCB0aGUgZXhwZWN0ZWQgc2NoZW1hIGZvciB2YWx1ZVxuICAgICAqL1xuICAgIGFzc2VydFR5cGVjaGVja1ZhbHVlKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLnR5cGVjaGVja1ZhbHVlKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE1hcFR5cGVjaGVja0Vycm9yKHZhbHVlLCB0aGlzLnZhbHVlU2NoZW1hLCAndmFsdWUnLCBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBNYXBUeXBlY2hlY2tFcnJvcn0gd2hlbiB0aGUgYXJndW1lbnQgcGFzc2VkIGRvZXMgbm90IG1hdGNoIHRoZSBleHBlY3RlZCBzY2hlbWEgZm9yIGtleVxuICAgICAqL1xuICAgIGFzc2VydFR5cGVjaGVja0tleShrZXkpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMudHlwZWNoZWNrS2V5KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNYXBUeXBlY2hlY2tFcnJvcihrZXksIHRoaXMua2V5U2NoZW1hLCAna2V5JywgZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2VyaWFsaXplRGV0ZXJtaW5pc3RpY2FsbHkoa2V5KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmdpZnkoa2V5KTtcbiAgICB9XG4gICAgKmtleXMoKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleV0gb2YgdGhpcy5lbnRyaWVzKCkpIHtcbiAgICAgICAgICAgIHlpZWxkIGtleTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAqdmFsdWVzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IFssIHZhbHVlXSBvZiB0aGlzLmVudHJpZXMoKSkge1xuICAgICAgICAgICAgeWllbGQgdmFsdWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgKmVudHJpZXMoKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRoaXMudmFsdWVNYXAua2V5cygpKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgeWllbGQgW3RoaXMua2V5TWFwLmdldChrZXkpLCB0aGlzLnZhbHVlTWFwLmdldChrZXkpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQoa2V5KSB7XG4gICAgICAgIHRoaXMuYXNzZXJ0VHlwZWNoZWNrS2V5KGtleSk7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IHRoaXMuc2VyaWFsaXplRGV0ZXJtaW5pc3RpY2FsbHkoa2V5KTtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsdWVNYXAuZ2V0KHN0cktleSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCBhIGtleSBhbmQgYSB2YWx1ZSBpbiB0aGUgTWljaGVsc29uTWFwLiBJZiB0aGUga2V5IGFscmVhZHkgZXhpc3RzLCBvdmVycmlkZSB0aGUgY3VycmVudCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlIG1hcC5zZXQoXCJteUtleVwiLCBcIm15VmFsdWVcIikgLy8gVXNpbmcgYSBzdHJpbmcgYXMga2V5XG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBtYXAuc2V0KHswOiBcInRlc3RcIiwgMTogXCJ0ZXN0MVwifSwgXCJteVZhbHVlXCIpIC8vIFVzaW5nIGEgcGFpciBhcyBrZXlcbiAgICAgKlxuICAgICAqIEB3YXJuIFRoZSBzYW1lIGtleSBjYW4gYmUgcmVwcmVzZW50ZWQgaW4gbXVsdGlwbGUgd2F5cywgZGVwZW5kaW5nIG9uIHRoZSB0eXBlIG9mIHRoZSBrZXkuIFRoaXMgZHVwbGljYXRlIGtleSBzaXR1YXRpb24gd2lsbCBjYXVzZSBhIHJ1bnRpbWUgZXJyb3IgKGR1cGxpY2F0ZSBrZXkpIHdoZW4gc2VuZGluZyB0aGUgbWFwIGRhdGEgdG8gdGhlIFRlem9zIFJQQyBub2RlLlxuICAgICAqXG4gICAgICogRm9yIGV4YW1wbGUsIGNvbnNpZGVyIGEgY29udHJhY3Qgd2l0aCBhIG1hcCB3aG9zZSBrZXkgaXMgb2YgdHlwZSBib29sZWFuLiAgSWYgeW91IHNldCB0aGUgZm9sbG93aW5nIHZhbHVlcyBpbiBNaWNoZWxzb25NYXA6IG1hcC5zZXQoZmFsc2UsIFwibXlWYWx1ZVwiKSBhbmQgbWFwLnNldChudWxsLCBcIm15VmFsdWVcIikuXG4gICAgICpcbiAgICAgKiBZb3Ugd2lsbCBnZXQgdHdvIHVuaXF1ZSBlbnRyaWVzIGluIHRoZSBNaWNoZWxzb25NYXAuIFRoZXNlIHZhbHVlcyB3aWxsIGJvdGggYmUgZXZhbHVhdGVkIGFzIGZhbHN5IGJ5IHRoZSBNaWNoZWxzb25FbmNvZGVyIGFuZCB1bHRpbWF0ZWx5IHJlamVjdGVkIGJ5IHRoZSBUZXpvcyBSUEMuXG4gICAgICovXG4gICAgc2V0KGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRUeXBlY2hlY2tLZXkoa2V5KTtcbiAgICAgICAgdGhpcy5hc3NlcnRUeXBlY2hlY2tWYWx1ZSh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHN0cktleSA9IHRoaXMuc2VyaWFsaXplRGV0ZXJtaW5pc3RpY2FsbHkoa2V5KTtcbiAgICAgICAgdGhpcy5rZXlNYXAuc2V0KHN0cktleSwga2V5KTtcbiAgICAgICAgdGhpcy52YWx1ZU1hcC5zZXQoc3RyS2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlbGV0ZShrZXkpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRUeXBlY2hlY2tLZXkoa2V5KTtcbiAgICAgICAgdGhpcy5rZXlNYXAuZGVsZXRlKHRoaXMuc2VyaWFsaXplRGV0ZXJtaW5pc3RpY2FsbHkoa2V5KSk7XG4gICAgICAgIHRoaXMudmFsdWVNYXAuZGVsZXRlKHRoaXMuc2VyaWFsaXplRGV0ZXJtaW5pc3RpY2FsbHkoa2V5KSk7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgdGhpcy5hc3NlcnRUeXBlY2hlY2tLZXkoa2V5KTtcbiAgICAgICAgY29uc3Qgc3RyS2V5ID0gdGhpcy5zZXJpYWxpemVEZXRlcm1pbmlzdGljYWxseShrZXkpO1xuICAgICAgICByZXR1cm4gdGhpcy5rZXlNYXAuaGFzKHN0cktleSkgJiYgdGhpcy52YWx1ZU1hcC5oYXMoc3RyS2V5KTtcbiAgICB9XG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMua2V5TWFwLmNsZWFyKCk7XG4gICAgICAgIHRoaXMudmFsdWVNYXAuY2xlYXIoKTtcbiAgICB9XG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmtleU1hcC5zaXplO1xuICAgIH1cbiAgICBmb3JFYWNoKGNiKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHRoaXMuZW50cmllcygpKSB7XG4gICAgICAgICAgICBjYih2YWx1ZSwga2V5LCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbl9hJDEgPSBtaWNoZWxzb25NYXBUeXBlU3ltYm9sO1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIHdoZW4gZW5jb2RpbmcgaW52YWxpZCBvciBpbmNvcnJlY3QgZGF0YSAoZS5nLiBpZiBhbiBhZGRyZXNzIGlzIGV4cGVjdGVkIGJ1dCBhIG51bWJlciBpcyByZWNlaXZlZClcbiAqL1xuY2xhc3MgVG9rZW5WYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgYmFzZU1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdUb2tlblZhbGlkYXRpb25FcnJvcic7XG4gICAgICAgIGNvbnN0IGFubm90ID0gdGhpcy50b2tlbi5hbm5vdCgpO1xuICAgICAgICBjb25zdCBhbm5vdFRleHQgPSBhbm5vdCA/IGBbJHthbm5vdH1dIGAgOiAnJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7YW5ub3RUZXh0fSR7YmFzZU1lc3NhZ2V9YDtcbiAgICB9XG59XG5jbGFzcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgICAgICB0aGlzLmNyZWF0ZVRva2VuID0gdGhpcy5mYWM7XG4gICAgfVxuICAgIHR5cGVXaXRob3V0QW5ub3RhdGlvbnMoKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZU1pY2hlbHNvbkV4cHJlc3Npb24gPSAodmFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXkubWFwKChpdGVtKSA9PiBoYW5kbGVNaWNoZWxzb25FeHByZXNzaW9uKGl0ZW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXh0ZW5kZWQgPSB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKGV4dGVuZGVkLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06IGV4dGVuZGVkLnByaW0sXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzOiBleHRlbmRlZC5hcmdzLm1hcCgoeCkgPT4gaGFuZGxlTWljaGVsc29uRXhwcmVzc2lvbih4KSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJpbTogZXh0ZW5kZWQucHJpbSxcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVNaWNoZWxzb25FeHRlbmRlZCA9ICh2YWwpID0+IHtcbiAgICAgICAgICAgIGlmICh2YWwuYXJncykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHByaW06IHZhbC5wcmltLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB2YWwuYXJncy5tYXAoKHgpID0+IGhhbmRsZU1pY2hlbHNvbkV4cHJlc3Npb24oeCkpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBwcmltOiB2YWwucHJpbSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gaGFuZGxlTWljaGVsc29uRXh0ZW5kZWQodGhpcy52YWwpO1xuICAgIH1cbiAgICBhbm5vdCgpIHtcbiAgICAgICAgcmV0dXJuIChBcnJheS5pc0FycmF5KHRoaXMudmFsLmFubm90cykgJiYgdGhpcy52YWwuYW5ub3RzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gdGhpcy52YWwuYW5ub3RzWzBdXG4gICAgICAgICAgICA6IFN0cmluZyh0aGlzLmlkeCkpLnJlcGxhY2UoLyglfDopKF9MaXFfZW50cnlfKT8vLCAnJyk7XG4gICAgfVxuICAgIGhhc0Fubm90YXRpb25zKCkge1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh0aGlzLnZhbC5hbm5vdHMpICYmIHRoaXMudmFsLmFubm90cy5sZW5ndGg7XG4gICAgfVxuICAgIGdldCB0b2tlblZhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudmFsO1xuICAgIH1cbiAgICBFeHRyYWN0U2lnbmF0dXJlKCkge1xuICAgICAgICByZXR1cm4gW1t0aGlzLkV4dHJhY3RTY2hlbWEoKV1dO1xuICAgIH1cbn1cbmNsYXNzIENvbXBhcmFibGVUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgICBjb21wYXJlKG8xLCBvMikge1xuICAgICAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbzEgPCBvMiA/IC0xIDogMTtcbiAgICB9XG59XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgQmlnIE1hcCB0eXBlc1xuICovXG5jbGFzcyBCaWdNYXBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBUb2tlblZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmlnTWFwVmFsaWRhdGlvbkVycm9yJztcbiAgICB9XG59XG5jbGFzcyBCaWdNYXBUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICBnZXQgVmFsdWVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMV0sIDApO1xuICAgIH1cbiAgICBnZXQgS2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYmlnX21hcDoge1xuICAgICAgICAgICAgICAgIGtleTogdGhpcy5LZXlTY2hlbWEuRXh0cmFjdFNjaGVtYSgpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLlZhbHVlU2NoZW1hLkV4dHJhY3RTY2hlbWEoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBCaWdNYXBUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAga2V5OiB0aGlzLktleVNjaGVtYS5nZW5lcmF0ZVNjaGVtYSgpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLlZhbHVlU2NoZW1hLmdlbmVyYXRlU2NoZW1hKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBCaWdNYXBWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFNaWNoZWxzb25NYXAuaXNNaWNoZWxzb25NYXAodmFsdWUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmlnTWFwVmFsaWRhdGlvbkVycm9yKHZhbHVlLCB0aGlzLCBgVmFsdWUgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGlzIG5vdCBhIE1pY2hlbHNvbk1hcGApO1xuICAgICAgICB9XG4gICAgfVxuICAgIG9iakxpdFRvTWljaGVsc29uTWFwKHZhbCkge1xuICAgICAgICBpZiAodmFsIGluc3RhbmNlb2YgTWljaGVsc29uTWFwKVxuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE1pY2hlbHNvbk1hcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE1pY2hlbHNvbk1hcC5mcm9tTGl0ZXJhbCh2YWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJpZ01hcFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWwgPSB0aGlzLm9iakxpdFRvTWljaGVsc29uTWFwKGFyZ3MucG9wKCkpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIHJldHVybiBBcnJheS5mcm9tKHZhbC5rZXlzKCkpXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gdGhpcy5LZXlTY2hlbWEuY29tcGFyZShhLCBiKSlcbiAgICAgICAgICAgIC5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwcmltOiAnRWx0JyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbdGhpcy5LZXlTY2hlbWEuRW5jb2RlT2JqZWN0KGtleSksIHRoaXMuVmFsdWVTY2hlbWEuRW5jb2RlT2JqZWN0KHZhbC5nZXQoa2V5KSldLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJpZ01hcFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QoYXJncywgc2VtYW50aWMpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5vYmpMaXRUb01pY2hlbHNvbk1hcChhcmdzKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbQmlnTWFwVG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tCaWdNYXBUb2tlbi5wcmltXSh2YWwsIHRoaXMudmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWwua2V5cygpKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHRoaXMuS2V5U2NoZW1hLmNvbXBhcmUoYSwgYikpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJpbTogJ0VsdCcsXG4gICAgICAgICAgICAgICAgYXJnczogW3RoaXMuS2V5U2NoZW1hLkVuY29kZU9iamVjdChrZXkpLCB0aGlzLlZhbHVlU2NoZW1hLkVuY29kZU9iamVjdCh2YWwuZ2V0KGtleSkpXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkTWFwVHlwZUVycm9yfSB3aGVuIHRoZSBhcmd1bWVudCBwYXNzZWQgdG8gdmFsIGlzIGFuIGFycmF5IGJ1dCBub3QgYSB2YWxpZCBtYXAgdHlwZVxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJpZ01hcFZhbGlkYXRpb25FcnJvcn0gd2hlbiB0aGUgdmFsdWUgaXMgaW52YWxpZFxuICAgICAqL1xuICAgIEV4ZWN1dGUodmFsLCBzZW1hbnRpYykge1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbQmlnTWFwVG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tCaWdNYXBUb2tlbi5wcmltXSh2YWwsIHRoaXMudmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgICAgICAvLyBBdGhlbnMgaXMgcmV0dXJuaW5nIGFuIGVtcHR5IGFycmF5IGZvciBiaWcgbWFwIGluIHN0b3JhZ2VcbiAgICAgICAgICAgIC8vIEludGVybmFsOiBJbiB0YXF1aXRvIHY1IGl0IGlzIHN0aWxsIHVzZWQgdG8gZGVjb2RlIGJpZyBtYXAgZGlmZiAoYXMgaWYgdGhleSB3ZXJlIGEgcmVndWxhciBtYXApXG4gICAgICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWljaGVsc29uTWFwKHRoaXMudmFsKTtcbiAgICAgICAgICAgIHZhbC5mb3JFYWNoKChjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgbWFwLnNldCh0aGlzLktleVNjaGVtYS5Ub0tleShjdXJyZW50LmFyZ3NbMF0pLCB0aGlzLlZhbHVlU2NoZW1hLkV4ZWN1dGUoY3VycmVudC5hcmdzWzFdKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBtYXA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoJ2ludCcgaW4gdmFsKSB7XG4gICAgICAgICAgICAvLyBCYWJ5bG9uIGlzIHJldHVybmluZyBhbiBpbnQgd2l0aCB0aGUgYmlnIG1hcCBpZCBpbiBjb250cmFjdCBzdG9yYWdlXG4gICAgICAgICAgICByZXR1cm4gdmFsLmludDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBCaWdNYXBWYWxpZGF0aW9uRXJyb3IodmFsLCB0aGlzLCBgQmlnIG1hcCBpcyBleHBlY3RpbmcgZWl0aGVyIGFuIGFycmF5IChBdGhlbnMpIG9yIGFuIG9iamVjdCB3aXRoIGFuIGludCBwcm9wZXJ0eSAoQmFieWxvbikuIEdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChCaWdNYXBUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5LZXlTY2hlbWEuZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKTtcbiAgICAgICAgdGhpcy5WYWx1ZVNjaGVtYS5maW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbkJpZ01hcFRva2VuLnByaW0gPSAnYmlnX21hcCc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgYW4gT3JUb2tlblxuICovXG5jbGFzcyBPclZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdPclZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgT3JUb2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBhcmdzW2FyZ3MubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IGxlZnRUb2tlbiA9IHRoaXMuY3JlYXRlVG9rZW4odGhpcy52YWwuYXJnc1swXSwgdGhpcy5pZHgpO1xuICAgICAgICBsZXQga2V5Q291bnQgPSAxO1xuICAgICAgICBpZiAobGVmdFRva2VuIGluc3RhbmNlb2YgT3JUb2tlbikge1xuICAgICAgICAgICAga2V5Q291bnQgPSBPYmplY3Qua2V5cyhsZWZ0VG9rZW4uRXh0cmFjdFNjaGVtYSgpKS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmlnaHRUb2tlbiA9IHRoaXMuY3JlYXRlVG9rZW4odGhpcy52YWwuYXJnc1sxXSwgdGhpcy5pZHggKyBrZXlDb3VudCk7XG4gICAgICAgIGlmIChTdHJpbmcobGVmdFRva2VuLmFubm90KCkpID09PSBTdHJpbmcobGFiZWwpICYmICEobGVmdFRva2VuIGluc3RhbmNlb2YgT3JUb2tlbikpIHtcbiAgICAgICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4geyBwcmltOiAnTGVmdCcsIGFyZ3M6IFtsZWZ0VG9rZW4uRW5jb2RlKGFyZ3MpXSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFN0cmluZyhyaWdodFRva2VuLmFubm90KCkpID09PSBTdHJpbmcobGFiZWwpICYmICEocmlnaHRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pKSB7XG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJpbTogJ1JpZ2h0JywgYXJnczogW3JpZ2h0VG9rZW4uRW5jb2RlKGFyZ3MpXSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKGxlZnRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWwgPSBsZWZ0VG9rZW4uRW5jb2RlKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJpbTogJ0xlZnQnLCBhcmdzOiBbdmFsXSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyaWdodFRva2VuIGluc3RhbmNlb2YgT3JUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbCA9IHJpZ2h0VG9rZW4uRW5jb2RlKGFyZ3MpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJpbTogJ1JpZ2h0JywgYXJnczogW3ZhbF0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFeHRyYWN0U2lnbmF0dXJlKCkge1xuICAgICAgICBjb25zdCBsZWZ0VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KTtcbiAgICAgICAgbGV0IGtleUNvdW50ID0gMTtcbiAgICAgICAgaWYgKGxlZnRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgIGtleUNvdW50ID0gT2JqZWN0LmtleXMobGVmdFRva2VuLkV4dHJhY3RTY2hlbWEoKSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMV0sIHRoaXMuaWR4ICsga2V5Q291bnQpO1xuICAgICAgICBjb25zdCBuZXdTaWcgPSBbXTtcbiAgICAgICAgaWYgKGxlZnRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgIG5ld1NpZy5wdXNoKC4uLmxlZnRUb2tlbi5FeHRyYWN0U2lnbmF0dXJlKCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBzaWcgb2YgbGVmdFRva2VuLkV4dHJhY3RTaWduYXR1cmUoKSkge1xuICAgICAgICAgICAgICAgIG5ld1NpZy5wdXNoKFtsZWZ0VG9rZW4uYW5ub3QoKSwgLi4uc2lnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJpZ2h0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICBuZXdTaWcucHVzaCguLi5yaWdodFRva2VuLkV4dHJhY3RTaWduYXR1cmUoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNpZyBvZiByaWdodFRva2VuLkV4dHJhY3RTaWduYXR1cmUoKSkge1xuICAgICAgICAgICAgICAgIG5ld1NpZy5wdXNoKFtyaWdodFRva2VuLmFubm90KCksIC4uLnNpZ10pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdTaWc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIE9yVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdChhcmdzLCBzZW1hbnRpYykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlSmF2YXNjcmlwdE9iamVjdChhcmdzKTtcbiAgICAgICAgY29uc3QgbGFiZWwgPSBPYmplY3Qua2V5cyhhcmdzKVswXTtcbiAgICAgICAgY29uc3QgbGVmdFRva2VuID0gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCB0aGlzLmlkeCk7XG4gICAgICAgIGxldCBrZXlDb3VudCA9IDE7XG4gICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICBrZXlDb3VudCA9IE9iamVjdC5rZXlzKGxlZnRUb2tlbi5FeHRyYWN0U2NoZW1hKCkpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodFRva2VuID0gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzFdLCB0aGlzLmlkeCArIGtleUNvdW50KTtcbiAgICAgICAgaWYgKFN0cmluZyhsZWZ0VG9rZW4uYW5ub3QoKSkgPT09IFN0cmluZyhsYWJlbCkgJiYgIShsZWZ0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgcHJpbTogJ0xlZnQnLCBhcmdzOiBbbGVmdFRva2VuLkVuY29kZU9iamVjdChhcmdzW2xhYmVsXSwgc2VtYW50aWMpXSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFN0cmluZyhyaWdodFRva2VuLmFubm90KCkpID09PSBTdHJpbmcobGFiZWwpICYmICEocmlnaHRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwcmltOiAnUmlnaHQnLCBhcmdzOiBbcmlnaHRUb2tlbi5FbmNvZGVPYmplY3QoYXJnc1tsYWJlbF0sIHNlbWFudGljKV0gfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gbGVmdFRva2VuLkVuY29kZU9iamVjdChhcmdzLCBzZW1hbnRpYyk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBwcmltOiAnTGVmdCcsIGFyZ3M6IFt2YWxdIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJpZ2h0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsID0gcmlnaHRUb2tlbi5FbmNvZGVPYmplY3QoYXJncywgc2VtYW50aWMpO1xuICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgcHJpbTogJ1JpZ2h0JywgYXJnczogW3ZhbF0gfTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBPclZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUphdmFzY3JpcHRPYmplY3QoYXJncykge1xuICAgICAgICBpZiAodHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KGFyZ3MpIHx8XG4gICAgICAgICAgICBhcmdzID09PSBudWxsIHx8XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhhcmdzKS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPclZhbGlkYXRpb25FcnJvcihhcmdzLCB0aGlzLCBgRW5jb2RlT2JqZWN0IGV4cGVjdHMgYW4gb2JqZWN0IHdpdGggYSBzaW5nbGUga2V5IGJ1dCBnb3Q6ICR7SlNPTi5zdHJpbmdpZnkoYXJncyl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgT3JWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRXhlY3V0ZSh2YWwsIHNlbWFudGljcykge1xuICAgICAgICBjb25zdCBsZWZ0VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KTtcbiAgICAgICAgbGV0IGtleUNvdW50ID0gMTtcbiAgICAgICAgaWYgKGxlZnRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgIGtleUNvdW50ID0gT2JqZWN0LmtleXMobGVmdFRva2VuLkV4dHJhY3RTY2hlbWEoKSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMV0sIHRoaXMuaWR4ICsga2V5Q291bnQpO1xuICAgICAgICBpZiAodmFsLnByaW0gPT09ICdSaWdodCcpIHtcbiAgICAgICAgICAgIGlmIChyaWdodFRva2VuIGluc3RhbmNlb2YgT3JUb2tlbikge1xuICAgICAgICAgICAgICAgIHJldHVybiByaWdodFRva2VuLkV4ZWN1dGUodmFsLmFyZ3NbMF0sIHNlbWFudGljcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBbcmlnaHRUb2tlbi5hbm5vdCgpXTogcmlnaHRUb2tlbi5FeGVjdXRlKHZhbC5hcmdzWzBdLCBzZW1hbnRpY3MpLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsLnByaW0gPT09ICdMZWZ0Jykge1xuICAgICAgICAgICAgaWYgKGxlZnRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFRva2VuLkV4ZWN1dGUodmFsLmFyZ3NbMF0sIHNlbWFudGljcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIFtsZWZ0VG9rZW4uYW5ub3QoKV06IGxlZnRUb2tlbi5FeGVjdXRlKHZhbC5hcmdzWzBdLCBzZW1hbnRpY3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBPclZhbGlkYXRpb25FcnJvcih2YWwsIHRoaXMsIGBXYXMgZXhwZWN0aW5nIExlZnQgb3IgUmlnaHQgcHJpbSBidXQgZ290OiAke0pTT04uc3RyaW5naWZ5KHZhbC5wcmltKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0cmF2ZXJzYWwoZ2V0TGVmdFZhbHVlLCBnZXRSaWdodFZhbHVlLCBjb25jYXQpIHtcbiAgICAgICAgY29uc3QgbGVmdFRva2VuID0gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCB0aGlzLmlkeCk7XG4gICAgICAgIGxldCBrZXlDb3VudCA9IDE7XG4gICAgICAgIGxldCBsZWZ0VmFsdWU7XG4gICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICBsZWZ0VmFsdWUgPSBnZXRMZWZ0VmFsdWUobGVmdFRva2VuKTtcbiAgICAgICAgICAgIGtleUNvdW50ID0gT2JqZWN0LmtleXMobGVmdFRva2VuLkV4dHJhY3RTY2hlbWEoKSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbGVmdFZhbHVlID0geyBbbGVmdFRva2VuLmFubm90KCldOiBnZXRMZWZ0VmFsdWUobGVmdFRva2VuKSB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMV0sIHRoaXMuaWR4ICsga2V5Q291bnQpO1xuICAgICAgICBsZXQgcmlnaHRWYWx1ZTtcbiAgICAgICAgaWYgKHJpZ2h0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICByaWdodFZhbHVlID0gZ2V0UmlnaHRWYWx1ZShyaWdodFRva2VuKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSB7IFtyaWdodFRva2VuLmFubm90KCldOiBnZXRSaWdodFZhbHVlKHJpZ2h0VG9rZW4pIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzID0gY29uY2F0KGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSk7XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhdmVyc2FsKChsZWZ0VG9rZW4pID0+IGxlZnRUb2tlbi5FeHRyYWN0U2NoZW1hKCksIChyaWdodFRva2VuKSA9PiByaWdodFRva2VuLkV4dHJhY3RTY2hlbWEoKSwgKGxlZnRWYWx1ZSwgcmlnaHRWYWx1ZSkgPT4gKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgbGVmdFZhbHVlKSwgcmlnaHRWYWx1ZSkpKTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IE9yVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy50cmF2ZXJzYWwoKGxlZnRUb2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VG9rZW4uZ2VuZXJhdGVTY2hlbWEoKS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFRva2VuLmdlbmVyYXRlU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKHJpZ2h0VG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0VG9rZW4uZ2VuZXJhdGVTY2hlbWEoKS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmlnaHRUb2tlbi5nZW5lcmF0ZVNjaGVtYSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIChsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxlZnRWYWx1ZSksIHJpZ2h0VmFsdWUpKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRUb2tlbihsYWJlbCkge1xuICAgICAgICBjb25zdCBsZWZ0VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KTtcbiAgICAgICAgbGV0IGtleUNvdW50ID0gMTtcbiAgICAgICAgaWYgKGxlZnRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgIGtleUNvdW50ID0gT2JqZWN0LmtleXMobGVmdFRva2VuLkV4dHJhY3RTY2hlbWEoKSkubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJpZ2h0VG9rZW4gPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMV0sIHRoaXMuaWR4ICsga2V5Q291bnQpO1xuICAgICAgICBpZiAoU3RyaW5nKGxlZnRUb2tlbi5hbm5vdCgpKSA9PT0gU3RyaW5nKGxhYmVsKSAmJlxuICAgICAgICAgICAgIShsZWZ0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSAmJlxuICAgICAgICAgICAgbGVmdFRva2VuIGluc3RhbmNlb2YgQ29tcGFyYWJsZVRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gbGVmdFRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFN0cmluZyhyaWdodFRva2VuLmFubm90KCkpID09PSBTdHJpbmcobGFiZWwpICYmXG4gICAgICAgICAgICAhKHJpZ2h0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSAmJlxuICAgICAgICAgICAgcmlnaHRUb2tlbiBpbnN0YW5jZW9mIENvbXBhcmFibGVUb2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHJpZ2h0VG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAobGVmdFRva2VuIGluc3RhbmNlb2YgT3JUb2tlbikge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvayA9IGxlZnRUb2tlbi5maW5kVG9rZW4obGFiZWwpO1xuICAgICAgICAgICAgICAgIGlmICh0b2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRvaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmlnaHRUb2tlbiBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b2sgPSByaWdodFRva2VuLmZpbmRUb2tlbihsYWJlbCk7XG4gICAgICAgICAgICAgICAgaWYgKHRvaykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXBhcmUodmFsMSwgdmFsMikge1xuICAgICAgICBjb25zdCBsYWJlbFZhbDEgPSBPYmplY3Qua2V5cyh2YWwxKVswXTtcbiAgICAgICAgY29uc3QgbGFiZWxWYWwyID0gT2JqZWN0LmtleXModmFsMilbMF07XG4gICAgICAgIGlmIChsYWJlbFZhbDEgPT09IGxhYmVsVmFsMikge1xuICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB0aGlzLmZpbmRUb2tlbihsYWJlbFZhbDEpO1xuICAgICAgICAgICAgaWYgKHRva2VuIGluc3RhbmNlb2YgQ29tcGFyYWJsZVRva2VuKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuLmNvbXBhcmUodmFsMVtsYWJlbFZhbDFdLCB2YWwyW2xhYmVsVmFsMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlZDEgPSBKU09OLnN0cmluZ2lmeSh0aGlzLkVuY29kZU9iamVjdCh2YWwxKSk7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkMiA9IEpTT04uc3RyaW5naWZ5KHRoaXMuRW5jb2RlT2JqZWN0KHZhbDIpKTtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVkMSA8IGVuY29kZWQyID8gLTEgOiAxO1xuICAgICAgICB9XG4gICAgfVxuICAgIFRvS2V5KHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FeGVjdXRlKHZhbCk7XG4gICAgfVxuICAgIFRvQmlnTWFwS2V5KHZhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB0aGlzLkVuY29kZU9iamVjdCh2YWwpLFxuICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlV2l0aG91dEFubm90YXRpb25zKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoT3JUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50cmF2ZXJzYWwoKGxlZnRUb2tlbikgPT4gbGVmdFRva2VuLmZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2VucyksIChyaWdodFRva2VuKSA9PiByaWdodFRva2VuLmZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2VucyksIChsZWZ0VmFsdWUsIHJpZ2h0VmFsdWUpID0+IChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxlZnRWYWx1ZSksIHJpZ2h0VmFsdWUpKSk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuT3JUb2tlbi5wcmltID0gJ29yJztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGluIGludmFsaWQgdG9rZW4gYXJndW1lbnQgYmVpbmcgcGFzc2VkXG4gKi9cbmNsYXNzIFRva2VuQXJndW1lbnRWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdUb2tlbkFyZ3VtZW50VmFsaWRhdGlvbkVycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIG9jY3VycmluZyB3aGVuIGRvaW5nIGEgY29tcGFyaXNvbiBvZiB0b2tlbnNcbiAqL1xuY2xhc3MgVG9rZW5Db21wYXJpc29uRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbDEsIHZhbDIpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWwxID0gdmFsMTtcbiAgICAgICAgdGhpcy52YWwyID0gdmFsMjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rva2VuQ29tcGFyaXNvbkVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYFRva2VucyAke0pTT04uc3RyaW5naWZ5KHZhbDEpfSBhbmQgJHtKU09OLnN0cmluZ2lmeSh2YWwyKX0gYXJlIG5vdCBjb21wYXJhYmxlYDtcbiAgICB9XG59XG4vLyBjb2xsYXBzZSBjb21iIHBhaXJcbi8qKlxuICogQHRocm93cyB7QGxpbmsgVG9rZW5Bcmd1bWVudFZhbGlkYXRpb25FcnJvcn1cbiAqL1xuZnVuY3Rpb24gY29sbGFwc2UkMSh2YWwsIHByaW0gPSBQYWlyVG9rZW4ucHJpbSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxhcHNlJDEoe1xuICAgICAgICAgICAgcHJpbTogcHJpbSxcbiAgICAgICAgICAgIGFyZ3M6IHZhbCxcbiAgICAgICAgfSwgcHJpbSk7XG4gICAgfVxuICAgIGlmICh2YWwuYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBUb2tlbkFyZ3VtZW50VmFsaWRhdGlvbkVycm9yKGBUaGUgdmFsdWUgJHtKU09OLnN0cmluZ2lmeSh2YWwpfSBpcyBhbiBpbnZhbGlkIFBhaXJUb2tlbiB3aXRoIG5vIGFyZ3VtZW50cywgYSBwYWlyIG11c3QgaGF2ZSB0d28gb3IgbW9yZSBhcmd1bWVudHMuYCk7XG4gICAgfVxuICAgIGlmICh2YWwuYXJncy5sZW5ndGggPiAyKSB7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICB2YWwuYXJnc1swXSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmltOiBwcmltLFxuICAgICAgICAgICAgICAgIGFyZ3M6IHZhbC5hcmdzLnNsaWNlKDEpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgXTtcbiAgICB9XG4gICAgcmV0dXJuIFt2YWwuYXJnc1swXSwgdmFsLmFyZ3NbMV1dO1xufVxuY2xhc3MgUGFpclRva2VuIGV4dGVuZHMgQ29tcGFyYWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKEFycmF5LmlzQXJyYXkodmFsKVxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgcHJpbTogUGFpclRva2VuLnByaW0sXG4gICAgICAgICAgICAgICAgYXJnczogdmFsLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiB2YWwucHJpbVxuICAgICAgICAgICAgICAgID8gdmFsXG4gICAgICAgICAgICAgICAgOiB7XG4gICAgICAgICAgICAgICAgICAgIHByaW06IFBhaXJUb2tlbi5wcmltLFxuICAgICAgICAgICAgICAgICAgICBhcmdzOiB2YWwsXG4gICAgICAgICAgICAgICAgfSwgaWR4LCBmYWMpO1xuICAgIH1cbiAgICBhcmdzKCkge1xuICAgICAgICAvLyBjb2xsYXBzZSBjb21iIHBhaXJcbiAgICAgICAgcmV0dXJuIGNvbGxhcHNlJDEodGhpcy52YWwpO1xuICAgIH1cbiAgICB0b2tlbnMoKSB7XG4gICAgICAgIGxldCBjbnQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcy5hcmdzKCkubWFwKChhKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b2sgPSB0aGlzLmNyZWF0ZVRva2VuKGEsIHRoaXMuaWR4ICsgY250KTtcbiAgICAgICAgICAgIGlmICh0b2sgaW5zdGFuY2VvZiBQYWlyVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBjbnQgKz0gT2JqZWN0LmtleXModG9rLkV4dHJhY3RTY2hlbWEoKSkubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY250Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdG9rO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHByaW06ICdQYWlyJyxcbiAgICAgICAgICAgIGFyZ3M6IHRoaXMudG9rZW5zKCkubWFwKCh0KSA9PiB0LkVuY29kZShhcmdzKSksXG4gICAgICAgIH07XG4gICAgfVxuICAgIEV4dHJhY3RTaWduYXR1cmUoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3MoKTtcbiAgICAgICAgY29uc3QgbGVmdFRva2VuID0gdGhpcy5jcmVhdGVUb2tlbihhcmdzWzBdLCB0aGlzLmlkeCk7XG4gICAgICAgIGxldCBrZXlDb3VudCA9IDE7XG4gICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBPclRva2VuKSB7XG4gICAgICAgICAgICBrZXlDb3VudCA9IE9iamVjdC5rZXlzKGxlZnRUb2tlbi5FeHRyYWN0U2NoZW1hKCkpLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodFRva2VuID0gdGhpcy5jcmVhdGVUb2tlbihhcmdzWzFdLCB0aGlzLmlkeCArIGtleUNvdW50KTtcbiAgICAgICAgY29uc3QgbmV3U2lnID0gW107XG4gICAgICAgIGZvciAoY29uc3QgbGVmdFNpZyBvZiBsZWZ0VG9rZW4uRXh0cmFjdFNpZ25hdHVyZSgpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJpZ2h0U2lnIG9mIHJpZ2h0VG9rZW4uRXh0cmFjdFNpZ25hdHVyZSgpKSB7XG4gICAgICAgICAgICAgICAgbmV3U2lnLnB1c2goWy4uLmxlZnRTaWcsIC4uLnJpZ2h0U2lnXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1NpZztcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHRoaXMuRW5jb2RlT2JqZWN0KHZhbCksXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGVXaXRob3V0QW5ub3RhdGlvbnMoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVG9LZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkV4ZWN1dGUodmFsKTtcbiAgICB9XG4gICAgRW5jb2RlT2JqZWN0KGFyZ3MsIHNlbWFudGljKSB7XG4gICAgICAgIGNvbnN0IFtsZWZ0VG9rZW4sIHJpZ2h0VG9rZW5dID0gdGhpcy50b2tlbnMoKTtcbiAgICAgICAgbGV0IGxlZnRWYWx1ZTtcbiAgICAgICAgaWYgKGxlZnRUb2tlbiBpbnN0YW5jZW9mIFBhaXJUb2tlbiAmJiAhbGVmdFRva2VuLmhhc0Fubm90YXRpb25zKCkpIHtcbiAgICAgICAgICAgIGxlZnRWYWx1ZSA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsZWZ0VmFsdWUgPSBhcmdzW2xlZnRUb2tlbi5hbm5vdCgpXTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmlnaHRWYWx1ZTtcbiAgICAgICAgaWYgKHJpZ2h0VG9rZW4gaW5zdGFuY2VvZiBQYWlyVG9rZW4gJiYgIXJpZ2h0VG9rZW4uaGFzQW5ub3RhdGlvbnMoKSkge1xuICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IGFyZ3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByaWdodFZhbHVlID0gYXJnc1tyaWdodFRva2VuLmFubm90KCldO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwcmltOiAnUGFpcicsXG4gICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgbGVmdFRva2VuLkVuY29kZU9iamVjdChsZWZ0VmFsdWUsIHNlbWFudGljKSxcbiAgICAgICAgICAgICAgICByaWdodFRva2VuLkVuY29kZU9iamVjdChyaWdodFZhbHVlLCBzZW1hbnRpYyksXG4gICAgICAgICAgICBdLFxuICAgICAgICB9O1xuICAgIH1cbiAgICB0cmF2ZXJzYWwoZ2V0TGVmdFZhbHVlLCBnZXRSaWdodFZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSB0aGlzLmFyZ3MoKTtcbiAgICAgICAgY29uc3QgbGVmdFRva2VuID0gdGhpcy5jcmVhdGVUb2tlbihhcmdzWzBdLCB0aGlzLmlkeCk7XG4gICAgICAgIGxldCBrZXlDb3VudCA9IDE7XG4gICAgICAgIGxldCBsZWZ0VmFsdWU7XG4gICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBQYWlyVG9rZW4gJiYgIWxlZnRUb2tlbi5oYXNBbm5vdGF0aW9ucygpKSB7XG4gICAgICAgICAgICBsZWZ0VmFsdWUgPSBnZXRMZWZ0VmFsdWUobGVmdFRva2VuKTtcbiAgICAgICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBQYWlyVG9rZW4pIHtcbiAgICAgICAgICAgICAgICBrZXlDb3VudCA9IE9iamVjdC5rZXlzKGxlZnRUb2tlbi5FeHRyYWN0U2NoZW1hKCkpLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxlZnRWYWx1ZSA9IHsgW2xlZnRUb2tlbi5hbm5vdCgpXTogZ2V0TGVmdFZhbHVlKGxlZnRUb2tlbikgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByaWdodFRva2VuID0gdGhpcy5jcmVhdGVUb2tlbihhcmdzWzFdLCB0aGlzLmlkeCArIGtleUNvdW50KTtcbiAgICAgICAgbGV0IHJpZ2h0VmFsdWU7XG4gICAgICAgIGlmIChyaWdodFRva2VuIGluc3RhbmNlb2YgUGFpclRva2VuICYmICFyaWdodFRva2VuLmhhc0Fubm90YXRpb25zKCkpIHtcbiAgICAgICAgICAgIHJpZ2h0VmFsdWUgPSBnZXRSaWdodFZhbHVlKHJpZ2h0VG9rZW4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmlnaHRWYWx1ZSA9IHsgW3JpZ2h0VG9rZW4uYW5ub3QoKV06IGdldFJpZ2h0VmFsdWUocmlnaHRUb2tlbikgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXMgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGxlZnRWYWx1ZSksIHJpZ2h0VmFsdWUpO1xuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCwgc2VtYW50aWNzKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBjb2xsYXBzZSQxKHZhbCwgJ1BhaXInKTtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhdmVyc2FsKChsZWZ0VG9rZW4pID0+IGxlZnRUb2tlbi5FeGVjdXRlKGFyZ3NbMF0sIHNlbWFudGljcyksIChyaWdodFRva2VuKSA9PiByaWdodFRva2VuLkV4ZWN1dGUoYXJnc1sxXSwgc2VtYW50aWNzKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhdmVyc2FsKChsZWZ0VG9rZW4pID0+IGxlZnRUb2tlbi5FeHRyYWN0U2NoZW1hKCksIChyaWdodFRva2VuKSA9PiByaWdodFRva2VuLkV4dHJhY3RTY2hlbWEoKSk7XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBQYWlyVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy50cmF2ZXJzYWwoKGxlZnRUb2tlbikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBQYWlyVG9rZW4gJiYgIWxlZnRUb2tlbi5oYXNBbm5vdGF0aW9ucygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsZWZ0VG9rZW4uZ2VuZXJhdGVTY2hlbWEoKS5zY2hlbWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbGVmdFRva2VuLmdlbmVyYXRlU2NoZW1hKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgKHJpZ2h0VG9rZW4pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmlnaHRUb2tlbiBpbnN0YW5jZW9mIFBhaXJUb2tlbiAmJiAhcmlnaHRUb2tlbi5oYXNBbm5vdGF0aW9ucygpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByaWdodFRva2VuLmdlbmVyYXRlU2NoZW1hKCkuc2NoZW1hO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0VG9rZW4uZ2VuZXJhdGVTY2hlbWEoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgVG9rZW5Db21wYXJpc29uRXJyb3J9XG4gICAgICovXG4gICAgY29tcGFyZSh2YWwxLCB2YWwyKSB7XG4gICAgICAgIGNvbnN0IFtsZWZ0VG9rZW4sIHJpZ2h0VG9rZW5dID0gdGhpcy50b2tlbnMoKTtcbiAgICAgICAgY29uc3QgZ2V0VmFsdWUgPSAodG9rZW4sIGFyZ3MpID0+IHtcbiAgICAgICAgICAgIGlmICh0b2tlbiBpbnN0YW5jZW9mIFBhaXJUb2tlbiAmJiAhdG9rZW4uaGFzQW5ub3RhdGlvbnMoKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhcmdzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFyZ3NbdG9rZW4uYW5ub3QoKV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmIChsZWZ0VG9rZW4gaW5zdGFuY2VvZiBDb21wYXJhYmxlVG9rZW4gJiYgcmlnaHRUb2tlbiBpbnN0YW5jZW9mIENvbXBhcmFibGVUb2tlbikge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gbGVmdFRva2VuLmNvbXBhcmUoZ2V0VmFsdWUobGVmdFRva2VuLCB2YWwxKSwgZ2V0VmFsdWUobGVmdFRva2VuLCB2YWwyKSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0ID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJpZ2h0VG9rZW4uY29tcGFyZShnZXRWYWx1ZShyaWdodFRva2VuLCB2YWwxKSwgZ2V0VmFsdWUocmlnaHRUb2tlbiwgdmFsMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgVG9rZW5Db21wYXJpc29uRXJyb3IodmFsMSwgdmFsMik7XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoUGFpclRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRva2VucygpLm1hcCgodCkgPT4gdC5maW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpKTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5QYWlyVG9rZW4ucHJpbSA9ICdwYWlyJztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBOYXRcbiAqL1xuY2xhc3MgTmF0VmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ05hdFZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgTmF0VG9rZW4gZXh0ZW5kcyBDb21wYXJhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgaWR4LCBmYWMpIHtcbiAgICAgICAgc3VwZXIodmFsLCBpZHgsIGZhYyk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5mYWMgPSBmYWM7XG4gICAgfVxuICAgIEV4ZWN1dGUodmFsKSB7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHZhbFtPYmplY3Qua2V5cyh2YWwpWzBdXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIE5hdFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIHJldHVybiB7IGludDogbmV3IEJpZ051bWJlcih2YWwpLnRvRml4ZWQoKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBOYXRWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsKSB7XG4gICAgICAgIGNvbnN0IGJpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIodmFsKTtcbiAgICAgICAgaWYgKGJpZ051bWJlci5pc05hTigpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF0VmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYFZhbHVlIGlzIG5vdCBhIG51bWJlcjogJHtKU09OLnN0cmluZ2lmeSh2YWwpfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChiaWdOdW1iZXIuaXNOZWdhdGl2ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTmF0VmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYFZhbHVlIGNhbm5vdCBiZSBuZWdhdGl2ZTogJHtKU09OLnN0cmluZ2lmeSh2YWwpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIE5hdFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIGlmIChzZW1hbnRpYyAmJiBzZW1hbnRpY1tOYXRUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW05hdFRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgaW50OiBuZXcgQmlnTnVtYmVyKHZhbCkudG9GaXhlZCgpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIE5hdFRva2VuLnByaW07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBOYXRUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiBOYXRUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBUb0JpZ01hcEtleSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogeyBpbnQ6IFN0cmluZyh2YWwpIH0sXG4gICAgICAgICAgICB0eXBlOiB7IHByaW06IE5hdFRva2VuLnByaW0gfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVG9LZXkoeyBpbnQgfSkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcihpbnQpO1xuICAgIH1cbiAgICBjb21wYXJlKG5hdDEsIG5hdDIpIHtcbiAgICAgICAgY29uc3QgbzEgPSBOdW1iZXIobmF0MSk7XG4gICAgICAgIGNvbnN0IG8yID0gTnVtYmVyKG5hdDIpO1xuICAgICAgICBpZiAobzEgPT09IG8yKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbzEgPCBvMiA/IC0xIDogMTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChOYXRUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5OYXRUb2tlbi5wcmltID0gJ25hdCc7XG5cbmNsYXNzIFN0cmluZ1Rva2VuIGV4dGVuZHMgQ29tcGFyYWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsW09iamVjdC5rZXlzKHZhbClbMF1dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmdUb2tlbi5wcmltO1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogU3RyaW5nVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogU3RyaW5nVG9rZW4ucHJpbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nOiB2YWwgfTtcbiAgICB9XG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW1N0cmluZ1Rva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbU3RyaW5nVG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBzdHJpbmc6IHZhbCB9O1xuICAgIH1cbiAgICBUb0tleSh7IHN0cmluZyB9KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIFRvQmlnTWFwS2V5KHZhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB7IHN0cmluZzogdmFsIH0sXG4gICAgICAgICAgICB0eXBlOiB7IHByaW06IFN0cmluZ1Rva2VuLnByaW0gfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChTdHJpbmdUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5TdHJpbmdUb2tlbi5wcmltID0gJ3N0cmluZyc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgYW4gQWRkcmVzc1xuICovXG5jbGFzcyBBZGRyZXNzVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0FkZHJlc3NWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIEFkZHJlc3NUb2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkodmFsKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSBiNThkZWNvZGUodmFsKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogeyBieXRlczogZGVjb2RlZCB9LFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiAnYnl0ZXMnIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEFkZHJlc3NWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlQWRkcmVzcyh2YWx1ZSkgIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBZGRyZXNzVmFsaWRhdGlvbkVycm9yKHZhbHVlLCB0aGlzLCBgQWRkcmVzcyBpcyBub3QgdmFsaWQ6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEFkZHJlc3NWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4geyBzdHJpbmc6IHZhbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBBZGRyZXNzVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0FkZHJlc3NUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0FkZHJlc3NUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0cmluZzogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEFkZHJlc3NWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbC5zdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdmFsLmJ5dGVzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQWRkcmVzc1ZhbGlkYXRpb25FcnJvcih2YWwsIHRoaXMsIGBjYW5ub3QgYmUgbWlzc2luZyBib3RoIHN0cmluZyBhbmQgYnl0ZXM6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlUHViS2V5KHZhbC5ieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIEFkZHJlc3NUb2tlbi5wcmltO1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogQWRkcmVzc1Rva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IEFkZHJlc3NUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBBZGRyZXNzVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIFRvS2V5KHsgYnl0ZXMsIHN0cmluZyB9KSB7XG4gICAgICAgIGlmIChzdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFieXRlcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFkZHJlc3NWYWxpZGF0aW9uRXJyb3IoeyBieXRlcywgc3RyaW5nIH0sIHRoaXMsIGBjYW5ub3QgYmUgbWlzc2luZyBib3RoIHN0cmluZyBhbmQgYnl0ZXMgJHtKU09OLnN0cmluZ2lmeSh7IHN0cmluZywgYnl0ZXMgfSl9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVB1YktleShieXRlcyk7XG4gICAgfVxuICAgIGNvbXBhcmUoYWRkcmVzczEsIGFkZHJlc3MyKSB7XG4gICAgICAgIGNvbnN0IGlzSW1wbGljaXQgPSAoYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3Muc3RhcnRzV2l0aCgndHonKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgaW1wbGljaXQxID0gaXNJbXBsaWNpdChhZGRyZXNzMSk7XG4gICAgICAgIGNvbnN0IGltcGxpY2l0MiA9IGlzSW1wbGljaXQoYWRkcmVzczIpO1xuICAgICAgICBpZiAoaW1wbGljaXQxICYmICFpbXBsaWNpdDIpIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpbXBsaWNpdDIgJiYgIWltcGxpY2l0MSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbXBhcmUoYWRkcmVzczEsIGFkZHJlc3MyKTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChBZGRyZXNzVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuQWRkcmVzc1Rva2VuLnByaW0gPSAnYWRkcmVzcyc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgYSBNYXBcbiAqL1xuY2xhc3MgTWFwVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ01hcFZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgTWFwVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgZ2V0IFZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzFdLCAwKTtcbiAgICB9XG4gICAgZ2V0IEtleVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odGhpcy52YWwuYXJnc1swXSwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIE1hcFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAoIU1pY2hlbHNvbk1hcC5pc01pY2hlbHNvbk1hcCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBNYXBWYWxpZGF0aW9uRXJyb3IodmFsdWUsIHRoaXMsIGBWYWx1ZSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gaXMgbm90IGEgdmFsaWQgTWljaGVsc29uTWFwYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwsIHNlbWFudGljcykge1xuICAgICAgICBjb25zdCBtYXAgPSBuZXcgTWljaGVsc29uTWFwKHRoaXMudmFsKTtcbiAgICAgICAgdmFsLmZvckVhY2goKGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIG1hcC5zZXQodGhpcy5LZXlTY2hlbWEuVG9LZXkoY3VycmVudC5hcmdzWzBdKSwgdGhpcy5WYWx1ZVNjaGVtYS5FeGVjdXRlKGN1cnJlbnQuYXJnc1sxXSwgc2VtYW50aWNzKSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gbWFwO1xuICAgIH1cbiAgICBvYmpMaXRUb01pY2hlbHNvbk1hcCh2YWwpIHtcbiAgICAgICAgaWYgKHZhbCBpbnN0YW5jZW9mIE1pY2hlbHNvbk1hcClcbiAgICAgICAgICAgIHJldHVybiB2YWw7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBNaWNoZWxzb25NYXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBNaWNoZWxzb25NYXAuZnJvbUxpdGVyYWwodmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBNYXBWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gdGhpcy5vYmpMaXRUb01pY2hlbHNvbk1hcChhcmdzLnBvcCgpKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWwua2V5cygpKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHRoaXMuS2V5U2NoZW1hLmNvbXBhcmUoYSwgYikpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJpbTogJ0VsdCcsXG4gICAgICAgICAgICAgICAgYXJnczogW3RoaXMuS2V5U2NoZW1hLkVuY29kZU9iamVjdChrZXkpLCB0aGlzLlZhbHVlU2NoZW1hLkVuY29kZU9iamVjdCh2YWwuZ2V0KGtleSkpXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBNYXBWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KGFyZ3MsIHNlbWFudGljKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IHRoaXMub2JqTGl0VG9NaWNoZWxzb25NYXAoYXJncyk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW01hcFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbTWFwVG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh2YWwua2V5cygpKVxuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHRoaXMuS2V5U2NoZW1hLmNvbXBhcmUoYSwgYikpXG4gICAgICAgICAgICAubWFwKChrZXkpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgcHJpbTogJ0VsdCcsXG4gICAgICAgICAgICAgICAgYXJnczogW3RoaXMuS2V5U2NoZW1hLkVuY29kZU9iamVjdChrZXkpLCB0aGlzLlZhbHVlU2NoZW1hLkVuY29kZU9iamVjdCh2YWwuZ2V0KGtleSkpXSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtYXA6IHtcbiAgICAgICAgICAgICAgICBrZXk6IHRoaXMuS2V5U2NoZW1hLkV4dHJhY3RTY2hlbWEoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5WYWx1ZVNjaGVtYS5FeHRyYWN0U2NoZW1hKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogTWFwVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgIGtleTogdGhpcy5LZXlTY2hlbWEuZ2VuZXJhdGVTY2hlbWEoKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5WYWx1ZVNjaGVtYS5nZW5lcmF0ZVNjaGVtYSgpLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChNYXBUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5LZXlTY2hlbWEuZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKTtcbiAgICAgICAgdGhpcy5WYWx1ZVNjaGVtYS5maW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbk1hcFRva2VuLnByaW0gPSAnbWFwJztcblxuY2xhc3MgQm9vbFRva2VuIGV4dGVuZHMgQ29tcGFyYWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHZhbC5wcmltKS50b0xvd2VyQ2FzZSgpID09PSAndHJ1ZScgPyB0cnVlIDogZmFsc2U7XG4gICAgfVxuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHJldHVybiB7IHByaW06IHZhbCA/ICdUcnVlJyA6ICdGYWxzZScgfTtcbiAgICB9XG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0Jvb2xUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0Jvb2xUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHByaW06IHZhbCA/ICdUcnVlJyA6ICdGYWxzZScgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gQm9vbFRva2VuLnByaW07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBCb29sVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogQm9vbFRva2VuLnByaW0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIFRvQmlnTWFwS2V5KHZhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB0aGlzLkVuY29kZU9iamVjdCh2YWwpLFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiBCb29sVG9rZW4ucHJpbSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBUb0tleSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRW5jb2RlT2JqZWN0KHZhbCk7XG4gICAgfVxuICAgIGNvbXBhcmUodmFsMSwgdmFsMikge1xuICAgICAgICBpZiAoKHZhbDEgJiYgdmFsMikgfHwgKCF2YWwxICYmICF2YWwyKSkge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsMSkge1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChCb29sVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuQm9vbFRva2VuLnByaW0gPSAnYm9vbCc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgYSBDb250cmFjdFxuICovXG5jbGFzcyBDb250cmFjdFZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdDb250cmFjdFZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgQ29udHJhY3RUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDb250cmFjdFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICAvLyB0ejEsdHoyIGFuZCB0ejMgc2VlbXMgdG8gYmUgdmFsaWQgY29udHJhY3QgdmFsdWVzIChmb3IgVW5pdCBjb250cmFjdClcbiAgICAgICAgaWYgKHZhbGlkYXRlQWRkcmVzcyh2YWx1ZSkgIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250cmFjdFZhbGlkYXRpb25FcnJvcih2YWx1ZSwgdGhpcywgYFZhbHVlICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSBpcyBub3QgYSB2YWxpZCBjb250cmFjdCBhZGRyZXNzLmApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDb250cmFjdFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICBpZiAodmFsLnN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWwuYnl0ZXMpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDb250cmFjdFZhbGlkYXRpb25FcnJvcih2YWwsIHRoaXMsIGBWYWx1ZSAke0pTT04uc3RyaW5naWZ5KHZhbCl9IGlzIG5vdCBhIHZhbGlkIGNvbnRyYWN0IGFkZHJlc3MuIG11c3QgY29udGFpbiBieXRlcyBvciBzdHJpbmcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY29kZVB1YktleSh2YWwuYnl0ZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDb250cmFjdFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIHJldHVybiB7IHN0cmluZzogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIENvbnRyYWN0VmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0NvbnRyYWN0VG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tDb250cmFjdFRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nOiB2YWwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gQ29udHJhY3RUb2tlbi5wcmltO1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgY29uc3QgdmFsdWVTY2hlbWEgPSB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIDApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBDb250cmFjdFRva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXI6IHRoaXMudmFsLmFyZ3NbMF0gPyB2YWx1ZVNjaGVtYS5nZW5lcmF0ZVNjaGVtYSgpIDoge30sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKENvbnRyYWN0VG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuQ29udHJhY3RUb2tlbi5wcmltID0gJ2NvbnRyYWN0JztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBhIExpc3RcbiAqL1xuY2xhc3MgTGlzdFZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdMaXN0VmFsaWRhdGlvbkVycm9yJztcbiAgICB9XG59XG5jbGFzcyBMaXN0VG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgZ2V0IHZhbHVlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCB0aGlzLmlkeCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIExpc3RWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IExpc3RWYWxpZGF0aW9uRXJyb3IodmFsdWUsIHRoaXMsIGBWYWx1ZSAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0gaXMgbm90IGEgdmFsaWQgYXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBMaXN0VmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCAwKTtcbiAgICAgICAgcmV0dXJuIHZhbC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgc2NoZW1hLkVuY29kZU9iamVjdChjdXJyZW50KV07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgTGlzdFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFeGVjdXRlKHZhbCwgc2VtYW50aWNzKSB7XG4gICAgICAgIGNvbnN0IHNjaGVtYSA9IHRoaXMuY3JlYXRlVG9rZW4odGhpcy52YWwuYXJnc1swXSwgMCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgcmV0dXJuIHZhbC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgc2NoZW1hLkV4ZWN1dGUoY3VycmVudCwgc2VtYW50aWNzKV07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgTGlzdFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QoYXJncywgc2VtYW50aWMpIHtcbiAgICAgICAgY29uc3Qgc2NoZW1hID0gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCAwKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZShhcmdzKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0xpc3RUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0xpc3RUb2tlbi5wcmltXShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJncy5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgc2NoZW1hLkVuY29kZU9iamVjdChjdXJyZW50KV07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW0xpc3RUb2tlbi5wcmltXTogdGhpcy52YWx1ZVNjaGVtYS5FeHRyYWN0U2NoZW1hKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBMaXN0VG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogdGhpcy52YWx1ZVNjaGVtYS5nZW5lcmF0ZVNjaGVtYSgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKExpc3RUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCB0aGlzLmlkeCkuZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5MaXN0VG9rZW4ucHJpbSA9ICdsaXN0JztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBNdXRlelxuICovXG5jbGFzcyBNdXRlelZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdNdXRlelZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgTXV0ZXpUb2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIodmFsW09iamVjdC5rZXlzKHZhbClbMF1dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gTXV0ZXpUb2tlbi5wcmltO1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogTXV0ZXpUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiBNdXRlelRva2VuLnByaW0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIE11dGV6VmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIHZhbGlkYXRlKHZhbCkge1xuICAgICAgICBjb25zdCBiaWdOdW1iZXIgPSBuZXcgQmlnTnVtYmVyKHZhbCk7XG4gICAgICAgIGlmIChiaWdOdW1iZXIuaXNOYU4oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IE11dGV6VmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYFZhbHVlIGlzIG5vdCBhIG51bWJlcjogJHt2YWx9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgTXV0ZXpWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4geyBpbnQ6IFN0cmluZyh2YWwpLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgTXV0ZXpWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbTXV0ZXpUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW011dGV6VG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbnQ6IFN0cmluZyh2YWwpLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHsgaW50OiBTdHJpbmcodmFsKSB9LFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiBNdXRlelRva2VuLnByaW0gfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVG9LZXkoeyBpbnQgfSkge1xuICAgICAgICByZXR1cm4gaW50O1xuICAgIH1cbiAgICBjb21wYXJlKG11dGV6MSwgbXV0ZXoyKSB7XG4gICAgICAgIGNvbnN0IG8xID0gTnVtYmVyKG11dGV6MSk7XG4gICAgICAgIGNvbnN0IG8yID0gTnVtYmVyKG11dGV6Mik7XG4gICAgICAgIGlmIChvMSA9PT0gbzIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvMSA8IG8yID8gLTEgOiAxO1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKE11dGV6VG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuTXV0ZXpUb2tlbi5wcmltID0gJ211dGV6JztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBCeXRlc1xuICovXG5jbGFzcyBCeXRlc1ZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdCeXRlc1ZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgQnl0ZXNUb2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHsgYnl0ZXM6IHZhbCB9LFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiBCeXRlc1Rva2VuLnByaW0gfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgQnl0ZXNWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiAvXlswLTlhLWZBLUZdKiQvLnRlc3QodmFsKSAmJiB2YWwubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCeXRlc1ZhbGlkYXRpb25FcnJvcih2YWwsIHRoaXMsIGBJbnZhbGlkIGJ5dGVzOiAke3ZhbH1gKTtcbiAgICB9XG4gICAgY29udmVydFVpbnQ4QXJyYXlUb0hleFN0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSA/IEJ1ZmZlci5mcm9tKHZhbCkudG9TdHJpbmcoJ2hleCcpIDogdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBCeXRlc1ZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBsZXQgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdmFsID0gc3RyaXBIZXhQcmVmaXgodGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIHJldHVybiB7IGJ5dGVzOiBTdHJpbmcodmFsKS50b1N0cmluZygpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJ5dGVzVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIHZhbCA9IHRoaXMuY29udmVydFVpbnQ4QXJyYXlUb0hleFN0cmluZyh2YWwpO1xuICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgIHZhbCA9IHN0cmlwSGV4UHJlZml4KHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbQnl0ZXNUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0J5dGVzVG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBieXRlczogU3RyaW5nKHZhbCkudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiBCeXRlc1Rva2VuLnByaW07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBCeXRlc1Rva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IEJ5dGVzVG9rZW4ucHJpbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgVG9LZXkoeyBieXRlcywgc3RyaW5nIH0pIHtcbiAgICAgICAgaWYgKHN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYnl0ZXM7XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoQnl0ZXNUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5CeXRlc1Rva2VuLnByaW0gPSAnYnl0ZXMnO1xuXG5jbGFzcyBPcHRpb25Ub2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgc3ViVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KTtcbiAgICB9XG4gICAgc2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVUb2tlbih0aGlzLnZhbC5hcmdzWzBdLCAwKTtcbiAgICB9XG4gICAgYW5ub3QoKSB7XG4gICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRoaXMudmFsLmFubm90cylcbiAgICAgICAgICAgID8gc3VwZXIuYW5ub3QoKVxuICAgICAgICAgICAgOiB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KS5hbm5vdCgpO1xuICAgIH1cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGFyZ3M7XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHZhbHVlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4geyBwcmltOiAnTm9uZScgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgICAgICAgICAgKHZhbHVlW3ZhbHVlLmxlbmd0aCAtIDFdID09PSB1bmRlZmluZWQgfHwgdmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gPT09IG51bGwpKSB7XG4gICAgICAgICAgICB2YWx1ZS5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiB7IHByaW06ICdOb25lJyB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHByaW06ICdTb21lJywgYXJnczogW3RoaXMuc2NoZW1hKCkuRW5jb2RlKGFyZ3MpXSB9O1xuICAgIH1cbiAgICBFbmNvZGVPYmplY3QoYXJncywgc2VtYW50aWMpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gYXJncztcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHByaW06ICdOb25lJyB9O1xuICAgICAgICB9XG4gICAgICAgIHZhbHVlID0gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiAnU29tZScgaW4gdmFsdWUgPyB2YWx1ZVsnU29tZSddIDogdmFsdWU7XG4gICAgICAgIHJldHVybiB7IHByaW06ICdTb21lJywgYXJnczogW3RoaXMuc2NoZW1hKCkuRW5jb2RlT2JqZWN0KHZhbHVlLCBzZW1hbnRpYyldIH07XG4gICAgfVxuICAgIEV4ZWN1dGUodmFsLCBzZW1hbnRpY3MpIHtcbiAgICAgICAgaWYgKHZhbC5wcmltID09PSAnTm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IFNvbWU6IHRoaXMuc2NoZW1hKCkuRXhlY3V0ZSh2YWwuYXJnc1swXSwgc2VtYW50aWNzKSB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7IFNvbWU6IHRoaXMuc2NoZW1hKCkuRXh0cmFjdFNjaGVtYSgpIH07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBPcHRpb25Ub2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiB0aGlzLnNjaGVtYSgpLmdlbmVyYXRlU2NoZW1hKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIEV4dHJhY3RTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5zY2hlbWEoKS5FeHRyYWN0U2lnbmF0dXJlKCldO1xuICAgIH1cbiAgICBnZXQgS2V5U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zY2hlbWEoKTtcbiAgICB9XG4gICAgY29tcGFyZSh2YWwxLCB2YWwyKSB7XG4gICAgICAgIGlmICghdmFsMSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF2YWwyKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5LZXlTY2hlbWEuY29tcGFyZSh2YWwxLCB2YWwyKTtcbiAgICB9XG4gICAgVG9LZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLkV4ZWN1dGUodmFsKTtcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHRoaXMuRW5jb2RlT2JqZWN0KHZhbCksXG4gICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGVXaXRob3V0QW5ub3RhdGlvbnMoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChPcHRpb25Ub2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zdWJUb2tlbigpLmZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuT3B0aW9uVG9rZW4ucHJpbSA9ICdvcHRpb24nO1xuXG5jbGFzcyBUaW1lc3RhbXBUb2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbC5zdHJpbmcgJiYgL15cXGQrJC8udGVzdCh2YWwuc3RyaW5nKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcih2YWwuc3RyaW5nKSAqIDEwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsLnN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKHZhbC5zdHJpbmcpLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsLmludCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEYXRlKE51bWJlcih2YWwuaW50KSAqIDEwMDApLnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnQ6IFN0cmluZyh2YWwpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdHJpbmc6IHZhbCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIGlmIChzZW1hbnRpYyAmJiBzZW1hbnRpY1tUaW1lc3RhbXBUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW1RpbWVzdGFtcFRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnQ6IFN0cmluZyh2YWwpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyBzdHJpbmc6IHZhbCB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIFRpbWVzdGFtcFRva2VuLnByaW07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBUaW1lc3RhbXBUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiBUaW1lc3RhbXBUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBUb0tleSh7IHN0cmluZyB9KSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuICAgIFRvQmlnTWFwS2V5KHZhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB7IHN0cmluZzogdmFsIH0sXG4gICAgICAgICAgICB0eXBlOiB7IHByaW06IFRpbWVzdGFtcFRva2VuLnByaW0gfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChUaW1lc3RhbXBUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5UaW1lc3RhbXBUb2tlbi5wcmltID0gJ3RpbWVzdGFtcCc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgSW50XG4gKi9cbmNsYXNzIEludFZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnRWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIEludFRva2VuIGV4dGVuZHMgQ29tcGFyYWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih2YWxbT2JqZWN0LmtleXModmFsKVswXV0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiBJbnRUb2tlbi5wcmltO1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogSW50VG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogSW50VG9rZW4ucHJpbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgSW50VmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIHZhbGlkYXRlKHZhbCkge1xuICAgICAgICBjb25zdCBiaWdOdW1iZXIgPSBuZXcgQmlnTnVtYmVyKHZhbCk7XG4gICAgICAgIGlmIChiaWdOdW1iZXIuaXNOYU4oKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludFZhbGlkYXRpb25FcnJvcih2YWwsIHRoaXMsIGBWYWx1ZSBpcyBub3QgYSBudW1iZXI6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnRWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4geyBpbnQ6IG5ldyBCaWdOdW1iZXIodmFsKS50b0ZpeGVkKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgSW50VmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0ludFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbSW50VG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBpbnQ6IG5ldyBCaWdOdW1iZXIodmFsKS50b0ZpeGVkKCkgfTtcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHsgaW50OiBTdHJpbmcodmFsKSB9LFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiBJbnRUb2tlbi5wcmltIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIFRvS2V5KHsgaW50IH0pIHtcbiAgICAgICAgcmV0dXJuIGludDtcbiAgICB9XG4gICAgY29tcGFyZShpbnQxLCBpbnQyKSB7XG4gICAgICAgIGNvbnN0IG8xID0gTnVtYmVyKGludDEpO1xuICAgICAgICBjb25zdCBvMiA9IE51bWJlcihpbnQyKTtcbiAgICAgICAgaWYgKG8xID09PSBvMikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG8xIDwgbzIgPyAtMSA6IDE7XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoSW50VG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuSW50VG9rZW4ucHJpbSA9ICdpbnQnO1xuXG5jbGFzcyBVbml0VG9rZW4gZXh0ZW5kcyBDb21wYXJhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgaWR4LCBmYWMpIHtcbiAgICAgICAgc3VwZXIodmFsLCBpZHgsIGZhYyk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5mYWMgPSBmYWM7XG4gICAgfVxuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGFyZ3MucG9wKCk7XG4gICAgICAgIHJldHVybiB7IHByaW06ICdVbml0JyB9O1xuICAgIH1cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbVW5pdFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbVW5pdFRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgcHJpbTogJ1VuaXQnIH07XG4gICAgfVxuICAgIEV4ZWN1dGUoX3ZhbCkge1xuICAgICAgICByZXR1cm4gVW5pdFZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiBVbml0VG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IFVuaXRUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiBVbml0VG9rZW4ucHJpbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcGFyZShfdmFsMSwgX3ZhbDIpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIFRvS2V5KF92YWwpIHtcbiAgICAgICAgcmV0dXJuIFVuaXRWYWx1ZTtcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkoX3ZhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB7IHByaW06ICdVbml0JyB9LFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiBVbml0VG9rZW4ucHJpbSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKFVuaXRUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5Vbml0VG9rZW4ucHJpbSA9ICd1bml0JztcblxuY29uc3QgcHVibGljS2V5UHJlZml4TGVuZ3RoID0gNDtcbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgYSBLZXlcbiAqL1xuY2xhc3MgS2V5VmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0tleVZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgS2V5VG9rZW4gZXh0ZW5kcyBDb21wYXJhYmxlVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgaWR4LCBmYWMpIHtcbiAgICAgICAgc3VwZXIodmFsLCBpZHgsIGZhYyk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5mYWMgPSBmYWM7XG4gICAgfVxuICAgIEV4ZWN1dGUodmFsKSB7XG4gICAgICAgIGlmICh2YWwuc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsLnN0cmluZztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlS2V5KHZhbC5ieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsaWRhdGVQdWJsaWNLZXkodmFsdWUpICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgS2V5VmFsaWRhdGlvbkVycm9yKHZhbHVlLCB0aGlzLCAnS2V5IGlzIG5vdCB2YWxpZCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIHJldHVybiB7IHN0cmluZzogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIGlmIChzZW1hbnRpYyAmJiBzZW1hbnRpY1tLZXlUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0tleVRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nOiB2YWwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gS2V5VG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IEtleVRva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IEtleVRva2VuLnByaW0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIFRvS2V5KHZhbCkge1xuICAgICAgICByZXR1cm4gdGhpcy5FeGVjdXRlKHZhbCk7XG4gICAgfVxuICAgIFRvQmlnTWFwS2V5KHZhbCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAga2V5OiB7IHN0cmluZzogdmFsIH0sXG4gICAgICAgICAgICB0eXBlOiB7IHByaW06IEtleVRva2VuLnByaW0gfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29tcGFyZShrZXkxLCBrZXkyKSB7XG4gICAgICAgIGNvbnN0IGtleVByZWZpeDEgPSB0aGlzLmdldFByZWZpeChrZXkxKTtcbiAgICAgICAgY29uc3Qga2V5UHJlZml4MiA9IHRoaXMuZ2V0UHJlZml4KGtleTIpO1xuICAgICAgICBpZiAoa2V5UHJlZml4MSA9PT0gUHJlZml4LkVEUEsgJiYga2V5UHJlZml4MiAhPT0gUHJlZml4LkVEUEspIHtcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChrZXlQcmVmaXgxID09PSBQcmVmaXguU1BQSyAmJiBrZXlQcmVmaXgyICE9PSBQcmVmaXguU1BQSykge1xuICAgICAgICAgICAgcmV0dXJuIGtleVByZWZpeDIgPT09IFByZWZpeC5FRFBLID8gMSA6IC0xO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleVByZWZpeDEgPT09IFByZWZpeC5QMlBLKSB7XG4gICAgICAgICAgICBpZiAoa2V5UHJlZml4MiAhPT0gUHJlZml4LlAyUEspIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGtleUJ5dGVzMSA9IHRoaXMuZ2V0UDI1NlB1YmxpY0tleUNvbXBhcmFibGVCeXRlcyhrZXkxKTtcbiAgICAgICAgICAgIGNvbnN0IGtleUJ5dGVzMiA9IHRoaXMuZ2V0UDI1NlB1YmxpY0tleUNvbXBhcmFibGVCeXRlcyhrZXkyKTtcbiAgICAgICAgICAgIHJldHVybiBCdWZmZXIuY29tcGFyZShrZXlCeXRlczEsIGtleUJ5dGVzMik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNvbXBhcmUoa2V5MSwga2V5Mik7XG4gICAgfVxuICAgIGdldFByZWZpeCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zdWJzdHJpbmcoMCwgcHVibGljS2V5UHJlZml4TGVuZ3RoKTtcbiAgICB9XG4gICAgZ2V0UDI1NlB1YmxpY0tleUNvbXBhcmFibGVCeXRlcyhwMnBrKSB7XG4gICAgICAgIHJldHVybiBiNThjZGVjb2RlKHAycGssIHByZWZpeFtQcmVmaXguUDJQS10pLnNsaWNlKDEpO1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKEtleVRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbktleVRva2VuLnByaW0gPSAna2V5JztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBLZXkgSGFzaFxuICovXG5jbGFzcyBLZXlIYXNoVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0tleUhhc2hWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIEtleUhhc2hUb2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbC5zdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVLZXlIYXNoKHZhbC5ieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEtleUhhc2hWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlS2V5SGFzaCh2YWx1ZSkgIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBLZXlIYXNoVmFsaWRhdGlvbkVycm9yKHZhbHVlLCB0aGlzLCBgS2V5SGFzaCBpcyBub3QgdmFsaWQ6ICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfWApO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEtleUhhc2hWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4geyBzdHJpbmc6IHZhbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBLZXlIYXNoVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0tleUhhc2hUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0tleUhhc2hUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0cmluZzogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIEtleUhhc2hUb2tlbi5wcmltO1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogS2V5SGFzaFRva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IEtleUhhc2hUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBUb0tleSh7IHN0cmluZywgYnl0ZXMgfSkge1xuICAgICAgICBpZiAoc3RyaW5nKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVLZXlIYXNoKGJ5dGVzKTtcbiAgICB9XG4gICAgVG9CaWdNYXBLZXkodmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBrZXk6IHsgc3RyaW5nOiB2YWwgfSxcbiAgICAgICAgICAgIHR5cGU6IHsgcHJpbTogS2V5SGFzaFRva2VuLnByaW0gfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChLZXlIYXNoVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuS2V5SGFzaFRva2VuLnByaW0gPSAna2V5X2hhc2gnO1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGhhcHBlbmluZyB3aGVuIHBhcnNpbmcgZW5jb2RpbmcvZXhlY3V0aW5nIGEgU2lnbmF0dXJlXG4gKi9cbmNsYXNzIFNpZ25hdHVyZVZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdTaWduYXR1cmVWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIFNpZ25hdHVyZVRva2VuIGV4dGVuZHMgQ29tcGFyYWJsZVRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICBpZiAodmFsLnN0cmluZykge1xuICAgICAgICAgICAgcmV0dXJuIHZhbC5zdHJpbmc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVE9ETyBkZWNvZGUgdGhlIHNpZ25hdHVyZVxuICAgICAgICByZXR1cm4gdmFsLmJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTaWduYXR1cmVWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbGlkYXRlU2lnbmF0dXJlKHZhbHVlKSAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNpZ25hdHVyZVZhbGlkYXRpb25FcnJvcih2YWx1ZSwgdGhpcywgJ1NpZ25hdHVyZSBpcyBub3QgdmFsaWQnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTaWduYXR1cmVWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4geyBzdHJpbmc6IHZhbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTaWduYXR1cmVWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbU2lnbmF0dXJlVG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tTaWduYXR1cmVUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHN0cmluZzogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIFNpZ25hdHVyZVRva2VuLnByaW07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBTaWduYXR1cmVUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiBTaWduYXR1cmVUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBUb0tleSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuRXhlY3V0ZSh2YWwpO1xuICAgIH1cbiAgICBUb0JpZ01hcEtleSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogeyBzdHJpbmc6IHZhbCB9LFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiBTaWduYXR1cmVUb2tlbi5wcmltIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoU2lnbmF0dXJlVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuU2lnbmF0dXJlVG9rZW4ucHJpbSA9ICdzaWduYXR1cmUnO1xuXG5jbGFzcyBMYW1iZGFUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICBnZXQgcGFyYW1TY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KTtcbiAgICB9XG4gICAgZ2V0IHJldHVyblNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlVG9rZW4odGhpcy52YWwuYXJnc1sxXSwgdGhpcy5pZHggKyAxKTtcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgaWYgKHZhbC5zdHJpbmcpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHZhbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbTGFtYmRhVG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tMYW1iZGFUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtMYW1iZGFUb2tlbi5wcmltXToge1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IHRoaXMucGFyYW1TY2hlbWEuRXh0cmFjdFNjaGVtYSgpLFxuICAgICAgICAgICAgICAgIHJldHVybnM6IHRoaXMucmV0dXJuU2NoZW1hLkV4dHJhY3RTY2hlbWEoKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBMYW1iZGFUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyczogdGhpcy5wYXJhbVNjaGVtYS5nZW5lcmF0ZVNjaGVtYSgpLFxuICAgICAgICAgICAgICAgIHJldHVybnM6IHRoaXMucmV0dXJuU2NoZW1hLmdlbmVyYXRlU2NoZW1hKCksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKExhbWJkYVRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KS5maW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpO1xuICAgICAgICB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMV0sIHRoaXMuaWR4KS5maW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpO1xuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbkxhbWJkYVRva2VuLnByaW0gPSAnbGFtYmRhJztcblxuY2xhc3MgT3BlcmF0aW9uVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5zdHJpbmc7XG4gICAgfVxuICAgIEVuY29kZSguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIHJldHVybiB7IHN0cmluZzogdmFsIH07XG4gICAgfVxuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIGlmIChzZW1hbnRpYyAmJiBzZW1hbnRpY1tPcGVyYXRpb25Ub2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW09wZXJhdGlvblRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nOiB2YWwgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gT3BlcmF0aW9uVG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IE9wZXJhdGlvblRva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IE9wZXJhdGlvblRva2VuLnByaW0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoT3BlcmF0aW9uVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuT3BlcmF0aW9uVG9rZW4ucHJpbSA9ICdvcGVyYXRpb24nO1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGhhcHBlbmluZyB3aGVuIHBhcnNpbmcgZW5jb2RpbmcvZXhlY3V0aW5nIGEgU2V0XG4gKi9cbmNsYXNzIFNldFZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdTZXRWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIFNldFRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgaWR4LCBmYWMpIHtcbiAgICAgICAgc3VwZXIodmFsLCBpZHgsIGZhYyk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5mYWMgPSBmYWM7XG4gICAgfVxuICAgIGdldCBLZXlTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTZXRWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNldFZhbGlkYXRpb25FcnJvcih2YWx1ZSwgdGhpcywgYFZhbHVlICR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfSBpcyBub3QgYW4gYXJyYXlgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTZXRWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgY29uc3QgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4gdmFsXG4gICAgICAgICAgICAuc29ydCgoYSwgYikgPT4gdGhpcy5LZXlTY2hlbWEuY29tcGFyZShhLCBiKSlcbiAgICAgICAgICAgIC5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ucHJldiwgdGhpcy5LZXlTY2hlbWEuRW5jb2RlT2JqZWN0KGN1cnJlbnQpXTtcbiAgICAgICAgfSwgW10pO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCwgc2VtYW50aWNzKSB7XG4gICAgICAgIHJldHVybiB2YWwucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIHRoaXMuS2V5U2NoZW1hLkV4ZWN1dGUoY3VycmVudCwgc2VtYW50aWNzKV07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgU2V0VmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdChhcmdzLCBzZW1hbnRpYykge1xuICAgICAgICB0aGlzLnZhbGlkYXRlKGFyZ3MpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbU2V0VG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tTZXRUb2tlbi5wcmltXShhcmdzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJnc1xuICAgICAgICAgICAgLnNvcnQoKGEsIGIpID0+IHRoaXMuS2V5U2NoZW1hLmNvbXBhcmUoYSwgYikpXG4gICAgICAgICAgICAucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gWy4uLnByZXYsIHRoaXMuS2V5U2NoZW1hLkVuY29kZU9iamVjdChjdXJyZW50KV07XG4gICAgICAgIH0sIFtdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gU2V0VG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IFNldFRva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IHRoaXMuS2V5U2NoZW1hLmdlbmVyYXRlU2NoZW1hKCksXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoU2V0VG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuS2V5U2NoZW1hLmZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucyk7XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuU2V0VG9rZW4ucHJpbSA9ICdzZXQnO1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGhhcHBlbmluZyB3aGVuIHBhcnNpbmcgZW5jb2RpbmcvZXhlY3V0aW5nIGEgQ2hhaW5JRFxuICovXG5jbGFzcyBDaGFpbklEVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NoYWluSURWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIENoYWluSURUb2tlbiBleHRlbmRzIENvbXBhcmFibGVUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgQ2hhaW5JRFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsaWRhdGVDaGFpbih2YWx1ZSkgIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBDaGFpbklEVmFsaWRhdGlvbkVycm9yKHZhbHVlLCB0aGlzLCBgVmFsdWUgJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGlzIG5vdCBhIHZhbGlkIENoYWluSURgKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsW09iamVjdC5rZXlzKHZhbClbMF1dO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiBDaGFpbklEVG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IENoYWluSURUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiBDaGFpbklEVG9rZW4ucHJpbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgQ2hhaW5JRFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgIHJldHVybiB7IHN0cmluZzogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIENoYWluSURWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbQ2hhaW5JRFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbQ2hhaW5JRFRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgc3RyaW5nOiB2YWwgfTtcbiAgICB9XG4gICAgVG9LZXkoeyBzdHJpbmcgfSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgIH1cbiAgICBUb0JpZ01hcEtleSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGtleTogeyBzdHJpbmc6IHZhbCB9LFxuICAgICAgICAgICAgdHlwZTogeyBwcmltOiBDaGFpbklEVG9rZW4ucHJpbSB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKENoYWluSURUb2tlbi5wcmltID09PSB0b2tlblRvRmluZCkge1xuICAgICAgICAgICAgdG9rZW5zLnB1c2godGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5DaGFpbklEVG9rZW4ucHJpbSA9ICdjaGFpbl9pZCc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgd2hlbiBlbmNvZGluZyBhbmQgc2VuZGluZyBhIHRpY2tldCB0byB0aGUgYmxvY2tjaGFpblxuICovXG5jbGFzcyBFbmNvZGVUaWNrZXRFcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdUaWNrZXRFbmNvZGVFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdUaWNrZXRzIGNhbm5vdCBiZSBzZW50IHRvIHRoZSBibG9ja2NoYWluOyB0aGV5IGFyZSBjcmVhdGVkIG9uLWNoYWluJztcbiAgICB9XG59XG5jb25zdCB0aWNrZXRlclR5cGUkMSA9IHsgcHJpbTogJ2NvbnRyYWN0JyB9O1xuY29uc3QgYW1vdW50VHlwZSQxID0geyBwcmltOiAnaW50JyB9O1xuY2xhc3MgVGlja2V0VG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgZ2V0IHZhbHVlVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgRW5jb2RlVGlja2V0RXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKF9hcmdzKSB7XG4gICAgICAgIHRocm93IG5ldyBFbmNvZGVUaWNrZXRFcnJvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBFbmNvZGVUaWNrZXRFcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QoYXJncywgc2VtYW50aWMpIHtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW1RpY2tldFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbVGlja2V0VG9rZW4ucHJpbV0oYXJncywgdGhpcy52YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFbmNvZGVUaWNrZXRFcnJvcigpO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCwgc2VtYW50aWNzKSB7XG4gICAgICAgIGlmIChzZW1hbnRpY3MgJiYgc2VtYW50aWNzW1RpY2tldFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNzW1RpY2tldFRva2VuLnByaW1dKHZhbCwgdGhpcy52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpY2tldGVyID0gdGhpcy5jcmVhdGVUb2tlbih0aWNrZXRlclR5cGUkMSwgdGhpcy5pZHgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVUb2tlbjtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdGhpcy5jcmVhdGVUb2tlbihhbW91bnRUeXBlJDEsIHRoaXMuaWR4KTtcbiAgICAgICAgaWYgKHVuZGVmaW5lZCA9PT0gdmFsLmFyZ3NbMl0gJiYgdW5kZWZpbmVkICE9PSB2YWwuYXJnc1sxXS5hcmdzKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHRpY2tldGVyOiB0aWNrZXRlci5FeGVjdXRlKHZhbC5hcmdzWzBdLCBzZW1hbnRpY3MpLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZS5FeGVjdXRlKHZhbC5hcmdzWzFdLmFyZ3NbMF0sIHNlbWFudGljcyksXG4gICAgICAgICAgICAgICAgYW1vdW50OiBhbW91bnQuRXhlY3V0ZSh2YWwuYXJnc1sxXS5hcmdzWzFdLCBzZW1hbnRpY3MpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdGlja2V0ZXI6IHRpY2tldGVyLkV4ZWN1dGUodmFsLmFyZ3NbMF0sIHNlbWFudGljcyksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUuRXhlY3V0ZSh2YWwuYXJnc1sxXSwgc2VtYW50aWNzKSxcbiAgICAgICAgICAgIGFtb3VudDogYW1vdW50LkV4ZWN1dGUodmFsLmFyZ3NbMl0sIHNlbWFudGljcyksXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpY2tldGVyOiBDb250cmFjdFRva2VuLnByaW0sXG4gICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVRva2VuLkV4dHJhY3RTY2hlbWEoKSxcbiAgICAgICAgICAgIGFtb3VudDogSW50VG9rZW4ucHJpbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IFRpY2tldFRva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy52YWx1ZVRva2VuLmdlbmVyYXRlU2NoZW1hKCksXG4gICAgICAgICAgICAgICAgdGlja2V0ZXI6IHtcbiAgICAgICAgICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBDb250cmFjdFRva2VuLnByaW0sXG4gICAgICAgICAgICAgICAgICAgIHNjaGVtYTogQ29udHJhY3RUb2tlbi5wcmltLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgYW1vdW50OiB7XG4gICAgICAgICAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogSW50VG9rZW4ucHJpbSxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBJbnRUb2tlbi5wcmltLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKFRpY2tldFRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlVG9rZW4uZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5UaWNrZXRUb2tlbi5wcmltID0gJ3RpY2tldCc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgd2hlbiBlbmNvZGluZyBhbmQgc2VuZGluZyBhIHRpY2tldCB0byB0aGUgYmxvY2tjaGFpblxuICovXG5jbGFzcyBFbmNvZGVUaWNrZXREZXByZWNhdGVkRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVGlja2V0RGVwcmVjYXRlZEVuY29kZUVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gJ1RpY2tldF9kZXByZWNhdGVkIGNhbm5vdCBiZSBzZW50IHRvIHRoZSBibG9ja2NoYWluOyB0aGV5IGFyZSBjcmVhdGVkIG9uLWNoYWluJztcbiAgICB9XG59XG5jb25zdCB0aWNrZXRlclR5cGUgPSB7IHByaW06ICdjb250cmFjdCcgfTtcbmNvbnN0IGFtb3VudFR5cGUgPSB7IHByaW06ICdpbnQnIH07XG5jbGFzcyBUaWNrZXREZXByZWNhdGVkVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgZ2V0IHZhbHVlVG9rZW4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZVRva2VuKHRoaXMudmFsLmFyZ3NbMF0sIHRoaXMuaWR4KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgRW5jb2RlVGlja2V0RGVwcmVjYXRlZEVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZShfYXJncykge1xuICAgICAgICB0aHJvdyBuZXcgRW5jb2RlVGlja2V0RGVwcmVjYXRlZEVycm9yKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEVuY29kZVRpY2tldERlcHJlY2F0ZWRFcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QoYXJncywgc2VtYW50aWMpIHtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW1RpY2tldERlcHJlY2F0ZWRUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW1RpY2tldERlcHJlY2F0ZWRUb2tlbi5wcmltXShhcmdzLCB0aGlzLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVuY29kZVRpY2tldERlcHJlY2F0ZWRFcnJvcigpO1xuICAgIH1cbiAgICBFeGVjdXRlKHZhbCwgc2VtYW50aWNzKSB7XG4gICAgICAgIGlmIChzZW1hbnRpY3MgJiYgc2VtYW50aWNzW1RpY2tldERlcHJlY2F0ZWRUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljc1tUaWNrZXREZXByZWNhdGVkVG9rZW4ucHJpbV0odmFsLCB0aGlzLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGlja2V0ZXIgPSB0aGlzLmNyZWF0ZVRva2VuKHRpY2tldGVyVHlwZSwgdGhpcy5pZHgpO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRoaXMudmFsdWVUb2tlbjtcbiAgICAgICAgY29uc3QgYW1vdW50ID0gdGhpcy5jcmVhdGVUb2tlbihhbW91bnRUeXBlLCB0aGlzLmlkeCk7XG4gICAgICAgIGlmICh1bmRlZmluZWQgPT09IHZhbC5hcmdzWzJdICYmIHVuZGVmaW5lZCAhPT0gdmFsLmFyZ3NbMV0uYXJncykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0aWNrZXRlcjogdGlja2V0ZXIuRXhlY3V0ZSh2YWwuYXJnc1swXSwgc2VtYW50aWNzKSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUuRXhlY3V0ZSh2YWwuYXJnc1sxXS5hcmdzWzBdLCBzZW1hbnRpY3MpLFxuICAgICAgICAgICAgICAgIGFtb3VudDogYW1vdW50LkV4ZWN1dGUodmFsLmFyZ3NbMV0uYXJnc1sxXSwgc2VtYW50aWNzKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRpY2tldGVyOiB0aWNrZXRlci5FeGVjdXRlKHZhbC5hcmdzWzBdLCBzZW1hbnRpY3MpLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLkV4ZWN1dGUodmFsLmFyZ3NbMV0sIHNlbWFudGljcyksXG4gICAgICAgICAgICBhbW91bnQ6IGFtb3VudC5FeGVjdXRlKHZhbC5hcmdzWzJdLCBzZW1hbnRpY3MpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0aWNrZXRlcjogQ29udHJhY3RUb2tlbi5wcmltLFxuICAgICAgICAgICAgdmFsdWU6IHRoaXMudmFsdWVUb2tlbi5FeHRyYWN0U2NoZW1hKCksXG4gICAgICAgICAgICBhbW91bnQ6IEludFRva2VuLnByaW0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBUaWNrZXREZXByZWNhdGVkVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgIHZhbHVlOiB0aGlzLnZhbHVlVG9rZW4uZ2VuZXJhdGVTY2hlbWEoKSxcbiAgICAgICAgICAgICAgICB0aWNrZXRlcjoge1xuICAgICAgICAgICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IENvbnRyYWN0VG9rZW4ucHJpbSxcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBDb250cmFjdFRva2VuLnByaW0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBhbW91bnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBJbnRUb2tlbi5wcmltLFxuICAgICAgICAgICAgICAgICAgICBzY2hlbWE6IEludFRva2VuLnByaW0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoVGlja2V0RGVwcmVjYXRlZFRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnZhbHVlVG9rZW4uZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKTtcbiAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICB9XG59XG5UaWNrZXREZXByZWNhdGVkVG9rZW4ucHJpbSA9ICd0aWNrZXRfZGVwcmVjYXRlZCc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgYSBOZXZlciBUb2tlblxuICovXG5jbGFzcyBOZXZlclRva2VuRXJyb3IgZXh0ZW5kcyBUb2tlblZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSAnTmV2ZXJUb2tlbkVycm9yJztcbiAgICB9XG59XG5jbGFzcyBOZXZlclRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgaWR4LCBmYWMpIHtcbiAgICAgICAgc3VwZXIodmFsLCBpZHgsIGZhYyk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5mYWMgPSBmYWM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIE5ldmVyVG9rZW5FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBjb25zdCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB0aHJvdyBuZXcgTmV2ZXJUb2tlbkVycm9yKHZhbCwgdGhpcywgYEFzc2lnbmluZyBhIHZhbHVlIHRvIHRoZSB0eXBlIG5ldmVyIGlzIGZvcmJpZGRlbi4gVHJ5aW5nIHRvIGFzc2lnbiAke0pTT04uc3RyaW5naWZ5KHZhbCl9LmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBOZXZlclRva2VuRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW05ldmVyVG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tOZXZlclRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IE5ldmVyVG9rZW5FcnJvcih2YWwsIHRoaXMsIGBBc3NpZ25pbmcgYSB2YWx1ZSB0byB0aGUgdHlwZSBuZXZlciBpcyBmb3JiaWRkZW4uIFRyeWluZyB0byBhc3NpZ24gJHtKU09OLnN0cmluZ2lmeSh2YWwpfS5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgTmV2ZXJUb2tlbkVycm9yfVxuICAgICAqL1xuICAgIEV4ZWN1dGUodmFsKSB7XG4gICAgICAgIHRocm93IG5ldyBOZXZlclRva2VuRXJyb3IodmFsLCB0aGlzLCBgVGhlcmUgaXMgbm8gbGl0ZXJhbCB2YWx1ZSBmb3IgdGhlIHR5cGUgbmV2ZXIuIFRyeWluZyB0byBleGVjdXRlICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uYCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIE5ldmVyVG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IE5ldmVyVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogTmV2ZXJUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKE5ldmVyVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuTmV2ZXJUb2tlbi5wcmltID0gJ25ldmVyJztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBhIFNhcGxpbmcgU3RhdGVcbiAqL1xuY2xhc3MgU2FwbGluZ1N0YXRlVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NhcGxpbmdTdGF0ZVZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgU2FwbGluZ1N0YXRlVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgaXNWYWxpZCh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIE9iamVjdC5rZXlzKHZhbCkubGVuZ3RoID09PSAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTYXBsaW5nU3RhdGVWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRXhlY3V0ZSh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIGlmIChzZW1hbnRpYyAmJiBzZW1hbnRpY1tTYXBsaW5nU3RhdGVUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW1NhcGxpbmdTdGF0ZVRva2VuLnByaW1dKHZhbCwgdGhpcy52YWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICgnaW50JyBpbiB2YWwpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWwuaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNhcGxpbmdTdGF0ZVZhbGlkYXRpb25FcnJvcih2YWwsIHRoaXMsIGBTYXBsaW5nIHN0YXRlIGlzIGV4cGVjdGluZyBhbiBvYmplY3Qgd2l0aCBhbiBpbnQgcHJvcGVydHkuIEdvdCAke0pTT04uc3RyaW5naWZ5KHZhbCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgU2FwbGluZ1N0YXRlVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGNvbnN0IHZhbCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGlmICh0aGlzLmlzVmFsaWQodmFsKSkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFNhcGxpbmdTdGF0ZVZhbGlkYXRpb25FcnJvcih2YWwsIHRoaXMsIGBJbnZhbGlkIHNhcGxpbmdfc3RhdGUuIFJlY2VpdmVkOiAke0pTT04uc3RyaW5naWZ5KHZhbCl9IHdoaWxlIGV4cGVjdGluZzoge31gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTYXBsaW5nU3RhdGVWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW1NhcGxpbmdTdGF0ZVRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbU2FwbGluZ1N0YXRlVG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1ZhbGlkKHZhbCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTYXBsaW5nU3RhdGVWYWxpZGF0aW9uRXJyb3IodmFsLCB0aGlzLCBgSW52YWxpZCBzYXBsaW5nX3N0YXRlLiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh2YWwpfSB3aGlsZSBleHBlY3Rpbmc6IHt9YCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1NhcGxpbmdTdGF0ZVRva2VuLnByaW1dOiB7XG4gICAgICAgICAgICAgICAgJ21lbW8tc2l6ZSc6IE51bWJlcih0aGlzLnZhbC5hcmdzWzBdWydpbnQnXSksXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogU2FwbGluZ1N0YXRlVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYToge1xuICAgICAgICAgICAgICAgIG1lbW9TaXplOiB0aGlzLnZhbC5hcmdzWzBdWydpbnQnXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoU2FwbGluZ1N0YXRlVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuU2FwbGluZ1N0YXRlVG9rZW4ucHJpbSA9ICdzYXBsaW5nX3N0YXRlJztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBhIFNhcGxpbmcgVHJhbnNhY3Rpb25cbiAqL1xuY2xhc3MgU2FwbGluZ1RyYW5zYWN0aW9uVmFsaWRhdGlvbkVycm9yIGV4dGVuZHMgVG9rZW5WYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSkge1xuICAgICAgICBzdXBlcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMudG9rZW4gPSB0b2tlbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1NhcGxpbmdUcmFuc2FjdGlvblZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgU2FwbGluZ1RyYW5zYWN0aW9uVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgU2FwbGluZ1RyYW5zYWN0aW9uVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEV4ZWN1dGUoX3ZhbCkge1xuICAgICAgICB0aHJvdyBuZXcgU2FwbGluZ1RyYW5zYWN0aW9uVmFsaWRhdGlvbkVycm9yKF92YWwsIHRoaXMsIGBUaGVyZSBpcyBubyBsaXRlcmFsIHZhbHVlIGZvciB0aGUgc2FwbGluZ190cmFuc2FjdGlvbiB0eXBlLiBHb3Q6ICR7SlNPTi5zdHJpbmdpZnkoX3ZhbCl9LmApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBTYXBsaW5nVHJhbnNhY3Rpb25WYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGVCeXRlcyh2YWwpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSAvXigweHwwWCk/KFswLTlhLWZBLUZdKiQpLy5leGVjKHZhbCk7XG4gICAgICAgIGlmIChieXRlcyAmJiBieXRlc1syXS5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gYnl0ZXNbMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU2FwbGluZ1RyYW5zYWN0aW9uVmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYEludmFsaWQgYnl0ZXM6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5ID8gQnVmZmVyLmZyb20odmFsKS50b1N0cmluZygnaGV4JykgOiB2YWw7XG4gICAgfVxuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGxldCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YWwgPSB0aGlzLnZhbGlkYXRlQnl0ZXModGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkpO1xuICAgICAgICByZXR1cm4geyBieXRlczogU3RyaW5nKHZhbCkudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICB2YWwgPSB0aGlzLnZhbGlkYXRlQnl0ZXModGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbU2FwbGluZ1RyYW5zYWN0aW9uVG9rZW4ucHJpbV0pIHtcbiAgICAgICAgICAgIHJldHVybiBzZW1hbnRpY1tTYXBsaW5nVHJhbnNhY3Rpb25Ub2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ5dGVzOiBTdHJpbmcodmFsKS50b1N0cmluZygpIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIFtTYXBsaW5nVHJhbnNhY3Rpb25Ub2tlbi5wcmltXToge1xuICAgICAgICAgICAgICAgICdtZW1vLXNpemUnOiBOdW1iZXIodGhpcy52YWwuYXJnc1swXVsnaW50J10pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IFNhcGxpbmdUcmFuc2FjdGlvblRva2VuLnByaW0sXG4gICAgICAgICAgICBzY2hlbWE6IHtcbiAgICAgICAgICAgICAgICBtZW1vU2l6ZTogdGhpcy52YWwuYXJnc1swXVsnaW50J10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKFNhcGxpbmdUcmFuc2FjdGlvblRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cblNhcGxpbmdUcmFuc2FjdGlvblRva2VuLnByaW0gPSAnc2FwbGluZ190cmFuc2FjdGlvbic7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZy9leGVjdXRpbmcgYSBTYXBsaW5nIFRyYW5zYWN0aW9uIERlcHJlY2F0ZWRcbiAqL1xuY2xhc3MgU2FwbGluZ1RyYW5zYWN0aW9uRGVwcmVjYXRlZFZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdTYXBsaW5nVHJhbnNhY3Rpb25EZXByZWNhdGVkVmFsaWRhdGlvbkVycm9yJztcbiAgICB9XG59XG5jbGFzcyBTYXBsaW5nVHJhbnNhY3Rpb25EZXByZWNhdGVkVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgU2FwbGluZ1RyYW5zYWN0aW9uRGVwcmVjYXRlZFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFeGVjdXRlKF92YWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFNhcGxpbmdUcmFuc2FjdGlvbkRlcHJlY2F0ZWRWYWxpZGF0aW9uRXJyb3IoX3ZhbCwgdGhpcywgYFRoZXJlIGlzIG5vIGxpdGVyYWwgdmFsdWUgZm9yIHRoZSBzYXBsaW5nX3RyYW5zYWN0aW9uX2RlcHJlY2F0ZWQgdHlwZS4gR290OiAke0pTT04uc3RyaW5naWZ5KF92YWwpfS5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgU2FwbGluZ1RyYW5zYWN0aW9uRGVwcmVjYXRlZFZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZUJ5dGVzKHZhbCkge1xuICAgICAgICBjb25zdCBieXRlcyA9IC9eKDB4fDBYKT8oWzAtOWEtZkEtRl0qJCkvLmV4ZWModmFsKTtcbiAgICAgICAgaWYgKGJ5dGVzICYmIGJ5dGVzWzJdLmxlbmd0aCAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBieXRlc1syXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBTYXBsaW5nVHJhbnNhY3Rpb25EZXByZWNhdGVkVmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYEludmFsaWQgYnl0ZXM6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5ID8gQnVmZmVyLmZyb20odmFsKS50b1N0cmluZygnaGV4JykgOiB2YWw7XG4gICAgfVxuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGxldCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YWwgPSB0aGlzLnZhbGlkYXRlQnl0ZXModGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkpO1xuICAgICAgICByZXR1cm4geyBieXRlczogU3RyaW5nKHZhbCkudG9TdHJpbmcoKSB9O1xuICAgIH1cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICB2YWwgPSB0aGlzLnZhbGlkYXRlQnl0ZXModGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbU2FwbGluZ1RyYW5zYWN0aW9uRGVwcmVjYXRlZFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbU2FwbGluZ1RyYW5zYWN0aW9uRGVwcmVjYXRlZFRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgYnl0ZXM6IFN0cmluZyh2YWwpLnRvU3RyaW5nKCkgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgW1NhcGxpbmdUcmFuc2FjdGlvbkRlcHJlY2F0ZWRUb2tlbi5wcmltXToge1xuICAgICAgICAgICAgICAgICdtZW1vLXNpemUnOiBOdW1iZXIodGhpcy52YWwuYXJnc1swXVsnaW50J10pLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IFNhcGxpbmdUcmFuc2FjdGlvbkRlcHJlY2F0ZWRUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgbWVtb1NpemU6IHRoaXMudmFsLmFyZ3NbMF1bJ2ludCddLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChTYXBsaW5nVHJhbnNhY3Rpb25EZXByZWNhdGVkVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuU2FwbGluZ1RyYW5zYWN0aW9uRGVwcmVjYXRlZFRva2VuLnByaW0gPSAnc2FwbGluZ190cmFuc2FjdGlvbl9kZXByZWNhdGVkJztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBhIEJMUzEyLTM4MSBzY2FsYXIgZmllbGQgRnJcbiAqL1xuY2xhc3MgQmxzMTIzODFmclZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdCbHMxMjM4MWZyVmFsaWRhdGlvbkVycm9yJztcbiAgICB9XG59XG5jbGFzcyBCbHMxMjM4MWZyVG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgQmxzMTIzODFmclZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWwpIHtcbiAgICAgICAgaWYgKC9eWzAtOWEtZkEtRl0qJC8udGVzdCh2YWwpICYmIHZhbC5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEJsczEyMzgxZnJWYWxpZGF0aW9uRXJyb3IodmFsLCB0aGlzLCBgSW52YWxpZCBieXRlczogJHtKU09OLnN0cmluZ2lmeSh2YWwpfWApO1xuICAgIH1cbiAgICBjb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmNvbnN0cnVjdG9yID09PSBVaW50OEFycmF5ID8gQnVmZmVyLmZyb20odmFsKS50b1N0cmluZygnaGV4JykgOiB2YWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJsczEyMzgxZnJWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgbGV0IHZhbCA9IGFyZ3MucG9wKCk7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgcmV0dXJuIHsgaW50OiB2YWwudG9TdHJpbmcoKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsID0gdGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCk7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlKHZhbCk7XG4gICAgICAgICAgICByZXR1cm4geyBieXRlczogdmFsIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgQmxzMTIzODFmclZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbQmxzMTIzODFmclRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbQmxzMTIzODFmclRva2VuLnByaW1dKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICByZXR1cm4geyBpbnQ6IHZhbC50b1N0cmluZygpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YWwgPSB0aGlzLmNvbnZlcnRVaW50OEFycmF5VG9IZXhTdHJpbmcodmFsKTtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgICAgIHJldHVybiB7IGJ5dGVzOiB2YWwgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBFeGVjdXRlKHZhbCkge1xuICAgICAgICByZXR1cm4gdmFsLmJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiBCbHMxMjM4MWZyVG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IEJsczEyMzgxZnJUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiBCbHMxMjM4MWZyVG9rZW4ucHJpbSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZmluZEFuZFJldHVyblRva2Vucyh0b2tlblRvRmluZCwgdG9rZW5zKSB7XG4gICAgICAgIGlmIChCbHMxMjM4MWZyVG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuLy8gQW4gZWxlbWVudCBvZiB0aGUgQkxTMTItMzgxIHNjYWxhciBmaWVsZCBGclxuLy8gc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL21pY2hlbHNvbi1yZWZlcmVuY2UvI3R5cGUtYmxzMTJfMzgxX2ZyXG5CbHMxMjM4MWZyVG9rZW4ucHJpbSA9ICdibHMxMl8zODFfZnInO1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGhhcHBlbmluZyB3aGVuIHBhcnNpbmcgZW5jb2RpbmcvZXhlY3V0aW5nIGEgQkxTMTItMzgxIGN1cnZlIEcxXG4gKi9cbmNsYXNzIEJsczEyMzgxZzFWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBUb2tlblZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmxzMTIzODFnMVZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgQmxzMTIzODFnMVRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgaWR4LCBmYWMpIHtcbiAgICAgICAgc3VwZXIodmFsLCBpZHgsIGZhYyk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5mYWMgPSBmYWM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJsczEyMzgxZzFWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsKSB7XG4gICAgICAgIGlmICgvXlswLTlhLWZBLUZdKiQvLnRlc3QodmFsKSAmJiB2YWwubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCbHMxMjM4MWcxVmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYEludmFsaWQgYnl0ZXM6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG4gICAgY29udmVydFVpbnQ4QXJyYXlUb0hleFN0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSA/IEJ1ZmZlci5mcm9tKHZhbCkudG9TdHJpbmcoJ2hleCcpIDogdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBCbHMxMjM4MWcxVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGxldCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YWwgPSB0aGlzLmNvbnZlcnRVaW50OEFycmF5VG9IZXhTdHJpbmcodmFsKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4geyBieXRlczogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJsczEyMzgxZzFWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgdmFsID0gdGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0JsczEyMzgxZzFUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0JsczEyMzgxZzFUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ5dGVzOiB2YWwgfTtcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5ieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gQmxzMTIzODFnMVRva2VuLnByaW07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBCbHMxMjM4MWcxVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogQmxzMTIzODFnMVRva2VuLnByaW0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoQmxzMTIzODFnMVRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbi8vIEEgcG9pbnQgb24gdGhlIEJMUzEyLTM4MSBjdXJ2ZSBHMVxuLy8gU2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL21pY2hlbHNvbi1yZWZlcmVuY2UvI3R5cGUtYmxzMTJfMzgxX2cxXG5CbHMxMjM4MWcxVG9rZW4ucHJpbSA9ICdibHMxMl8zODFfZzEnO1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGhhcHBlbmluZyB3aGVuIHBhcnNpbmcgZW5jb2RpbmcvZXhlY3V0aW5nIGEgQkxTMTItMzgxIGN1cnZlIEcyXG4gKi9cbmNsYXNzIEJsczEyMzgxZzJWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBUb2tlblZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmxzMTIzODFnMlZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgQmxzMTIzODFnMlRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICAgIGNvbnN0cnVjdG9yKHZhbCwgaWR4LCBmYWMpIHtcbiAgICAgICAgc3VwZXIodmFsLCBpZHgsIGZhYyk7XG4gICAgICAgIHRoaXMudmFsID0gdmFsO1xuICAgICAgICB0aGlzLmlkeCA9IGlkeDtcbiAgICAgICAgdGhpcy5mYWMgPSBmYWM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJsczEyMzgxZzJWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsKSB7XG4gICAgICAgIGlmICgvXlswLTlhLWZBLUZdKiQvLnRlc3QodmFsKSAmJiB2YWwubGVuZ3RoICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBCbHMxMjM4MWcyVmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYEludmFsaWQgYnl0ZXM6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG4gICAgY29udmVydFVpbnQ4QXJyYXlUb0hleFN0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSA/IEJ1ZmZlci5mcm9tKHZhbCkudG9TdHJpbmcoJ2hleCcpIDogdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBCbHMxMjM4MWcyVmFsaWRhdGlvbkVycm9yfVxuICAgICAqL1xuICAgIEVuY29kZShhcmdzKSB7XG4gICAgICAgIGxldCB2YWwgPSBhcmdzLnBvcCgpO1xuICAgICAgICB2YWwgPSB0aGlzLmNvbnZlcnRVaW50OEFycmF5VG9IZXhTdHJpbmcodmFsKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICByZXR1cm4geyBieXRlczogdmFsIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEJsczEyMzgxZzJWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlT2JqZWN0KHZhbCwgc2VtYW50aWMpIHtcbiAgICAgICAgdmFsID0gdGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgaWYgKHNlbWFudGljICYmIHNlbWFudGljW0JsczEyMzgxZzJUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0JsczEyMzgxZzJUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGJ5dGVzOiB2YWwgfTtcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5ieXRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gQmxzMTIzODFnMlRva2VuLnByaW07XG4gICAgfVxuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgX19taWNoZWxzb25UeXBlOiBCbHMxMjM4MWcyVG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogQmxzMTIzODFnMlRva2VuLnByaW0sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucykge1xuICAgICAgICBpZiAoQmxzMTIzODFnMlRva2VuLnByaW0gPT09IHRva2VuVG9GaW5kKSB7XG4gICAgICAgICAgICB0b2tlbnMucHVzaCh0aGlzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH1cbn1cbi8vIEEgcG9pbnQgb24gdGhlIEJMUzEyLTM4MSBjdXJ2ZSBHMlxuLy8gU2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL21pY2hlbHNvbi1yZWZlcmVuY2UvI3R5cGUtYmxzMTJfMzgxX2cyXG5CbHMxMjM4MWcyVG9rZW4ucHJpbSA9ICdibHMxMl8zODFfZzInO1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGhhcHBlbmluZyB3aGVuIHBhcnNpbmcgZW5jb2RpbmcvZXhlY3V0aW5nIGEgQ2hlc3RcbiAqL1xuY2xhc3MgQ2hlc3RWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBUb2tlblZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQ2hlc3RWYWxpZGF0aW9uRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIENoZXN0VG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgQ2hlc3RLZXlWYWxpZGF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgdmFsaWRhdGUodmFsKSB7XG4gICAgICAgIGlmICgvXlswLTlhLWZBLUZdKiQvLnRlc3QodmFsKSAmJiB2YWwubGVuZ3RoICUgMiA9PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IENoZXN0VmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYEludmFsaWQgYnl0ZXM6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG4gICAgY29udmVydFVpbnQ4QXJyYXlUb0hleFN0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSA/IEJ1ZmZlci5mcm9tKHZhbCkudG9TdHJpbmcoJ2hleCcpIDogdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDaGVzdEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBsZXQgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdmFsID0gdGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXM6IHZhbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDaGVzdEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICB2YWwgPSB0aGlzLmNvbnZlcnRVaW50OEFycmF5VG9IZXhTdHJpbmcodmFsKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbQ2hlc3RUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0NoZXN0VG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBieXRlczogdmFsIH07XG4gICAgfVxuICAgIEV4ZWN1dGUodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwuYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIENoZXN0VG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IENoZXN0VG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogQ2hlc3RUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKENoZXN0VG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuQ2hlc3RUb2tlbi5wcmltID0gJ2NoZXN0JztcblxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSBoYXBwZW5pbmcgd2hlbiBwYXJzaW5nIGVuY29kaW5nL2V4ZWN1dGluZyBhIENoZXN0IEtleVxuICovXG5jbGFzcyBDaGVzdEtleVZhbGlkYXRpb25FcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdDaGVzdEtleVZhbGlkYXRpb25FcnJvcic7XG4gICAgfVxufVxuY2xhc3MgQ2hlc3RLZXlUb2tlbiBleHRlbmRzIFRva2VuIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWwsIGlkeCwgZmFjKSB7XG4gICAgICAgIHN1cGVyKHZhbCwgaWR4LCBmYWMpO1xuICAgICAgICB0aGlzLnZhbCA9IHZhbDtcbiAgICAgICAgdGhpcy5pZHggPSBpZHg7XG4gICAgICAgIHRoaXMuZmFjID0gZmFjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDaGVzdEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICB2YWxpZGF0ZSh2YWwpIHtcbiAgICAgICAgaWYgKC9eWzAtOWEtZkEtRl0qJC8udGVzdCh2YWwpICYmIHZhbC5sZW5ndGggJSAyID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IENoZXN0S2V5VmFsaWRhdGlvbkVycm9yKHZhbCwgdGhpcywgYEludmFsaWQgYnl0ZXM6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX1gKTtcbiAgICB9XG4gICAgY29udmVydFVpbnQ4QXJyYXlUb0hleFN0cmluZyh2YWwpIHtcbiAgICAgICAgcmV0dXJuIHZhbC5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSA/IEJ1ZmZlci5mcm9tKHZhbCkudG9TdHJpbmcoJ2hleCcpIDogdmFsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDaGVzdEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUoYXJncykge1xuICAgICAgICBsZXQgdmFsID0gYXJncy5wb3AoKTtcbiAgICAgICAgdmFsID0gdGhpcy5jb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nKHZhbCk7XG4gICAgICAgIHRoaXMudmFsaWRhdGUodmFsKTtcbiAgICAgICAgcmV0dXJuIHsgYnl0ZXM6IHZhbCB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBDaGVzdEtleVZhbGlkYXRpb25FcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QodmFsLCBzZW1hbnRpYykge1xuICAgICAgICB2YWwgPSB0aGlzLmNvbnZlcnRVaW50OEFycmF5VG9IZXhTdHJpbmcodmFsKTtcbiAgICAgICAgdGhpcy52YWxpZGF0ZSh2YWwpO1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbQ2hlc3RLZXlUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0NoZXN0S2V5VG9rZW4ucHJpbV0odmFsKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBieXRlczogdmFsIH07XG4gICAgfVxuICAgIEV4ZWN1dGUodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwuYnl0ZXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIENoZXN0S2V5VG9rZW4ucHJpbTtcbiAgICB9XG4gICAgZ2VuZXJhdGVTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBfX21pY2hlbHNvblR5cGU6IENoZXN0S2V5VG9rZW4ucHJpbSxcbiAgICAgICAgICAgIHNjaGVtYTogQ2hlc3RLZXlUb2tlbi5wcmltLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKENoZXN0S2V5VG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuQ2hlc3RLZXlUb2tlbi5wcmltID0gJ2NoZXN0X2tleSc7XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgaGFwcGVuaW5nIHdoZW4gcGFyc2luZyBlbmNvZGluZyBhIEdsb2JhbCBDb25zdGFudFxuICovXG5jbGFzcyBHbG9iYWxDb25zdGFudEVuY29kaW5nRXJyb3IgZXh0ZW5kcyBUb2tlblZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IodmFsdWUsIHRva2VuLCBtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKHZhbHVlLCB0b2tlbiwgbWVzc2FnZSk7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy50b2tlbiA9IHRva2VuO1xuICAgICAgICB0aGlzLm5hbWUgPSAnR2xvYmFsQ29uc3RhbnRFbmNvZGluZ0Vycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBmYWlsdXJlIGhhcHBlbmluZyB3aGVuIHBhcnNpbmcgZXhlY3V0aW5nIGEgR2xvYmFsIENvbnN0YW50XG4gKi9cbmNsYXNzIEdsb2JhbENvbnN0YW50RGVjb2RpbmdFcnJvciBleHRlbmRzIFRva2VuVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgdG9rZW4sIG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIodmFsdWUsIHRva2VuLCBtZXNzYWdlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLnRva2VuID0gdG9rZW47XG4gICAgICAgIHRoaXMubmFtZSA9ICdHbG9iYWxDb25zdGFudERlY29kaW5nRXJyb3InO1xuICAgIH1cbn1cbmNsYXNzIEdsb2JhbENvbnN0YW50VG9rZW4gZXh0ZW5kcyBUb2tlbiB7XG4gICAgY29uc3RydWN0b3IodmFsLCBpZHgsIGZhYykge1xuICAgICAgICBzdXBlcih2YWwsIGlkeCwgZmFjKTtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXMuaWR4ID0gaWR4O1xuICAgICAgICB0aGlzLmZhYyA9IGZhYztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgR2xvYmFsQ29uc3RhbnREZWNvZGluZ0Vycm9yfVxuICAgICAqL1xuICAgIEV4ZWN1dGUodmFsLCBzZW1hbnRpYykge1xuICAgICAgICBpZiAoc2VtYW50aWMgJiYgc2VtYW50aWNbR2xvYmFsQ29uc3RhbnRUb2tlbi5wcmltXSkge1xuICAgICAgICAgICAgcmV0dXJuIHNlbWFudGljW0dsb2JhbENvbnN0YW50VG9rZW4ucHJpbV0odmFsLCB0aGlzLnZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgR2xvYmFsQ29uc3RhbnREZWNvZGluZ0Vycm9yKHZhbCwgdGhpcywgYFVuYWJsZSB0byBkZWNvZGUgYSB2YWx1ZSByZXByZXNlbnRlZCBieSBhIGdsb2JhbCBjb25zdGFudHMuIFBsZWFzZSBwcm92aWRlIGFuIGV4cGFuZGVkIHNjcmlwdCB0byB0aGUgTWljaGVsc29uLUVuY29kZXIgb3Igc2VtYW50aWNzIGZvciB0aGUgZGVjb2RpbmcuIFRoZSBmb2xsb3dpbmcgZ2xvYmFsIGNvbnN0YW50IGhhc2ggd2FzIGVuY291bnRlcmVkOiAke3RoaXMudmFsLmFyZ3NbMF1bJ3N0cmluZyddfS5gKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBHbG9iYWxDb25zdGFudEVuY29kaW5nRXJyb3J9XG4gICAgICovXG4gICAgRW5jb2RlKGFyZ3MpIHtcbiAgICAgICAgdGhyb3cgbmV3IEdsb2JhbENvbnN0YW50RW5jb2RpbmdFcnJvcihhcmdzLCB0aGlzLCBgVW5hYmxlIHRvIGVuY29kZSBhIHNjcmlwdCBjb250YWluaW5nIGdsb2JhbCBjb25zdGFudHMuIFBsZWFzZSBwcm92aWRlIGFuIGV4cGFuZGVkIHNjcmlwdCB0byB0aGUgTWljaGVsc29uLUVuY29kZXIuIFRoZSBmb2xsb3dpbmcgZ2xvYmFsIGNvbnN0YW50IGhhc2ggd2FzIGVuY291bnRlcmVkOiAke3RoaXMudmFsLmFyZ3NbMF1bJ3N0cmluZyddfS5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHRocm93cyB7QGxpbmsgR2xvYmFsQ29uc3RhbnRFbmNvZGluZ0Vycm9yfVxuICAgICAqL1xuICAgIEVuY29kZU9iamVjdCh2YWwsIHNlbWFudGljKSB7XG4gICAgICAgIGlmIChzZW1hbnRpYyAmJiBzZW1hbnRpY1tHbG9iYWxDb25zdGFudFRva2VuLnByaW1dKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VtYW50aWNbR2xvYmFsQ29uc3RhbnRUb2tlbi5wcmltXSh2YWwpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBHbG9iYWxDb25zdGFudEVuY29kaW5nRXJyb3IodmFsLCB0aGlzLCBgVW5hYmxlIHRvIGVuY29kZSBhIHNjcmlwdCBjb250YWluaW5nIGdsb2JhbCBjb25zdGFudHMuIFBsZWFzZSBwcm92aWRlIGFuIGV4cGFuZGVkIHNjcmlwdCB0byB0aGUgTWljaGVsc29uLUVuY29kZXIuIFRoZSBmb2xsb3dpbmcgZ2xvYmFsIGNvbnN0YW50IGhhc2ggd2FzIGVuY291bnRlcmVkOiAke3RoaXMudmFsLmFyZ3NbMF1bJ3N0cmluZyddfS5gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRXh0cmFjdFNjaGVtYSBoYXMgYmVlbiBkZXByZWNhdGVkIGluIGZhdm9yIG9mIGdlbmVyYXRlU2NoZW1hXG4gICAgICpcbiAgICAgKi9cbiAgICBFeHRyYWN0U2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gR2xvYmFsQ29uc3RhbnRUb2tlbi5wcmltO1xuICAgIH1cbiAgICBnZW5lcmF0ZVNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIF9fbWljaGVsc29uVHlwZTogR2xvYmFsQ29uc3RhbnRUb2tlbi5wcmltLFxuICAgICAgICAgICAgc2NoZW1hOiB7XG4gICAgICAgICAgICAgICAgaGFzaDogdGhpcy52YWwuYXJnc1swXVsnc3RyaW5nJ10sXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmaW5kQW5kUmV0dXJuVG9rZW5zKHRva2VuVG9GaW5kLCB0b2tlbnMpIHtcbiAgICAgICAgaWYgKEdsb2JhbENvbnN0YW50VG9rZW4ucHJpbSA9PT0gdG9rZW5Ub0ZpbmQpIHtcbiAgICAgICAgICAgIHRva2Vucy5wdXNoKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgfVxufVxuR2xvYmFsQ29uc3RhbnRUb2tlbi5wcmltID0gJ2NvbnN0YW50JztcblxuY29uc3QgdG9rZW5zID0gW1xuICAgIFBhaXJUb2tlbixcbiAgICBOYXRUb2tlbixcbiAgICBTdHJpbmdUb2tlbixcbiAgICBCaWdNYXBUb2tlbixcbiAgICBBZGRyZXNzVG9rZW4sXG4gICAgTWFwVG9rZW4sXG4gICAgQm9vbFRva2VuLFxuICAgIE9yVG9rZW4sXG4gICAgQ29udHJhY3RUb2tlbixcbiAgICBMaXN0VG9rZW4sXG4gICAgTXV0ZXpUb2tlbixcbiAgICBCeXRlc1Rva2VuLFxuICAgIE9wdGlvblRva2VuLFxuICAgIFRpbWVzdGFtcFRva2VuLFxuICAgIEludFRva2VuLFxuICAgIFVuaXRUb2tlbixcbiAgICBLZXlUb2tlbixcbiAgICBLZXlIYXNoVG9rZW4sXG4gICAgU2lnbmF0dXJlVG9rZW4sXG4gICAgTGFtYmRhVG9rZW4sXG4gICAgT3BlcmF0aW9uVG9rZW4sXG4gICAgU2V0VG9rZW4sXG4gICAgQ2hhaW5JRFRva2VuLFxuICAgIFRpY2tldFRva2VuLFxuICAgIFRpY2tldERlcHJlY2F0ZWRUb2tlbixcbiAgICBOZXZlclRva2VuLFxuICAgIFNhcGxpbmdTdGF0ZVRva2VuLFxuICAgIFNhcGxpbmdUcmFuc2FjdGlvblRva2VuLFxuICAgIFNhcGxpbmdUcmFuc2FjdGlvbkRlcHJlY2F0ZWRUb2tlbixcbiAgICBCbHMxMjM4MWZyVG9rZW4sXG4gICAgQmxzMTIzODFnMVRva2VuLFxuICAgIEJsczEyMzgxZzJUb2tlbixcbiAgICBDaGVzdFRva2VuLFxuICAgIENoZXN0S2V5VG9rZW4sXG4gICAgR2xvYmFsQ29uc3RhbnRUb2tlbixcbl07XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIHNjcmlwdCBoYXZpbmcgYW4gaW52YWxpZCB0eXBlIG9yIGl0IGJlaW5nIHVuc3VwcG9ydGVkIGJ5IHRoZSBNaWNoZWxzb24gRW5jb2Rlci4gTm90ZSBzb21lIHByb3RvY29sIGNoYW5nZXMgbWlnaHQgYWZmZWN0IHRoaXMsIHdlIGVuY291cmFnZSB1c2VycyB0byBvcGVuIGFuIGlzc3VlIHNvIHdlIGNhbiBsb29rIGludG8gaW1wbGVtZW50aW5nIHN1cHBvcnQgZm9yIHNhaWQgdHlwZXMuXG4gKi9cbmNsYXNzIEludmFsaWRUb2tlbkVycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZCB0b2tlbiBlcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhIHRva2VuIGZyb20gYSB2YWx1ZVxuICogQHRocm93cyB7QGxpbmsgSW52YWxpZFRva2VuRXJyb3J9IElmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgTWljaGVsc29uIEVuY29kZXJcbiAqL1xuZnVuY3Rpb24gY3JlYXRlVG9rZW4odmFsLCBpZHgpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAgIHJldHVybiBuZXcgUGFpclRva2VuKHZhbCwgaWR4LCBjcmVhdGVUb2tlbik7XG4gICAgfVxuICAgIGNvbnN0IHQgPSB0b2tlbnMuZmluZCgoeCkgPT4geC5wcmltID09PSB2YWwucHJpbSk7XG4gICAgaWYgKCF0KSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkVG9rZW5FcnJvcihgTWFsZm9ybWVkIGRhdGE6ICR7SlNPTi5zdHJpbmdpZnkodmFsKX0uIEV4cGVjdGVkIGEgdmFsdWUgd2l0aCBhIHZhbGlkIHByaW0gcHJvcGVydHlgLCB2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IHQodmFsLCBpZHgsIGNyZWF0ZVRva2VuKTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSB3aGVuIGVuY29kaW5nICh0cmFuc2Zvcm1pbmcgSlMgcGFyYW1ldGVyIGludG8gSlNPTiBNaWNoZWxzb24pIHRoZSBwYXJhbWV0ZXIgb2YgdGhlIHZpZXdcbiAqL1xuY2xhc3MgUGFyYW1ldGVyRW5jb2RpbmdFcnJvciBleHRlbmRzIEludmFsaWRWaWV3UGFyYW1ldGVyRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHZpZXdOYW1lLCBzaWdzLCBhcmdzLCBjYXVzZSkge1xuICAgICAgICBzdXBlcih2aWV3TmFtZSwgc2lncywgYXJncywgY2F1c2UpO1xuICAgICAgICB0aGlzLnZpZXdOYW1lID0gdmlld05hbWU7XG4gICAgICAgIHRoaXMuc2lncyA9IHNpZ3M7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1BhcmFtZXRlckVuY29kaW5nRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgQ291bGQgbm90IGVuY29kZSBwYXJhbWV0ZXIgJHtKU09OLnN0cmluZ2lmeShhcmdzKX0gcmVjZWl2ZWQgZm9yIG5hbWUgXCIke3ZpZXdOYW1lfVwiIGV4cGVjdGluZyBvbmUgb2YgdGhlIGZvbGxvd2luZyBzaWduYXR1cmVzICR7SlNPTi5zdHJpbmdpZnkoc2lncyl9YDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBvbi1jaGFpbiB2aWV3IGZvdW5kIG9uIHRoZSBzY3JpcHRcbiAqL1xuY2xhc3MgSW52YWxpZFNjcmlwdEVycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihzY3JpcHQsIHJlYXNvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNjcmlwdCA9IHNjcmlwdDtcbiAgICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkU2NyaXB0RXJyb3InO1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBJbnZhbGlkIG9uLWNoYWluIHZpZXcgZm91bmQgaW4gdGhlIGZvbGxvd2luZyBzY3JpcHQuYDtcbiAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgbWVzc2FnZSArPSBgIFJlYXNvbjogJHtyZWFzb259LmA7XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZSArPSBgU2NyaXB0OiAke0pTT04uc3RyaW5naWZ5KHNjcmlwdCl9YDtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBSUEMgcmVzcG9uc2UgYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZFJwY1Jlc3BvbnNlRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHNjcmlwdCwgcmVhc29uKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2NyaXB0ID0gc2NyaXB0O1xuICAgICAgICB0aGlzLnJlYXNvbiA9IHJlYXNvbjtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRScGNSZXNwb25zZUVycm9yJztcbiAgICAgICAgbGV0IG1lc3NhZ2UgPSBgSW52YWxpZCBSUEMgcmVzcG9uc2UgcGFzc2VkIGFzIGFyZ3VtZW50KHMpLmA7XG4gICAgICAgIGlmIChyZWFzb24pIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gYCBSZWFzb246ICR7cmVhc29ufS5gO1xuICAgICAgICB9XG4gICAgICAgIG1lc3NhZ2UgKz0gYCBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeShzY3JpcHQpfWA7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGludmFsaWQgYmlnIG1hcCBzY2hlbWEgYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZEJpZ01hcFNjaGVtYUVycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEJpZ01hcFNjaGVtYUVycm9yJztcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBiaWcgbWFwIGRpZmYgYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZEJpZ01hcERpZmZFcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgdmFsdWUpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRCaWdNYXBEaWZmRXJyb3InO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgd2hlbiB0cnlpbmcgdG8gZW5jb2RlIGJpZyBtYXBzXG4gKi9cbmNsYXNzIEJpZ01hcEVuY29kaW5nRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgZGV0YWlscywgc2NoZW1hLCB2YWx1ZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQmlnTWFwRW5jb2RpbmdFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBVbmFibGUgdG8gZW5jb2RlIHRoZSBiaWcgbWFwICR7b2JqfS4gU2NoZW1hIGlzOiAke0pTT04uc3RyaW5naWZ5KHNjaGVtYSl9LiBUaGUgJHtvYmp9IGlzOiAke0pTT04uc3RyaW5naWZ5KHZhbHVlKX0uIEVycm9yIGRldGFpbHM6ICR7ZGV0YWlsc31gO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIGZhaWx1cmUgd2hlbiB0cnlpbmcgdG8gZW5jb2RlIHN0b3JhZ2VcbiAqL1xuY2xhc3MgU3RvcmFnZUVuY29kaW5nRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG9iaiwgZGV0YWlscywgc2NoZW1hLCB2YWx1ZSwgc2VtYW50aWNzKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuZGV0YWlscyA9IGRldGFpbHM7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gc2NoZW1hO1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgICAgIHRoaXMuc2VtYW50aWNzID0gc2VtYW50aWNzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnU3RvcmFnZUVuY29kaW5nRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgVW5hYmxlIHRvIGVuY29kZSAke29ian0uIFRoZSBzY2hlbWEgaXM6ICR7SlNPTi5zdHJpbmdpZnkoc2NoZW1hKX0sIHRoZSB2YWx1ZSBpczogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LiR7c2VtYW50aWNzID8gYEFuZCB0aGUgc2VtYW50aWMgaXM6ICR7SlNPTi5zdHJpbmdpZnkoc2VtYW50aWNzKX1gIDogJyd9LiBFcnJvciBkZXRhaWxzOiAke2RldGFpbHN9YDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gR2VuZXJhbCBlcnJvciB0aGF0IGluZGljYXRlcyBhIGZ1bmN0aW9uIG5vdCBiZWluZyBwYXNzZWQgYSBuZWNlc3NhcnkgYXJndW1lbnRcbiAqL1xuY2xhc3MgTWlzc2luZ0FyZ3VtZW50RXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdNaXNzaW5nQXJndW1lbnRFcnJvcic7XG4gICAgfVxufVxuXG52YXIgX2E7XG5jb25zdCBzY2hlbWFUeXBlU3ltYm9sID0gU3ltYm9sLmZvcigndGFxdWl0by1zY2hlbWEtdHlwZS1zeW1ib2wnKTtcbi8vIGNvbGxhcHNlIGNvbWIgcGFpclxuZnVuY3Rpb24gY29sbGFwc2UodmFsLCBwcmltID0gUGFpclRva2VuLnByaW0pIHtcbiAgICB2YXIgX2IsIF9jO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxhcHNlKHtcbiAgICAgICAgICAgIHByaW06IHByaW0sXG4gICAgICAgICAgICBhcmdzOiB2YWwsXG4gICAgICAgIH0sIHByaW0pO1xuICAgIH1cbiAgICBjb25zdCBleHRlbmRlZCA9IHZhbDtcbiAgICBpZiAoZXh0ZW5kZWQucHJpbSA9PT0gcHJpbSAmJiBleHRlbmRlZC5hcmdzICYmIGV4dGVuZGVkLmFyZ3MubGVuZ3RoID4gMikge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBleHRlbmRlZCksIHsgYXJnczogW1xuICAgICAgICAgICAgICAgIChfYiA9IGV4dGVuZGVkLmFyZ3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYlswXSxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHByaW06IHByaW0sXG4gICAgICAgICAgICAgICAgICAgIGFyZ3M6IChfYyA9IGV4dGVuZGVkLmFyZ3MpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zbGljZSgxKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkO1xufVxuZnVuY3Rpb24gZGVlcEVxdWFsKGEsIGIpIHtcbiAgICBpZiAoYSA9PT0gdW5kZWZpbmVkIHx8IGIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgY29uc3QgYWMgPSBjb2xsYXBzZShhKTtcbiAgICBjb25zdCBiYyA9IGNvbGxhcHNlKGIpO1xuICAgIHJldHVybiAoYWMucHJpbSA9PT0gYmMucHJpbSAmJlxuICAgICAgICAoKGFjLmFyZ3MgPT09IHVuZGVmaW5lZCAmJiBiYy5hcmdzID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAoYWMuYXJncyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgYmMuYXJncyAhPT0gdW5kZWZpbmVkICYmXG4gICAgICAgICAgICAgICAgYWMuYXJncy5sZW5ndGggPT09IGJjLmFyZ3MubGVuZ3RoICYmXG4gICAgICAgICAgICAgICAgYWMuYXJncy5ldmVyeSgodiwgaSkgPT4geyB2YXIgX2IsIF9jOyByZXR1cm4gZGVlcEVxdWFsKHYsIChfYyA9IChfYiA9IGJjLmFyZ3MpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYltpXSkgIT09IG51bGwgJiYgX2MgIT09IHZvaWQgMCA/IF9jIDoge30pOyB9KSkpICYmXG4gICAgICAgICgoYWMuYW5ub3RzID09PSB1bmRlZmluZWQgJiYgYmMuYW5ub3RzID09PSB1bmRlZmluZWQpIHx8XG4gICAgICAgICAgICAoYWMuYW5ub3RzICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICAgICBiYy5hbm5vdHMgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgIGFjLmFubm90cy5sZW5ndGggPT09IGJjLmFubm90cy5sZW5ndGggJiZcbiAgICAgICAgICAgICAgICBhYy5hbm5vdHMuZXZlcnkoKHYsIGkpID0+IHsgdmFyIF9iOyByZXR1cm4gdiA9PT0gKChfYiA9IGJjLmFubm90cykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iW2ldKTsgfSkpKSk7XG59XG4vKipcbiAqIEB3YXJuIE91ciBjdXJyZW50IHNtYXJ0IGNvbnRyYWN0IGFic3RyYWN0aW9uIGZlYXR1cmUgaXMgY3VycmVudGx5IGluIHByZXZpZXcuIEl0cyBBUEkgaXMgbm90IGZpbmFsLCBhbmQgaXQgbWF5IG5vdCBjb3ZlciBldmVyeSB1c2UgY2FzZSAoeWV0KS4gV2Ugd2lsbCBncmVhdGx5IGFwcHJlY2lhdGUgYW55IGZlZWRiYWNrIG9uIHRoaXMgZmVhdHVyZS5cbiAqL1xuY2xhc3MgU2NoZW1hIHtcbiAgICBzdGF0aWMgaXNTY2hlbWEob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgb2JqW3NjaGVtYVR5cGVTeW1ib2xdID09PSB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkUnBjUmVzcG9uc2VFcnJvcn1cbiAgICAgKi9cbiAgICBzdGF0aWMgZnJvbVJQQ1Jlc3BvbnNlKHZhbCkge1xuICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRScGNSZXNwb25zZUVycm9yKHZhbCwgJ3RoZSBSUEMgcmVzcG9uc2UgaXMgZW1wdHknKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXZhbC5zY3JpcHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUnBjUmVzcG9uc2VFcnJvcih2YWwsICd0aGUgUlBDIHJlc3BvbnNlIGhhcyBubyBzY3JpcHQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsLnNjcmlwdC5jb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRScGNSZXNwb25zZUVycm9yKHZhbCwgJ1RoZSByZXNwb25zZS5zY3JpcHQuY29kZSBzaG91bGQgYmUgYW4gYXJyYXknKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY29kZSA9IHZhbC5zY3JpcHQuY29kZTtcbiAgICAgICAgd2hpbGUgKGNvZGUubGVuZ3RoID09PSAxICYmIEFycmF5LmlzQXJyYXkoY29kZVswXSkpIHtcbiAgICAgICAgICAgIGNvZGUgPSBjb2RlWzBdO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHN0b3JhZ2UgPSBjb2RlLmZpbmQoKHgpID0+ICdwcmltJyBpbiB4ICYmIHgucHJpbSA9PT0gJ3N0b3JhZ2UnKTtcbiAgICAgICAgaWYgKCFzdG9yYWdlIHx8ICFBcnJheS5pc0FycmF5KHN0b3JhZ2UuYXJncykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUnBjUmVzcG9uc2VFcnJvcih2YWwsICdUaGUgcmVzcG9uc2Uuc2NyaXB0LmNvZGUgaGFzIGFuIGVsZW1lbnQgb2YgdHlwZSB7cHJpbTogXCJzdG9yYWdlXCJ9LCBidXQgaXRzIGFyZ3MgaXMgbm90IGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBTY2hlbWEoc3RvcmFnZS5hcmdzWzBdKTtcbiAgICB9XG4gICAgaXNFeHByZXNzaW9uRXh0ZW5kZWQodmFsKSB7XG4gICAgICAgIHJldHVybiAncHJpbScgaW4gdmFsICYmIEFycmF5LmlzQXJyYXkodmFsLmFyZ3MpO1xuICAgIH1cbiAgICBjb25zdHJ1Y3Rvcih2YWwpIHtcbiAgICAgICAgdGhpcy52YWwgPSB2YWw7XG4gICAgICAgIHRoaXNbX2FdID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yb290ID0gY3JlYXRlVG9rZW4odmFsLCAwKTtcbiAgICAgICAgaWYgKHRoaXMucm9vdCBpbnN0YW5jZW9mIEJpZ01hcFRva2VuKSB7XG4gICAgICAgICAgICB0aGlzLmJpZ01hcCA9IHRoaXMucm9vdDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLmlzRXhwcmVzc2lvbkV4dGVuZGVkKHZhbCkgJiYgdmFsLnByaW0gPT09ICdwYWlyJykge1xuICAgICAgICAgICAgY29uc3QgZXhwID0gdmFsLmFyZ3NbMF07XG4gICAgICAgICAgICBpZiAodGhpcy5pc0V4cHJlc3Npb25FeHRlbmRlZChleHApICYmIGV4cC5wcmltID09PSAnYmlnX21hcCcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJpZ01hcCA9IG5ldyBCaWdNYXBUb2tlbihleHAsIDAsIGNyZWF0ZVRva2VuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUb3BMZXZlbEFubm90YXRpb24ob2JqKSB7XG4gICAgICAgIC8vIFBhaXJUb2tlbiBhbmQgT3JUb2tlbiBjYW4gaGF2ZSByZWR1bmRhbnQgdG9wIGxldmVsIGFubm90YXRpb24gaW4gdGhlaXIgc3RvcmFnZVxuICAgICAgICBpZiAodGhpcy5yb290IGluc3RhbmNlb2YgUGFpclRva2VuIHx8IHRoaXMucm9vdCBpbnN0YW5jZW9mIE9yVG9rZW4pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJvb3QuaGFzQW5ub3RhdGlvbnMoKSAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmpbT2JqZWN0LmtleXMob2JqKVswXV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgRXhlY3V0ZSh2YWwsIHNlbWFudGljcykge1xuICAgICAgICBjb25zdCBzdG9yYWdlID0gdGhpcy5yb290LkV4ZWN1dGUodmFsLCBzZW1hbnRpY3MpO1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVUb3BMZXZlbEFubm90YXRpb24oc3RvcmFnZSk7XG4gICAgfVxuICAgIFR5cGVjaGVjayh2YWwpIHtcbiAgICAgICAgaWYgKHRoaXMucm9vdCBpbnN0YW5jZW9mIEJpZ01hcFRva2VuICYmIE51bWJlci5pc0ludGVnZXIoTnVtYmVyKHZhbCkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm9vdCBpbnN0YW5jZW9mIFRpY2tldFRva2VuICYmIHZhbC50aWNrZXRlciAmJiB2YWwudmFsdWUgJiYgdmFsLmFtb3VudCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJvb3QgaW5zdGFuY2VvZiBUaWNrZXREZXByZWNhdGVkVG9rZW4gJiYgdmFsLnRpY2tldGVyICYmIHZhbC52YWx1ZSAmJiB2YWwuYW1vdW50KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMucm9vdCBpbnN0YW5jZW9mIE1hcFRva2VuICYmIHRoaXMucm9vdC5WYWx1ZVNjaGVtYSBpbnN0YW5jZW9mIEJpZ01hcFRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yb290LkVuY29kZU9iamVjdCh2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkQmlnTWFwU2NoZW1hRXJyb3J9XG4gICAgICogQHRocm93cyB7QGxpbmsgSW52YWxpZEJpZ01hcERpZmZFcnJvcn1cbiAgICAgKi9cbiAgICBFeGVjdXRlT25CaWdNYXBEaWZmKGRpZmYsIHNlbWFudGljcykge1xuICAgICAgICBpZiAoIXRoaXMuYmlnTWFwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEJpZ01hcFNjaGVtYUVycm9yKCdCaWcgbWFwIHNjaGVtYSBpcyB1bmRlZmluZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZGlmZikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQmlnTWFwRGlmZkVycm9yKGBCaWcgbWFwIGRpZmYgbXVzdCBiZSBhbiBhcnJheSwgZ290OiAke0pTT04uc3RyaW5naWZ5KGRpZmYpfWAsIGRpZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsdEZvcm1hdCA9IGRpZmYubWFwKCh7IGtleSwgdmFsdWUgfSkgPT4gKHsgYXJnczogW2tleSwgdmFsdWVdIH0pKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYmlnTWFwLkV4ZWN1dGUoZWx0Rm9ybWF0LCBzZW1hbnRpY3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkQmlnTWFwU2NoZW1hRXJyb3J9XG4gICAgICovXG4gICAgRXhlY3V0ZU9uQmlnTWFwVmFsdWUoa2V5LCBzZW1hbnRpY3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLmJpZ01hcCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCaWdNYXBTY2hlbWFFcnJvcignQmlnIG1hcCBzY2hlbWEgaXMgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYmlnTWFwLlZhbHVlU2NoZW1hLkV4ZWN1dGUoa2V5LCBzZW1hbnRpY3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkQmlnTWFwU2NoZW1hRXJyb3J9XG4gICAgICogQHRocm93cyB7QGxpbmsgQmlnTWFwRW5jb2RpbmdFcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVCaWdNYXBLZXkoa2V5KSB7XG4gICAgICAgIGlmICghdGhpcy5iaWdNYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQmlnTWFwU2NoZW1hRXJyb3IoJ0JpZyBtYXAgc2NoZW1hIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5iaWdNYXAuS2V5U2NoZW1hLlRvQmlnTWFwS2V5KGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQmlnTWFwRW5jb2RpbmdFcnJvcigna2V5JywgZXgsIHRoaXMuYmlnTWFwLktleVNjaGVtYSwga2V5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBUb2tlblZhbGlkYXRpb25FcnJvcn1cbiAgICAgKiBAdGhyb3dzIHtAbGluayBTdG9yYWdlRW5jb2RpbmdFcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGUodmFsdWUsIHNlbWFudGljcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5FbmNvZGVPYmplY3QodmFsdWUsIHNlbWFudGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBUb2tlblZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFN0b3JhZ2VFbmNvZGluZ0Vycm9yKCdzdG9yYWdlIG9iamVjdCcsIGV4LCB0aGlzLnJvb3QsIHZhbHVlLCBzZW1hbnRpY3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIEV4dHJhY3RTY2hlbWEgaGFzIGJlZW4gZGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZW5lcmF0ZVNjaGVtYVxuICAgICAqXG4gICAgICovXG4gICAgRXh0cmFjdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlVG9wTGV2ZWxBbm5vdGF0aW9uKHRoaXMucm9vdC5FeHRyYWN0U2NoZW1hKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUHJvZHVjZSBhIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBzdG9yYWdlIHNjaGVtYS5cbiAgICAgKiBOb3RlOiBQcm92aWRlIGd1aWRhbmNlIG9uIGhvdyB0byB3cml0ZSB0aGUgc3RvcmFnZSBvYmplY3QgZm9yIHRoZSBvcmlnaW5hdGlvbiBvcGVyYXRpb24gd2l0aCBUYXF1aXRvLlxuICAgICAqL1xuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmVUb3BMZXZlbEFubm90YXRpb24odGhpcy5yb290LmdlbmVyYXRlU2NoZW1hKCkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEludmFsaWRCaWdNYXBTY2hlbWFFcnJvcn1cbiAgICAgKi9cbiAgICBDb21wdXRlU3RhdGUodHgsIHN0YXRlKSB7XG4gICAgICAgIGlmICghdGhpcy5iaWdNYXApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQmlnTWFwU2NoZW1hRXJyb3IoJ0JpZyBtYXAgc2NoZW1hIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJpZ01hcCA9IHR4LnJlZHVjZSgocHJldiwgY3VycmVudCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcHJldiksIHRoaXMuRXhlY3V0ZU9uQmlnTWFwRGlmZihjdXJyZW50LmNvbnRlbnRzWzBdLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQuYmlnX21hcF9kaWZmKSk7XG4gICAgICAgIH0sIHt9KTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5FeGVjdXRlKHN0YXRlKSksIHsgW3RoaXMuYmlnTWFwLmFubm90KCldOiBiaWdNYXAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBMb29rIHVwIGluIHRvcC1sZXZlbCBwYWlycyBvZiB0aGUgc3RvcmFnZSB0byBmaW5kIGEgdmFsdWUgbWF0Y2hpbmcgdGhlIHNwZWNpZmllZCB0eXBlXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBUaGUgZmlyc3QgdmFsdWUgZm91bmQgdGhhdCBtYXRjaCB0aGUgdHlwZSBvciBgdW5kZWZpbmVkYCBpZiBubyB2YWx1ZSBpcyBmb3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHN0b3JhZ2Ugc3RvcmFnZSB0byBwYXJzZSB0byBmaW5kIHRoZSB2YWx1ZVxuICAgICAqIEBwYXJhbSB2YWx1ZVR5cGUgdHlwZSBvZiB2YWx1ZSB0byBsb29rIGZvclxuICAgICAqXG4gICAgICovXG4gICAgRmluZEZpcnN0SW5Ub3BMZXZlbFBhaXIoc3RvcmFnZSwgdmFsdWVUeXBlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmRWYWx1ZSh0aGlzLnJvb3RbJ3ZhbCddLCBzdG9yYWdlLCB2YWx1ZVR5cGUpO1xuICAgIH1cbiAgICAvLyBUT0RPIGNoZWNrIHRoZXNlIHR5cGUgY2FzdHNcbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBNaXNzaW5nQXJndW1lbnRFcnJvcn1cbiAgICAgKi9cbiAgICBmaW5kVmFsdWUoc2NoZW1hLCBzdG9yYWdlLCB2YWx1ZVRvRmluZCkge1xuICAgICAgICBpZiAoZGVlcEVxdWFsKHZhbHVlVG9GaW5kLCBzY2hlbWEpKSB7XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzY2hlbWEpIHx8IHNjaGVtYS5wcmltID09PSAncGFpcicpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjaCA9IGNvbGxhcHNlKHNjaGVtYSk7XG4gICAgICAgICAgICBjb25zdCBzdHJnID0gY29sbGFwc2Uoc3RvcmFnZSwgJ1BhaXInKTtcbiAgICAgICAgICAgIGlmIChzY2guYXJncyA9PT0gdW5kZWZpbmVkIHx8IHN0cmcuYXJncyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE1pc3NpbmdBcmd1bWVudEVycm9yKCdUb2tlbnMgaGF2ZSBubyBhcmd1bWVudHMnKTsgLy8gdW5saWtlbHlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzY2guYXJnc1swXSlcbiAgICAgICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICAgIC8vIHVuc2FmZVxuICAgICAgICAgICAgICAgIHRoaXMuZmluZFZhbHVlKHNjaC5hcmdzWzBdLCBzdHJnLmFyZ3NbMF0sIHZhbHVlVG9GaW5kKSB8fFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbmRWYWx1ZShzY2guYXJnc1sxXSwgc3RyZy5hcmdzWzFdLCB2YWx1ZVRvRmluZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBMb29rIHVwIHRoZSBzY2hlbWEgdG8gZmluZCBhbnkgb2NjdXJyZW5jZSBvZiBhIHBhcnRpY3VsYXIgdG9rZW4uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBhbiBhcnJheSBvZiB0b2tlbnMgb2YgdGhlIHNwZWNpZmllZCBraW5kIG9yIGFuIGVtcHR5IGFycmF5IGlmIG5vIHRva2VuIHdhcyBmb3VuZFxuICAgICAqXG4gICAgICogQHBhcmFtIHRva2VuVG9GaW5kIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHByaW0gcHJvcGVydHkgb2YgdGhlIHRva2VuIHRvIGZpbmRcbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgXG4gICAgICogVXNlZnVsIHRvIGZpbmQgYWxsIGdsb2JhbCBjb25zdGFudHMgaW4gYSBzY3JpcHQsIGFuIGFycmF5IG9mIEdsb2JhbENvbnN0YW50VG9rZW4gaXMgcmV0dXJuZWQ6XG4gICAgICpcbiAgICAgKiBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKHNjcmlwdCk7XG4gICAgICogY29uc3QgYWxsR2xvYmFsQ29uc3RhbnRUb2tlbnMgPSBzY2hlbWEuZmluZFRva2VuKCdjb25zdGFudCcpO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICovXG4gICAgZmluZFRva2VuKHRva2VuVG9GaW5kKSB7XG4gICAgICAgIGNvbnN0IHRva2VucyA9IFtdO1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmZpbmRBbmRSZXR1cm5Ub2tlbnModG9rZW5Ub0ZpbmQsIHRva2Vucyk7XG4gICAgfVxufVxuX2EgPSBzY2hlbWFUeXBlU3ltYm9sO1xuXG4vKipcbiAqIEB3YXJuIE91ciBjdXJyZW50IHNtYXJ0IGNvbnRyYWN0IGFic3RyYWN0aW9uIGZlYXR1cmUgaXMgY3VycmVudGx5IGluIHByZXZpZXcuIEl0J3MgQVBJIGlzIG5vdCBmaW5hbCwgYW5kIGl0IG1heSBub3QgY292ZXIgZXZlcnkgdXNlIGNhc2UgKHlldCkuIFdlIHdpbGwgZ3JlYXRseSBhcHByZWNpYXRlIGFueSBmZWVkYmFjayBvbiB0aGlzIGZlYXR1cmUuXG4gKi9cbmNsYXNzIFBhcmFtZXRlclNjaGVtYSB7XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGFuIGluc3RhbmNlIG9mIFBhcmFtZXRlclNjaGVtYSBmcm9tIGEgY29udHJhY3Qgc2NyaXB0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsIGNvbnRyYWN0IHNjcmlwdCBvYnRhaW5lZCBmcm9tIHRoZSBSUENcbiAgICAgKiBAcmV0dXJucyBQYXJhbWV0ZXJTY2hlbWFcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkUnBjUmVzcG9uc2VFcnJvcn0gSWYgdGhlIFJQQyByZXNwb25zZSBpcyBpbnZhbGlkXG4gICAgICovXG4gICAgc3RhdGljIGZyb21SUENSZXNwb25zZSh2YWwpIHtcbiAgICAgICAgaWYgKCF2YWwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUnBjUmVzcG9uc2VFcnJvcih2YWwsICd0aGUgUlBDIHJlc3BvbnNlIGlzIGVtcHR5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWwuc2NyaXB0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFJwY1Jlc3BvbnNlRXJyb3IodmFsLCAndGhlIFJQQyByZXNwb25zZSBoYXMgbm8gc2NyaXB0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbC5zY3JpcHQuY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkUnBjUmVzcG9uc2VFcnJvcih2YWwsICdUaGUgcmVzcG9uc2Uuc2NyaXB0LmNvZGUgc2hvdWxkIGJlIGFuIGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1ldGVyID0gdmFsLnNjcmlwdC5jb2RlLmZpbmQoKHgpID0+ICdwcmltJyBpbiB4ICYmIHgucHJpbSA9PT0gJ3BhcmFtZXRlcicpO1xuICAgICAgICBpZiAoIXBhcmFtZXRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRScGNSZXNwb25zZUVycm9yKHZhbCwgYFRoZSByZXNwb25zZS5zY3JpcHQuY29kZSBzaG91bGQgaGF2ZSBhbiBlbGVtZW50IG9mIHR5cGUge3ByaW06IFwicGFyYW1ldGVyXCJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtZXRlci5hcmdzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRScGNSZXNwb25zZUVycm9yKHZhbCwgYFRoZSByZXNwb25zZS5zY3JpcHQuY29kZSBoYXMgYW4gZWxlbWVudCBvZiB0eXBlIHtwcmltOiBcInBhcmFtZXRlclwifSwgYnV0IGl0cyBhcmdzIGlzIG5vdCBhbiBhcnJheWApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1ldGVyU2NoZW1hKHBhcmFtZXRlci5hcmdzWzBdKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIENoZWNrIGlmIHRoZSBDb250cmFjdCBwYXJhbWV0ZXIgaXMgbXVsdGlwbGUgZW50cnkgcG9pbnQgb3Igbm90XG4gICAgICovXG4gICAgZ2V0IGlzTXVsdGlwbGVFbnRyeVBvaW50KCkge1xuICAgICAgICByZXR1cm4gKHRoaXMucm9vdCBpbnN0YW5jZW9mIE9yVG9rZW4gfHxcbiAgICAgICAgICAgICh0aGlzLnJvb3QgaW5zdGFuY2VvZiBPcHRpb25Ub2tlbiAmJiB0aGlzLnJvb3Quc3ViVG9rZW4oKSBpbnN0YW5jZW9mIE9yVG9rZW4pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIENoZWNrIGlmIHRoZSBDb250cmFjdCBwYXJhbWV0ZXIgaGFzIGFuIGFubm90YXRpb24gb3Igbm90XG4gICAgICovXG4gICAgZ2V0IGhhc0Fubm90YXRpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTXVsdGlwbGVFbnRyeVBvaW50KSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5FeHRyYWN0U2NoZW1hKCkpWzBdICE9PSAnMCc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIHRoZSBzY2hlbWEgb2YgdGhlIHBhcmFtZXRlciBvZiBhIHNwZWNpZmljIGVudHJ5IHBvaW50XG4gICAgICogQHRocm93cyB7QGxpbmsgSW52YWxpZFRva2VuRXJyb3J9XG4gICAgICovXG4gICAgY29uc3RydWN0b3IodmFsKSB7XG4gICAgICAgIHRoaXMucm9vdCA9IGNyZWF0ZVRva2VuKHZhbCwgMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBqYXZhc2NyaXB0IG9iamVjdCBlcXVpdmFsZW50IG9mIHRoZSBNaWNoZWxpbmUgdmFsdWUgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBFeGVjdXRlKHZhbCwgc2VtYW50aWNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuRXhlY3V0ZSh2YWwsIHNlbWFudGljcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIGEgbWljaGVsaW5lIGZvcm1hdHRlZCBvYmplY3QgZm9yIHRoZSB2YWx1ZXMgcHJvdmlkZWRcbiAgICAgKiBAdGhyb3dzIHtAbGluayBUb2tlblZhbGlkYXRpb25FcnJvcn1cbiAgICAgKiBAdGhyb3dzIHtAbGluayBQYXJhbWV0ZXJFbmNvZGluZ0Vycm9yfVxuICAgICAqL1xuICAgIEVuY29kZSguLi5hcmdzKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290LkVuY29kZShhcmdzLnJldmVyc2UoKSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBUb2tlblZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcmFtZXRlckVuY29kaW5nRXJyb3IoJ1VuYWJsZSB0byBlbmNvZGUgcGFyYW1ldGVyJywgdGhpcy5yb290LCBhcmdzLCBleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgYSBtaWNoZWxpbmUgZm9ybWF0dGVkIG9iamVjdCBmb3IgdGhlIGphdmFzY3JpcHQgb2JqZWN0IHByb3ZpZGVkXG4gICAgICogQHRocm93cyB7QGxpbmsgVG9rZW5WYWxpZGF0aW9uRXJyb3J9XG4gICAgICogQHRocm93cyB7QGxpbmsgUGFyYW1ldGVyRW5jb2RpbmdFcnJvcn1cbiAgICAgKi9cbiAgICBFbmNvZGVPYmplY3QodmFsdWUsIHNlbWFudGljcykge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucm9vdC5FbmNvZGVPYmplY3QodmFsdWUsIHNlbWFudGljcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBUb2tlblZhbGlkYXRpb25FcnJvcikge1xuICAgICAgICAgICAgICAgIHRocm93IGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IFBhcmFtZXRlckVuY29kaW5nRXJyb3IoJ1VuYWJsZSB0byBlbmNvZGUgcGFyYW1ldGVyIG9iamVjdCcsIHRoaXMucm9vdCwgdmFsdWUsIGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBFeHRyYWN0U2NoZW1hIGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2VuZXJhdGVTY2hlbWFcbiAgICAgKlxuICAgICAqL1xuICAgIEV4dHJhY3RTY2hlbWEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3QuRXh0cmFjdFNjaGVtYSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUHJvZHVjZSBhIHNjaGVtYSBncm91cGluZyB0b2dldGhlciBhbGwgdGhlIGVudHJ5IHBvaW50cyBvZiBhIGNvbnRyYWN0LlxuICAgICAqL1xuICAgIGdlbmVyYXRlU2NoZW1hKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LmdlbmVyYXRlU2NoZW1hKCk7XG4gICAgfVxuICAgIEV4dHJhY3RTaWduYXR1cmVzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290LkV4dHJhY3RTaWduYXR1cmUoKTtcbiAgICB9XG59XG5cbmNsYXNzIFZpZXdTY2hlbWEge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBWaWV3U2NoZW1hIGZvciBlYWNoIHZpZXcgaW4gYSBzY3JpcHRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgY29udHJhY3Qgc2NyaXB0IG9idGFpbmVkIGZyb20gdGhlIFJQQ1xuICAgICAqIEByZXR1cm5zIGFycmF5IG9mIFZpZXdTY2hlbWEgb3IgZW1wdHkgYXJyYXkgaWYgdGhlcmUgaXMgbm8gdmlldyBpbiB0aGUgY29udHJhY3RcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkU2NyaXB0RXJyb3J9XG4gICAgICovXG4gICAgc3RhdGljIGZyb21SUENSZXNwb25zZSh2YWwpIHtcbiAgICAgICAgY29uc3QgYWxsVmlld1NjaGVtYSA9IFtdO1xuICAgICAgICBjb25zdCB2aWV3cyA9IHZhbCAmJlxuICAgICAgICAgICAgdmFsLnNjcmlwdCAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh2YWwuc2NyaXB0LmNvZGUpICYmXG4gICAgICAgICAgICB2YWwuc2NyaXB0LmNvZGUuZmlsdGVyKCh4KSA9PiB4LnByaW0gPT09ICd2aWV3Jyk7XG4gICAgICAgIGlmICh2aWV3cykge1xuICAgICAgICAgICAgdmlld3MuZm9yRWFjaCgodmlldykgPT4ge1xuICAgICAgICAgICAgICAgIGFsbFZpZXdTY2hlbWEucHVzaChuZXcgVmlld1NjaGVtYSh2aWV3LmFyZ3MpKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbGxWaWV3U2NoZW1hO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkU2NyaXB0RXJyb3J9XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iodmlld0FyZ3MpIHtcbiAgICAgICAgaWYgKCF2aWV3QXJncykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRTY3JpcHRFcnJvcih2aWV3QXJncywgJ3RoZSBhcmdzIGFyZSBub3QgZGVmaW5lZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2aWV3QXJncy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkU2NyaXB0RXJyb3Iodmlld0FyZ3MsIGB0aGVyZSBzaG91bGQgYmUgZXhhY3RseSA0IGFyZ3VtZW50c2ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICghKCdzdHJpbmcnIGluIHZpZXdBcmdzWzBdKSB8fCAhdmlld0FyZ3NbMF1bJ3N0cmluZyddKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNjcmlwdEVycm9yKHZpZXdBcmdzLCBgVGhlIGZpcnN0IGFyZ3VtZW50IHNob3VsZCBiZSBhIHN0cmluZywgcmVwcmVzZW50aW5nIHRoZSB2aWV3IG5hbWUuIEl0IHNob3VsZCBiZSBpbiB0aGUgZm9ybTogeyBzdHJpbmc6ICd2aWV3TmFtZScgfWApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudmlld05hbWUgPSB2aWV3QXJnc1swXVsnc3RyaW5nJ107XG4gICAgICAgIHRoaXMudmlld0FyZ3NUeXBlID0gdmlld0FyZ3NbMV07XG4gICAgICAgIHRoaXMudmlld1JldHVyblR5cGUgPSB2aWV3QXJnc1syXTtcbiAgICAgICAgdGhpcy5pbnN0cnVjdGlvbnMgPSB2aWV3QXJnc1szXTtcbiAgICAgICAgdGhpcy5yb290QXJnc1R5cGUgPSBjcmVhdGVUb2tlbih0aGlzLnZpZXdBcmdzVHlwZSwgMCk7XG4gICAgICAgIHRoaXMucm9vdFJldHVyblR5cGUgPSBjcmVhdGVUb2tlbih0aGlzLnZpZXdSZXR1cm5UeXBlLCAwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gVHJhbnNmb3JtIHRoZSB2aWV3IHBhcmFtZXRlciBpbnRvIE1pY2hlbHNvblxuICAgICAqXG4gICAgICogQHBhcmFtIGFyZ3MgcGFyYW1ldGVyIG9mIHRoZSB2aWV3IGluIGpzIGZvcm1hdFxuICAgICAqIEByZXR1cm5zIHBhcmFtZXRlciBvZiB0aGUgdmlldyBpbiBNaWNoZWxzb25cbiAgICAgKiBAdGhyb3dzIHtAbGluayBQYXJhbWV0ZXJFbmNvZGluZ0Vycm9yfVxuICAgICAqL1xuICAgIGVuY29kZVZpZXdBcmdzKGFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJvb3RBcmdzVHlwZS5FbmNvZGVPYmplY3QoYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUGFyYW1ldGVyRW5jb2RpbmdFcnJvcih0aGlzLnZpZXdOYW1lLCB1bmRlZmluZWQsIGFyZ3MsIGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBUcmFuc2Zvcm0gdGhlIHZpZXcgcmVzdWx0IGZyb20gTWljaGVsc29uIHRvIHJlYWRhYmxlIGRhdGFcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWwgcmVzdWx0IG9mIHRoZSB2aWV3IGluIEpTT04gTWljaGVsc29uXG4gICAgICogQHBhcmFtIHNlbWFudGljcyBvcHRpb25hbCBzZW1hbnRpY3MgdG8gb3ZlcnJpZGUgdGhlIGRlZmF1bHQgZGVjb2RpbmcgYmVoYXZpb3JcbiAgICAgKiBAcmV0dXJucyByZXN1bHQgb2YgdGhlIHZpZXcgaW4gYSByZWFkYWJsZSBmb3JtYXRcbiAgICAgKi9cbiAgICBkZWNvZGVWaWV3UmVzdWx0KHZhbCwgc2VtYW50aWNzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvb3RSZXR1cm5UeXBlLkV4ZWN1dGUodmFsLCBzZW1hbnRpY3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gdGhlIHNpZ25hdHVyZSBvZiB0aGUgdmlldyBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBleHRyYWN0QXJnc1NjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdEFyZ3NUeXBlLkV4dHJhY3RTY2hlbWEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIHRoZSBmb3JtYXQgb2YgdGhlIHZpZXcgcmVzdWx0XG4gICAgICovXG4gICAgZXh0cmFjdFJlc3VsdFNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm9vdFJldHVyblR5cGUuRXh0cmFjdFNjaGVtYSgpO1xuICAgIH1cbn1cblxuY2xhc3MgRXZlbnRTY2hlbWEge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgdHlwZSkge1xuICAgICAgICB0aGlzLnRhZyA9IHRhZztcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NaWNoZWxpbmVWYWx1ZSh2YWwpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudFNjaGVtYSgoX2EgPSB2YWwuYW5ub3RzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FbMF0sIChfYiA9IHZhbC5hcmdzKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2JbMF0pO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVJQQ1Jlc3BvbnNlKHZhbCkge1xuICAgICAgICBjb25zdCBhbGxFdmVudFNjaGVtYSA9IFtdO1xuICAgICAgICB2YWwuc2NyaXB0LmNvZGUuZm9yRWFjaCgoY29kZSkgPT4ge1xuICAgICAgICAgICAgaWYgKCEoJ3ByaW0nIGluIGNvZGUpIHx8XG4gICAgICAgICAgICAgICAgY29kZS5wcmltICE9PSAnY29kZScgfHxcbiAgICAgICAgICAgICAgICAhKCdhcmdzJyBpbiBjb2RlKSB8fFxuICAgICAgICAgICAgICAgICFjb2RlLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhbGxFdmVudFNjaGVtYS5wdXNoKC4uLkV2ZW50U2NoZW1hLmV4dHJhY3RFdmVudHNSZWN1cnNpdmVseShjb2RlLmFyZ3MpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBFdmVudFNjaGVtYS5yZW1vdmVEdXBsaWNhdGVzKGFsbEV2ZW50U2NoZW1hKTtcbiAgICB9XG4gICAgc3RhdGljIHJlbW92ZUR1cGxpY2F0ZXMoZXZlbnRzKSB7XG4gICAgICAgIGNvbnN0IHVuaXF1ZUV2ZW50cyA9IFtdO1xuICAgICAgICBldmVudHMuZm9yRWFjaCgoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlkeCA9IHVuaXF1ZUV2ZW50cy5maW5kSW5kZXgoKGUpID0+IGUudGFnID09PSBldmVudC50YWcgJiYgZGVlcEVxdWFsKGUudHlwZSwgZXZlbnQudHlwZSkpO1xuICAgICAgICAgICAgaWYgKGlkeCA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICB1bmlxdWVFdmVudHMucHVzaChldmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdW5pcXVlRXZlbnRzO1xuICAgIH1cbiAgICBzdGF0aWMgZXh0cmFjdEV2ZW50c1JlY3Vyc2l2ZWx5KGNvZGUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY29kZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlLmZsYXRNYXAoKGMpID0+IEV2ZW50U2NoZW1hLmV4dHJhY3RFdmVudHNSZWN1cnNpdmVseShjKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ3ByaW0nIGluIGNvZGUpKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvZGUucHJpbSA9PT0gJ0VNSVQnKSB7XG4gICAgICAgICAgICByZXR1cm4gW0V2ZW50U2NoZW1hLmZyb21NaWNoZWxpbmVWYWx1ZShjb2RlKV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoJ2FyZ3MnIGluIGNvZGUpIHx8ICFjb2RlLmFyZ3MpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29kZS5hcmdzLmZsYXRNYXAoKGMpID0+IEV2ZW50U2NoZW1hLmV4dHJhY3RFdmVudHNSZWN1cnNpdmVseShjKSk7XG4gICAgfVxufVxuXG4vLyBJTVBPUlRBTlQ6IFRISVMgRklMRSBJUyBBVVRPIEdFTkVSQVRFRCEgRE8gTk9UIE1BTlVBTExZIEVESVQgT1IgQ0hFQ0tJTiFcbmNvbnN0IFZFUlNJT04gPSB7XG4gICAgXCJjb21taXRIYXNoXCI6IFwiMTNhMTJhYjdjZjQ0MjA0MzUyNjc0NWRiMmJiZjRlZjNiMDg5YzM0YVwiLFxuICAgIFwidmVyc2lvblwiOiBcIjE5LjAuMlwiXG59O1xuXG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBAdGFxdWl0by9taWNoZWxzb24tZW5jb2RlclxuICovXG5jb25zdCBVbml0VmFsdWUgPSBTeW1ib2woKTtcbmNvbnN0IFNhcGxpbmdTdGF0ZVZhbHVlID0ge307XG5cbmV4cG9ydCB7IEFkZHJlc3NWYWxpZGF0aW9uRXJyb3IsIEJpZ01hcEVuY29kaW5nRXJyb3IsIEJpZ01hcFZhbGlkYXRpb25FcnJvciwgQnl0ZXNWYWxpZGF0aW9uRXJyb3IsIENoYWluSURWYWxpZGF0aW9uRXJyb3IsIENvbnRyYWN0VmFsaWRhdGlvbkVycm9yLCBFbmNvZGVUaWNrZXRFcnJvciwgRXZlbnRTY2hlbWEsIEludFZhbGlkYXRpb25FcnJvciwgSW52YWxpZEJpZ01hcERpZmZFcnJvciwgSW52YWxpZEJpZ01hcFNjaGVtYUVycm9yLCBJbnZhbGlkTWFwVHlwZUVycm9yLCBJbnZhbGlkUnBjUmVzcG9uc2VFcnJvciwgSW52YWxpZFNjcmlwdEVycm9yLCBLZXlIYXNoVmFsaWRhdGlvbkVycm9yLCBLZXlWYWxpZGF0aW9uRXJyb3IsIExpc3RWYWxpZGF0aW9uRXJyb3IsIE1hcFR5cGVjaGVja0Vycm9yLCBNYXBWYWxpZGF0aW9uRXJyb3IsIE1pY2hlbHNvbk1hcCwgTWlzc2luZ0FyZ3VtZW50RXJyb3IsIE11dGV6VmFsaWRhdGlvbkVycm9yLCBOYXRWYWxpZGF0aW9uRXJyb3IsIE9yVmFsaWRhdGlvbkVycm9yLCBQYXJhbWV0ZXJFbmNvZGluZ0Vycm9yLCBQYXJhbWV0ZXJTY2hlbWEsIFNhcGxpbmdTdGF0ZVZhbHVlLCBTY2hlbWEsIFNldFZhbGlkYXRpb25FcnJvciwgU2lnbmF0dXJlVmFsaWRhdGlvbkVycm9yLCBTdG9yYWdlRW5jb2RpbmdFcnJvciwgVG9rZW4sIFRva2VuQXJndW1lbnRWYWxpZGF0aW9uRXJyb3IsIFRva2VuQ29tcGFyaXNvbkVycm9yLCBVbml0VmFsdWUsIFZFUlNJT04sIFZpZXdTY2hlbWEsIGRlZXBFcXVhbCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFxdWl0by1taWNoZWxzb24tZW5jb2Rlci5lczYuanMubWFwXG4iXSwibmFtZXMiOlsic3RyaW5naWZ5IiwiVGFxdWl0b0Vycm9yIiwiSW52YWxpZFZpZXdQYXJhbWV0ZXJFcnJvciIsIkJpZ051bWJlciIsImI1OGRlY29kZSIsInZhbGlkYXRlQWRkcmVzcyIsIlZhbGlkYXRpb25SZXN1bHQiLCJlbmNvZGVQdWJLZXkiLCJzdHJpcEhleFByZWZpeCIsImVuY29kZUtleSIsInZhbGlkYXRlUHVibGljS2V5IiwiUHJlZml4IiwiYjU4Y2RlY29kZSIsInByZWZpeCIsImVuY29kZUtleUhhc2giLCJ2YWxpZGF0ZUtleUhhc2giLCJ2YWxpZGF0ZVNpZ25hdHVyZSIsInZhbGlkYXRlQ2hhaW4iLCJfYSQxIiwiSW52YWxpZE1hcFR5cGVFcnJvciIsImNvbnN0cnVjdG9yIiwibWFwVHlwZSIsInJlYXNvbiIsIm1lc3NhZ2UiLCJKU09OIiwibmFtZSIsIm1pY2hlbHNvbk1hcFR5cGVTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJ2YWxpZGF0ZU1hcFR5cGUiLCJ2YWx1ZSIsImluY2x1ZGVzIiwicHJpbSIsIkFycmF5IiwiaXNBcnJheSIsImFyZ3MiLCJsZW5ndGgiLCJNYXBUeXBlY2hlY2tFcnJvciIsInR5cGUiLCJvYmplY3RUeXBlIiwiTWljaGVsc29uTWFwIiwiaXNNaWNoZWxzb25NYXAiLCJvYmoiLCJ2YWx1ZU1hcCIsIk1hcCIsImtleU1hcCIsInNldFR5cGUiLCJrZXlTY2hlbWEiLCJTY2hlbWEiLCJ2YWx1ZVNjaGVtYSIsInJlbW92ZVR5cGUiLCJ1bmRlZmluZWQiLCJmcm9tTGl0ZXJhbCIsIm1hcCIsIk9iamVjdCIsImtleXMiLCJmb3JFYWNoIiwia2V5Iiwic2V0IiwidHlwZWNoZWNrS2V5IiwiVHlwZWNoZWNrIiwidHlwZWNoZWNrVmFsdWUiLCJhc3NlcnRUeXBlY2hlY2tWYWx1ZSIsImUiLCJhc3NlcnRUeXBlY2hlY2tLZXkiLCJzZXJpYWxpemVEZXRlcm1pbmlzdGljYWxseSIsImVudHJpZXMiLCJ2YWx1ZXMiLCJnZXQiLCJzdHJLZXkiLCJkZWxldGUiLCJoYXMiLCJjbGVhciIsInNpemUiLCJjYiIsIlRva2VuVmFsaWRhdGlvbkVycm9yIiwidG9rZW4iLCJiYXNlTWVzc2FnZSIsImFubm90IiwiYW5ub3RUZXh0IiwiVG9rZW4iLCJ2YWwiLCJpZHgiLCJmYWMiLCJjcmVhdGVUb2tlbiIsInR5cGVXaXRob3V0QW5ub3RhdGlvbnMiLCJoYW5kbGVNaWNoZWxzb25FeHByZXNzaW9uIiwiYXJyYXkiLCJpdGVtIiwiZXh0ZW5kZWQiLCJ4IiwiaGFuZGxlTWljaGVsc29uRXh0ZW5kZWQiLCJhbm5vdHMiLCJTdHJpbmciLCJyZXBsYWNlIiwiaGFzQW5ub3RhdGlvbnMiLCJ0b2tlblZhbCIsIkV4dHJhY3RTaWduYXR1cmUiLCJFeHRyYWN0U2NoZW1hIiwiQ29tcGFyYWJsZVRva2VuIiwiY29tcGFyZSIsIm8xIiwibzIiLCJCaWdNYXBWYWxpZGF0aW9uRXJyb3IiLCJCaWdNYXBUb2tlbiIsIlZhbHVlU2NoZW1hIiwiS2V5U2NoZW1hIiwiYmlnX21hcCIsImdlbmVyYXRlU2NoZW1hIiwiX19taWNoZWxzb25UeXBlIiwic2NoZW1hIiwidmFsaWRhdGUiLCJvYmpMaXRUb01pY2hlbHNvbk1hcCIsIkVuY29kZSIsInBvcCIsImZyb20iLCJzb3J0IiwiYSIsImIiLCJFbmNvZGVPYmplY3QiLCJzZW1hbnRpYyIsIkV4ZWN1dGUiLCJjdXJyZW50IiwiVG9LZXkiLCJpbnQiLCJmaW5kQW5kUmV0dXJuVG9rZW5zIiwidG9rZW5Ub0ZpbmQiLCJ0b2tlbnMiLCJwdXNoIiwiT3JWYWxpZGF0aW9uRXJyb3IiLCJPclRva2VuIiwibGFiZWwiLCJsZWZ0VG9rZW4iLCJrZXlDb3VudCIsInJpZ2h0VG9rZW4iLCJuZXdTaWciLCJzaWciLCJ2YWxpZGF0ZUphdmFzY3JpcHRPYmplY3QiLCJzZW1hbnRpY3MiLCJ0cmF2ZXJzYWwiLCJnZXRMZWZ0VmFsdWUiLCJnZXRSaWdodFZhbHVlIiwiY29uY2F0IiwibGVmdFZhbHVlIiwicmlnaHRWYWx1ZSIsInJlcyIsImFzc2lnbiIsImZpbmRUb2tlbiIsInRvayIsInZhbDEiLCJ2YWwyIiwibGFiZWxWYWwxIiwibGFiZWxWYWwyIiwiZW5jb2RlZDEiLCJlbmNvZGVkMiIsIlRvQmlnTWFwS2V5IiwiVG9rZW5Bcmd1bWVudFZhbGlkYXRpb25FcnJvciIsIlRva2VuQ29tcGFyaXNvbkVycm9yIiwiY29sbGFwc2UkMSIsIlBhaXJUb2tlbiIsInNsaWNlIiwiY250IiwidCIsImxlZnRTaWciLCJyaWdodFNpZyIsImdldFZhbHVlIiwicmVzdWx0IiwiTmF0VmFsaWRhdGlvbkVycm9yIiwiTmF0VG9rZW4iLCJ0b0ZpeGVkIiwiYmlnTnVtYmVyIiwiaXNOYU4iLCJpc05lZ2F0aXZlIiwibmF0MSIsIm5hdDIiLCJOdW1iZXIiLCJTdHJpbmdUb2tlbiIsInN0cmluZyIsIkFkZHJlc3NWYWxpZGF0aW9uRXJyb3IiLCJBZGRyZXNzVG9rZW4iLCJkZWNvZGVkIiwiYnl0ZXMiLCJWQUxJRCIsImFkZHJlc3MxIiwiYWRkcmVzczIiLCJpc0ltcGxpY2l0IiwiYWRkcmVzcyIsInN0YXJ0c1dpdGgiLCJpbXBsaWNpdDEiLCJpbXBsaWNpdDIiLCJNYXBWYWxpZGF0aW9uRXJyb3IiLCJNYXBUb2tlbiIsIkJvb2xUb2tlbiIsInRvTG93ZXJDYXNlIiwiQ29udHJhY3RWYWxpZGF0aW9uRXJyb3IiLCJDb250cmFjdFRva2VuIiwicGFyYW1ldGVyIiwiTGlzdFZhbGlkYXRpb25FcnJvciIsIkxpc3RUb2tlbiIsInJlZHVjZSIsInByZXYiLCJNdXRlelZhbGlkYXRpb25FcnJvciIsIk11dGV6VG9rZW4iLCJ0b1N0cmluZyIsIm11dGV6MSIsIm11dGV6MiIsIkJ5dGVzVmFsaWRhdGlvbkVycm9yIiwiQnl0ZXNUb2tlbiIsInRlc3QiLCJjb252ZXJ0VWludDhBcnJheVRvSGV4U3RyaW5nIiwiVWludDhBcnJheSIsIkJ1ZmZlciIsIk9wdGlvblRva2VuIiwic3ViVG9rZW4iLCJTb21lIiwiVGltZXN0YW1wVG9rZW4iLCJEYXRlIiwidG9JU09TdHJpbmciLCJJbnRWYWxpZGF0aW9uRXJyb3IiLCJJbnRUb2tlbiIsImludDEiLCJpbnQyIiwiVW5pdFRva2VuIiwiX3ZhbCIsIlVuaXRWYWx1ZSIsIl92YWwxIiwiX3ZhbDIiLCJwdWJsaWNLZXlQcmVmaXhMZW5ndGgiLCJLZXlWYWxpZGF0aW9uRXJyb3IiLCJLZXlUb2tlbiIsImtleTEiLCJrZXkyIiwia2V5UHJlZml4MSIsImdldFByZWZpeCIsImtleVByZWZpeDIiLCJFRFBLIiwiU1BQSyIsIlAyUEsiLCJrZXlCeXRlczEiLCJnZXRQMjU2UHVibGljS2V5Q29tcGFyYWJsZUJ5dGVzIiwia2V5Qnl0ZXMyIiwic3Vic3RyaW5nIiwicDJwayIsIktleUhhc2hWYWxpZGF0aW9uRXJyb3IiLCJLZXlIYXNoVG9rZW4iLCJTaWduYXR1cmVWYWxpZGF0aW9uRXJyb3IiLCJTaWduYXR1cmVUb2tlbiIsIkxhbWJkYVRva2VuIiwicGFyYW1TY2hlbWEiLCJyZXR1cm5TY2hlbWEiLCJwYXJhbWV0ZXJzIiwicmV0dXJucyIsIk9wZXJhdGlvblRva2VuIiwiU2V0VmFsaWRhdGlvbkVycm9yIiwiU2V0VG9rZW4iLCJDaGFpbklEVmFsaWRhdGlvbkVycm9yIiwiQ2hhaW5JRFRva2VuIiwiRW5jb2RlVGlja2V0RXJyb3IiLCJ0aWNrZXRlclR5cGUkMSIsImFtb3VudFR5cGUkMSIsIlRpY2tldFRva2VuIiwidmFsdWVUb2tlbiIsIl9hcmdzIiwidGlja2V0ZXIiLCJhbW91bnQiLCJFbmNvZGVUaWNrZXREZXByZWNhdGVkRXJyb3IiLCJ0aWNrZXRlclR5cGUiLCJhbW91bnRUeXBlIiwiVGlja2V0RGVwcmVjYXRlZFRva2VuIiwiTmV2ZXJUb2tlbkVycm9yIiwiTmV2ZXJUb2tlbiIsIlNhcGxpbmdTdGF0ZVZhbGlkYXRpb25FcnJvciIsIlNhcGxpbmdTdGF0ZVRva2VuIiwiaXNWYWxpZCIsIm1lbW9TaXplIiwiU2FwbGluZ1RyYW5zYWN0aW9uVmFsaWRhdGlvbkVycm9yIiwiU2FwbGluZ1RyYW5zYWN0aW9uVG9rZW4iLCJ2YWxpZGF0ZUJ5dGVzIiwiZXhlYyIsIlNhcGxpbmdUcmFuc2FjdGlvbkRlcHJlY2F0ZWRWYWxpZGF0aW9uRXJyb3IiLCJTYXBsaW5nVHJhbnNhY3Rpb25EZXByZWNhdGVkVG9rZW4iLCJCbHMxMjM4MWZyVmFsaWRhdGlvbkVycm9yIiwiQmxzMTIzODFmclRva2VuIiwiQmxzMTIzODFnMVZhbGlkYXRpb25FcnJvciIsIkJsczEyMzgxZzFUb2tlbiIsIkJsczEyMzgxZzJWYWxpZGF0aW9uRXJyb3IiLCJCbHMxMjM4MWcyVG9rZW4iLCJDaGVzdFZhbGlkYXRpb25FcnJvciIsIkNoZXN0VG9rZW4iLCJDaGVzdEtleVZhbGlkYXRpb25FcnJvciIsIkNoZXN0S2V5VG9rZW4iLCJHbG9iYWxDb25zdGFudEVuY29kaW5nRXJyb3IiLCJHbG9iYWxDb25zdGFudERlY29kaW5nRXJyb3IiLCJHbG9iYWxDb25zdGFudFRva2VuIiwiaGFzaCIsIkludmFsaWRUb2tlbkVycm9yIiwiZGF0YSIsImZpbmQiLCJQYXJhbWV0ZXJFbmNvZGluZ0Vycm9yIiwidmlld05hbWUiLCJzaWdzIiwiY2F1c2UiLCJJbnZhbGlkU2NyaXB0RXJyb3IiLCJzY3JpcHQiLCJJbnZhbGlkUnBjUmVzcG9uc2VFcnJvciIsIkludmFsaWRCaWdNYXBTY2hlbWFFcnJvciIsIkludmFsaWRCaWdNYXBEaWZmRXJyb3IiLCJCaWdNYXBFbmNvZGluZ0Vycm9yIiwiZGV0YWlscyIsIlN0b3JhZ2VFbmNvZGluZ0Vycm9yIiwiTWlzc2luZ0FyZ3VtZW50RXJyb3IiLCJfYSIsInNjaGVtYVR5cGVTeW1ib2wiLCJjb2xsYXBzZSIsIl9iIiwiX2MiLCJkZWVwRXF1YWwiLCJhYyIsImJjIiwiZXZlcnkiLCJ2IiwiaSIsImlzU2NoZW1hIiwiZnJvbVJQQ1Jlc3BvbnNlIiwiY29kZSIsInN0b3JhZ2UiLCJpc0V4cHJlc3Npb25FeHRlbmRlZCIsInJvb3QiLCJiaWdNYXAiLCJleHAiLCJyZW1vdmVUb3BMZXZlbEFubm90YXRpb24iLCJpc0ludGVnZXIiLCJFeGVjdXRlT25CaWdNYXBEaWZmIiwiZGlmZiIsImVsdEZvcm1hdCIsIkV4ZWN1dGVPbkJpZ01hcFZhbHVlIiwiRW5jb2RlQmlnTWFwS2V5IiwiZXgiLCJDb21wdXRlU3RhdGUiLCJ0eCIsInN0YXRlIiwiY29udGVudHMiLCJtZXRhZGF0YSIsIm9wZXJhdGlvbl9yZXN1bHQiLCJiaWdfbWFwX2RpZmYiLCJGaW5kRmlyc3RJblRvcExldmVsUGFpciIsInZhbHVlVHlwZSIsImZpbmRWYWx1ZSIsInZhbHVlVG9GaW5kIiwic2NoIiwic3RyZyIsIlBhcmFtZXRlclNjaGVtYSIsImlzTXVsdGlwbGVFbnRyeVBvaW50IiwiaGFzQW5ub3RhdGlvbiIsInJldmVyc2UiLCJFeHRyYWN0U2lnbmF0dXJlcyIsIlZpZXdTY2hlbWEiLCJhbGxWaWV3U2NoZW1hIiwidmlld3MiLCJmaWx0ZXIiLCJ2aWV3Iiwidmlld0FyZ3MiLCJ2aWV3QXJnc1R5cGUiLCJ2aWV3UmV0dXJuVHlwZSIsImluc3RydWN0aW9ucyIsInJvb3RBcmdzVHlwZSIsInJvb3RSZXR1cm5UeXBlIiwiZW5jb2RlVmlld0FyZ3MiLCJkZWNvZGVWaWV3UmVzdWx0IiwiZXh0cmFjdEFyZ3NTY2hlbWEiLCJleHRyYWN0UmVzdWx0U2NoZW1hIiwiRXZlbnRTY2hlbWEiLCJ0YWciLCJmcm9tTWljaGVsaW5lVmFsdWUiLCJhbGxFdmVudFNjaGVtYSIsImV4dHJhY3RFdmVudHNSZWN1cnNpdmVseSIsInJlbW92ZUR1cGxpY2F0ZXMiLCJldmVudHMiLCJ1bmlxdWVFdmVudHMiLCJldmVudCIsImZpbmRJbmRleCIsImZsYXRNYXAiLCJjIiwiVkVSU0lPTiIsIlNhcGxpbmdTdGF0ZVZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/rpc/dist/taquito-rpc.es6.js":
/*!***********************************************************!*\
  !*** ./node_modules/@taquito/rpc/dist/taquito-rpc.es6.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   METADATA_BALANCE_UPDATES_CATEGORY: () => (/* binding */ METADATA_BALANCE_UPDATES_CATEGORY),\n/* harmony export */   OPERATION_METADATA: () => (/* binding */ OPERATION_METADATA),\n/* harmony export */   OpKind: () => (/* binding */ OpKind),\n/* harmony export */   PvmKind: () => (/* binding */ PvmKind),\n/* harmony export */   RpcClient: () => (/* binding */ RpcClient),\n/* harmony export */   RpcClientCache: () => (/* binding */ RpcClientCache),\n/* harmony export */   SmartRollupInputProofKind: () => (/* binding */ SmartRollupInputProofKind),\n/* harmony export */   SmartRollupRefutationOptions: () => (/* binding */ SmartRollupRefutationOptions),\n/* harmony export */   SmartRollupRefuteGameEndedPlayerOutcomes: () => (/* binding */ SmartRollupRefuteGameEndedPlayerOutcomes),\n/* harmony export */   SmartRollupRefuteGameEndedReason: () => (/* binding */ SmartRollupRefuteGameEndedReason),\n/* harmony export */   SmartRollupRefuteGameStatusOptions: () => (/* binding */ SmartRollupRefuteGameStatusOptions),\n/* harmony export */   SmartRollupRefuteRevealProofKind: () => (/* binding */ SmartRollupRefuteRevealProofKind),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   castToBigNumber: () => (/* binding */ castToBigNumber),\n/* harmony export */   defaultChain: () => (/* binding */ defaultChain),\n/* harmony export */   defaultRPCOptions: () => (/* binding */ defaultRPCOptions)\n/* harmony export */ });\n/* harmony import */ var _taquito_http_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @taquito/http-utils */ \"(ssr)/./node_modules/@taquito/http-utils/dist/taquito-http-utils.es6.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var _taquito_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @taquito/utils */ \"(ssr)/./node_modules/@taquito/utils/dist/taquito-utils.es6.js\");\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst defaultChain = \"main\";\nconst defaultRPCOptions = {\n    block: \"head\"\n};\nvar RPCMethodName;\n(function(RPCMethodName) {\n    RPCMethodName[\"GET_BAKING_RIGHTS\"] = \"getBakingRights\";\n    RPCMethodName[\"GET_BALLOTS\"] = \"getBallots\";\n    RPCMethodName[\"GET_BALLOT_LIST\"] = \"getBallotList\";\n    RPCMethodName[\"GET_BIG_MAP_KEY\"] = \"getBigMapKey\";\n    RPCMethodName[\"GET_BIG_MAP_EXPR\"] = \"getBigMapExpr\";\n    RPCMethodName[\"GET_BLOCK_HASH\"] = \"getBlockHash\";\n    RPCMethodName[\"GET_BLOCK\"] = \"getBlock\";\n    RPCMethodName[\"GET_BLOCK_HEADER\"] = \"getBlockHeader\";\n    RPCMethodName[\"GET_BLOCK_METADATA\"] = \"getBlockMetadata\";\n    RPCMethodName[\"GET_BALANCE\"] = \"getBalance\";\n    RPCMethodName[\"GET_CHAIN_ID\"] = \"getChainId\";\n    RPCMethodName[\"GET_CONSTANTS\"] = \"getConstants\";\n    RPCMethodName[\"GET_CONTRACT\"] = \"getContract\";\n    RPCMethodName[\"GET_CURRENT_PERIOD\"] = \"getCurrentPeriod\";\n    RPCMethodName[\"GET_CURRENT_PROPOSAL\"] = \"getCurrentProposal\";\n    RPCMethodName[\"GET_CURRENT_QUORUM\"] = \"getCurrentQuorum\";\n    RPCMethodName[\"GET_DELEGATE\"] = \"getDelegate\";\n    RPCMethodName[\"GET_DELEGATES\"] = \"getDelegates\";\n    RPCMethodName[\"GET_VOTING_INFO\"] = \"getVotingInfo\";\n    RPCMethodName[\"GET_ATTESTATION_RIGHTS\"] = \"getAttestationRights\";\n    RPCMethodName[\"GET_ENDORSING_RIGHTS\"] = \"getEndorsingRights\";\n    RPCMethodName[\"GET_ENTRYPOINTS\"] = \"getEntrypoints\";\n    RPCMethodName[\"GET_LIVE_BLOCKS\"] = \"getLiveBlocks\";\n    RPCMethodName[\"GET_MANAGER_KEY\"] = \"getManagerKey\";\n    RPCMethodName[\"GET_NORMALIZED_SCRIPT\"] = \"getNormalizedScript\";\n    RPCMethodName[\"GET_PROPOSALS\"] = \"getProposals\";\n    RPCMethodName[\"GET_PROTOCOLS\"] = \"getProtocols\";\n    RPCMethodName[\"GET_SAPLING_DIFF_BY_CONTRACT\"] = \"getSaplingDiffByContract\";\n    RPCMethodName[\"GET_SAPLING_DIFF_BY_ID\"] = \"getSaplingDiffById\";\n    RPCMethodName[\"GET_SCRIPT\"] = \"getScript\";\n    RPCMethodName[\"GET_STORAGE\"] = \"getStorage\";\n    RPCMethodName[\"GET_SUCCESSOR_PERIOD\"] = \"getSuccessorPeriod\";\n    RPCMethodName[\"GET_VOTES_LISTINGS\"] = \"getVotesListings\";\n    RPCMethodName[\"PACK_DATA\"] = \"packData\";\n    RPCMethodName[\"GET_STORAGE_USED_SPACE\"] = \"getStorageUsedSpace\";\n    RPCMethodName[\"GET_STORAGE_PAID_SPACE\"] = \"getStoragePaidSpace\";\n    RPCMethodName[\"GET_TICKET_BALANCE\"] = \"getTicketBalance\";\n    RPCMethodName[\"GET_ALL_TICKET_BALANCES\"] = \"getAllTicketBalances\";\n    RPCMethodName[\"GET_PENDING_OPERATIONS\"] = \"getPendingOperations\";\n})(RPCMethodName || (RPCMethodName = {}));\n/**\n * Casts object/array items to BigNumber\n * @param data input object or array\n * @param keys keys for processing or all items if not defined\n *\n */ function castToBigNumber(data, keys) {\n    const returnArray = Array.isArray(data);\n    if (typeof keys === \"undefined\") {\n        keys = Object.keys(data);\n    }\n    const response = returnArray ? [] : {};\n    keys.forEach((key)=>{\n        const item = data[key];\n        let res;\n        if (typeof item === \"undefined\") {\n            return;\n        }\n        if (Array.isArray(item)) {\n            res = castToBigNumber(item);\n            response[key] = res;\n            return;\n        }\n        res = new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](item);\n        response[key] = res;\n    });\n    return response;\n}\nconst defaultTtl = 1000;\n/***\n * @description RpcClientCache acts as a decorator over the RpcClient instance by caching responses for the period defined by the ttl.\n */ class RpcClientCache {\n    /**\n     *\n     * @param rpcClient rpcClient responsible of the interaction with Tezos network through an rpc node\n     * @param ttl number representing the time to live (default 1000 milliseconds)\n     *\n     * @example new RpcClientCache(new RpcClient('https://mainnet.ecadinfra.com/'))\n     */ constructor(rpcClient, ttl = defaultTtl){\n        this.rpcClient = rpcClient;\n        this.ttl = ttl;\n        this._cache = {};\n    }\n    getAllCachedData() {\n        return this._cache;\n    }\n    /**\n     * @description Remove all the data in the cache.\n     *\n     */ deleteAllCachedData() {\n        for(const key in this._cache){\n            delete this._cache[key];\n        }\n    }\n    formatCacheKey(rpcUrl, rpcMethodName, rpcMethodParams, rpcMethodData) {\n        let paramsToString = \"\";\n        rpcMethodParams.forEach((param)=>{\n            paramsToString = typeof param === \"object\" ? paramsToString + JSON.stringify(param) + \"/\" : paramsToString + param + \"/\";\n        });\n        return rpcMethodData ? `${rpcUrl}/${rpcMethodName}/${paramsToString}${JSON.stringify(rpcMethodData)}/` : `${rpcUrl}/${rpcMethodName}/${paramsToString}`;\n    }\n    has(key) {\n        return key in this._cache;\n    }\n    get(key) {\n        return this._cache[key].response;\n    }\n    put(key, response) {\n        const handle = setTimeout(()=>{\n            return this.remove(key);\n        }, this.ttl);\n        Object.assign(this._cache, {\n            [key]: {\n                handle,\n                response\n            }\n        });\n    }\n    remove(key) {\n        if (key in this._cache) {\n            delete this._cache[key];\n        }\n    }\n    validateAddress(address) {\n        const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.validateAddress)(address);\n        if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_2__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_3__.InvalidAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.invalidDetail)(addressValidation));\n        }\n    }\n    validateContract(address) {\n        const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.validateContractAddress)(address);\n        if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_2__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_3__.InvalidContractAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.invalidDetail)(addressValidation));\n        }\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Get the block's hash, its unique identifier.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash\n     */ getBlockHash({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_HASH, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBlockHash({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks\n     */ getLiveBlocks({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_LIVE_BLOCKS, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getLiveBlocks({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address address from which we want to retrieve the balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the spendable balance of a contract, excluding frozen bonds\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance\n     */ getBalance(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALANCE, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBalance(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the storage\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the data of the contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */ getStorage(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getStorage(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the code and data of the contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n     */ getScript(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SCRIPT, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getScript(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param unparsingMode default is { unparsing_mode: \"Readable\" }\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the script of the contract and normalize it using the requested unparsing mode.\n     */ getNormalizedScript(address, unparsingMode = {\n        unparsing_mode: \"Readable\"\n    }, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_NORMALIZED_SCRIPT, [\n                block,\n                address\n            ], unparsingMode);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getNormalizedScript(address, unparsingMode, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete status of a contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id\n     */ getContract(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CONTRACT, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getContract(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the manager\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the manager of an implicit contract\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key\n     */ getManagerKey(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_MANAGER_KEY, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getManagerKey(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the delegate (baker)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the delegate of a contract, if any\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate\n     */ getDelegate(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_DELEGATE, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getDelegate(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @deprecated Deprecated in favor of getBigMapKeyByID\n     * @param address contract address from which we want to retrieve the big map key\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in the big map storage of the contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */ getBigMapKey(address, key, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const keyUrl = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BIG_MAP_KEY, [\n                block,\n                address\n            ], key);\n            if (this.has(keyUrl)) {\n                return this.get(keyUrl);\n            } else {\n                const response = this.rpcClient.getBigMapKey(address, key, {\n                    block\n                });\n                this.put(keyUrl, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param id Big Map ID\n     * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in a big map.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n     */ getBigMapExpr(id, expr, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BIG_MAP_EXPR, [\n                block,\n                id,\n                expr\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBigMapExpr(id, expr, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Everything about a delegate\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh\n     */ getDelegates(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_DELEGATES, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getDelegates(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh-voting-info\n     */ getVotingInfo(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_VOTING_INFO, [\n                block,\n                address\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getVotingInfo(address, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description All constants\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants\n     */ getConstants({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CONSTANTS, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getConstants({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version.\n     * @description All the information about a block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id\n     * @example getBlock() will default to `/main/chains/block/head?version=0` which shows { kind: endorsement }\n     * @example getBlock({ block: 'head~2', version: 1 }) will return an offset of 2 from head blocks and shows { kind: attestation }\n     * @example getBlock({ block: 'BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2' }) will return an offset of 2 blocks from given block hash..\n     */ getBlock({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBlock({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The whole block header\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header\n     */ getBlockHeader({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_HEADER, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBlockHeader({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version\n     * @description All the metadata associated to the block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata\n     */ getBlockMetadata({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BLOCK_METADATA, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBlockMetadata({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, consensus_key, and max_round)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the list of delegates allowed to bake a block.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights\n     */ getBakingRights(args = {}, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BAKING_RIGHTS, [\n                block,\n                args\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBakingRights(args, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the delegates allowed to attest a block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights\n     */ getAttestationRights(args = {}, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ATTESTATION_RIGHTS, [\n                block,\n                args\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getAttestationRights(args, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @deprecated Deprecated in favor of getAttestationRights\n     * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)\n     * @param options contains generic configuration for rpc calls\n     * @description Retrieves the delegates allowed to endorse a block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights\n     */ getEndorsingRights(args = {}, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ENDORSING_RIGHTS, [\n                block,\n                args\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getEndorsingRights(args, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list\n     */ getBallotList({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALLOT_LIST, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBallotList({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Sum of ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots\n     */ getBallots({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_BALLOTS, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getBallots({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current proposal under evaluation.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal\n     */ getCurrentProposal({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_PROPOSAL, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getCurrentProposal({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current expected quorum.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum\n     */ getCurrentQuorum({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_QUORUM, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getCurrentQuorum({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of delegates with their voting power\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings\n     */ getVotesListings({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_VOTES_LISTINGS, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getVotesListings({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of proposals with number of supporters\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals\n     */ getProposals({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PROPOSALS, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getProposals({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param data operation contents to forge\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Forge an operation returning the unsigned bytes\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations\n     */ forgeOperations(data, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.forgeOperations(data, {\n                block\n            });\n        });\n    }\n    /**\n     * @param signedOpBytes signed bytes to inject\n     * @description Inject an operation in node and broadcast it and return the ID of the operation\n     * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation\n     */ injectOperation(signedOpBytes) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.injectOperation(signedOpBytes);\n        });\n    }\n    /**\n     * @param ops Operations to apply\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate the application of the operations with the context of the given block and return the result of each operation application\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations\n     */ preapplyOperations(ops, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.preapplyOperations(ops, {\n                block\n            });\n        });\n    }\n    /**\n     * @param contract address of the contract we want to get the entrypoints of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Return the list of entrypoints of the contract\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints\n     * @version 005_PsBABY5H\n     */ getEntrypoints(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(contract);\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ENTRYPOINTS, [\n                block,\n                contract\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getEntrypoints(contract, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @deprecated Deprecated in favor of simulateOperation\n     * @param op Operation to run\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Run an operation with the context of the given block and without signature checks and return the operation application result, including the consumed gas.\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation\n     */ runOperation(op, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.runOperation(op, {\n                block\n            });\n        });\n    }\n    /**\n     * @param op Operation to simulate\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate running an operation at some future moment (based on the number of blocks given in the `latency` argument), and return the operation application result.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/oxford-openapi.json\n     */ simulateOperation(op, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.simulateOperation(op, {\n                block\n            });\n        });\n    }\n    /**\n     * @param code Code to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Run a Michelson script in the current context\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code\n     */ runCode(code, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.runCode(code, {\n                block\n            });\n        });\n    }\n    /**\n     * @param viewScriptParams Parameters of the script view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a michelson view\n     */ runScriptView(_a, _b) {\n        var { unparsing_mode = \"Readable\" } = _a, rest = __rest(_a, [\n            \"unparsing_mode\"\n        ]);\n        var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.runScriptView(Object.assign({\n                unparsing_mode\n            }, rest), {\n                block\n            });\n        });\n    }\n    /**\n     * @param viewParams Parameters of the view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.\n     */ runView(_a, _b) {\n        var { unparsing_mode = \"Readable\" } = _a, rest = __rest(_a, [\n            \"unparsing_mode\"\n        ]);\n        var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpcClient.runView(Object.assign({\n                unparsing_mode\n            }, rest), {\n                block\n            });\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CHAIN_ID, []);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getChainId();\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param data Data to pack\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK\n     * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the the RPC to pack.\n     * This precaution helps protect you and your applications users from RPC nodes that have been compromised.\n     * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.\n     * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.\n     * @example packData({ data: { string: \"test\" }, type: { prim: \"string\" } })\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data\n     */ packData(data, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.PACK_DATA, [\n                block\n            ], data);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.packData(data, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     *\n     * @description Return rpc root url\n     */ getRpcUrl() {\n        return this.rpcClient.getRpcUrl();\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the interrogated block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period\n     */ getCurrentPeriod({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_CURRENT_PERIOD, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getCurrentPeriod({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the next block.Useful to craft operations that will be valid in the next block\n     * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period\n     */ getSuccessorPeriod({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SUCCESSOR_PERIOD, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getSuccessorPeriod({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param id Sapling state ID\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff\n     */ getSaplingDiffById(id, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SAPLING_DIFF_BY_ID, [\n                block,\n                id\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getSaplingDiffById(id, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param contract address of the contract we want to get the sapling diff\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff\n     */ getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_SAPLING_DIFF_BY_CONTRACT, [\n                block,\n                contract\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getSaplingDiffByContract(contract, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description get current and next protocol\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols\n     */ getProtocols({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PROTOCOLS, [\n                block\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getProtocols({\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the used storage space of the contract\n     * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */ getStorageUsedSpace(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE_USED_SPACE, [\n                block,\n                contract\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getStorageUsedSpace(contract, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n  =   * @description Access the paid storage space of the contract\n     * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */ getStoragePaidSpace(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_STORAGE_PAID_SPACE, [\n                block,\n                contract\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getStoragePaidSpace(contract, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param contract implicit or originated address we want to retrieve ticket balance of\n     * @param ticket object to specify a ticket by ticketer, content type and content\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the contract's balance of ticket with specified ticketer, content type, and content.\n     * @example ticket { ticketer: 'address', content_type: { prim: \"string\" }, content: { string: 'ticket1' } }\n     * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes\n     */ getTicketBalance(contract, ticket, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_TICKET_BALANCE, [\n                block,\n                contract\n            ], ticket);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getTicketBalance(contract, ticket, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @param contract originated address we want to retrieve ticket balances of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete list of tickets owned by the given contract by scanning the contract's storage.\n     * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes\n     */ getAllTicketBalances(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_ALL_TICKET_BALANCES, [\n                block,\n                contract\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getAllTicketBalances(contract, {\n                    block\n                });\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n    /**\n     * @description List the prevalidated operations in mempool (accessibility of mempool depends on each rpc endpoint)\n     * @param args has 5 optional properties. We support version 1 as default will output { applied: { kind: endorsement} } version 2 will output { validated: { kind: attestation} }. The rest of the properties is to filter pending operations response\n     * @default args { version: '1', applied: true, refused: true, outdated, true, branchRefused: true, branchDelayed: true, validationPass: undefined }\n     * @see https://tezos.gitlab.io/CHANGES.html?highlight=pending_operations#id4\n     */ getPendingOperations(args = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const key = this.formatCacheKey(this.rpcClient.getRpcUrl(), RPCMethodName.GET_PENDING_OPERATIONS, [\n                args\n            ]);\n            if (this.has(key)) {\n                return this.get(key);\n            } else {\n                const response = this.rpcClient.getPendingOperations(args);\n                this.put(key, response);\n                return response;\n            }\n        });\n    }\n}\nvar OPERATION_METADATA;\n(function(OPERATION_METADATA) {\n    OPERATION_METADATA[\"TOO_LARGE\"] = \"too large\";\n})(OPERATION_METADATA || (OPERATION_METADATA = {}));\nvar METADATA_BALANCE_UPDATES_CATEGORY;\n(function(METADATA_BALANCE_UPDATES_CATEGORY) {\n    METADATA_BALANCE_UPDATES_CATEGORY[\"BAKING_BONUSES\"] = \"baking bonuses\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"BAKING_REWARDS\"] = \"baking rewards\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"BLOCK_FEES\"] = \"block fees\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"BONDS\"] = \"bonds\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"BOOTSTRAP\"] = \"bootstrap\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"BURNED\"] = \"burned\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"COMMITMENT\"] = \"commitment\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"DELEGATE_DENOMINATOR\"] = \"delegate_denominator\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"DELEGATOR_NUMERATOR\"] = \"delegator_numerator\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"DEPOSITS\"] = \"deposits\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"ENDORSING_REWARDS\"] = \"endorsing rewards\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"INVOICE\"] = \"invoice\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"LOST_ENDORSING_REWARDS\"] = \"lost endorsing rewards\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"MINTED\"] = \"minted\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"NONCE_REVELATION_REWARDS\"] = \"nonce revelation rewards\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"PUNISHMENTS\"] = \"punishments\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"SMART_ROLLUP_REFUTATION_PUNISHMENTS\"] = \"smart_rollup_refutation_punishments\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"SMART_ROLLUP_REFUTATION_REWARDS\"] = \"smart_rollup_refutation_rewards\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"STORAGE_FEES\"] = \"storage fees\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"SUBSIDY\"] = \"subsidy\";\n    METADATA_BALANCE_UPDATES_CATEGORY[\"UNSTAKED_DEPOSITS\"] = \"unstaked_deposits\";\n})(METADATA_BALANCE_UPDATES_CATEGORY || (METADATA_BALANCE_UPDATES_CATEGORY = {}));\nvar PvmKind;\n(function(PvmKind) {\n    PvmKind[\"WASM2\"] = \"wasm_2_0_0\";\n    PvmKind[\"ARITH\"] = \"arith\";\n    PvmKind[\"RISCV\"] = \"riscv\";\n})(PvmKind || (PvmKind = {}));\nvar SmartRollupRefutationOptions;\n(function(SmartRollupRefutationOptions) {\n    SmartRollupRefutationOptions[\"START\"] = \"start\";\n    SmartRollupRefutationOptions[\"MOVE\"] = \"move\";\n})(SmartRollupRefutationOptions || (SmartRollupRefutationOptions = {}));\nvar SmartRollupInputProofKind;\n(function(SmartRollupInputProofKind) {\n    SmartRollupInputProofKind[\"INBOX_PROOF\"] = \"inbox_proof\";\n    SmartRollupInputProofKind[\"REVEAL_PROOF\"] = \"reveal_proof\";\n    SmartRollupInputProofKind[\"FIRST_INPUT\"] = \"first_input\";\n})(SmartRollupInputProofKind || (SmartRollupInputProofKind = {}));\nvar SmartRollupRefuteRevealProofKind;\n(function(SmartRollupRefuteRevealProofKind) {\n    SmartRollupRefuteRevealProofKind[\"RAW_DATA_PROOF\"] = \"raw_data_proof\";\n    SmartRollupRefuteRevealProofKind[\"METADATA_PROOF\"] = \"metadata_proof\";\n    SmartRollupRefuteRevealProofKind[\"DAL_PAGE_PROOF\"] = \"dal_page_proof\";\n})(SmartRollupRefuteRevealProofKind || (SmartRollupRefuteRevealProofKind = {}));\nvar SmartRollupRefuteGameStatusOptions;\n(function(SmartRollupRefuteGameStatusOptions) {\n    SmartRollupRefuteGameStatusOptions[\"ONGOING\"] = \"ongoing\";\n    SmartRollupRefuteGameStatusOptions[\"ENDED\"] = \"ended\";\n})(SmartRollupRefuteGameStatusOptions || (SmartRollupRefuteGameStatusOptions = {}));\nvar SmartRollupRefuteGameEndedPlayerOutcomes;\n(function(SmartRollupRefuteGameEndedPlayerOutcomes) {\n    SmartRollupRefuteGameEndedPlayerOutcomes[\"LOSER\"] = \"loser\";\n    SmartRollupRefuteGameEndedPlayerOutcomes[\"DRAW\"] = \"draw\";\n})(SmartRollupRefuteGameEndedPlayerOutcomes || (SmartRollupRefuteGameEndedPlayerOutcomes = {}));\nvar SmartRollupRefuteGameEndedReason;\n(function(SmartRollupRefuteGameEndedReason) {\n    SmartRollupRefuteGameEndedReason[\"CONFLICT_RESOLVED\"] = \"conflict_resolved\";\n    SmartRollupRefuteGameEndedReason[\"TIMEOUT\"] = \"timeout\";\n})(SmartRollupRefuteGameEndedReason || (SmartRollupRefuteGameEndedReason = {}));\nvar OpKind;\n(function(OpKind) {\n    OpKind[\"ORIGINATION\"] = \"origination\";\n    OpKind[\"DELEGATION\"] = \"delegation\";\n    OpKind[\"REVEAL\"] = \"reveal\";\n    OpKind[\"TRANSACTION\"] = \"transaction\";\n    OpKind[\"ACTIVATION\"] = \"activate_account\";\n    OpKind[\"ATTESTATION\"] = \"attestation\";\n    OpKind[\"ENDORSEMENT\"] = \"endorsement\";\n    OpKind[\"PREATTESTATION\"] = \"preattestation\";\n    OpKind[\"PREENDORSEMENT\"] = \"preendorsement\";\n    OpKind[\"SET_DEPOSITS_LIMIT\"] = \"set_deposits_limit\";\n    OpKind[\"DOUBLE_PREATTESTATION_EVIDENCE\"] = \"double_preattestation_evidence\";\n    OpKind[\"DOUBLE_PREENDORSEMENT_EVIDENCE\"] = \"double_preendorsement_evidence\";\n    OpKind[\"ATTESTATION_WITH_SLOT\"] = \"attestation_with_slot\";\n    OpKind[\"ENDORSEMENT_WITH_SLOT\"] = \"endorsement_with_slot\";\n    OpKind[\"SEED_NONCE_REVELATION\"] = \"seed_nonce_revelation\";\n    OpKind[\"DOUBLE_ATTESTATION_EVIDENCE\"] = \"double_attestation_evidence\";\n    OpKind[\"DOUBLE_ENDORSEMENT_EVIDENCE\"] = \"double_endorsement_evidence\";\n    OpKind[\"DOUBLE_BAKING_EVIDENCE\"] = \"double_baking_evidence\";\n    OpKind[\"PROPOSALS\"] = \"proposals\";\n    OpKind[\"BALLOT\"] = \"ballot\";\n    OpKind[\"FAILING_NOOP\"] = \"failing_noop\";\n    OpKind[\"REGISTER_GLOBAL_CONSTANT\"] = \"register_global_constant\";\n    OpKind[\"TRANSFER_TICKET\"] = \"transfer_ticket\";\n    OpKind[\"INCREASE_PAID_STORAGE\"] = \"increase_paid_storage\";\n    OpKind[\"UPDATE_CONSENSUS_KEY\"] = \"update_consensus_key\";\n    OpKind[\"DRAIN_DELEGATE\"] = \"drain_delegate\";\n    OpKind[\"VDF_REVELATION\"] = \"vdf_revelation\";\n    OpKind[\"EVENT\"] = \"event\";\n    OpKind[\"TICKET_UPDATES\"] = \"ticket_updates\";\n    OpKind[\"SMART_ROLLUP_ORIGINATE\"] = \"smart_rollup_originate\";\n    OpKind[\"SMART_ROLLUP_ADD_MESSAGES\"] = \"smart_rollup_add_messages\";\n    OpKind[\"SMART_ROLLUP_EXECUTE_OUTBOX_MESSAGE\"] = \"smart_rollup_execute_outbox_message\";\n    OpKind[\"SMART_ROLLUP_PUBLISH\"] = \"smart_rollup_publish\";\n    OpKind[\"SMART_ROLLUP_CEMENT\"] = \"smart_rollup_cement\";\n    OpKind[\"SMART_ROLLUP_RECOVER_BOND\"] = \"smart_rollup_recover_bond\";\n    OpKind[\"SMART_ROLLUP_REFUTE\"] = \"smart_rollup_refute\";\n    OpKind[\"SMART_ROLLUP_TIMEOUT\"] = \"smart_rollup_timeout\";\n})(OpKind || (OpKind = {}));\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\n/***\n * @description RpcClient allows interaction with Tezos network through an rpc node\n */ class RpcClient {\n    /**\n     *\n     * @param url rpc root url\n     * @param chain chain (default main)\n     * @param httpBackend Http backend that issue http request.\n     * You can override it by providing your own if you which to hook in the request/response\n     *\n     * @example new RpcClient('https://mainnet.ecadinfra.com/', 'main') this will use https://mainnet.ecadinfra.com//chains/main\n     */ constructor(url, chain = defaultChain, httpBackend = new _taquito_http_utils__WEBPACK_IMPORTED_MODULE_0__.HttpBackend()){\n        this.url = url;\n        this.chain = chain;\n        this.httpBackend = httpBackend;\n    }\n    createURL(path) {\n        // Trim trailing slashes because it is assumed to be included in path\n        // the regex solution is prone to ReDoS. Please see: https://stackoverflow.com/questions/6680825/return-string-without-trailing-slash#comment124306698_6680877\n        // We also got a CodeQL error for the regex based solution\n        let rootUrl = this.url;\n        while(rootUrl.endsWith(\"/\")){\n            rootUrl = rootUrl.slice(0, -1);\n        }\n        return `${rootUrl}${path}`;\n    }\n    validateAddress(address) {\n        const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.validateAddress)(address);\n        if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_2__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_3__.InvalidAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.invalidDetail)(addressValidation));\n        }\n    }\n    validateContract(address) {\n        const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.validateContractAddress)(address);\n        if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_2__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_3__.InvalidContractAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_2__.invalidDetail)(addressValidation));\n        }\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Get the block's hash, its unique identifier.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-hash\n     */ getBlockHash({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const hash = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/hash`),\n                method: \"GET\"\n            });\n            return hash;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-live-blocks\n     */ getLiveBlocks({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const blocks = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/live_blocks`),\n                method: \"GET\"\n            });\n            return blocks;\n        });\n    }\n    /**\n     * @param address address from which we want to retrieve the balance\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the spendable balance of a contract, excluding frozen bonds\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-balance\n     */ getBalance(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const balance = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/balance`),\n                method: \"GET\"\n            });\n            return new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](balance);\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the storage\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the data of the contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */ getStorage(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(address);\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/storage`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the code and data of the contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n     */ getScript(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(address);\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the script\n     * @param unparsingMode default is { unparsing_mode: \"Readable\" }\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the script of the contract and normalize it using the requested unparsing mode.\n     */ getNormalizedScript(address, unparsingMode = {\n        unparsing_mode: \"Readable\"\n    }, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(address);\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/script/normalized`),\n                method: \"POST\"\n            }, unparsingMode);\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete status of a contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id\n     */ getContract(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const contractResponse = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}`),\n                method: \"GET\"\n            });\n            return Object.assign(Object.assign({}, contractResponse), {\n                balance: new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](contractResponse.balance)\n            });\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the manager\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the manager of an implicit contract\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-manager-key\n     */ getManagerKey(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/manager_key`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param address contract address from which we want to retrieve the delegate (baker)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the delegate of a contract, if any\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-delegate\n     */ getDelegate(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            let delegate;\n            try {\n                delegate = yield this.httpBackend.createRequest({\n                    url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/delegate`),\n                    method: \"GET\"\n                });\n            } catch (ex) {\n                if (ex instanceof _taquito_http_utils__WEBPACK_IMPORTED_MODULE_0__.HttpResponseError && ex.status === _taquito_http_utils__WEBPACK_IMPORTED_MODULE_0__.STATUS_CODE.NOT_FOUND) {\n                    delegate = null;\n                } else {\n                    throw ex;\n                }\n            }\n            return delegate;\n        });\n    }\n    /**\n     * @deprecated Deprecated in favor of getBigMapKeyByID\n     * @param address contract address from which we want to retrieve the big map key\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in the big map storage of the contract.\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */ getBigMapKey(address, key, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${address}/big_map_get`),\n                method: \"POST\"\n            }, key);\n        });\n    }\n    /**\n     * @param id Big Map ID\n     * @param expr Expression hash to query (A b58check encoded Blake2b hash of the expression (The expression can be packed using the pack_data method))\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the value associated with a key in a big map.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n     */ getBigMapExpr(id, expr, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/big_maps/${id}/${expr}`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Everything about a delegate\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-delegates-pkh\n     */ getDelegates(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}`),\n                method: \"GET\"\n            });\n            const castedResponse = castToBigNumber(response, [\n                \"balance\",\n                \"full_balance\",\n                \"current_frozen_deposits\",\n                \"frozen_deposits\",\n                \"frozen_balance\",\n                \"frozen_deposits_limit\",\n                \"staking_balance\",\n                \"delegated_balance\",\n                \"voting_power\",\n                \"total_delegated_stake\",\n                \"staking_denominator\"\n            ]);\n            return Object.assign(Object.assign(Object.assign({}, response), castedResponse), {\n                frozen_balance_by_cycle: response.frozen_balance_by_cycle ? response.frozen_balance_by_cycle.map((_a)=>{\n                    var { deposit, deposits, fees, rewards } = _a, rest = __rest(_a, [\n                        \"deposit\",\n                        \"deposits\",\n                        \"fees\",\n                        \"rewards\"\n                    ]);\n                    const castedToBigNumber = castToBigNumber({\n                        deposit,\n                        deposits,\n                        fees,\n                        rewards\n                    }, [\n                        \"deposit\",\n                        \"deposits\",\n                        \"fees\",\n                        \"rewards\"\n                    ]);\n                    return Object.assign(Object.assign({}, rest), {\n                        deposit: castedToBigNumber.deposit,\n                        deposits: castedToBigNumber.deposits,\n                        fees: castedToBigNumber.fees,\n                        rewards: castedToBigNumber.rewards\n                    });\n                }) : undefined\n            });\n        });\n    }\n    /**\n     * @param address delegate address which we want to retrieve\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the delegate info (e.g. voting power) found in the listings of the current voting period\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-delegates-pkh-voting-info\n     */ getVotingInfo(address, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateAddress(address);\n            return yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/delegates/${address}/voting_info`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description All constants\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-constants\n     */ getConstants({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/constants`),\n                method: \"GET\"\n            });\n            const castedResponse = castToBigNumber(response, [\n                \"time_between_blocks\",\n                \"hard_gas_limit_per_operation\",\n                \"hard_gas_limit_per_block\",\n                \"proof_of_work_threshold\",\n                \"tokens_per_roll\",\n                \"seed_nonce_revelation_tip\",\n                \"block_security_deposit\",\n                \"endorsement_security_deposit\",\n                \"block_reward\",\n                \"endorsement_reward\",\n                \"cost_per_byte\",\n                \"hard_storage_limit_per_operation\",\n                \"test_chain_duration\",\n                \"baking_reward_per_endorsement\",\n                \"delay_per_missing_endorsement\",\n                \"minimal_block_delay\",\n                \"liquidity_baking_subsidy\",\n                \"cache_layout\",\n                \"baking_reward_fixed_portion\",\n                \"baking_reward_bonus_per_slot\",\n                \"endorsing_reward_per_slot\",\n                \"double_baking_punishment\",\n                \"delay_increment_per_round\",\n                \"tx_rollup_commitment_bond\",\n                \"vdf_difficulty\",\n                \"sc_rollup_stake_amount\",\n                \"minimal_stake\"\n            ]);\n            return Object.assign(Object.assign({}, response), castedResponse);\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version.\n     * @description All the information about a block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id\n     * @example getBlock() will default to `/main/chains/block/head?version=0` which shows { kind: endorsement }\n     * @example getBlock({ block: 'head~2', version: 1 }) will return an offset of 2 from head blocks and shows { kind: attestation }\n     * @example getBlock({ block: 'BL8fTiWcSxWCjiMVnDkbh6EuhqVPZzgWheJ2dqwrxYRm9AephXh~2' }) will return an offset of 2 blocks from given block hash..\n     */ getBlock({ block, version } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const requestOptions = {\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}`),\n                method: \"GET\"\n            };\n            if (version !== undefined) {\n                requestOptions.query = {\n                    version\n                };\n            }\n            return yield this.httpBackend.createRequest(requestOptions);\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description The whole block header\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-header\n     */ getBlockHeader({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/header`),\n                method: \"GET\"\n            });\n            return response;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head) and version\n     * @description All the metadata associated to the block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-metadata\n     */ getBlockMetadata({ block, version } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const requestOptions = {\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/metadata`),\n                method: \"GET\"\n            };\n            if (version !== undefined) {\n                requestOptions.query = {\n                    version\n                };\n            }\n            return yield this.httpBackend.createRequest(requestOptions);\n        });\n    }\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, consensus_key, and max_round)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the list of delegates allowed to bake a block.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-baking-rights\n     */ getBakingRights(args = {}, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/baking_rights`),\n                method: \"GET\",\n                query: args\n            });\n            return response;\n        });\n    }\n    /**\n     * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Retrieves the delegates allowed to attest a block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights\n     */ getAttestationRights(args = {}, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/attestation_rights`),\n                method: \"GET\",\n                query: args\n            });\n            return response;\n        });\n    }\n    /**\n     * @deprecated Deprecated in favor of getAttestationRights\n     * @param args contains optional query arguments (level, cycle, delegate, and consensus_key)\n     * @param options contains generic configuration for rpc calls\n     * @description Retrieves the delegates allowed to endorse a block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-helpers-endorsing-rights\n     */ getEndorsingRights(args = {}, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/endorsing_rights`),\n                method: \"GET\",\n                query: args\n            });\n            return response;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballot-list\n     */ getBallotList({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballot_list`),\n                method: \"GET\"\n            });\n            return response;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Sum of ballots casted so far during a voting period\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-ballots\n     */ getBallots({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/ballots`),\n                method: \"GET\"\n            });\n            const casted = castToBigNumber(response, [\n                \"yay\",\n                \"nay\",\n                \"pass\"\n            ]);\n            return casted;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current proposal under evaluation.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-proposal\n     */ getCurrentProposal({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_proposal`),\n                method: \"GET\"\n            });\n            return response;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Current expected quorum.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-quorum\n     */ getCurrentQuorum({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_quorum`),\n                method: \"GET\"\n            });\n            return response;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of delegates with their voting power\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-listings\n     */ getVotesListings({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/listings`),\n                method: \"GET\"\n            });\n            response.map((item)=>{\n                if (item.voting_power) {\n                    item.voting_power = new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](item.voting_power);\n                }\n                return item;\n            });\n            return response;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description List of proposals with number of supporters\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-proposals\n     */ getProposals({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/proposals`),\n                method: \"GET\"\n            });\n            response.map((item)=>{\n                return item[1] = new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](item[1]);\n            });\n            return response;\n        });\n    }\n    /**\n     * @param data operation contents to forge\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Forge an operation returning the unsigned bytes\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-forge-operations\n     */ forgeOperations(data, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/forge/operations`),\n                method: \"POST\"\n            }, data);\n        });\n    }\n    /**\n     * @param signedOpBytes signed bytes to inject\n     * @description Inject an operation in node and broadcast it and return the ID of the operation\n     * @see https://tezos.gitlab.io/api/rpc.html#post-injection-operation\n     */ injectOperation(signedOpBytes) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/injection/operation`),\n                method: \"POST\"\n            }, signedOpBytes);\n        });\n    }\n    /**\n     * @param ops Operations to apply\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate the application of the operations with the context of the given block and return the result of each operation application\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-preapply-operations\n     */ preapplyOperations(ops, { block, version } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const requestOptions = {\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/preapply/operations`),\n                method: \"POST\"\n            };\n            if (version !== undefined) {\n                requestOptions.query = {\n                    version\n                };\n            }\n            return yield this.httpBackend.createRequest(requestOptions, ops);\n        });\n    }\n    /**\n     * @param contract address of the contract we want to get the entrypoints of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Return the list of entrypoints of the contract\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-entrypoints\n     * @version 005_PsBABY5H\n     */ getEntrypoints(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.validateContract(contract);\n            const contractResponse = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/entrypoints`),\n                method: \"GET\"\n            });\n            return contractResponse;\n        });\n    }\n    /**\n     * @deprecated Deprecated in favor of simulateOperation\n     * @param op Operation to run\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Run an operation with the context of the given block and without signature checks and return the operation application result, including the consumed gas.\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-operation\n     */ runOperation(op, { block, version } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const requestOptions = {\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_operation`),\n                method: \"POST\"\n            };\n            if (version !== undefined) {\n                requestOptions.query = {\n                    version\n                };\n            }\n            return yield this.httpBackend.createRequest(requestOptions, op);\n        });\n    }\n    /**\n     * @param op Operation to simulate\n     * @param options contains generic configuration for rpc calls to specified block and version\n     * @description Simulate running an operation at some future moment (based on the number of blocks given in the `latency` argument), and return the operation application result.\n     * @see https://gitlab.com/tezos/tezos/-/blob/master/docs/api/oxford-openapi.json\n     */ simulateOperation(op, { block, version } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const requestOptions = {\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/simulate_operation`),\n                method: \"POST\"\n            };\n            if (version !== undefined) {\n                requestOptions.query = {\n                    version\n                };\n            }\n            return yield this.httpBackend.createRequest(requestOptions, op);\n        });\n    }\n    /**\n     * @param code Code to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Run a Michelson script in the current context\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-run-code\n     */ runCode(code, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_code`),\n                method: \"POST\"\n            }, code);\n            return response;\n        });\n    }\n    /**\n     * @param viewScriptParams Parameters of the script view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a michelson view\n     */ runScriptView(_a, _b) {\n        var { unparsing_mode = \"Readable\" } = _a, rest = __rest(_a, [\n            \"unparsing_mode\"\n        ]);\n        var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_script_view`),\n                method: \"POST\"\n            }, Object.assign({\n                unparsing_mode\n            }, rest));\n        });\n    }\n    /**\n     * @param viewParams Parameters of the view to run\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Simulate a call to a view following the TZIP-4 standard. See https://gitlab.com/tzip/tzip/-/blob/master/proposals/tzip-4/tzip-4.md#view-entrypoints.\n     */ runView(_a, _b) {\n        var { unparsing_mode = \"Readable\" } = _a, rest = __rest(_a, [\n            \"unparsing_mode\"\n        ]);\n        var _c = _b === void 0 ? defaultRPCOptions : _b, block = _c.block;\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/run_view`),\n                method: \"POST\"\n            }, Object.assign({\n                unparsing_mode\n            }, rest));\n        });\n    }\n    getChainId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/chain_id`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param data Data to pack\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Computes the serialized version of a data expression using the same algorithm as script instruction PACK\n     * Note: You should always verify the packed bytes before signing or requesting that they be signed when using the the RPC to pack.\n     * This precaution helps protect you and your applications users from RPC nodes that have been compromised.\n     * A node that is operated by a bad actor, or compromised by a bad actor could return a fully formed operation that does not correspond to the input provided to the RPC endpoint.\n     * A safer solution to pack and sign data would be to use the `packDataBytes` function available in the `@taquito/michel-codec` package.\n     * @example packData({ data: { string: \"test\" }, type: { prim: \"string\" } })\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-helpers-scripts-pack-data\n     */ packData(data, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const _a = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/helpers/scripts/pack_data`),\n                method: \"POST\"\n            }, data), { gas } = _a, rest = __rest(_a, [\n                \"gas\"\n            ]);\n            let formattedGas = gas;\n            const tryBigNumber = new bignumber_js__WEBPACK_IMPORTED_MODULE_1__[\"default\"](gas || \"\");\n            if (!tryBigNumber.isNaN()) {\n                formattedGas = tryBigNumber;\n            }\n            return Object.assign({\n                gas: formattedGas\n            }, rest);\n        });\n    }\n    /**\n     *\n     * @description Return rpc root url\n     */ getRpcUrl() {\n        return this.url;\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the interrogated block\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-current-period\n     */ getCurrentPeriod({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/current_period`),\n                method: \"GET\"\n            });\n            return response;\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the voting period (index, kind, starting position) and related information (position, remaining) of the next block.Useful to craft operations that will be valid in the next block\n     * @example getSuccessorPeriod() will default to successor voting period for /main/chains/block/head.\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-votes-successor-period\n     */ getSuccessorPeriod({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const response = yield this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/votes/successor_period`),\n                method: \"GET\"\n            });\n            return response;\n        });\n    }\n    /**\n     * @param id Sapling state ID\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-sapling-sapling-state-id-get-diff\n     */ getSaplingDiffById(id, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/sapling/${id}/get_diff`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param contract address of the contract we want to get the sapling diff\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Returns the root and a diff of a state starting from an optional offset which is zero by default\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-context-contracts-contract-id-single-sapling-get-diff\n     */ getSaplingDiffByContract(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/single_sapling_get_diff`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description get current and next protocol\n     * @see https://tezos.gitlab.io/active/rpc.html#get-block-id-protocols\n     */ getProtocols({ block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/protocols`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the used storage space of the contract\n     * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */ getStorageUsedSpace(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/used_space`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param contract address of the contract we want to retrieve storage information of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n  =   * @description Access the paid storage space of the contract\n     * @see https://tezos.gitlab.io/lima/rpc.html#get-block-id-context-contracts-contract-id-storage\n     */ getStoragePaidSpace(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/storage/paid_space`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @param contract implicit or originated address we want to retrieve ticket balance of\n     * @param ticket object to specify a ticket by ticketer, content type and content\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the contract's balance of ticket with specified ticketer, content type, and content.\n     * @example ticket { ticketer: 'address', content_type: { prim: \"string\" }, content: { string: 'ticket1' } }\n     * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes\n     */ getTicketBalance(contract, ticket, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/ticket_balance`),\n                method: \"POST\"\n            }, ticket);\n        });\n    }\n    /**\n     * @param contract originated address we want to retrieve ticket balances of\n     * @param options contains generic configuration for rpc calls to specified block (default to head)\n     * @description Access the complete list of tickets owned by the given contract by scanning the contract's storage.\n     * @see https://tezos.gitlab.io/protocols/016_mumbai.html#rpc-changes\n     */ getAllTicketBalances(contract, { block } = defaultRPCOptions) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/blocks/${block}/context/contracts/${contract}/all_ticket_balances`),\n                method: \"GET\"\n            });\n        });\n    }\n    /**\n     * @description List the prevalidated operations in mempool (accessibility of mempool depends on each rpc endpoint)\n     * @param args has 5 optional properties. We support version 1 as default will output { applied: { kind: endorsement} } version 2 will output { validated: { kind: attestation} }. The rest of the properties is to filter pending operations response\n     * @default args { version: '1', applied: true, refused: true, outdated, true, branchRefused: true, branchDelayed: true, validationPass: undefined }\n     * @see https://tezos.gitlab.io/CHANGES.html?highlight=pending_operations#id4\n     */ getPendingOperations(args = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.httpBackend.createRequest({\n                url: this.createURL(`/chains/${this.chain}/mempool/pending_operations`),\n                method: \"GET\",\n                query: args\n            });\n        });\n    }\n}\n //# sourceMappingURL=taquito-rpc.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vcnBjL2Rpc3QvdGFxdWl0by1ycGMuZXM2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQWtGO0FBQzdDO0FBQ3NFO0FBQzFCO0FBRWpGOzs7Ozs7Ozs7Ozs7OzhFQWE4RSxHQUM5RSxvREFBb0QsR0FHcEQsU0FBU1UsT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUVBLFNBQVNXLFVBQVVDLE9BQU8sRUFBRUMsVUFBVSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7SUFDaEQsU0FBU0MsTUFBTUMsS0FBSztRQUFJLE9BQU9BLGlCQUFpQkgsSUFBSUcsUUFBUSxJQUFJSCxFQUFFLFNBQVVJLE9BQU87WUFBSUEsUUFBUUQ7UUFBUTtJQUFJO0lBQzNHLE9BQU8sSUFB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SUFDSjtJQUNBOzs7OztLQUtDLEdBQ0RFLHFCQUFxQmxDLFFBQVEsRUFBRSxFQUFFMUcsS0FBSyxFQUFFLEdBQUdELGlCQUFpQixFQUFFO1FBQzFELE9BQU96QixVQUFVLElBQUksRUFBRSxLQUFLLEdBQUcsS0FBSyxHQUFHO1lBQ25DLE9BQU8sSUFBSSxDQUFDd0wsV0FBVyxDQUFDTyxhQUFhLENBQUM7Z0JBQ2xDVCxLQUFLLElBQUksQ0FBQ0csU0FBUyxDQUFDLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQ0YsS0FBSyxDQUFDLFFBQVEsRUFBRTdKLE1BQU0sbUJBQW1CLEVBQUUwRyxTQUFTLG9CQUFvQixDQUFDO2dCQUM3RzRELFFBQVE7WUFDWjtRQUNKO0lBQ0o7SUFDQTs7Ozs7S0FLQyxHQUNEeEIscUJBQXFCNUQsT0FBTyxDQUFDLENBQUMsRUFBRTtRQUM1QixPQUFPNUcsVUFBVSxJQUFJLEVBQUUsS0FBSyxHQUFHLEtBQUssR0FBRztZQUNuQyxPQUFPLElBQUksQ0FBQ3dMLFdBQVcsQ0FBQ08sYUFBYSxDQUFDO2dCQUNsQ1QsS0FBSyxJQUFJLENBQUNHLFNBQVMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUNGLEtBQUssQ0FBQywyQkFBMkIsQ0FBQztnQkFDdEVTLFFBQVE7Z0JBQ1JtQixPQUFPdkc7WUFDWDtRQUNKO0lBQ0o7QUFDSjtBQUVtWCxDQUNuWCwyQ0FBMkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd3JwZXJrcy8uL25vZGVfbW9kdWxlcy9AdGFxdWl0by9ycGMvZGlzdC90YXF1aXRvLXJwYy5lczYuanM/MjdhNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwQmFja2VuZCwgSHR0cFJlc3BvbnNlRXJyb3IsIFNUQVRVU19DT0RFIH0gZnJvbSAnQHRhcXVpdG8vaHR0cC11dGlscyc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgeyB2YWxpZGF0ZUFkZHJlc3MsIFZhbGlkYXRpb25SZXN1bHQsIGludmFsaWREZXRhaWwsIHZhbGlkYXRlQ29udHJhY3RBZGRyZXNzIH0gZnJvbSAnQHRhcXVpdG8vdXRpbHMnO1xuaW1wb3J0IHsgSW52YWxpZEFkZHJlc3NFcnJvciwgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yIH0gZnJvbSAnQHRhcXVpdG8vY29yZSc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSwgU3VwcHJlc3NlZEVycm9yLCBTeW1ib2wgKi9cclxuXHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbnR5cGVvZiBTdXBwcmVzc2VkRXJyb3IgPT09IFwiZnVuY3Rpb25cIiA/IFN1cHByZXNzZWRFcnJvciA6IGZ1bmN0aW9uIChlcnJvciwgc3VwcHJlc3NlZCwgbWVzc2FnZSkge1xyXG4gICAgdmFyIGUgPSBuZXcgRXJyb3IobWVzc2FnZSk7XHJcbiAgICByZXR1cm4gZS5uYW1lID0gXCJTdXBwcmVzc2VkRXJyb3JcIiwgZS5lcnJvciA9IGVycm9yLCBlLnN1cHByZXNzZWQgPSBzdXBwcmVzc2VkLCBlO1xyXG59O1xuXG5jb25zdCBkZWZhdWx0Q2hhaW4gPSAnbWFpbic7XG5jb25zdCBkZWZhdWx0UlBDT3B0aW9ucyA9IHsgYmxvY2s6ICdoZWFkJyB9O1xudmFyIFJQQ01ldGhvZE5hbWU7XG4oZnVuY3Rpb24gKFJQQ01ldGhvZE5hbWUpIHtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0JBS0lOR19SSUdIVFNcIl0gPSBcImdldEJha2luZ1JpZ2h0c1wiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfQkFMTE9UU1wiXSA9IFwiZ2V0QmFsbG90c1wiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfQkFMTE9UX0xJU1RcIl0gPSBcImdldEJhbGxvdExpc3RcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0JJR19NQVBfS0VZXCJdID0gXCJnZXRCaWdNYXBLZXlcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0JJR19NQVBfRVhQUlwiXSA9IFwiZ2V0QmlnTWFwRXhwclwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfQkxPQ0tfSEFTSFwiXSA9IFwiZ2V0QmxvY2tIYXNoXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9CTE9DS1wiXSA9IFwiZ2V0QmxvY2tcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0JMT0NLX0hFQURFUlwiXSA9IFwiZ2V0QmxvY2tIZWFkZXJcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0JMT0NLX01FVEFEQVRBXCJdID0gXCJnZXRCbG9ja01ldGFkYXRhXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9CQUxBTkNFXCJdID0gXCJnZXRCYWxhbmNlXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9DSEFJTl9JRFwiXSA9IFwiZ2V0Q2hhaW5JZFwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfQ09OU1RBTlRTXCJdID0gXCJnZXRDb25zdGFudHNcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0NPTlRSQUNUXCJdID0gXCJnZXRDb250cmFjdFwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfQ1VSUkVOVF9QRVJJT0RcIl0gPSBcImdldEN1cnJlbnRQZXJpb2RcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0NVUlJFTlRfUFJPUE9TQUxcIl0gPSBcImdldEN1cnJlbnRQcm9wb3NhbFwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfQ1VSUkVOVF9RVU9SVU1cIl0gPSBcImdldEN1cnJlbnRRdW9ydW1cIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0RFTEVHQVRFXCJdID0gXCJnZXREZWxlZ2F0ZVwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfREVMRUdBVEVTXCJdID0gXCJnZXREZWxlZ2F0ZXNcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX1ZPVElOR19JTkZPXCJdID0gXCJnZXRWb3RpbmdJbmZvXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9BVFRFU1RBVElPTl9SSUdIVFNcIl0gPSBcImdldEF0dGVzdGF0aW9uUmlnaHRzXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9FTkRPUlNJTkdfUklHSFRTXCJdID0gXCJnZXRFbmRvcnNpbmdSaWdodHNcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX0VOVFJZUE9JTlRTXCJdID0gXCJnZXRFbnRyeXBvaW50c1wiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfTElWRV9CTE9DS1NcIl0gPSBcImdldExpdmVCbG9ja3NcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX01BTkFHRVJfS0VZXCJdID0gXCJnZXRNYW5hZ2VyS2V5XCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9OT1JNQUxJWkVEX1NDUklQVFwiXSA9IFwiZ2V0Tm9ybWFsaXplZFNjcmlwdFwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfUFJPUE9TQUxTXCJdID0gXCJnZXRQcm9wb3NhbHNcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX1BST1RPQ09MU1wiXSA9IFwiZ2V0UHJvdG9jb2xzXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9TQVBMSU5HX0RJRkZfQllfQ09OVFJBQ1RcIl0gPSBcImdldFNhcGxpbmdEaWZmQnlDb250cmFjdFwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfU0FQTElOR19ESUZGX0JZX0lEXCJdID0gXCJnZXRTYXBsaW5nRGlmZkJ5SWRcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX1NDUklQVFwiXSA9IFwiZ2V0U2NyaXB0XCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9TVE9SQUdFXCJdID0gXCJnZXRTdG9yYWdlXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9TVUNDRVNTT1JfUEVSSU9EXCJdID0gXCJnZXRTdWNjZXNzb3JQZXJpb2RcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX1ZPVEVTX0xJU1RJTkdTXCJdID0gXCJnZXRWb3Rlc0xpc3RpbmdzXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIlBBQ0tfREFUQVwiXSA9IFwicGFja0RhdGFcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX1NUT1JBR0VfVVNFRF9TUEFDRVwiXSA9IFwiZ2V0U3RvcmFnZVVzZWRTcGFjZVwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfU1RPUkFHRV9QQUlEX1NQQUNFXCJdID0gXCJnZXRTdG9yYWdlUGFpZFNwYWNlXCI7XG4gICAgUlBDTWV0aG9kTmFtZVtcIkdFVF9USUNLRVRfQkFMQU5DRVwiXSA9IFwiZ2V0VGlja2V0QmFsYW5jZVwiO1xuICAgIFJQQ01ldGhvZE5hbWVbXCJHRVRfQUxMX1RJQ0tFVF9CQUxBTkNFU1wiXSA9IFwiZ2V0QWxsVGlja2V0QmFsYW5jZXNcIjtcbiAgICBSUENNZXRob2ROYW1lW1wiR0VUX1BFTkRJTkdfT1BFUkFUSU9OU1wiXSA9IFwiZ2V0UGVuZGluZ09wZXJhdGlvbnNcIjtcbn0pKFJQQ01ldGhvZE5hbWUgfHwgKFJQQ01ldGhvZE5hbWUgPSB7fSkpO1xuXG4vKipcbiAqIENhc3RzIG9iamVjdC9hcnJheSBpdGVtcyB0byBCaWdOdW1iZXJcbiAqIEBwYXJhbSBkYXRhIGlucHV0IG9iamVjdCBvciBhcnJheVxuICogQHBhcmFtIGtleXMga2V5cyBmb3IgcHJvY2Vzc2luZyBvciBhbGwgaXRlbXMgaWYgbm90IGRlZmluZWRcbiAqXG4gKi9cbmZ1bmN0aW9uIGNhc3RUb0JpZ051bWJlcihkYXRhLCBrZXlzKSB7XG4gICAgY29uc3QgcmV0dXJuQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGlmICh0eXBlb2Yga2V5cyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAga2V5cyA9IE9iamVjdC5rZXlzKGRhdGEpO1xuICAgIH1cbiAgICBjb25zdCByZXNwb25zZSA9IHJldHVybkFycmF5ID8gW10gOiB7fTtcbiAgICBrZXlzLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBpdGVtID0gZGF0YVtrZXldO1xuICAgICAgICBsZXQgcmVzO1xuICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaXRlbSkpIHtcbiAgICAgICAgICAgIHJlcyA9IGNhc3RUb0JpZ051bWJlcihpdGVtKTtcbiAgICAgICAgICAgIHJlc3BvbnNlW2tleV0gPSByZXM7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgcmVzID0gbmV3IEJpZ051bWJlcihpdGVtKTtcbiAgICAgICAgcmVzcG9uc2Vba2V5XSA9IHJlcztcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzcG9uc2U7XG59XG5cbmNvbnN0IGRlZmF1bHRUdGwgPSAxMDAwO1xuLyoqKlxuICogQGRlc2NyaXB0aW9uIFJwY0NsaWVudENhY2hlIGFjdHMgYXMgYSBkZWNvcmF0b3Igb3ZlciB0aGUgUnBjQ2xpZW50IGluc3RhbmNlIGJ5IGNhY2hpbmcgcmVzcG9uc2VzIGZvciB0aGUgcGVyaW9kIGRlZmluZWQgYnkgdGhlIHR0bC5cbiAqL1xuY2xhc3MgUnBjQ2xpZW50Q2FjaGUge1xuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIHJwY0NsaWVudCBycGNDbGllbnQgcmVzcG9uc2libGUgb2YgdGhlIGludGVyYWN0aW9uIHdpdGggVGV6b3MgbmV0d29yayB0aHJvdWdoIGFuIHJwYyBub2RlXG4gICAgICogQHBhcmFtIHR0bCBudW1iZXIgcmVwcmVzZW50aW5nIHRoZSB0aW1lIHRvIGxpdmUgKGRlZmF1bHQgMTAwMCBtaWxsaXNlY29uZHMpXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBuZXcgUnBjQ2xpZW50Q2FjaGUobmV3IFJwY0NsaWVudCgnaHR0cHM6Ly9tYWlubmV0LmVjYWRpbmZyYS5jb20vJykpXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocnBjQ2xpZW50LCB0dGwgPSBkZWZhdWx0VHRsKSB7XG4gICAgICAgIHRoaXMucnBjQ2xpZW50ID0gcnBjQ2xpZW50O1xuICAgICAgICB0aGlzLnR0bCA9IHR0bDtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgZ2V0QWxsQ2FjaGVkRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVtb3ZlIGFsbCB0aGUgZGF0YSBpbiB0aGUgY2FjaGUuXG4gICAgICpcbiAgICAgKi9cbiAgICBkZWxldGVBbGxDYWNoZWREYXRhKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLl9jYWNoZSkge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2NhY2hlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9ybWF0Q2FjaGVLZXkocnBjVXJsLCBycGNNZXRob2ROYW1lLCBycGNNZXRob2RQYXJhbXMsIHJwY01ldGhvZERhdGEpIHtcbiAgICAgICAgbGV0IHBhcmFtc1RvU3RyaW5nID0gJyc7XG4gICAgICAgIHJwY01ldGhvZFBhcmFtcy5mb3JFYWNoKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgcGFyYW1zVG9TdHJpbmcgPVxuICAgICAgICAgICAgICAgIHR5cGVvZiBwYXJhbSA9PT0gJ29iamVjdCdcbiAgICAgICAgICAgICAgICAgICAgPyBwYXJhbXNUb1N0cmluZyArIEpTT04uc3RyaW5naWZ5KHBhcmFtKSArICcvJ1xuICAgICAgICAgICAgICAgICAgICA6IHBhcmFtc1RvU3RyaW5nICsgcGFyYW0gKyAnLyc7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcnBjTWV0aG9kRGF0YVxuICAgICAgICAgICAgPyBgJHtycGNVcmx9LyR7cnBjTWV0aG9kTmFtZX0vJHtwYXJhbXNUb1N0cmluZ30ke0pTT04uc3RyaW5naWZ5KHJwY01ldGhvZERhdGEpfS9gXG4gICAgICAgICAgICA6IGAke3JwY1VybH0vJHtycGNNZXRob2ROYW1lfS8ke3BhcmFtc1RvU3RyaW5nfWA7XG4gICAgfVxuICAgIGhhcyhrZXkpIHtcbiAgICAgICAgcmV0dXJuIGtleSBpbiB0aGlzLl9jYWNoZTtcbiAgICB9XG4gICAgZ2V0KGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVba2V5XS5yZXNwb25zZTtcbiAgICB9XG4gICAgcHV0KGtleSwgcmVzcG9uc2UpIHtcbiAgICAgICAgY29uc3QgaGFuZGxlID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yZW1vdmUoa2V5KTtcbiAgICAgICAgfSwgdGhpcy50dGwpO1xuICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2NhY2hlLCB7IFtrZXldOiB7IGhhbmRsZSwgcmVzcG9uc2UgfSB9KTtcbiAgICB9XG4gICAgcmVtb3ZlKGtleSkge1xuICAgICAgICBpZiAoa2V5IGluIHRoaXMuX2NhY2hlKSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fY2FjaGVba2V5XTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcykge1xuICAgICAgICBjb25zdCBhZGRyZXNzVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgaWYgKGFkZHJlc3NWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihhZGRyZXNzLCBpbnZhbGlkRGV0YWlsKGFkZHJlc3NWYWxpZGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFsaWRhdGVDb250cmFjdChhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NWYWxpZGF0aW9uID0gdmFsaWRhdGVDb250cmFjdEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIGlmIChhZGRyZXNzVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcihhZGRyZXNzLCBpbnZhbGlkRGV0YWlsKGFkZHJlc3NWYWxpZGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgYmxvY2sncyBoYXNoLCBpdHMgdW5pcXVlIGlkZW50aWZpZXIuXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWhhc2hcbiAgICAgKi9cbiAgICBnZXRCbG9ja0hhc2goeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX0JMT0NLX0hBU0gsIFtcbiAgICAgICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0QmxvY2tIYXNoKHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIExpc3QgdGhlIGFuY2VzdG9ycyBvZiB0aGUgZ2l2ZW4gYmxvY2sgd2hpY2gsIGlmIHJlZmVycmVkIHRvIGFzIHRoZSBicmFuY2ggaW4gYW4gb3BlcmF0aW9uIGhlYWRlciwgYXJlIHJlY2VudCBlbm91Z2ggZm9yIHRoYXQgb3BlcmF0aW9uIHRvIGJlIGluY2x1ZGVkIGluIHRoZSBjdXJyZW50IGJsb2NrLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1saXZlLWJsb2Nrc1xuICAgICAqL1xuICAgIGdldExpdmVCbG9ja3MoeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX0xJVkVfQkxPQ0tTLCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldExpdmVCbG9ja3MoeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgYmFsYW5jZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIHNwZW5kYWJsZSBiYWxhbmNlIG9mIGEgY29udHJhY3QsIGV4Y2x1ZGluZyBmcm96ZW4gYm9uZHNcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtY29udGV4dC1jb250cmFjdHMtY29udHJhY3QtaWQtYmFsYW5jZVxuICAgICAqL1xuICAgIGdldEJhbGFuY2UoYWRkcmVzcywgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfQkFMQU5DRSwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldEJhbGFuY2UoYWRkcmVzcywgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgc3RvcmFnZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIGRhdGEgb2YgdGhlIGNvbnRyYWN0LlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1zdG9yYWdlXG4gICAgICovXG4gICAgZ2V0U3RvcmFnZShhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvbnRyYWN0KGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfU1RPUkFHRSwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldFN0b3JhZ2UoYWRkcmVzcywgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgc2NyaXB0XG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgY29kZSBhbmQgZGF0YSBvZiB0aGUgY29udHJhY3QuXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLXNjcmlwdFxuICAgICAqL1xuICAgIGdldFNjcmlwdChhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUNvbnRyYWN0KGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfU0NSSVBULCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0U2NyaXB0KGFkZHJlc3MsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIHNjcmlwdFxuICAgICAqIEBwYXJhbSB1bnBhcnNpbmdNb2RlIGRlZmF1bHQgaXMgeyB1bnBhcnNpbmdfbW9kZTogXCJSZWFkYWJsZVwiIH1cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBzY3JpcHQgb2YgdGhlIGNvbnRyYWN0IGFuZCBub3JtYWxpemUgaXQgdXNpbmcgdGhlIHJlcXVlc3RlZCB1bnBhcnNpbmcgbW9kZS5cbiAgICAgKi9cbiAgICBnZXROb3JtYWxpemVkU2NyaXB0KGFkZHJlc3MsIHVucGFyc2luZ01vZGUgPSB7IHVucGFyc2luZ19tb2RlOiAnUmVhZGFibGUnIH0sIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29udHJhY3QoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9OT1JNQUxJWkVEX1NDUklQVCwgW2Jsb2NrLCBhZGRyZXNzXSwgdW5wYXJzaW5nTW9kZSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXROb3JtYWxpemVkU2NyaXB0KGFkZHJlc3MsIHVucGFyc2luZ01vZGUsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBjb21wbGV0ZSBzdGF0dXMgb2YgYSBjb250cmFjdC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtY29udGV4dC1jb250cmFjdHMtY29udHJhY3QtaWRcbiAgICAgKi9cbiAgICBnZXRDb250cmFjdChhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9DT05UUkFDVCwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldENvbnRyYWN0KGFkZHJlc3MsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIG1hbmFnZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBtYW5hZ2VyIG9mIGFuIGltcGxpY2l0IGNvbnRyYWN0XG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLW1hbmFnZXIta2V5XG4gICAgICovXG4gICAgZ2V0TWFuYWdlcktleShhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9NQU5BR0VSX0tFWSwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgICAgIGFkZHJlc3MsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldE1hbmFnZXJLZXkoYWRkcmVzcywgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgZGVsZWdhdGUgKGJha2VyKVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIGRlbGVnYXRlIG9mIGEgY29udHJhY3QsIGlmIGFueVxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1kZWxlZ2F0ZVxuICAgICAqL1xuICAgIGdldERlbGVnYXRlKGFkZHJlc3MsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX0RFTEVHQVRFLCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0RGVsZWdhdGUoYWRkcmVzcywgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIGZhdm9yIG9mIGdldEJpZ01hcEtleUJ5SURcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgYmlnIG1hcCBrZXlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBrZXkgaW4gdGhlIGJpZyBtYXAgc3RvcmFnZSBvZiB0aGUgY29udHJhY3QuXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjcG9zdC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1iaWctbWFwLWdldFxuICAgICAqL1xuICAgIGdldEJpZ01hcEtleShhZGRyZXNzLCBrZXksIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGtleVVybCA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX0JJR19NQVBfS0VZLCBbYmxvY2ssIGFkZHJlc3NdLCBrZXkpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleVVybCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5VXJsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0QmlnTWFwS2V5KGFkZHJlc3MsIGtleSwgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXlVcmwsIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gaWQgQmlnIE1hcCBJRFxuICAgICAqIEBwYXJhbSBleHByIEV4cHJlc3Npb24gaGFzaCB0byBxdWVyeSAoQSBiNThjaGVjayBlbmNvZGVkIEJsYWtlMmIgaGFzaCBvZiB0aGUgZXhwcmVzc2lvbiAoVGhlIGV4cHJlc3Npb24gY2FuIGJlIHBhY2tlZCB1c2luZyB0aGUgcGFja19kYXRhIG1ldGhvZCkpXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGEga2V5IGluIGEgYmlnIG1hcC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtY29udGV4dC1iaWctbWFwcy1iaWctbWFwLWlkLXNjcmlwdC1leHByXG4gICAgICovXG4gICAgZ2V0QmlnTWFwRXhwcihpZCwgZXhwciwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX0JJR19NQVBfRVhQUiwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGV4cHIsXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldEJpZ01hcEV4cHIoaWQsIGV4cHIsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgZGVsZWdhdGUgYWRkcmVzcyB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEV2ZXJ5dGhpbmcgYWJvdXQgYSBkZWxlZ2F0ZVxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWRlbGVnYXRlcy1wa2hcbiAgICAgKi9cbiAgICBnZXREZWxlZ2F0ZXMoYWRkcmVzcywgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfREVMRUdBVEVTLCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0RGVsZWdhdGVzKGFkZHJlc3MsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgZGVsZWdhdGUgYWRkcmVzcyB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIGRlbGVnYXRlIGluZm8gKGUuZy4gdm90aW5nIHBvd2VyKSBmb3VuZCBpbiB0aGUgbGlzdGluZ3Mgb2YgdGhlIGN1cnJlbnQgdm90aW5nIHBlcmlvZFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYWN0aXZlL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWRlbGVnYXRlcy1wa2gtdm90aW5nLWluZm9cbiAgICAgKi9cbiAgICBnZXRWb3RpbmdJbmZvKGFkZHJlc3MsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX1ZPVElOR19JTkZPLCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAgICAgYWRkcmVzcyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0Vm90aW5nSW5mbyhhZGRyZXNzLCB7IGJsb2NrIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHV0KGtleSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGwgY29uc3RhbnRzXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29uc3RhbnRzXG4gICAgICovXG4gICAgZ2V0Q29uc3RhbnRzKHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9DT05TVEFOVFMsIFtcbiAgICAgICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0Q29uc3RhbnRzKHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpIGFuZCB2ZXJzaW9uLlxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGwgdGhlIGluZm9ybWF0aW9uIGFib3V0IGEgYmxvY2tcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWRcbiAgICAgKiBAZXhhbXBsZSBnZXRCbG9jaygpIHdpbGwgZGVmYXVsdCB0byBgL21haW4vY2hhaW5zL2Jsb2NrL2hlYWQ/dmVyc2lvbj0wYCB3aGljaCBzaG93cyB7IGtpbmQ6IGVuZG9yc2VtZW50IH1cbiAgICAgKiBAZXhhbXBsZSBnZXRCbG9jayh7IGJsb2NrOiAnaGVhZH4yJywgdmVyc2lvbjogMSB9KSB3aWxsIHJldHVybiBhbiBvZmZzZXQgb2YgMiBmcm9tIGhlYWQgYmxvY2tzIGFuZCBzaG93cyB7IGtpbmQ6IGF0dGVzdGF0aW9uIH1cbiAgICAgKiBAZXhhbXBsZSBnZXRCbG9jayh7IGJsb2NrOiAnQkw4ZlRpV2NTeFdDamlNVm5Ea2JoNkV1aHFWUFp6Z1doZUoyZHF3cnhZUm05QWVwaFhofjInIH0pIHdpbGwgcmV0dXJuIGFuIG9mZnNldCBvZiAyIGJsb2NrcyBmcm9tIGdpdmVuIGJsb2NrIGhhc2guLlxuICAgICAqL1xuICAgIGdldEJsb2NrKHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9CTE9DSywgW2Jsb2NrXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRCbG9jayh7IGJsb2NrIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHV0KGtleSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgd2hvbGUgYmxvY2sgaGVhZGVyXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWhlYWRlclxuICAgICAqL1xuICAgIGdldEJsb2NrSGVhZGVyKHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9CTE9DS19IRUFERVIsIFtcbiAgICAgICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0QmxvY2tIZWFkZXIoeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZCkgYW5kIHZlcnNpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQWxsIHRoZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSBibG9ja1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1tZXRhZGF0YVxuICAgICAqL1xuICAgIGdldEJsb2NrTWV0YWRhdGEoeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX0JMT0NLX01FVEFEQVRBLCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldEJsb2NrTWV0YWRhdGEoeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYXJncyBjb250YWlucyBvcHRpb25hbCBxdWVyeSBhcmd1bWVudHMgKGxldmVsLCBjeWNsZSwgZGVsZWdhdGUsIGNvbnNlbnN1c19rZXksIGFuZCBtYXhfcm91bmQpXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgbGlzdCBvZiBkZWxlZ2F0ZXMgYWxsb3dlZCB0byBiYWtlIGEgYmxvY2suXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWhlbHBlcnMtYmFraW5nLXJpZ2h0c1xuICAgICAqL1xuICAgIGdldEJha2luZ1JpZ2h0cyhhcmdzID0ge30sIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9CQUtJTkdfUklHSFRTLCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICAgICAgYXJncyxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0QmFraW5nUmlnaHRzKGFyZ3MsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3MgY29udGFpbnMgb3B0aW9uYWwgcXVlcnkgYXJndW1lbnRzIChsZXZlbCwgY3ljbGUsIGRlbGVnYXRlLCBhbmQgY29uc2Vuc3VzX2tleSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBkZWxlZ2F0ZXMgYWxsb3dlZCB0byBhdHRlc3QgYSBibG9ja1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1oZWxwZXJzLWVuZG9yc2luZy1yaWdodHNcbiAgICAgKi9cbiAgICBnZXRBdHRlc3RhdGlvblJpZ2h0cyhhcmdzID0ge30sIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9BVFRFU1RBVElPTl9SSUdIVFMsIFtibG9jaywgYXJnc10pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0QXR0ZXN0YXRpb25SaWdodHMoYXJncywgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIGZhdm9yIG9mIGdldEF0dGVzdGF0aW9uUmlnaHRzXG4gICAgICogQHBhcmFtIGFyZ3MgY29udGFpbnMgb3B0aW9uYWwgcXVlcnkgYXJndW1lbnRzIChsZXZlbCwgY3ljbGUsIGRlbGVnYXRlLCBhbmQgY29uc2Vuc3VzX2tleSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxsc1xuICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIGRlbGVnYXRlcyBhbGxvd2VkIHRvIGVuZG9yc2UgYSBibG9ja1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1oZWxwZXJzLWVuZG9yc2luZy1yaWdodHNcbiAgICAgKi9cbiAgICBnZXRFbmRvcnNpbmdSaWdodHMoYXJncyA9IHt9LCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfRU5ET1JTSU5HX1JJR0hUUywgW2Jsb2NrLCBhcmdzXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRFbmRvcnNpbmdSaWdodHMoYXJncywgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQmFsbG90cyBjYXN0ZWQgc28gZmFyIGR1cmluZyBhIHZvdGluZyBwZXJpb2RcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtdm90ZXMtYmFsbG90LWxpc3RcbiAgICAgKi9cbiAgICBnZXRCYWxsb3RMaXN0KHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9CQUxMT1RfTElTVCwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRCYWxsb3RMaXN0KHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFN1bSBvZiBiYWxsb3RzIGNhc3RlZCBzbyBmYXIgZHVyaW5nIGEgdm90aW5nIHBlcmlvZFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1iYWxsb3RzXG4gICAgICovXG4gICAgZ2V0QmFsbG90cyh7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfQkFMTE9UUywgW2Jsb2NrXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRCYWxsb3RzKHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEN1cnJlbnQgcHJvcG9zYWwgdW5kZXIgZXZhbHVhdGlvbi5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtdm90ZXMtY3VycmVudC1wcm9wb3NhbFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRQcm9wb3NhbCh7IGJsb2NrLCB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX0NVUlJFTlRfUFJPUE9TQUwsIFtibG9ja10pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0Q3VycmVudFByb3Bvc2FsKHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEN1cnJlbnQgZXhwZWN0ZWQgcXVvcnVtLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1jdXJyZW50LXF1b3J1bVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRRdW9ydW0oeyBibG9jaywgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9DVVJSRU5UX1FVT1JVTSwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRDdXJyZW50UXVvcnVtKHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIExpc3Qgb2YgZGVsZWdhdGVzIHdpdGggdGhlaXIgdm90aW5nIHBvd2VyXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLXZvdGVzLWxpc3RpbmdzXG4gICAgICovXG4gICAgZ2V0Vm90ZXNMaXN0aW5ncyh7IGJsb2NrLCB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX1ZPVEVTX0xJU1RJTkdTLCBbXG4gICAgICAgICAgICAgICAgYmxvY2ssXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldFZvdGVzTGlzdGluZ3MoeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gTGlzdCBvZiBwcm9wb3NhbHMgd2l0aCBudW1iZXIgb2Ygc3VwcG9ydGVyc1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1wcm9wb3NhbHNcbiAgICAgKi9cbiAgICBnZXRQcm9wb3NhbHMoeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX1BST1BPU0FMUywgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRQcm9wb3NhbHMoeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBvcGVyYXRpb24gY29udGVudHMgdG8gZm9yZ2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gRm9yZ2UgYW4gb3BlcmF0aW9uIHJldHVybmluZyB0aGUgdW5zaWduZWQgYnl0ZXNcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNwb3N0LWJsb2NrLWlkLWhlbHBlcnMtZm9yZ2Utb3BlcmF0aW9uc1xuICAgICAqL1xuICAgIGZvcmdlT3BlcmF0aW9ucyhkYXRhLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjQ2xpZW50LmZvcmdlT3BlcmF0aW9ucyhkYXRhLCB7IGJsb2NrIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHNpZ25lZE9wQnl0ZXMgc2lnbmVkIGJ5dGVzIHRvIGluamVjdFxuICAgICAqIEBkZXNjcmlwdGlvbiBJbmplY3QgYW4gb3BlcmF0aW9uIGluIG5vZGUgYW5kIGJyb2FkY2FzdCBpdCBhbmQgcmV0dXJuIHRoZSBJRCBvZiB0aGUgb3BlcmF0aW9uXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjcG9zdC1pbmplY3Rpb24tb3BlcmF0aW9uXG4gICAgICovXG4gICAgaW5qZWN0T3BlcmF0aW9uKHNpZ25lZE9wQnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwY0NsaWVudC5pbmplY3RPcGVyYXRpb24oc2lnbmVkT3BCeXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3BzIE9wZXJhdGlvbnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgYW5kIHZlcnNpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gU2ltdWxhdGUgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZSBvcGVyYXRpb25zIHdpdGggdGhlIGNvbnRleHQgb2YgdGhlIGdpdmVuIGJsb2NrIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiBlYWNoIG9wZXJhdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI3Bvc3QtYmxvY2staWQtaGVscGVycy1wcmVhcHBseS1vcGVyYXRpb25zXG4gICAgICovXG4gICAgcHJlYXBwbHlPcGVyYXRpb25zKG9wcywgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwY0NsaWVudC5wcmVhcHBseU9wZXJhdGlvbnMob3BzLCB7IGJsb2NrIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHdlIHdhbnQgdG8gZ2V0IHRoZSBlbnRyeXBvaW50cyBvZlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gdGhlIGxpc3Qgb2YgZW50cnlwb2ludHMgb2YgdGhlIGNvbnRyYWN0XG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLWVudHJ5cG9pbnRzXG4gICAgICogQHZlcnNpb24gMDA1X1BzQkFCWTVIXG4gICAgICovXG4gICAgZ2V0RW50cnlwb2ludHMoY29udHJhY3QsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29udHJhY3QoY29udHJhY3QpO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfRU5UUllQT0lOVFMsIFtcbiAgICAgICAgICAgICAgICBibG9jayxcbiAgICAgICAgICAgICAgICBjb250cmFjdCxcbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0RW50cnlwb2ludHMoY29udHJhY3QsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiBmYXZvciBvZiBzaW11bGF0ZU9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcCBPcGVyYXRpb24gdG8gcnVuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIGFuZCB2ZXJzaW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFJ1biBhbiBvcGVyYXRpb24gd2l0aCB0aGUgY29udGV4dCBvZiB0aGUgZ2l2ZW4gYmxvY2sgYW5kIHdpdGhvdXQgc2lnbmF0dXJlIGNoZWNrcyBhbmQgcmV0dXJuIHRoZSBvcGVyYXRpb24gYXBwbGljYXRpb24gcmVzdWx0LCBpbmNsdWRpbmcgdGhlIGNvbnN1bWVkIGdhcy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNwb3N0LWJsb2NrLWlkLWhlbHBlcnMtc2NyaXB0cy1ydW4tb3BlcmF0aW9uXG4gICAgICovXG4gICAgcnVuT3BlcmF0aW9uKG9wLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjQ2xpZW50LnJ1bk9wZXJhdGlvbihvcCwgeyBibG9jayB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcCBPcGVyYXRpb24gdG8gc2ltdWxhdGVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgYW5kIHZlcnNpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gU2ltdWxhdGUgcnVubmluZyBhbiBvcGVyYXRpb24gYXQgc29tZSBmdXR1cmUgbW9tZW50IChiYXNlZCBvbiB0aGUgbnVtYmVyIG9mIGJsb2NrcyBnaXZlbiBpbiB0aGUgYGxhdGVuY3lgIGFyZ3VtZW50KSwgYW5kIHJldHVybiB0aGUgb3BlcmF0aW9uIGFwcGxpY2F0aW9uIHJlc3VsdC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vZ2l0bGFiLmNvbS90ZXpvcy90ZXpvcy8tL2Jsb2IvbWFzdGVyL2RvY3MvYXBpL294Zm9yZC1vcGVuYXBpLmpzb25cbiAgICAgKi9cbiAgICBzaW11bGF0ZU9wZXJhdGlvbihvcCwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwY0NsaWVudC5zaW11bGF0ZU9wZXJhdGlvbihvcCwgeyBibG9jayB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb2RlIENvZGUgdG8gcnVuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFJ1biBhIE1pY2hlbHNvbiBzY3JpcHQgaW4gdGhlIGN1cnJlbnQgY29udGV4dFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI3Bvc3QtYmxvY2staWQtaGVscGVycy1zY3JpcHRzLXJ1bi1jb2RlXG4gICAgICovXG4gICAgcnVuQ29kZShjb2RlLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjQ2xpZW50LnJ1bkNvZGUoY29kZSwgeyBibG9jayB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSB2aWV3U2NyaXB0UGFyYW1zIFBhcmFtZXRlcnMgb2YgdGhlIHNjcmlwdCB2aWV3IHRvIHJ1blxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBTaW11bGF0ZSBhIGNhbGwgdG8gYSBtaWNoZWxzb24gdmlld1xuICAgICAqL1xuICAgIHJ1blNjcmlwdFZpZXcoX2EsIF9iKSB7XG4gICAgICAgIHZhciB7IHVucGFyc2luZ19tb2RlID0gJ1JlYWRhYmxlJyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInVucGFyc2luZ19tb2RlXCJdKTtcbiAgICAgICAgdmFyIF9jID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRSUENPcHRpb25zIDogX2IsIGJsb2NrID0gX2MuYmxvY2s7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGNDbGllbnQucnVuU2NyaXB0VmlldyhPYmplY3QuYXNzaWduKHsgdW5wYXJzaW5nX21vZGUgfSwgcmVzdCksIHsgYmxvY2sgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmlld1BhcmFtcyBQYXJhbWV0ZXJzIG9mIHRoZSB2aWV3IHRvIHJ1blxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBTaW11bGF0ZSBhIGNhbGwgdG8gYSB2aWV3IGZvbGxvd2luZyB0aGUgVFpJUC00IHN0YW5kYXJkLiBTZWUgaHR0cHM6Ly9naXRsYWIuY29tL3R6aXAvdHppcC8tL2Jsb2IvbWFzdGVyL3Byb3Bvc2Fscy90emlwLTQvdHppcC00Lm1kI3ZpZXctZW50cnlwb2ludHMuXG4gICAgICovXG4gICAgcnVuVmlldyhfYSwgX2IpIHtcbiAgICAgICAgdmFyIHsgdW5wYXJzaW5nX21vZGUgPSAnUmVhZGFibGUnIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1widW5wYXJzaW5nX21vZGVcIl0pO1xuICAgICAgICB2YXIgX2MgPSBfYiA9PT0gdm9pZCAwID8gZGVmYXVsdFJQQ09wdGlvbnMgOiBfYiwgYmxvY2sgPSBfYy5ibG9jaztcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwY0NsaWVudC5ydW5WaWV3KE9iamVjdC5hc3NpZ24oeyB1bnBhcnNpbmdfbW9kZSB9LCByZXN0KSwgeyBibG9jayB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENoYWluSWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9DSEFJTl9JRCwgW10pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0Q2hhaW5JZCgpO1xuICAgICAgICAgICAgICAgIHRoaXMucHV0KGtleSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBkYXRhIERhdGEgdG8gcGFja1xuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBDb21wdXRlcyB0aGUgc2VyaWFsaXplZCB2ZXJzaW9uIG9mIGEgZGF0YSBleHByZXNzaW9uIHVzaW5nIHRoZSBzYW1lIGFsZ29yaXRobSBhcyBzY3JpcHQgaW5zdHJ1Y3Rpb24gUEFDS1xuICAgICAqIE5vdGU6IFlvdSBzaG91bGQgYWx3YXlzIHZlcmlmeSB0aGUgcGFja2VkIGJ5dGVzIGJlZm9yZSBzaWduaW5nIG9yIHJlcXVlc3RpbmcgdGhhdCB0aGV5IGJlIHNpZ25lZCB3aGVuIHVzaW5nIHRoZSB0aGUgUlBDIHRvIHBhY2suXG4gICAgICogVGhpcyBwcmVjYXV0aW9uIGhlbHBzIHByb3RlY3QgeW91IGFuZCB5b3VyIGFwcGxpY2F0aW9ucyB1c2VycyBmcm9tIFJQQyBub2RlcyB0aGF0IGhhdmUgYmVlbiBjb21wcm9taXNlZC5cbiAgICAgKiBBIG5vZGUgdGhhdCBpcyBvcGVyYXRlZCBieSBhIGJhZCBhY3Rvciwgb3IgY29tcHJvbWlzZWQgYnkgYSBiYWQgYWN0b3IgY291bGQgcmV0dXJuIGEgZnVsbHkgZm9ybWVkIG9wZXJhdGlvbiB0aGF0IGRvZXMgbm90IGNvcnJlc3BvbmQgdG8gdGhlIGlucHV0IHByb3ZpZGVkIHRvIHRoZSBSUEMgZW5kcG9pbnQuXG4gICAgICogQSBzYWZlciBzb2x1dGlvbiB0byBwYWNrIGFuZCBzaWduIGRhdGEgd291bGQgYmUgdG8gdXNlIHRoZSBgcGFja0RhdGFCeXRlc2AgZnVuY3Rpb24gYXZhaWxhYmxlIGluIHRoZSBgQHRhcXVpdG8vbWljaGVsLWNvZGVjYCBwYWNrYWdlLlxuICAgICAqIEBleGFtcGxlIHBhY2tEYXRhKHsgZGF0YTogeyBzdHJpbmc6IFwidGVzdFwiIH0sIHR5cGU6IHsgcHJpbTogXCJzdHJpbmdcIiB9IH0pXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjcG9zdC1ibG9jay1pZC1oZWxwZXJzLXNjcmlwdHMtcGFjay1kYXRhXG4gICAgICovXG4gICAgcGFja0RhdGEoZGF0YSwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuUEFDS19EQVRBLCBbYmxvY2tdLCBkYXRhKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LnBhY2tEYXRhKGRhdGEsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIHJwYyByb290IHVybFxuICAgICAqL1xuICAgIGdldFJwY1VybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgdm90aW5nIHBlcmlvZCAoaW5kZXgsIGtpbmQsIHN0YXJ0aW5nIHBvc2l0aW9uKSBhbmQgcmVsYXRlZCBpbmZvcm1hdGlvbiAocG9zaXRpb24sIHJlbWFpbmluZykgb2YgdGhlIGludGVycm9nYXRlZCBibG9ja1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1jdXJyZW50LXBlcmlvZFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRQZXJpb2QoeyBibG9jaywgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9DVVJSRU5UX1BFUklPRCwgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRDdXJyZW50UGVyaW9kKHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIHZvdGluZyBwZXJpb2QgKGluZGV4LCBraW5kLCBzdGFydGluZyBwb3NpdGlvbikgYW5kIHJlbGF0ZWQgaW5mb3JtYXRpb24gKHBvc2l0aW9uLCByZW1haW5pbmcpIG9mIHRoZSBuZXh0IGJsb2NrLlVzZWZ1bCB0byBjcmFmdCBvcGVyYXRpb25zIHRoYXQgd2lsbCBiZSB2YWxpZCBpbiB0aGUgbmV4dCBibG9ja1xuICAgICAqIEBleGFtcGxlIGdldFN1Y2Nlc3NvclBlcmlvZCgpIHdpbGwgZGVmYXVsdCB0byBzdWNjZXNzb3Igdm90aW5nIHBlcmlvZCBmb3IgL21haW4vY2hhaW5zL2Jsb2NrL2hlYWQuXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLXZvdGVzLXN1Y2Nlc3Nvci1wZXJpb2RcbiAgICAgKi9cbiAgICBnZXRTdWNjZXNzb3JQZXJpb2QoeyBibG9jaywgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9TVUNDRVNTT1JfUEVSSU9ELCBbYmxvY2tdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldFN1Y2Nlc3NvclBlcmlvZCh7IGJsb2NrIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHV0KGtleSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpZCBTYXBsaW5nIHN0YXRlIElEXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIHJvb3QgYW5kIGEgZGlmZiBvZiBhIHN0YXRlIHN0YXJ0aW5nIGZyb20gYW4gb3B0aW9uYWwgb2Zmc2V0IHdoaWNoIGlzIHplcm8gYnkgZGVmYXVsdFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYWN0aXZlL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LXNhcGxpbmctc2FwbGluZy1zdGF0ZS1pZC1nZXQtZGlmZlxuICAgICAqL1xuICAgIGdldFNhcGxpbmdEaWZmQnlJZChpZCwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX1NBUExJTkdfRElGRl9CWV9JRCwgW2Jsb2NrLCBpZF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0U2FwbGluZ0RpZmZCeUlkKGlkLCB7IGJsb2NrIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHV0KGtleSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB3ZSB3YW50IHRvIGdldCB0aGUgc2FwbGluZyBkaWZmXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIHJvb3QgYW5kIGEgZGlmZiBvZiBhIHN0YXRlIHN0YXJ0aW5nIGZyb20gYW4gb3B0aW9uYWwgb2Zmc2V0IHdoaWNoIGlzIHplcm8gYnkgZGVmYXVsdFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYWN0aXZlL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1zaW5nbGUtc2FwbGluZy1nZXQtZGlmZlxuICAgICAqL1xuICAgIGdldFNhcGxpbmdEaWZmQnlDb250cmFjdChjb250cmFjdCwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX1NBUExJTkdfRElGRl9CWV9DT05UUkFDVCwgW2Jsb2NrLCBjb250cmFjdF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0U2FwbGluZ0RpZmZCeUNvbnRyYWN0KGNvbnRyYWN0LCB7IGJsb2NrIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHV0KGtleSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXQgY3VycmVudCBhbmQgbmV4dCBwcm90b2NvbFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYWN0aXZlL3JwYy5odG1sI2dldC1ibG9jay1pZC1wcm90b2NvbHNcbiAgICAgKi9cbiAgICBnZXRQcm90b2NvbHMoeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX1BST1RPQ09MUywgW1xuICAgICAgICAgICAgICAgIGJsb2NrLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRQcm90b2NvbHMoeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgY29udHJhY3Qgd2Ugd2FudCB0byByZXRyaWV2ZSBzdG9yYWdlIGluZm9ybWF0aW9uIG9mXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgdXNlZCBzdG9yYWdlIHNwYWNlIG9mIHRoZSBjb250cmFjdFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vbGltYS9ycGMuaHRtbCNnZXQtYmxvY2staWQtY29udGV4dC1jb250cmFjdHMtY29udHJhY3QtaWQtc3RvcmFnZVxuICAgICAqL1xuICAgIGdldFN0b3JhZ2VVc2VkU3BhY2UoY29udHJhY3QsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9TVE9SQUdFX1VTRURfU1BBQ0UsIFtibG9jaywgY29udHJhY3RdKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHRoaXMucnBjQ2xpZW50LmdldFN0b3JhZ2VVc2VkU3BhY2UoY29udHJhY3QsIHsgYmxvY2sgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXQoa2V5LCByZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHdlIHdhbnQgdG8gcmV0cmlldmUgc3RvcmFnZSBpbmZvcm1hdGlvbiBvZlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICA9ICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBwYWlkIHN0b3JhZ2Ugc3BhY2Ugb2YgdGhlIGNvbnRyYWN0XG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9saW1hL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1zdG9yYWdlXG4gICAgICovXG4gICAgZ2V0U3RvcmFnZVBhaWRTcGFjZShjb250cmFjdCwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGtleSA9IHRoaXMuZm9ybWF0Q2FjaGVLZXkodGhpcy5ycGNDbGllbnQuZ2V0UnBjVXJsKCksIFJQQ01ldGhvZE5hbWUuR0VUX1NUT1JBR0VfUEFJRF9TUEFDRSwgW2Jsb2NrLCBjb250cmFjdF0pO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0U3RvcmFnZVBhaWRTcGFjZShjb250cmFjdCwgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgaW1wbGljaXQgb3Igb3JpZ2luYXRlZCBhZGRyZXNzIHdlIHdhbnQgdG8gcmV0cmlldmUgdGlja2V0IGJhbGFuY2Ugb2ZcbiAgICAgKiBAcGFyYW0gdGlja2V0IG9iamVjdCB0byBzcGVjaWZ5IGEgdGlja2V0IGJ5IHRpY2tldGVyLCBjb250ZW50IHR5cGUgYW5kIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBjb250cmFjdCdzIGJhbGFuY2Ugb2YgdGlja2V0IHdpdGggc3BlY2lmaWVkIHRpY2tldGVyLCBjb250ZW50IHR5cGUsIGFuZCBjb250ZW50LlxuICAgICAqIEBleGFtcGxlIHRpY2tldCB7IHRpY2tldGVyOiAnYWRkcmVzcycsIGNvbnRlbnRfdHlwZTogeyBwcmltOiBcInN0cmluZ1wiIH0sIGNvbnRlbnQ6IHsgc3RyaW5nOiAndGlja2V0MScgfSB9XG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9wcm90b2NvbHMvMDE2X211bWJhaS5odG1sI3JwYy1jaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0VGlja2V0QmFsYW5jZShjb250cmFjdCwgdGlja2V0LCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gdGhpcy5mb3JtYXRDYWNoZUtleSh0aGlzLnJwY0NsaWVudC5nZXRScGNVcmwoKSwgUlBDTWV0aG9kTmFtZS5HRVRfVElDS0VUX0JBTEFOQ0UsIFtibG9jaywgY29udHJhY3RdLCB0aWNrZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaGFzKGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0gdGhpcy5ycGNDbGllbnQuZ2V0VGlja2V0QmFsYW5jZShjb250cmFjdCwgdGlja2V0LCB7IGJsb2NrIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMucHV0KGtleSwgcmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb250cmFjdCBvcmlnaW5hdGVkIGFkZHJlc3Mgd2Ugd2FudCB0byByZXRyaWV2ZSB0aWNrZXQgYmFsYW5jZXMgb2ZcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBjb21wbGV0ZSBsaXN0IG9mIHRpY2tldHMgb3duZWQgYnkgdGhlIGdpdmVuIGNvbnRyYWN0IGJ5IHNjYW5uaW5nIHRoZSBjb250cmFjdCdzIHN0b3JhZ2UuXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9wcm90b2NvbHMvMDE2X211bWJhaS5odG1sI3JwYy1jaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0QWxsVGlja2V0QmFsYW5jZXMoY29udHJhY3QsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9BTExfVElDS0VUX0JBTEFOQ0VTLCBbYmxvY2ssIGNvbnRyYWN0XSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRBbGxUaWNrZXRCYWxhbmNlcyhjb250cmFjdCwgeyBibG9jayB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gTGlzdCB0aGUgcHJldmFsaWRhdGVkIG9wZXJhdGlvbnMgaW4gbWVtcG9vbCAoYWNjZXNzaWJpbGl0eSBvZiBtZW1wb29sIGRlcGVuZHMgb24gZWFjaCBycGMgZW5kcG9pbnQpXG4gICAgICogQHBhcmFtIGFyZ3MgaGFzIDUgb3B0aW9uYWwgcHJvcGVydGllcy4gV2Ugc3VwcG9ydCB2ZXJzaW9uIDEgYXMgZGVmYXVsdCB3aWxsIG91dHB1dCB7IGFwcGxpZWQ6IHsga2luZDogZW5kb3JzZW1lbnR9IH0gdmVyc2lvbiAyIHdpbGwgb3V0cHV0IHsgdmFsaWRhdGVkOiB7IGtpbmQ6IGF0dGVzdGF0aW9ufSB9LiBUaGUgcmVzdCBvZiB0aGUgcHJvcGVydGllcyBpcyB0byBmaWx0ZXIgcGVuZGluZyBvcGVyYXRpb25zIHJlc3BvbnNlXG4gICAgICogQGRlZmF1bHQgYXJncyB7IHZlcnNpb246ICcxJywgYXBwbGllZDogdHJ1ZSwgcmVmdXNlZDogdHJ1ZSwgb3V0ZGF0ZWQsIHRydWUsIGJyYW5jaFJlZnVzZWQ6IHRydWUsIGJyYW5jaERlbGF5ZWQ6IHRydWUsIHZhbGlkYXRpb25QYXNzOiB1bmRlZmluZWQgfVxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vQ0hBTkdFUy5odG1sP2hpZ2hsaWdodD1wZW5kaW5nX29wZXJhdGlvbnMjaWQ0XG4gICAgICovXG4gICAgZ2V0UGVuZGluZ09wZXJhdGlvbnMoYXJncyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmZvcm1hdENhY2hlS2V5KHRoaXMucnBjQ2xpZW50LmdldFJwY1VybCgpLCBSUENNZXRob2ROYW1lLkdFVF9QRU5ESU5HX09QRVJBVElPTlMsIFthcmdzXSk7XG4gICAgICAgICAgICBpZiAodGhpcy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChrZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB0aGlzLnJwY0NsaWVudC5nZXRQZW5kaW5nT3BlcmF0aW9ucyhhcmdzKTtcbiAgICAgICAgICAgICAgICB0aGlzLnB1dChrZXksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxudmFyIE9QRVJBVElPTl9NRVRBREFUQTtcbihmdW5jdGlvbiAoT1BFUkFUSU9OX01FVEFEQVRBKSB7XG4gICAgT1BFUkFUSU9OX01FVEFEQVRBW1wiVE9PX0xBUkdFXCJdID0gXCJ0b28gbGFyZ2VcIjtcbn0pKE9QRVJBVElPTl9NRVRBREFUQSB8fCAoT1BFUkFUSU9OX01FVEFEQVRBID0ge30pKTtcbnZhciBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUlk7XG4oZnVuY3Rpb24gKE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWSkge1xuICAgIE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWVtcIkJBS0lOR19CT05VU0VTXCJdID0gXCJiYWtpbmcgYm9udXNlc1wiO1xuICAgIE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWVtcIkJBS0lOR19SRVdBUkRTXCJdID0gXCJiYWtpbmcgcmV3YXJkc1wiO1xuICAgIE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWVtcIkJMT0NLX0ZFRVNcIl0gPSBcImJsb2NrIGZlZXNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJCT05EU1wiXSA9IFwiYm9uZHNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJCT09UU1RSQVBcIl0gPSBcImJvb3RzdHJhcFwiO1xuICAgIE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWVtcIkJVUk5FRFwiXSA9IFwiYnVybmVkXCI7XG4gICAgTUVUQURBVEFfQkFMQU5DRV9VUERBVEVTX0NBVEVHT1JZW1wiQ09NTUlUTUVOVFwiXSA9IFwiY29tbWl0bWVudFwiO1xuICAgIE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWVtcIkRFTEVHQVRFX0RFTk9NSU5BVE9SXCJdID0gXCJkZWxlZ2F0ZV9kZW5vbWluYXRvclwiO1xuICAgIE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWVtcIkRFTEVHQVRPUl9OVU1FUkFUT1JcIl0gPSBcImRlbGVnYXRvcl9udW1lcmF0b3JcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJERVBPU0lUU1wiXSA9IFwiZGVwb3NpdHNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJFTkRPUlNJTkdfUkVXQVJEU1wiXSA9IFwiZW5kb3JzaW5nIHJld2FyZHNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJJTlZPSUNFXCJdID0gXCJpbnZvaWNlXCI7XG4gICAgTUVUQURBVEFfQkFMQU5DRV9VUERBVEVTX0NBVEVHT1JZW1wiTE9TVF9FTkRPUlNJTkdfUkVXQVJEU1wiXSA9IFwibG9zdCBlbmRvcnNpbmcgcmV3YXJkc1wiO1xuICAgIE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWVtcIk1JTlRFRFwiXSA9IFwibWludGVkXCI7XG4gICAgTUVUQURBVEFfQkFMQU5DRV9VUERBVEVTX0NBVEVHT1JZW1wiTk9OQ0VfUkVWRUxBVElPTl9SRVdBUkRTXCJdID0gXCJub25jZSByZXZlbGF0aW9uIHJld2FyZHNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJQVU5JU0hNRU5UU1wiXSA9IFwicHVuaXNobWVudHNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJTTUFSVF9ST0xMVVBfUkVGVVRBVElPTl9QVU5JU0hNRU5UU1wiXSA9IFwic21hcnRfcm9sbHVwX3JlZnV0YXRpb25fcHVuaXNobWVudHNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJTTUFSVF9ST0xMVVBfUkVGVVRBVElPTl9SRVdBUkRTXCJdID0gXCJzbWFydF9yb2xsdXBfcmVmdXRhdGlvbl9yZXdhcmRzXCI7XG4gICAgTUVUQURBVEFfQkFMQU5DRV9VUERBVEVTX0NBVEVHT1JZW1wiU1RPUkFHRV9GRUVTXCJdID0gXCJzdG9yYWdlIGZlZXNcIjtcbiAgICBNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUllbXCJTVUJTSURZXCJdID0gXCJzdWJzaWR5XCI7XG4gICAgTUVUQURBVEFfQkFMQU5DRV9VUERBVEVTX0NBVEVHT1JZW1wiVU5TVEFLRURfREVQT1NJVFNcIl0gPSBcInVuc3Rha2VkX2RlcG9zaXRzXCI7XG59KShNRVRBREFUQV9CQUxBTkNFX1VQREFURVNfQ0FURUdPUlkgfHwgKE1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWSA9IHt9KSk7XG52YXIgUHZtS2luZDtcbihmdW5jdGlvbiAoUHZtS2luZCkge1xuICAgIFB2bUtpbmRbXCJXQVNNMlwiXSA9IFwid2FzbV8yXzBfMFwiO1xuICAgIFB2bUtpbmRbXCJBUklUSFwiXSA9IFwiYXJpdGhcIjtcbiAgICBQdm1LaW5kW1wiUklTQ1ZcIl0gPSBcInJpc2N2XCI7XG59KShQdm1LaW5kIHx8IChQdm1LaW5kID0ge30pKTtcbnZhciBTbWFydFJvbGx1cFJlZnV0YXRpb25PcHRpb25zO1xuKGZ1bmN0aW9uIChTbWFydFJvbGx1cFJlZnV0YXRpb25PcHRpb25zKSB7XG4gICAgU21hcnRSb2xsdXBSZWZ1dGF0aW9uT3B0aW9uc1tcIlNUQVJUXCJdID0gXCJzdGFydFwiO1xuICAgIFNtYXJ0Um9sbHVwUmVmdXRhdGlvbk9wdGlvbnNbXCJNT1ZFXCJdID0gXCJtb3ZlXCI7XG59KShTbWFydFJvbGx1cFJlZnV0YXRpb25PcHRpb25zIHx8IChTbWFydFJvbGx1cFJlZnV0YXRpb25PcHRpb25zID0ge30pKTtcbnZhciBTbWFydFJvbGx1cElucHV0UHJvb2ZLaW5kO1xuKGZ1bmN0aW9uIChTbWFydFJvbGx1cElucHV0UHJvb2ZLaW5kKSB7XG4gICAgU21hcnRSb2xsdXBJbnB1dFByb29mS2luZFtcIklOQk9YX1BST09GXCJdID0gXCJpbmJveF9wcm9vZlwiO1xuICAgIFNtYXJ0Um9sbHVwSW5wdXRQcm9vZktpbmRbXCJSRVZFQUxfUFJPT0ZcIl0gPSBcInJldmVhbF9wcm9vZlwiO1xuICAgIFNtYXJ0Um9sbHVwSW5wdXRQcm9vZktpbmRbXCJGSVJTVF9JTlBVVFwiXSA9IFwiZmlyc3RfaW5wdXRcIjtcbn0pKFNtYXJ0Um9sbHVwSW5wdXRQcm9vZktpbmQgfHwgKFNtYXJ0Um9sbHVwSW5wdXRQcm9vZktpbmQgPSB7fSkpO1xudmFyIFNtYXJ0Um9sbHVwUmVmdXRlUmV2ZWFsUHJvb2ZLaW5kO1xuKGZ1bmN0aW9uIChTbWFydFJvbGx1cFJlZnV0ZVJldmVhbFByb29mS2luZCkge1xuICAgIFNtYXJ0Um9sbHVwUmVmdXRlUmV2ZWFsUHJvb2ZLaW5kW1wiUkFXX0RBVEFfUFJPT0ZcIl0gPSBcInJhd19kYXRhX3Byb29mXCI7XG4gICAgU21hcnRSb2xsdXBSZWZ1dGVSZXZlYWxQcm9vZktpbmRbXCJNRVRBREFUQV9QUk9PRlwiXSA9IFwibWV0YWRhdGFfcHJvb2ZcIjtcbiAgICBTbWFydFJvbGx1cFJlZnV0ZVJldmVhbFByb29mS2luZFtcIkRBTF9QQUdFX1BST09GXCJdID0gXCJkYWxfcGFnZV9wcm9vZlwiO1xufSkoU21hcnRSb2xsdXBSZWZ1dGVSZXZlYWxQcm9vZktpbmQgfHwgKFNtYXJ0Um9sbHVwUmVmdXRlUmV2ZWFsUHJvb2ZLaW5kID0ge30pKTtcbnZhciBTbWFydFJvbGx1cFJlZnV0ZUdhbWVTdGF0dXNPcHRpb25zO1xuKGZ1bmN0aW9uIChTbWFydFJvbGx1cFJlZnV0ZUdhbWVTdGF0dXNPcHRpb25zKSB7XG4gICAgU21hcnRSb2xsdXBSZWZ1dGVHYW1lU3RhdHVzT3B0aW9uc1tcIk9OR09JTkdcIl0gPSBcIm9uZ29pbmdcIjtcbiAgICBTbWFydFJvbGx1cFJlZnV0ZUdhbWVTdGF0dXNPcHRpb25zW1wiRU5ERURcIl0gPSBcImVuZGVkXCI7XG59KShTbWFydFJvbGx1cFJlZnV0ZUdhbWVTdGF0dXNPcHRpb25zIHx8IChTbWFydFJvbGx1cFJlZnV0ZUdhbWVTdGF0dXNPcHRpb25zID0ge30pKTtcbnZhciBTbWFydFJvbGx1cFJlZnV0ZUdhbWVFbmRlZFBsYXllck91dGNvbWVzO1xuKGZ1bmN0aW9uIChTbWFydFJvbGx1cFJlZnV0ZUdhbWVFbmRlZFBsYXllck91dGNvbWVzKSB7XG4gICAgU21hcnRSb2xsdXBSZWZ1dGVHYW1lRW5kZWRQbGF5ZXJPdXRjb21lc1tcIkxPU0VSXCJdID0gXCJsb3NlclwiO1xuICAgIFNtYXJ0Um9sbHVwUmVmdXRlR2FtZUVuZGVkUGxheWVyT3V0Y29tZXNbXCJEUkFXXCJdID0gXCJkcmF3XCI7XG59KShTbWFydFJvbGx1cFJlZnV0ZUdhbWVFbmRlZFBsYXllck91dGNvbWVzIHx8IChTbWFydFJvbGx1cFJlZnV0ZUdhbWVFbmRlZFBsYXllck91dGNvbWVzID0ge30pKTtcbnZhciBTbWFydFJvbGx1cFJlZnV0ZUdhbWVFbmRlZFJlYXNvbjtcbihmdW5jdGlvbiAoU21hcnRSb2xsdXBSZWZ1dGVHYW1lRW5kZWRSZWFzb24pIHtcbiAgICBTbWFydFJvbGx1cFJlZnV0ZUdhbWVFbmRlZFJlYXNvbltcIkNPTkZMSUNUX1JFU09MVkVEXCJdID0gXCJjb25mbGljdF9yZXNvbHZlZFwiO1xuICAgIFNtYXJ0Um9sbHVwUmVmdXRlR2FtZUVuZGVkUmVhc29uW1wiVElNRU9VVFwiXSA9IFwidGltZW91dFwiO1xufSkoU21hcnRSb2xsdXBSZWZ1dGVHYW1lRW5kZWRSZWFzb24gfHwgKFNtYXJ0Um9sbHVwUmVmdXRlR2FtZUVuZGVkUmVhc29uID0ge30pKTtcblxudmFyIE9wS2luZDtcbihmdW5jdGlvbiAoT3BLaW5kKSB7XG4gICAgT3BLaW5kW1wiT1JJR0lOQVRJT05cIl0gPSBcIm9yaWdpbmF0aW9uXCI7XG4gICAgT3BLaW5kW1wiREVMRUdBVElPTlwiXSA9IFwiZGVsZWdhdGlvblwiO1xuICAgIE9wS2luZFtcIlJFVkVBTFwiXSA9IFwicmV2ZWFsXCI7XG4gICAgT3BLaW5kW1wiVFJBTlNBQ1RJT05cIl0gPSBcInRyYW5zYWN0aW9uXCI7XG4gICAgT3BLaW5kW1wiQUNUSVZBVElPTlwiXSA9IFwiYWN0aXZhdGVfYWNjb3VudFwiO1xuICAgIE9wS2luZFtcIkFUVEVTVEFUSU9OXCJdID0gXCJhdHRlc3RhdGlvblwiO1xuICAgIE9wS2luZFtcIkVORE9SU0VNRU5UXCJdID0gXCJlbmRvcnNlbWVudFwiO1xuICAgIE9wS2luZFtcIlBSRUFUVEVTVEFUSU9OXCJdID0gXCJwcmVhdHRlc3RhdGlvblwiO1xuICAgIE9wS2luZFtcIlBSRUVORE9SU0VNRU5UXCJdID0gXCJwcmVlbmRvcnNlbWVudFwiO1xuICAgIE9wS2luZFtcIlNFVF9ERVBPU0lUU19MSU1JVFwiXSA9IFwic2V0X2RlcG9zaXRzX2xpbWl0XCI7XG4gICAgT3BLaW5kW1wiRE9VQkxFX1BSRUFUVEVTVEFUSU9OX0VWSURFTkNFXCJdID0gXCJkb3VibGVfcHJlYXR0ZXN0YXRpb25fZXZpZGVuY2VcIjtcbiAgICBPcEtpbmRbXCJET1VCTEVfUFJFRU5ET1JTRU1FTlRfRVZJREVOQ0VcIl0gPSBcImRvdWJsZV9wcmVlbmRvcnNlbWVudF9ldmlkZW5jZVwiO1xuICAgIE9wS2luZFtcIkFUVEVTVEFUSU9OX1dJVEhfU0xPVFwiXSA9IFwiYXR0ZXN0YXRpb25fd2l0aF9zbG90XCI7XG4gICAgT3BLaW5kW1wiRU5ET1JTRU1FTlRfV0lUSF9TTE9UXCJdID0gXCJlbmRvcnNlbWVudF93aXRoX3Nsb3RcIjtcbiAgICBPcEtpbmRbXCJTRUVEX05PTkNFX1JFVkVMQVRJT05cIl0gPSBcInNlZWRfbm9uY2VfcmV2ZWxhdGlvblwiO1xuICAgIE9wS2luZFtcIkRPVUJMRV9BVFRFU1RBVElPTl9FVklERU5DRVwiXSA9IFwiZG91YmxlX2F0dGVzdGF0aW9uX2V2aWRlbmNlXCI7XG4gICAgT3BLaW5kW1wiRE9VQkxFX0VORE9SU0VNRU5UX0VWSURFTkNFXCJdID0gXCJkb3VibGVfZW5kb3JzZW1lbnRfZXZpZGVuY2VcIjtcbiAgICBPcEtpbmRbXCJET1VCTEVfQkFLSU5HX0VWSURFTkNFXCJdID0gXCJkb3VibGVfYmFraW5nX2V2aWRlbmNlXCI7XG4gICAgT3BLaW5kW1wiUFJPUE9TQUxTXCJdID0gXCJwcm9wb3NhbHNcIjtcbiAgICBPcEtpbmRbXCJCQUxMT1RcIl0gPSBcImJhbGxvdFwiO1xuICAgIE9wS2luZFtcIkZBSUxJTkdfTk9PUFwiXSA9IFwiZmFpbGluZ19ub29wXCI7XG4gICAgT3BLaW5kW1wiUkVHSVNURVJfR0xPQkFMX0NPTlNUQU5UXCJdID0gXCJyZWdpc3Rlcl9nbG9iYWxfY29uc3RhbnRcIjtcbiAgICBPcEtpbmRbXCJUUkFOU0ZFUl9USUNLRVRcIl0gPSBcInRyYW5zZmVyX3RpY2tldFwiO1xuICAgIE9wS2luZFtcIklOQ1JFQVNFX1BBSURfU1RPUkFHRVwiXSA9IFwiaW5jcmVhc2VfcGFpZF9zdG9yYWdlXCI7XG4gICAgT3BLaW5kW1wiVVBEQVRFX0NPTlNFTlNVU19LRVlcIl0gPSBcInVwZGF0ZV9jb25zZW5zdXNfa2V5XCI7XG4gICAgT3BLaW5kW1wiRFJBSU5fREVMRUdBVEVcIl0gPSBcImRyYWluX2RlbGVnYXRlXCI7XG4gICAgT3BLaW5kW1wiVkRGX1JFVkVMQVRJT05cIl0gPSBcInZkZl9yZXZlbGF0aW9uXCI7XG4gICAgT3BLaW5kW1wiRVZFTlRcIl0gPSBcImV2ZW50XCI7XG4gICAgT3BLaW5kW1wiVElDS0VUX1VQREFURVNcIl0gPSBcInRpY2tldF91cGRhdGVzXCI7XG4gICAgT3BLaW5kW1wiU01BUlRfUk9MTFVQX09SSUdJTkFURVwiXSA9IFwic21hcnRfcm9sbHVwX29yaWdpbmF0ZVwiO1xuICAgIE9wS2luZFtcIlNNQVJUX1JPTExVUF9BRERfTUVTU0FHRVNcIl0gPSBcInNtYXJ0X3JvbGx1cF9hZGRfbWVzc2FnZXNcIjtcbiAgICBPcEtpbmRbXCJTTUFSVF9ST0xMVVBfRVhFQ1VURV9PVVRCT1hfTUVTU0FHRVwiXSA9IFwic21hcnRfcm9sbHVwX2V4ZWN1dGVfb3V0Ym94X21lc3NhZ2VcIjtcbiAgICBPcEtpbmRbXCJTTUFSVF9ST0xMVVBfUFVCTElTSFwiXSA9IFwic21hcnRfcm9sbHVwX3B1Ymxpc2hcIjtcbiAgICBPcEtpbmRbXCJTTUFSVF9ST0xMVVBfQ0VNRU5UXCJdID0gXCJzbWFydF9yb2xsdXBfY2VtZW50XCI7XG4gICAgT3BLaW5kW1wiU01BUlRfUk9MTFVQX1JFQ09WRVJfQk9ORFwiXSA9IFwic21hcnRfcm9sbHVwX3JlY292ZXJfYm9uZFwiO1xuICAgIE9wS2luZFtcIlNNQVJUX1JPTExVUF9SRUZVVEVcIl0gPSBcInNtYXJ0X3JvbGx1cF9yZWZ1dGVcIjtcbiAgICBPcEtpbmRbXCJTTUFSVF9ST0xMVVBfVElNRU9VVFwiXSA9IFwic21hcnRfcm9sbHVwX3RpbWVvdXRcIjtcbn0pKE9wS2luZCB8fCAoT3BLaW5kID0ge30pKTtcblxuLy8gSU1QT1JUQU5UOiBUSElTIEZJTEUgSVMgQVVUTyBHRU5FUkFURUQhIERPIE5PVCBNQU5VQUxMWSBFRElUIE9SIENIRUNLSU4hXG5jb25zdCBWRVJTSU9OID0ge1xuICAgIFwiY29tbWl0SGFzaFwiOiBcIjEzYTEyYWI3Y2Y0NDIwNDM1MjY3NDVkYjJiYmY0ZWYzYjA4OWMzNGFcIixcbiAgICBcInZlcnNpb25cIjogXCIxOS4wLjJcIlxufTtcblxuLyoqKlxuICogQGRlc2NyaXB0aW9uIFJwY0NsaWVudCBhbGxvd3MgaW50ZXJhY3Rpb24gd2l0aCBUZXpvcyBuZXR3b3JrIHRocm91Z2ggYW4gcnBjIG5vZGVcbiAqL1xuY2xhc3MgUnBjQ2xpZW50IHtcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSB1cmwgcnBjIHJvb3QgdXJsXG4gICAgICogQHBhcmFtIGNoYWluIGNoYWluIChkZWZhdWx0IG1haW4pXG4gICAgICogQHBhcmFtIGh0dHBCYWNrZW5kIEh0dHAgYmFja2VuZCB0aGF0IGlzc3VlIGh0dHAgcmVxdWVzdC5cbiAgICAgKiBZb3UgY2FuIG92ZXJyaWRlIGl0IGJ5IHByb3ZpZGluZyB5b3VyIG93biBpZiB5b3Ugd2hpY2ggdG8gaG9vayBpbiB0aGUgcmVxdWVzdC9yZXNwb25zZVxuICAgICAqXG4gICAgICogQGV4YW1wbGUgbmV3IFJwY0NsaWVudCgnaHR0cHM6Ly9tYWlubmV0LmVjYWRpbmZyYS5jb20vJywgJ21haW4nKSB0aGlzIHdpbGwgdXNlIGh0dHBzOi8vbWFpbm5ldC5lY2FkaW5mcmEuY29tLy9jaGFpbnMvbWFpblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHVybCwgY2hhaW4gPSBkZWZhdWx0Q2hhaW4sIGh0dHBCYWNrZW5kID0gbmV3IEh0dHBCYWNrZW5kKCkpIHtcbiAgICAgICAgdGhpcy51cmwgPSB1cmw7XG4gICAgICAgIHRoaXMuY2hhaW4gPSBjaGFpbjtcbiAgICAgICAgdGhpcy5odHRwQmFja2VuZCA9IGh0dHBCYWNrZW5kO1xuICAgIH1cbiAgICBjcmVhdGVVUkwocGF0aCkge1xuICAgICAgICAvLyBUcmltIHRyYWlsaW5nIHNsYXNoZXMgYmVjYXVzZSBpdCBpcyBhc3N1bWVkIHRvIGJlIGluY2x1ZGVkIGluIHBhdGhcbiAgICAgICAgLy8gdGhlIHJlZ2V4IHNvbHV0aW9uIGlzIHByb25lIHRvIFJlRG9TLiBQbGVhc2Ugc2VlOiBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy82NjgwODI1L3JldHVybi1zdHJpbmctd2l0aG91dC10cmFpbGluZy1zbGFzaCNjb21tZW50MTI0MzA2Njk4XzY2ODA4NzdcbiAgICAgICAgLy8gV2UgYWxzbyBnb3QgYSBDb2RlUUwgZXJyb3IgZm9yIHRoZSByZWdleCBiYXNlZCBzb2x1dGlvblxuICAgICAgICBsZXQgcm9vdFVybCA9IHRoaXMudXJsO1xuICAgICAgICB3aGlsZSAocm9vdFVybC5lbmRzV2l0aCgnLycpKSB7XG4gICAgICAgICAgICByb290VXJsID0gcm9vdFVybC5zbGljZSgwLCAtMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGAke3Jvb3RVcmx9JHtwYXRofWA7XG4gICAgfVxuICAgIHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIGNvbnN0IGFkZHJlc3NWYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICBpZiAoYWRkcmVzc1ZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGFkZHJlc3MsIGludmFsaWREZXRhaWwoYWRkcmVzc1ZhbGlkYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YWxpZGF0ZUNvbnRyYWN0KGFkZHJlc3MpIHtcbiAgICAgICAgY29uc3QgYWRkcmVzc1ZhbGlkYXRpb24gPSB2YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgaWYgKGFkZHJlc3NWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yKGFkZHJlc3MsIGludmFsaWREZXRhaWwoYWRkcmVzc1ZhbGlkYXRpb24pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBibG9jaydzIGhhc2gsIGl0cyB1bmlxdWUgaWRlbnRpZmllci5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtaGFzaFxuICAgICAqL1xuICAgIGdldEJsb2NrSGFzaCh7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oYXNoYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gTGlzdCB0aGUgYW5jZXN0b3JzIG9mIHRoZSBnaXZlbiBibG9jayB3aGljaCwgaWYgcmVmZXJyZWQgdG8gYXMgdGhlIGJyYW5jaCBpbiBhbiBvcGVyYXRpb24gaGVhZGVyLCBhcmUgcmVjZW50IGVub3VnaCBmb3IgdGhhdCBvcGVyYXRpb24gdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWxpdmUtYmxvY2tzXG4gICAgICovXG4gICAgZ2V0TGl2ZUJsb2Nrcyh7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L2xpdmVfYmxvY2tzYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrcztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIGFkZHJlc3MgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBiYWxhbmNlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgc3BlbmRhYmxlIGJhbGFuY2Ugb2YgYSBjb250cmFjdCwgZXhjbHVkaW5nIGZyb3plbiBib25kc1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1iYWxhbmNlXG4gICAgICovXG4gICAgZ2V0QmFsYW5jZShhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCBiYWxhbmNlID0geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L2NvbnRleHQvY29udHJhY3RzLyR7YWRkcmVzc30vYmFsYW5jZWApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKGJhbGFuY2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBkYXRhIG9mIHRoZSBjb250cmFjdC5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtY29udGV4dC1jb250cmFjdHMtY29udHJhY3QtaWQtc3RvcmFnZVxuICAgICAqL1xuICAgIGdldFN0b3JhZ2UoYWRkcmVzcywgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vY29udGV4dC9jb250cmFjdHMvJHthZGRyZXNzfS9zdG9yYWdlYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIHNjcmlwdFxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIGNvZGUgYW5kIGRhdGEgb2YgdGhlIGNvbnRyYWN0LlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1zY3JpcHRcbiAgICAgKi9cbiAgICBnZXRTY3JpcHQoYWRkcmVzcywgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vY29udGV4dC9jb250cmFjdHMvJHthZGRyZXNzfS9zY3JpcHRgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgc2NyaXB0XG4gICAgICogQHBhcmFtIHVucGFyc2luZ01vZGUgZGVmYXVsdCBpcyB7IHVucGFyc2luZ19tb2RlOiBcIlJlYWRhYmxlXCIgfVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIHNjcmlwdCBvZiB0aGUgY29udHJhY3QgYW5kIG5vcm1hbGl6ZSBpdCB1c2luZyB0aGUgcmVxdWVzdGVkIHVucGFyc2luZyBtb2RlLlxuICAgICAqL1xuICAgIGdldE5vcm1hbGl6ZWRTY3JpcHQoYWRkcmVzcywgdW5wYXJzaW5nTW9kZSA9IHsgdW5wYXJzaW5nX21vZGU6ICdSZWFkYWJsZScgfSwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVDb250cmFjdChhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vY29udGV4dC9jb250cmFjdHMvJHthZGRyZXNzfS9zY3JpcHQvbm9ybWFsaXplZGApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfSwgdW5wYXJzaW5nTW9kZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIGNvbXBsZXRlIHN0YXR1cyBvZiBhIGNvbnRyYWN0LlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZFxuICAgICAqL1xuICAgIGdldENvbnRyYWN0KGFkZHJlc3MsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0UmVzcG9uc2UgPSB5aWVsZCB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vY29udGV4dC9jb250cmFjdHMvJHthZGRyZXNzfWApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGNvbnRyYWN0UmVzcG9uc2UpLCB7IGJhbGFuY2U6IG5ldyBCaWdOdW1iZXIoY29udHJhY3RSZXNwb25zZS5iYWxhbmNlKSB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIGNvbnRyYWN0IGFkZHJlc3MgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBtYW5hZ2VyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgbWFuYWdlciBvZiBhbiBpbXBsaWNpdCBjb250cmFjdFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1tYW5hZ2VyLWtleVxuICAgICAqL1xuICAgIGdldE1hbmFnZXJLZXkoYWRkcmVzcywgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMudmFsaWRhdGVBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2NvbnRyYWN0cy8ke2FkZHJlc3N9L21hbmFnZXJfa2V5YCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIGRlbGVnYXRlIChiYWtlcilcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBkZWxlZ2F0ZSBvZiBhIGNvbnRyYWN0LCBpZiBhbnlcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtY29udGV4dC1jb250cmFjdHMtY29udHJhY3QtaWQtZGVsZWdhdGVcbiAgICAgKi9cbiAgICBnZXREZWxlZ2F0ZShhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBsZXQgZGVsZWdhdGU7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGRlbGVnYXRlID0geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2NvbnRyYWN0cy8ke2FkZHJlc3N9L2RlbGVnYXRlYCksXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2VFcnJvciAmJiBleC5zdGF0dXMgPT09IFNUQVRVU19DT0RFLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICBkZWxlZ2F0ZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIGZhdm9yIG9mIGdldEJpZ01hcEtleUJ5SURcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBjb250cmFjdCBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgYmlnIG1hcCBrZXlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBrZXkgaW4gdGhlIGJpZyBtYXAgc3RvcmFnZSBvZiB0aGUgY29udHJhY3QuXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjcG9zdC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1iaWctbWFwLWdldFxuICAgICAqL1xuICAgIGdldEJpZ01hcEtleShhZGRyZXNzLCBrZXksIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vY29udGV4dC9jb250cmFjdHMvJHthZGRyZXNzfS9iaWdfbWFwX2dldGApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfSwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpZCBCaWcgTWFwIElEXG4gICAgICogQHBhcmFtIGV4cHIgRXhwcmVzc2lvbiBoYXNoIHRvIHF1ZXJ5IChBIGI1OGNoZWNrIGVuY29kZWQgQmxha2UyYiBoYXNoIG9mIHRoZSBleHByZXNzaW9uIChUaGUgZXhwcmVzc2lvbiBjYW4gYmUgcGFja2VkIHVzaW5nIHRoZSBwYWNrX2RhdGEgbWV0aG9kKSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBrZXkgaW4gYSBiaWcgbWFwLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWJpZy1tYXBzLWJpZy1tYXAtaWQtc2NyaXB0LWV4cHJcbiAgICAgKi9cbiAgICBnZXRCaWdNYXBFeHByKGlkLCBleHByLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2JpZ19tYXBzLyR7aWR9LyR7ZXhwcn1gKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBkZWxlZ2F0ZSBhZGRyZXNzIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmVcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gRXZlcnl0aGluZyBhYm91dCBhIGRlbGVnYXRlXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtZGVsZWdhdGVzLXBraFxuICAgICAqL1xuICAgIGdldERlbGVnYXRlcyhhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2RlbGVnYXRlcy8ke2FkZHJlc3N9YCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY2FzdGVkUmVzcG9uc2UgPSBjYXN0VG9CaWdOdW1iZXIocmVzcG9uc2UsIFtcbiAgICAgICAgICAgICAgICAnYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2Z1bGxfYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ2N1cnJlbnRfZnJvemVuX2RlcG9zaXRzJyxcbiAgICAgICAgICAgICAgICAnZnJvemVuX2RlcG9zaXRzJyxcbiAgICAgICAgICAgICAgICAnZnJvemVuX2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICdmcm96ZW5fZGVwb3NpdHNfbGltaXQnLFxuICAgICAgICAgICAgICAgICdzdGFraW5nX2JhbGFuY2UnLFxuICAgICAgICAgICAgICAgICdkZWxlZ2F0ZWRfYmFsYW5jZScsXG4gICAgICAgICAgICAgICAgJ3ZvdGluZ19wb3dlcicsXG4gICAgICAgICAgICAgICAgJ3RvdGFsX2RlbGVnYXRlZF9zdGFrZScsXG4gICAgICAgICAgICAgICAgJ3N0YWtpbmdfZGVub21pbmF0b3InLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3BvbnNlKSwgY2FzdGVkUmVzcG9uc2UpLCB7IGZyb3plbl9iYWxhbmNlX2J5X2N5Y2xlOiByZXNwb25zZS5mcm96ZW5fYmFsYW5jZV9ieV9jeWNsZVxuICAgICAgICAgICAgICAgICAgICA/IHJlc3BvbnNlLmZyb3plbl9iYWxhbmNlX2J5X2N5Y2xlLm1hcCgoX2EpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciB7IGRlcG9zaXQsIGRlcG9zaXRzLCBmZWVzLCByZXdhcmRzIH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiZGVwb3NpdFwiLCBcImRlcG9zaXRzXCIsIFwiZmVlc1wiLCBcInJld2FyZHNcIl0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FzdGVkVG9CaWdOdW1iZXIgPSBjYXN0VG9CaWdOdW1iZXIoeyBkZXBvc2l0LCBkZXBvc2l0cywgZmVlcywgcmV3YXJkcyB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdkZXBvc2l0cycsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2ZlZXMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdyZXdhcmRzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIHsgZGVwb3NpdDogY2FzdGVkVG9CaWdOdW1iZXIuZGVwb3NpdCwgZGVwb3NpdHM6IGNhc3RlZFRvQmlnTnVtYmVyLmRlcG9zaXRzLCBmZWVzOiBjYXN0ZWRUb0JpZ051bWJlci5mZWVzLCByZXdhcmRzOiBjYXN0ZWRUb0JpZ051bWJlci5yZXdhcmRzIH0pO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICA6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIGRlbGVnYXRlIGFkZHJlc3Mgd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSBkZWxlZ2F0ZSBpbmZvIChlLmcuIHZvdGluZyBwb3dlcikgZm91bmQgaW4gdGhlIGxpc3RpbmdzIG9mIHRoZSBjdXJyZW50IHZvdGluZyBwZXJpb2RcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FjdGl2ZS9ycGMuaHRtbCNnZXQtYmxvY2staWQtY29udGV4dC1kZWxlZ2F0ZXMtcGtoLXZvdGluZy1pbmZvXG4gICAgICovXG4gICAgZ2V0Vm90aW5nSW5mbyhhZGRyZXNzLCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy52YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L2NvbnRleHQvZGVsZWdhdGVzLyR7YWRkcmVzc30vdm90aW5nX2luZm9gKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWxsIGNvbnN0YW50c1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnN0YW50c1xuICAgICAqL1xuICAgIGdldENvbnN0YW50cyh7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vY29udGV4dC9jb25zdGFudHNgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjYXN0ZWRSZXNwb25zZSA9IGNhc3RUb0JpZ051bWJlcihyZXNwb25zZSwgW1xuICAgICAgICAgICAgICAgICd0aW1lX2JldHdlZW5fYmxvY2tzJyxcbiAgICAgICAgICAgICAgICAnaGFyZF9nYXNfbGltaXRfcGVyX29wZXJhdGlvbicsXG4gICAgICAgICAgICAgICAgJ2hhcmRfZ2FzX2xpbWl0X3Blcl9ibG9jaycsXG4gICAgICAgICAgICAgICAgJ3Byb29mX29mX3dvcmtfdGhyZXNob2xkJyxcbiAgICAgICAgICAgICAgICAndG9rZW5zX3Blcl9yb2xsJyxcbiAgICAgICAgICAgICAgICAnc2VlZF9ub25jZV9yZXZlbGF0aW9uX3RpcCcsXG4gICAgICAgICAgICAgICAgJ2Jsb2NrX3NlY3VyaXR5X2RlcG9zaXQnLFxuICAgICAgICAgICAgICAgICdlbmRvcnNlbWVudF9zZWN1cml0eV9kZXBvc2l0JyxcbiAgICAgICAgICAgICAgICAnYmxvY2tfcmV3YXJkJyxcbiAgICAgICAgICAgICAgICAnZW5kb3JzZW1lbnRfcmV3YXJkJyxcbiAgICAgICAgICAgICAgICAnY29zdF9wZXJfYnl0ZScsXG4gICAgICAgICAgICAgICAgJ2hhcmRfc3RvcmFnZV9saW1pdF9wZXJfb3BlcmF0aW9uJyxcbiAgICAgICAgICAgICAgICAndGVzdF9jaGFpbl9kdXJhdGlvbicsXG4gICAgICAgICAgICAgICAgJ2Jha2luZ19yZXdhcmRfcGVyX2VuZG9yc2VtZW50JyxcbiAgICAgICAgICAgICAgICAnZGVsYXlfcGVyX21pc3NpbmdfZW5kb3JzZW1lbnQnLFxuICAgICAgICAgICAgICAgICdtaW5pbWFsX2Jsb2NrX2RlbGF5JyxcbiAgICAgICAgICAgICAgICAnbGlxdWlkaXR5X2Jha2luZ19zdWJzaWR5JyxcbiAgICAgICAgICAgICAgICAnY2FjaGVfbGF5b3V0JyxcbiAgICAgICAgICAgICAgICAnYmFraW5nX3Jld2FyZF9maXhlZF9wb3J0aW9uJyxcbiAgICAgICAgICAgICAgICAnYmFraW5nX3Jld2FyZF9ib251c19wZXJfc2xvdCcsXG4gICAgICAgICAgICAgICAgJ2VuZG9yc2luZ19yZXdhcmRfcGVyX3Nsb3QnLFxuICAgICAgICAgICAgICAgICdkb3VibGVfYmFraW5nX3B1bmlzaG1lbnQnLFxuICAgICAgICAgICAgICAgICdkZWxheV9pbmNyZW1lbnRfcGVyX3JvdW5kJyxcbiAgICAgICAgICAgICAgICAndHhfcm9sbHVwX2NvbW1pdG1lbnRfYm9uZCcsXG4gICAgICAgICAgICAgICAgJ3ZkZl9kaWZmaWN1bHR5JyxcbiAgICAgICAgICAgICAgICAnc2Nfcm9sbHVwX3N0YWtlX2Ftb3VudCcsXG4gICAgICAgICAgICAgICAgJ21pbmltYWxfc3Rha2UnLFxuICAgICAgICAgICAgXSk7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXNwb25zZSksIGNhc3RlZFJlc3BvbnNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKSBhbmQgdmVyc2lvbi5cbiAgICAgKiBAZGVzY3JpcHRpb24gQWxsIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkXG4gICAgICogQGV4YW1wbGUgZ2V0QmxvY2soKSB3aWxsIGRlZmF1bHQgdG8gYC9tYWluL2NoYWlucy9ibG9jay9oZWFkP3ZlcnNpb249MGAgd2hpY2ggc2hvd3MgeyBraW5kOiBlbmRvcnNlbWVudCB9XG4gICAgICogQGV4YW1wbGUgZ2V0QmxvY2soeyBibG9jazogJ2hlYWR+MicsIHZlcnNpb246IDEgfSkgd2lsbCByZXR1cm4gYW4gb2Zmc2V0IG9mIDIgZnJvbSBoZWFkIGJsb2NrcyBhbmQgc2hvd3MgeyBraW5kOiBhdHRlc3RhdGlvbiB9XG4gICAgICogQGV4YW1wbGUgZ2V0QmxvY2soeyBibG9jazogJ0JMOGZUaVdjU3hXQ2ppTVZuRGtiaDZFdWhxVlBaemdXaGVKMmRxd3J4WVJtOUFlcGhYaH4yJyB9KSB3aWxsIHJldHVybiBhbiBvZmZzZXQgb2YgMiBibG9ja3MgZnJvbSBnaXZlbiBibG9jayBoYXNoLi5cbiAgICAgKi9cbiAgICBnZXRCbG9jayh7IGJsb2NrLCB2ZXJzaW9uIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfWApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnF1ZXJ5ID0geyB2ZXJzaW9uIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgd2hvbGUgYmxvY2sgaGVhZGVyXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWhlYWRlclxuICAgICAqL1xuICAgIGdldEJsb2NrSGVhZGVyKHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oZWFkZXJgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZCkgYW5kIHZlcnNpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gQWxsIHRoZSBtZXRhZGF0YSBhc3NvY2lhdGVkIHRvIHRoZSBibG9ja1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1tZXRhZGF0YVxuICAgICAqL1xuICAgIGdldEJsb2NrTWV0YWRhdGEoeyBibG9jaywgdmVyc2lvbiwgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXF1ZXN0T3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L21ldGFkYXRhYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodmVyc2lvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdE9wdGlvbnMucXVlcnkgPSB7IHZlcnNpb24gfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3QocmVxdWVzdE9wdGlvbnMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3MgY29udGFpbnMgb3B0aW9uYWwgcXVlcnkgYXJndW1lbnRzIChsZXZlbCwgY3ljbGUsIGRlbGVnYXRlLCBjb25zZW5zdXNfa2V5LCBhbmQgbWF4X3JvdW5kKVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZXMgdGhlIGxpc3Qgb2YgZGVsZWdhdGVzIGFsbG93ZWQgdG8gYmFrZSBhIGJsb2NrLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1oZWxwZXJzLWJha2luZy1yaWdodHNcbiAgICAgKi9cbiAgICBnZXRCYWtpbmdSaWdodHMoYXJncyA9IHt9LCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vaGVscGVycy9iYWtpbmdfcmlnaHRzYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgICAgICBxdWVyeTogYXJncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGFyZ3MgY29udGFpbnMgb3B0aW9uYWwgcXVlcnkgYXJndW1lbnRzIChsZXZlbCwgY3ljbGUsIGRlbGVnYXRlLCBhbmQgY29uc2Vuc3VzX2tleSlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmVzIHRoZSBkZWxlZ2F0ZXMgYWxsb3dlZCB0byBhdHRlc3QgYSBibG9ja1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1oZWxwZXJzLWVuZG9yc2luZy1yaWdodHNcbiAgICAgKi9cbiAgICBnZXRBdHRlc3RhdGlvblJpZ2h0cyhhcmdzID0ge30sIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oZWxwZXJzL2F0dGVzdGF0aW9uX3JpZ2h0c2ApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgcXVlcnk6IGFyZ3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXByZWNhdGVkIERlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2V0QXR0ZXN0YXRpb25SaWdodHNcbiAgICAgKiBAcGFyYW0gYXJncyBjb250YWlucyBvcHRpb25hbCBxdWVyeSBhcmd1bWVudHMgKGxldmVsLCBjeWNsZSwgZGVsZWdhdGUsIGFuZCBjb25zZW5zdXNfa2V5KVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlcyB0aGUgZGVsZWdhdGVzIGFsbG93ZWQgdG8gZW5kb3JzZSBhIGJsb2NrXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWhlbHBlcnMtZW5kb3JzaW5nLXJpZ2h0c1xuICAgICAqL1xuICAgIGdldEVuZG9yc2luZ1JpZ2h0cyhhcmdzID0ge30sIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oZWxwZXJzL2VuZG9yc2luZ19yaWdodHNgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBhcmdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQmFsbG90cyBjYXN0ZWQgc28gZmFyIGR1cmluZyBhIHZvdGluZyBwZXJpb2RcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtdm90ZXMtYmFsbG90LWxpc3RcbiAgICAgKi9cbiAgICBnZXRCYWxsb3RMaXN0KHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS92b3Rlcy9iYWxsb3RfbGlzdGApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBTdW0gb2YgYmFsbG90cyBjYXN0ZWQgc28gZmFyIGR1cmluZyBhIHZvdGluZyBwZXJpb2RcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtdm90ZXMtYmFsbG90c1xuICAgICAqL1xuICAgIGdldEJhbGxvdHMoeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L3ZvdGVzL2JhbGxvdHNgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBjYXN0ZWQgPSBjYXN0VG9CaWdOdW1iZXIocmVzcG9uc2UsIFsneWF5JywgJ25heScsICdwYXNzJ10pO1xuICAgICAgICAgICAgcmV0dXJuIGNhc3RlZDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBDdXJyZW50IHByb3Bvc2FsIHVuZGVyIGV2YWx1YXRpb24uXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLXZvdGVzLWN1cnJlbnQtcHJvcG9zYWxcbiAgICAgKi9cbiAgICBnZXRDdXJyZW50UHJvcG9zYWwoeyBibG9jaywgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS92b3Rlcy9jdXJyZW50X3Byb3Bvc2FsYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEN1cnJlbnQgZXhwZWN0ZWQgcXVvcnVtLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1jdXJyZW50LXF1b3J1bVxuICAgICAqL1xuICAgIGdldEN1cnJlbnRRdW9ydW0oeyBibG9jaywgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS92b3Rlcy9jdXJyZW50X3F1b3J1bWApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBMaXN0IG9mIGRlbGVnYXRlcyB3aXRoIHRoZWlyIHZvdGluZyBwb3dlclxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1saXN0aW5nc1xuICAgICAqL1xuICAgIGdldFZvdGVzTGlzdGluZ3MoeyBibG9jaywgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS92b3Rlcy9saXN0aW5nc2ApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlc3BvbnNlLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChpdGVtLnZvdGluZ19wb3dlcikge1xuICAgICAgICAgICAgICAgICAgICBpdGVtLnZvdGluZ19wb3dlciA9IG5ldyBCaWdOdW1iZXIoaXRlbS52b3RpbmdfcG93ZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIExpc3Qgb2YgcHJvcG9zYWxzIHdpdGggbnVtYmVyIG9mIHN1cHBvcnRlcnNcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNnZXQtYmxvY2staWQtdm90ZXMtcHJvcG9zYWxzXG4gICAgICovXG4gICAgZ2V0UHJvcG9zYWxzKHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS92b3Rlcy9wcm9wb3NhbHNgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXNwb25zZS5tYXAoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKGl0ZW1bMV0gPSBuZXcgQmlnTnVtYmVyKGl0ZW1bMV0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGRhdGEgb3BlcmF0aW9uIGNvbnRlbnRzIHRvIGZvcmdlXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIEZvcmdlIGFuIG9wZXJhdGlvbiByZXR1cm5pbmcgdGhlIHVuc2lnbmVkIGJ5dGVzXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjcG9zdC1ibG9jay1pZC1oZWxwZXJzLWZvcmdlLW9wZXJhdGlvbnNcbiAgICAgKi9cbiAgICBmb3JnZU9wZXJhdGlvbnMoZGF0YSwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vaGVscGVycy9mb3JnZS9vcGVyYXRpb25zYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9LCBkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBzaWduZWRPcEJ5dGVzIHNpZ25lZCBieXRlcyB0byBpbmplY3RcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5qZWN0IGFuIG9wZXJhdGlvbiBpbiBub2RlIGFuZCBicm9hZGNhc3QgaXQgYW5kIHJldHVybiB0aGUgSUQgb2YgdGhlIG9wZXJhdGlvblxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI3Bvc3QtaW5qZWN0aW9uLW9wZXJhdGlvblxuICAgICAqL1xuICAgIGluamVjdE9wZXJhdGlvbihzaWduZWRPcEJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvaW5qZWN0aW9uL29wZXJhdGlvbmApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfSwgc2lnbmVkT3BCeXRlcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3BzIE9wZXJhdGlvbnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgYW5kIHZlcnNpb25cbiAgICAgKiBAZGVzY3JpcHRpb24gU2ltdWxhdGUgdGhlIGFwcGxpY2F0aW9uIG9mIHRoZSBvcGVyYXRpb25zIHdpdGggdGhlIGNvbnRleHQgb2YgdGhlIGdpdmVuIGJsb2NrIGFuZCByZXR1cm4gdGhlIHJlc3VsdCBvZiBlYWNoIG9wZXJhdGlvbiBhcHBsaWNhdGlvblxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI3Bvc3QtYmxvY2staWQtaGVscGVycy1wcmVhcHBseS1vcGVyYXRpb25zXG4gICAgICovXG4gICAgcHJlYXBwbHlPcGVyYXRpb25zKG9wcywgeyBibG9jaywgdmVyc2lvbiB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vaGVscGVycy9wcmVhcHBseS9vcGVyYXRpb25zYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnF1ZXJ5ID0geyB2ZXJzaW9uIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBvcHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHdlIHdhbnQgdG8gZ2V0IHRoZSBlbnRyeXBvaW50cyBvZlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gdGhlIGxpc3Qgb2YgZW50cnlwb2ludHMgb2YgdGhlIGNvbnRyYWN0XG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLWVudHJ5cG9pbnRzXG4gICAgICogQHZlcnNpb24gMDA1X1BzQkFCWTVIXG4gICAgICovXG4gICAgZ2V0RW50cnlwb2ludHMoY29udHJhY3QsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZhbGlkYXRlQ29udHJhY3QoY29udHJhY3QpO1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RSZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2NvbnRyYWN0cy8ke2NvbnRyYWN0fS9lbnRyeXBvaW50c2ApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjb250cmFjdFJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiBmYXZvciBvZiBzaW11bGF0ZU9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcCBPcGVyYXRpb24gdG8gcnVuXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIGFuZCB2ZXJzaW9uXG4gICAgICogQGRlc2NyaXB0aW9uIFJ1biBhbiBvcGVyYXRpb24gd2l0aCB0aGUgY29udGV4dCBvZiB0aGUgZ2l2ZW4gYmxvY2sgYW5kIHdpdGhvdXQgc2lnbmF0dXJlIGNoZWNrcyBhbmQgcmV0dXJuIHRoZSBvcGVyYXRpb24gYXBwbGljYXRpb24gcmVzdWx0LCBpbmNsdWRpbmcgdGhlIGNvbnN1bWVkIGdhcy5cbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNwb3N0LWJsb2NrLWlkLWhlbHBlcnMtc2NyaXB0cy1ydW4tb3BlcmF0aW9uXG4gICAgICovXG4gICAgcnVuT3BlcmF0aW9uKG9wLCB7IGJsb2NrLCB2ZXJzaW9uIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oZWxwZXJzL3NjcmlwdHMvcnVuX29wZXJhdGlvbmApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICByZXF1ZXN0T3B0aW9ucy5xdWVyeSA9IHsgdmVyc2lvbiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdChyZXF1ZXN0T3B0aW9ucywgb3ApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIG9wIE9wZXJhdGlvbiB0byBzaW11bGF0ZVxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayBhbmQgdmVyc2lvblxuICAgICAqIEBkZXNjcmlwdGlvbiBTaW11bGF0ZSBydW5uaW5nIGFuIG9wZXJhdGlvbiBhdCBzb21lIGZ1dHVyZSBtb21lbnQgKGJhc2VkIG9uIHRoZSBudW1iZXIgb2YgYmxvY2tzIGdpdmVuIGluIHRoZSBgbGF0ZW5jeWAgYXJndW1lbnQpLCBhbmQgcmV0dXJuIHRoZSBvcGVyYXRpb24gYXBwbGljYXRpb24gcmVzdWx0LlxuICAgICAqIEBzZWUgaHR0cHM6Ly9naXRsYWIuY29tL3Rlem9zL3Rlem9zLy0vYmxvYi9tYXN0ZXIvZG9jcy9hcGkvb3hmb3JkLW9wZW5hcGkuanNvblxuICAgICAqL1xuICAgIHNpbXVsYXRlT3BlcmF0aW9uKG9wLCB7IGJsb2NrLCB2ZXJzaW9uIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oZWxwZXJzL3NjcmlwdHMvc2ltdWxhdGVfb3BlcmF0aW9uYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHJlcXVlc3RPcHRpb25zLnF1ZXJ5ID0geyB2ZXJzaW9uIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHJlcXVlc3RPcHRpb25zLCBvcCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29kZSBDb2RlIHRvIHJ1blxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBSdW4gYSBNaWNoZWxzb24gc2NyaXB0IGluIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNwb3N0LWJsb2NrLWlkLWhlbHBlcnMtc2NyaXB0cy1ydW4tY29kZVxuICAgICAqL1xuICAgIHJ1bkNvZGUoY29kZSwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geWllbGQgdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L2hlbHBlcnMvc2NyaXB0cy9ydW5fY29kZWApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfSwgY29kZSk7XG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gdmlld1NjcmlwdFBhcmFtcyBQYXJhbWV0ZXJzIG9mIHRoZSBzY3JpcHQgdmlldyB0byBydW5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gU2ltdWxhdGUgYSBjYWxsIHRvIGEgbWljaGVsc29uIHZpZXdcbiAgICAgKi9cbiAgICBydW5TY3JpcHRWaWV3KF9hLCBfYikge1xuICAgICAgICB2YXIgeyB1bnBhcnNpbmdfbW9kZSA9ICdSZWFkYWJsZScgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJ1bnBhcnNpbmdfbW9kZVwiXSk7XG4gICAgICAgIHZhciBfYyA9IF9iID09PSB2b2lkIDAgPyBkZWZhdWx0UlBDT3B0aW9ucyA6IF9iLCBibG9jayA9IF9jLmJsb2NrO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oZWxwZXJzL3NjcmlwdHMvcnVuX3NjcmlwdF92aWV3YCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9LCBPYmplY3QuYXNzaWduKHsgdW5wYXJzaW5nX21vZGUgfSwgcmVzdCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIHZpZXdQYXJhbXMgUGFyYW1ldGVycyBvZiB0aGUgdmlldyB0byBydW5cbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gU2ltdWxhdGUgYSBjYWxsIHRvIGEgdmlldyBmb2xsb3dpbmcgdGhlIFRaSVAtNCBzdGFuZGFyZC4gU2VlIGh0dHBzOi8vZ2l0bGFiLmNvbS90emlwL3R6aXAvLS9ibG9iL21hc3Rlci9wcm9wb3NhbHMvdHppcC00L3R6aXAtNC5tZCN2aWV3LWVudHJ5cG9pbnRzLlxuICAgICAqL1xuICAgIHJ1blZpZXcoX2EsIF9iKSB7XG4gICAgICAgIHZhciB7IHVucGFyc2luZ19tb2RlID0gJ1JlYWRhYmxlJyB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcInVucGFyc2luZ19tb2RlXCJdKTtcbiAgICAgICAgdmFyIF9jID0gX2IgPT09IHZvaWQgMCA/IGRlZmF1bHRSUENPcHRpb25zIDogX2IsIGJsb2NrID0gX2MuYmxvY2s7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L2hlbHBlcnMvc2NyaXB0cy9ydW5fdmlld2ApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfSwgT2JqZWN0LmFzc2lnbih7IHVucGFyc2luZ19tb2RlIH0sIHJlc3QpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldENoYWluSWQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vY2hhaW5faWRgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZGF0YSBEYXRhIHRvIHBhY2tcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQ29tcHV0ZXMgdGhlIHNlcmlhbGl6ZWQgdmVyc2lvbiBvZiBhIGRhdGEgZXhwcmVzc2lvbiB1c2luZyB0aGUgc2FtZSBhbGdvcml0aG0gYXMgc2NyaXB0IGluc3RydWN0aW9uIFBBQ0tcbiAgICAgKiBOb3RlOiBZb3Ugc2hvdWxkIGFsd2F5cyB2ZXJpZnkgdGhlIHBhY2tlZCBieXRlcyBiZWZvcmUgc2lnbmluZyBvciByZXF1ZXN0aW5nIHRoYXQgdGhleSBiZSBzaWduZWQgd2hlbiB1c2luZyB0aGUgdGhlIFJQQyB0byBwYWNrLlxuICAgICAqIFRoaXMgcHJlY2F1dGlvbiBoZWxwcyBwcm90ZWN0IHlvdSBhbmQgeW91ciBhcHBsaWNhdGlvbnMgdXNlcnMgZnJvbSBSUEMgbm9kZXMgdGhhdCBoYXZlIGJlZW4gY29tcHJvbWlzZWQuXG4gICAgICogQSBub2RlIHRoYXQgaXMgb3BlcmF0ZWQgYnkgYSBiYWQgYWN0b3IsIG9yIGNvbXByb21pc2VkIGJ5IGEgYmFkIGFjdG9yIGNvdWxkIHJldHVybiBhIGZ1bGx5IGZvcm1lZCBvcGVyYXRpb24gdGhhdCBkb2VzIG5vdCBjb3JyZXNwb25kIHRvIHRoZSBpbnB1dCBwcm92aWRlZCB0byB0aGUgUlBDIGVuZHBvaW50LlxuICAgICAqIEEgc2FmZXIgc29sdXRpb24gdG8gcGFjayBhbmQgc2lnbiBkYXRhIHdvdWxkIGJlIHRvIHVzZSB0aGUgYHBhY2tEYXRhQnl0ZXNgIGZ1bmN0aW9uIGF2YWlsYWJsZSBpbiB0aGUgYEB0YXF1aXRvL21pY2hlbC1jb2RlY2AgcGFja2FnZS5cbiAgICAgKiBAZXhhbXBsZSBwYWNrRGF0YSh7IGRhdGE6IHsgc3RyaW5nOiBcInRlc3RcIiB9LCB0eXBlOiB7IHByaW06IFwic3RyaW5nXCIgfSB9KVxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI3Bvc3QtYmxvY2staWQtaGVscGVycy1zY3JpcHRzLXBhY2stZGF0YVxuICAgICAqL1xuICAgIHBhY2tEYXRhKGRhdGEsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBfYSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9oZWxwZXJzL3NjcmlwdHMvcGFja19kYXRhYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICAgICAgICB9LCBkYXRhKSwgeyBnYXMgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJnYXNcIl0pO1xuICAgICAgICAgICAgbGV0IGZvcm1hdHRlZEdhcyA9IGdhcztcbiAgICAgICAgICAgIGNvbnN0IHRyeUJpZ051bWJlciA9IG5ldyBCaWdOdW1iZXIoZ2FzIHx8ICcnKTtcbiAgICAgICAgICAgIGlmICghdHJ5QmlnTnVtYmVyLmlzTmFOKCkpIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRHYXMgPSB0cnlCaWdOdW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7IGdhczogZm9ybWF0dGVkR2FzIH0sIHJlc3QpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIHJwYyByb290IHVybFxuICAgICAqL1xuICAgIGdldFJwY1VybCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudXJsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgdm90aW5nIHBlcmlvZCAoaW5kZXgsIGtpbmQsIHN0YXJ0aW5nIHBvc2l0aW9uKSBhbmQgcmVsYXRlZCBpbmZvcm1hdGlvbiAocG9zaXRpb24sIHJlbWFpbmluZykgb2YgdGhlIGludGVycm9nYXRlZCBibG9ja1xuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1jdXJyZW50LXBlcmlvZFxuICAgICAqL1xuICAgIGdldEN1cnJlbnRQZXJpb2QoeyBibG9jaywgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IHlpZWxkIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS92b3Rlcy9jdXJyZW50X3BlcmlvZGApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm5zIHRoZSB2b3RpbmcgcGVyaW9kIChpbmRleCwga2luZCwgc3RhcnRpbmcgcG9zaXRpb24pIGFuZCByZWxhdGVkIGluZm9ybWF0aW9uIChwb3NpdGlvbiwgcmVtYWluaW5nKSBvZiB0aGUgbmV4dCBibG9jay5Vc2VmdWwgdG8gY3JhZnQgb3BlcmF0aW9ucyB0aGF0IHdpbGwgYmUgdmFsaWQgaW4gdGhlIG5leHQgYmxvY2tcbiAgICAgKiBAZXhhbXBsZSBnZXRTdWNjZXNzb3JQZXJpb2QoKSB3aWxsIGRlZmF1bHQgdG8gc3VjY2Vzc29yIHZvdGluZyBwZXJpb2QgZm9yIC9tYWluL2NoYWlucy9ibG9jay9oZWFkLlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC12b3Rlcy1zdWNjZXNzb3ItcGVyaW9kXG4gICAgICovXG4gICAgZ2V0U3VjY2Vzc29yUGVyaW9kKHsgYmxvY2ssIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vdm90ZXMvc3VjY2Vzc29yX3BlcmlvZGApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXNwb25zZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBpZCBTYXBsaW5nIHN0YXRlIElEXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybnMgdGhlIHJvb3QgYW5kIGEgZGlmZiBvZiBhIHN0YXRlIHN0YXJ0aW5nIGZyb20gYW4gb3B0aW9uYWwgb2Zmc2V0IHdoaWNoIGlzIHplcm8gYnkgZGVmYXVsdFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYWN0aXZlL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LXNhcGxpbmctc2FwbGluZy1zdGF0ZS1pZC1nZXQtZGlmZlxuICAgICAqL1xuICAgIGdldFNhcGxpbmdEaWZmQnlJZChpZCwgeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vY29udGV4dC9zYXBsaW5nLyR7aWR9L2dldF9kaWZmYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHdlIHdhbnQgdG8gZ2V0IHRoZSBzYXBsaW5nIGRpZmZcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJucyB0aGUgcm9vdCBhbmQgYSBkaWZmIG9mIGEgc3RhdGUgc3RhcnRpbmcgZnJvbSBhbiBvcHRpb25hbCBvZmZzZXQgd2hpY2ggaXMgemVybyBieSBkZWZhdWx0XG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hY3RpdmUvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLXNpbmdsZS1zYXBsaW5nLWdldC1kaWZmXG4gICAgICovXG4gICAgZ2V0U2FwbGluZ0RpZmZCeUNvbnRyYWN0KGNvbnRyYWN0LCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2NvbnRyYWN0cy8ke2NvbnRyYWN0fS9zaW5nbGVfc2FwbGluZ19nZXRfZGlmZmApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBnZXQgY3VycmVudCBhbmQgbmV4dCBwcm90b2NvbFxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYWN0aXZlL3JwYy5odG1sI2dldC1ibG9jay1pZC1wcm90b2NvbHNcbiAgICAgKi9cbiAgICBnZXRQcm90b2NvbHMoeyBibG9jayB9ID0gZGVmYXVsdFJQQ09wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmh0dHBCYWNrZW5kLmNyZWF0ZVJlcXVlc3Qoe1xuICAgICAgICAgICAgICAgIHVybDogdGhpcy5jcmVhdGVVUkwoYC9jaGFpbnMvJHt0aGlzLmNoYWlufS9ibG9ja3MvJHtibG9ja30vcHJvdG9jb2xzYCksXG4gICAgICAgICAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0IGFkZHJlc3Mgb2YgdGhlIGNvbnRyYWN0IHdlIHdhbnQgdG8gcmV0cmlldmUgc3RvcmFnZSBpbmZvcm1hdGlvbiBvZlxuICAgICAqIEBwYXJhbSBvcHRpb25zIGNvbnRhaW5zIGdlbmVyaWMgY29uZmlndXJhdGlvbiBmb3IgcnBjIGNhbGxzIHRvIHNwZWNpZmllZCBibG9jayAoZGVmYXVsdCB0byBoZWFkKVxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIHVzZWQgc3RvcmFnZSBzcGFjZSBvZiB0aGUgY29udHJhY3RcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2xpbWEvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLXN0b3JhZ2VcbiAgICAgKi9cbiAgICBnZXRTdG9yYWdlVXNlZFNwYWNlKGNvbnRyYWN0LCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2NvbnRyYWN0cy8ke2NvbnRyYWN0fS9zdG9yYWdlL3VzZWRfc3BhY2VgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgYWRkcmVzcyBvZiB0aGUgY29udHJhY3Qgd2Ugd2FudCB0byByZXRyaWV2ZSBzdG9yYWdlIGluZm9ybWF0aW9uIG9mXG4gICAgICogQHBhcmFtIG9wdGlvbnMgY29udGFpbnMgZ2VuZXJpYyBjb25maWd1cmF0aW9uIGZvciBycGMgY2FsbHMgdG8gc3BlY2lmaWVkIGJsb2NrIChkZWZhdWx0IHRvIGhlYWQpXG4gID0gICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIHBhaWQgc3RvcmFnZSBzcGFjZSBvZiB0aGUgY29udHJhY3RcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2xpbWEvcnBjLmh0bWwjZ2V0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLXN0b3JhZ2VcbiAgICAgKi9cbiAgICBnZXRTdG9yYWdlUGFpZFNwYWNlKGNvbnRyYWN0LCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2NvbnRyYWN0cy8ke2NvbnRyYWN0fS9zdG9yYWdlL3BhaWRfc3BhY2VgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgaW1wbGljaXQgb3Igb3JpZ2luYXRlZCBhZGRyZXNzIHdlIHdhbnQgdG8gcmV0cmlldmUgdGlja2V0IGJhbGFuY2Ugb2ZcbiAgICAgKiBAcGFyYW0gdGlja2V0IG9iamVjdCB0byBzcGVjaWZ5IGEgdGlja2V0IGJ5IHRpY2tldGVyLCBjb250ZW50IHR5cGUgYW5kIGNvbnRlbnRcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBjb250cmFjdCdzIGJhbGFuY2Ugb2YgdGlja2V0IHdpdGggc3BlY2lmaWVkIHRpY2tldGVyLCBjb250ZW50IHR5cGUsIGFuZCBjb250ZW50LlxuICAgICAqIEBleGFtcGxlIHRpY2tldCB7IHRpY2tldGVyOiAnYWRkcmVzcycsIGNvbnRlbnRfdHlwZTogeyBwcmltOiBcInN0cmluZ1wiIH0sIGNvbnRlbnQ6IHsgc3RyaW5nOiAndGlja2V0MScgfSB9XG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9wcm90b2NvbHMvMDE2X211bWJhaS5odG1sI3JwYy1jaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0VGlja2V0QmFsYW5jZShjb250cmFjdCwgdGlja2V0LCB7IGJsb2NrIH0gPSBkZWZhdWx0UlBDT3B0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaHR0cEJhY2tlbmQuY3JlYXRlUmVxdWVzdCh7XG4gICAgICAgICAgICAgICAgdXJsOiB0aGlzLmNyZWF0ZVVSTChgL2NoYWlucy8ke3RoaXMuY2hhaW59L2Jsb2Nrcy8ke2Jsb2NrfS9jb250ZXh0L2NvbnRyYWN0cy8ke2NvbnRyYWN0fS90aWNrZXRfYmFsYW5jZWApLFxuICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICAgICAgfSwgdGlja2V0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwYXJhbSBjb250cmFjdCBvcmlnaW5hdGVkIGFkZHJlc3Mgd2Ugd2FudCB0byByZXRyaWV2ZSB0aWNrZXQgYmFsYW5jZXMgb2ZcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBjb250YWlucyBnZW5lcmljIGNvbmZpZ3VyYXRpb24gZm9yIHJwYyBjYWxscyB0byBzcGVjaWZpZWQgYmxvY2sgKGRlZmF1bHQgdG8gaGVhZClcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBjb21wbGV0ZSBsaXN0IG9mIHRpY2tldHMgb3duZWQgYnkgdGhlIGdpdmVuIGNvbnRyYWN0IGJ5IHNjYW5uaW5nIHRoZSBjb250cmFjdCdzIHN0b3JhZ2UuXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9wcm90b2NvbHMvMDE2X211bWJhaS5odG1sI3JwYy1jaGFuZ2VzXG4gICAgICovXG4gICAgZ2V0QWxsVGlja2V0QmFsYW5jZXMoY29udHJhY3QsIHsgYmxvY2sgfSA9IGRlZmF1bHRSUENPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vYmxvY2tzLyR7YmxvY2t9L2NvbnRleHQvY29udHJhY3RzLyR7Y29udHJhY3R9L2FsbF90aWNrZXRfYmFsYW5jZXNgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gTGlzdCB0aGUgcHJldmFsaWRhdGVkIG9wZXJhdGlvbnMgaW4gbWVtcG9vbCAoYWNjZXNzaWJpbGl0eSBvZiBtZW1wb29sIGRlcGVuZHMgb24gZWFjaCBycGMgZW5kcG9pbnQpXG4gICAgICogQHBhcmFtIGFyZ3MgaGFzIDUgb3B0aW9uYWwgcHJvcGVydGllcy4gV2Ugc3VwcG9ydCB2ZXJzaW9uIDEgYXMgZGVmYXVsdCB3aWxsIG91dHB1dCB7IGFwcGxpZWQ6IHsga2luZDogZW5kb3JzZW1lbnR9IH0gdmVyc2lvbiAyIHdpbGwgb3V0cHV0IHsgdmFsaWRhdGVkOiB7IGtpbmQ6IGF0dGVzdGF0aW9ufSB9LiBUaGUgcmVzdCBvZiB0aGUgcHJvcGVydGllcyBpcyB0byBmaWx0ZXIgcGVuZGluZyBvcGVyYXRpb25zIHJlc3BvbnNlXG4gICAgICogQGRlZmF1bHQgYXJncyB7IHZlcnNpb246ICcxJywgYXBwbGllZDogdHJ1ZSwgcmVmdXNlZDogdHJ1ZSwgb3V0ZGF0ZWQsIHRydWUsIGJyYW5jaFJlZnVzZWQ6IHRydWUsIGJyYW5jaERlbGF5ZWQ6IHRydWUsIHZhbGlkYXRpb25QYXNzOiB1bmRlZmluZWQgfVxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vQ0hBTkdFUy5odG1sP2hpZ2hsaWdodD1wZW5kaW5nX29wZXJhdGlvbnMjaWQ0XG4gICAgICovXG4gICAgZ2V0UGVuZGluZ09wZXJhdGlvbnMoYXJncyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5odHRwQmFja2VuZC5jcmVhdGVSZXF1ZXN0KHtcbiAgICAgICAgICAgICAgICB1cmw6IHRoaXMuY3JlYXRlVVJMKGAvY2hhaW5zLyR7dGhpcy5jaGFpbn0vbWVtcG9vbC9wZW5kaW5nX29wZXJhdGlvbnNgKSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHF1ZXJ5OiBhcmdzLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgTUVUQURBVEFfQkFMQU5DRV9VUERBVEVTX0NBVEVHT1JZLCBPUEVSQVRJT05fTUVUQURBVEEsIE9wS2luZCwgUHZtS2luZCwgUnBjQ2xpZW50LCBScGNDbGllbnRDYWNoZSwgU21hcnRSb2xsdXBJbnB1dFByb29mS2luZCwgU21hcnRSb2xsdXBSZWZ1dGF0aW9uT3B0aW9ucywgU21hcnRSb2xsdXBSZWZ1dGVHYW1lRW5kZWRQbGF5ZXJPdXRjb21lcywgU21hcnRSb2xsdXBSZWZ1dGVHYW1lRW5kZWRSZWFzb24sIFNtYXJ0Um9sbHVwUmVmdXRlR2FtZVN0YXR1c09wdGlvbnMsIFNtYXJ0Um9sbHVwUmVmdXRlUmV2ZWFsUHJvb2ZLaW5kLCBWRVJTSU9OLCBjYXN0VG9CaWdOdW1iZXIsIGRlZmF1bHRDaGFpbiwgZGVmYXVsdFJQQ09wdGlvbnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXRhcXVpdG8tcnBjLmVzNi5qcy5tYXBcbiJdLCJuYW1lcyI6WyJIdHRwQmFja2VuZCIsIkh0dHBSZXNwb25zZUVycm9yIiwiU1RBVFVTX0NPREUiLCJCaWdOdW1iZXIiLCJ2YWxpZGF0ZUFkZHJlc3MiLCJWYWxpZGF0aW9uUmVzdWx0IiwiaW52YWxpZERldGFpbCIsInZhbGlkYXRlQ29udHJhY3RBZGRyZXNzIiwiSW52YWxpZEFkZHJlc3NFcnJvciIsIkludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvciIsIl9fcmVzdCIsInMiLCJlIiwidCIsInAiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImNhbGwiLCJpbmRleE9mIiwiZ2V0T3duUHJvcGVydHlTeW1ib2xzIiwiaSIsImxlbmd0aCIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwiX19hd2FpdGVyIiwidGhpc0FyZyIsIl9hcmd1bWVudHMiLCJQIiwiZ2VuZXJhdG9yIiwiYWRvcHQiLCJ2YWx1ZSIsInJlc29sdmUiLCJQcm9taXNlIiwicmVqZWN0IiwiZnVsZmlsbGVkIiwic3RlcCIsIm5leHQiLCJyZWplY3RlZCIsInJlc3VsdCIsImRvbmUiLCJ0aGVuIiwiYXBwbHkiLCJTdXBwcmVzc2VkRXJyb3IiLCJlcnJvciIsInN1cHByZXNzZWQiLCJtZXNzYWdlIiwiRXJyb3IiLCJuYW1lIiwiZGVmYXVsdENoYWluIiwiZGVmYXVsdFJQQ09wdGlvbnMiLCJibG9jayIsIlJQQ01ldGhvZE5hbWUiLCJjYXN0VG9CaWdOdW1iZXIiLCJkYXRhIiwia2V5cyIsInJldHVybkFycmF5IiwiQXJyYXkiLCJpc0FycmF5IiwicmVzcG9uc2UiLCJmb3JFYWNoIiwia2V5IiwiaXRlbSIsInJlcyIsImRlZmF1bHRUdGwiLCJScGNDbGllbnRDYWNoZSIsImNvbnN0cnVjdG9yIiwicnBjQ2xpZW50IiwidHRsIiwiX2NhY2hlIiwiZ2V0QWxsQ2FjaGVkRGF0YSIsImRlbGV0ZUFsbENhY2hlZERhdGEiLCJmb3JtYXRDYWNoZUtleSIsInJwY1VybCIsInJwY01ldGhvZE5hbWUiLCJycGNNZXRob2RQYXJhbXMiLCJycGNNZXRob2REYXRhIiwicGFyYW1zVG9TdHJpbmciLCJwYXJhbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJoYXMiLCJnZXQiLCJwdXQiLCJoYW5kbGUiLCJzZXRUaW1lb3V0IiwicmVtb3ZlIiwiYXNzaWduIiwiYWRkcmVzcyIsImFkZHJlc3NWYWxpZGF0aW9uIiwiVkFMSUQiLCJ2YWxpZGF0ZUNvbnRyYWN0IiwiZ2V0QmxvY2tIYXNoIiwiZ2V0UnBjVXJsIiwiR0VUX0JMT0NLX0hBU0giLCJnZXRMaXZlQmxvY2tzIiwiR0VUX0xJVkVfQkxPQ0tTIiwiZ2V0QmFsYW5jZSIsIkdFVF9CQUxBTkNFIiwiZ2V0U3RvcmFnZSIsIkdFVF9TVE9SQUdFIiwiZ2V0U2NyaXB0IiwiR0VUX1NDUklQVCIsImdldE5vcm1hbGl6ZWRTY3JpcHQiLCJ1bnBhcnNpbmdNb2RlIiwidW5wYXJzaW5nX21vZGUiLCJHRVRfTk9STUFMSVpFRF9TQ1JJUFQiLCJnZXRDb250cmFjdCIsIkdFVF9DT05UUkFDVCIsImdldE1hbmFnZXJLZXkiLCJHRVRfTUFOQUdFUl9LRVkiLCJnZXREZWxlZ2F0ZSIsIkdFVF9ERUxFR0FURSIsImdldEJpZ01hcEtleSIsImtleVVybCIsIkdFVF9CSUdfTUFQX0tFWSIsImdldEJpZ01hcEV4cHIiLCJpZCIsImV4cHIiLCJHRVRfQklHX01BUF9FWFBSIiwiZ2V0RGVsZWdhdGVzIiwiR0VUX0RFTEVHQVRFUyIsImdldFZvdGluZ0luZm8iLCJHRVRfVk9USU5HX0lORk8iLCJnZXRDb25zdGFudHMiLCJHRVRfQ09OU1RBTlRTIiwiZ2V0QmxvY2siLCJHRVRfQkxPQ0siLCJnZXRCbG9ja0hlYWRlciIsIkdFVF9CTE9DS19IRUFERVIiLCJnZXRCbG9ja01ldGFkYXRhIiwiR0VUX0JMT0NLX01FVEFEQVRBIiwiZ2V0QmFraW5nUmlnaHRzIiwiYXJncyIsIkdFVF9CQUtJTkdfUklHSFRTIiwiZ2V0QXR0ZXN0YXRpb25SaWdodHMiLCJHRVRfQVRURVNUQVRJT05fUklHSFRTIiwiZ2V0RW5kb3JzaW5nUmlnaHRzIiwiR0VUX0VORE9SU0lOR19SSUdIVFMiLCJnZXRCYWxsb3RMaXN0IiwiR0VUX0JBTExPVF9MSVNUIiwiZ2V0QmFsbG90cyIsIkdFVF9CQUxMT1RTIiwiZ2V0Q3VycmVudFByb3Bvc2FsIiwiR0VUX0NVUlJFTlRfUFJPUE9TQUwiLCJnZXRDdXJyZW50UXVvcnVtIiwiR0VUX0NVUlJFTlRfUVVPUlVNIiwiZ2V0Vm90ZXNMaXN0aW5ncyIsIkdFVF9WT1RFU19MSVNUSU5HUyIsImdldFByb3Bvc2FscyIsIkdFVF9QUk9QT1NBTFMiLCJmb3JnZU9wZXJhdGlvbnMiLCJpbmplY3RPcGVyYXRpb24iLCJzaWduZWRPcEJ5dGVzIiwicHJlYXBwbHlPcGVyYXRpb25zIiwib3BzIiwiZ2V0RW50cnlwb2ludHMiLCJjb250cmFjdCIsIkdFVF9FTlRSWVBPSU5UUyIsInJ1bk9wZXJhdGlvbiIsIm9wIiwic2ltdWxhdGVPcGVyYXRpb24iLCJydW5Db2RlIiwiY29kZSIsInJ1blNjcmlwdFZpZXciLCJfYSIsIl9iIiwicmVzdCIsIl9jIiwicnVuVmlldyIsImdldENoYWluSWQiLCJHRVRfQ0hBSU5fSUQiLCJwYWNrRGF0YSIsIlBBQ0tfREFUQSIsImdldEN1cnJlbnRQZXJpb2QiLCJHRVRfQ1VSUkVOVF9QRVJJT0QiLCJnZXRTdWNjZXNzb3JQZXJpb2QiLCJHRVRfU1VDQ0VTU09SX1BFUklPRCIsImdldFNhcGxpbmdEaWZmQnlJZCIsIkdFVF9TQVBMSU5HX0RJRkZfQllfSUQiLCJnZXRTYXBsaW5nRGlmZkJ5Q29udHJhY3QiLCJHRVRfU0FQTElOR19ESUZGX0JZX0NPTlRSQUNUIiwiZ2V0UHJvdG9jb2xzIiwiR0VUX1BST1RPQ09MUyIsImdldFN0b3JhZ2VVc2VkU3BhY2UiLCJHRVRfU1RPUkFHRV9VU0VEX1NQQUNFIiwiZ2V0U3RvcmFnZVBhaWRTcGFjZSIsIkdFVF9TVE9SQUdFX1BBSURfU1BBQ0UiLCJnZXRUaWNrZXRCYWxhbmNlIiwidGlja2V0IiwiR0VUX1RJQ0tFVF9CQUxBTkNFIiwiZ2V0QWxsVGlja2V0QmFsYW5jZXMiLCJHRVRfQUxMX1RJQ0tFVF9CQUxBTkNFUyIsImdldFBlbmRpbmdPcGVyYXRpb25zIiwiR0VUX1BFTkRJTkdfT1BFUkFUSU9OUyIsIk9QRVJBVElPTl9NRVRBREFUQSIsIk1FVEFEQVRBX0JBTEFOQ0VfVVBEQVRFU19DQVRFR09SWSIsIlB2bUtpbmQiLCJTbWFydFJvbGx1cFJlZnV0YXRpb25PcHRpb25zIiwiU21hcnRSb2xsdXBJbnB1dFByb29mS2luZCIsIlNtYXJ0Um9sbHVwUmVmdXRlUmV2ZWFsUHJvb2ZLaW5kIiwiU21hcnRSb2xsdXBSZWZ1dGVHYW1lU3RhdHVzT3B0aW9ucyIsIlNtYXJ0Um9sbHVwUmVmdXRlR2FtZUVuZGVkUGxheWVyT3V0Y29tZXMiLCJTbWFydFJvbGx1cFJlZnV0ZUdhbWVFbmRlZFJlYXNvbiIsIk9wS2luZCIsIlZFUlNJT04iLCJScGNDbGllbnQiLCJ1cmwiLCJjaGFpbiIsImh0dHBCYWNrZW5kIiwiY3JlYXRlVVJMIiwicGF0aCIsInJvb3RVcmwiLCJlbmRzV2l0aCIsInNsaWNlIiwiaGFzaCIsImNyZWF0ZVJlcXVlc3QiLCJtZXRob2QiLCJibG9ja3MiLCJiYWxhbmNlIiwiY29udHJhY3RSZXNwb25zZSIsImRlbGVnYXRlIiwiZXgiLCJzdGF0dXMiLCJOT1RfRk9VTkQiLCJjYXN0ZWRSZXNwb25zZSIsImZyb3plbl9iYWxhbmNlX2J5X2N5Y2xlIiwibWFwIiwiZGVwb3NpdCIsImRlcG9zaXRzIiwiZmVlcyIsInJld2FyZHMiLCJjYXN0ZWRUb0JpZ051bWJlciIsInVuZGVmaW5lZCIsInZlcnNpb24iLCJyZXF1ZXN0T3B0aW9ucyIsInF1ZXJ5IiwiY2FzdGVkIiwidm90aW5nX3Bvd2VyIiwiZ2FzIiwiZm9ybWF0dGVkR2FzIiwidHJ5QmlnTnVtYmVyIiwiaXNOYU4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/rpc/dist/taquito-rpc.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/taquito/dist/taquito.es6.js":
/*!***********************************************************!*\
  !*** ./node_modules/@taquito/taquito/dist/taquito.es6.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BallotOperation: () => (/* binding */ BallotOperation),\n/* harmony export */   BatchOperation: () => (/* binding */ BatchOperation),\n/* harmony export */   BigMapAbstraction: () => (/* binding */ BigMapAbstraction),\n/* harmony export */   COST_PER_BYTE: () => (/* binding */ COST_PER_BYTE),\n/* harmony export */   ChainIds: () => (/* binding */ ChainIds),\n/* harmony export */   CompositeForger: () => (/* binding */ CompositeForger),\n/* harmony export */   Context: () => (/* binding */ Context),\n/* harmony export */   ContractAbstraction: () => (/* binding */ ContractAbstraction),\n/* harmony export */   ContractMethod: () => (/* binding */ ContractMethod),\n/* harmony export */   ContractMethodObject: () => (/* binding */ ContractMethodObject),\n/* harmony export */   ContractView: () => (/* binding */ ContractView),\n/* harmony export */   DEFAULT_FEE: () => (/* binding */ DEFAULT_FEE),\n/* harmony export */   DEFAULT_GAS_LIMIT: () => (/* binding */ DEFAULT_GAS_LIMIT),\n/* harmony export */   DEFAULT_SMART_CONTRACT_METHOD_NAME: () => (/* binding */ DEFAULT_SMART_CONTRACT_METHOD_NAME),\n/* harmony export */   DEFAULT_STORAGE_LIMIT: () => (/* binding */ DEFAULT_STORAGE_LIMIT),\n/* harmony export */   DefaultGlobalConstantsProvider: () => (/* binding */ DefaultGlobalConstantsProvider),\n/* harmony export */   DelegateOperation: () => (/* binding */ DelegateOperation),\n/* harmony export */   DelegationWalletOperation: () => (/* binding */ DelegationWalletOperation),\n/* harmony export */   DrainDelegateOperation: () => (/* binding */ DrainDelegateOperation),\n/* harmony export */   Estimate: () => (/* binding */ Estimate),\n/* harmony export */   GlobalConstantNotFound: () => (/* binding */ GlobalConstantNotFound),\n/* harmony export */   InvalidBalanceError: () => (/* binding */ InvalidBalanceError),\n/* harmony export */   InvalidCodeParameter: () => (/* binding */ InvalidCodeParameter),\n/* harmony export */   InvalidDelegationSource: () => (/* binding */ InvalidDelegationSource),\n/* harmony export */   InvalidEstimateValueError: () => (/* binding */ InvalidEstimateValueError),\n/* harmony export */   InvalidInitParameter: () => (/* binding */ InvalidInitParameter),\n/* harmony export */   InvalidParameterError: () => (/* binding */ InvalidParameterError),\n/* harmony export */   InvalidViewSimulationContext: () => (/* binding */ InvalidViewSimulationContext),\n/* harmony export */   LegacyWalletProvider: () => (/* binding */ LegacyWalletProvider),\n/* harmony export */   MANAGER_LAMBDA: () => (/* binding */ MANAGER_LAMBDA),\n/* harmony export */   MichelCodecPacker: () => (/* binding */ MichelCodecPacker),\n/* harmony export */   MichelCodecParser: () => (/* binding */ MichelCodecParser),\n/* harmony export */   MichelsonMap: () => (/* reexport safe */ _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.MichelsonMap),\n/* harmony export */   NoopParser: () => (/* binding */ NoopParser),\n/* harmony export */   ObservableSubscription: () => (/* binding */ ObservableSubscription),\n/* harmony export */   OpKind: () => (/* reexport safe */ _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   OperationBatch: () => (/* binding */ OperationBatch),\n/* harmony export */   OriginationOperation: () => (/* binding */ OriginationOperation),\n/* harmony export */   OriginationParameterError: () => (/* binding */ OriginationParameterError),\n/* harmony export */   OriginationWalletOperation: () => (/* binding */ OriginationWalletOperation),\n/* harmony export */   PollingSubscribeProvider: () => (/* binding */ PollingSubscribeProvider),\n/* harmony export */   PrepareProvider: () => (/* binding */ PrepareProvider),\n/* harmony export */   Protocols: () => (/* binding */ Protocols),\n/* harmony export */   RPCEstimateProvider: () => (/* binding */ RPCEstimateProvider),\n/* harmony export */   RevealEstimateError: () => (/* binding */ RevealEstimateError),\n/* harmony export */   RevealOperationError: () => (/* binding */ RevealOperationError),\n/* harmony export */   RpcForger: () => (/* binding */ RpcForger),\n/* harmony export */   RpcInjector: () => (/* binding */ RpcInjector),\n/* harmony export */   RpcPacker: () => (/* binding */ RpcPacker),\n/* harmony export */   RpcReadAdapter: () => (/* binding */ RpcReadAdapter),\n/* harmony export */   SaplingStateAbstraction: () => (/* binding */ SaplingStateAbstraction),\n/* harmony export */   TaquitoLocalForger: () => (/* binding */ TaquitoLocalForger),\n/* harmony export */   TezosOperationError: () => (/* binding */ TezosOperationError),\n/* harmony export */   TezosPreapplyFailureError: () => (/* binding */ TezosPreapplyFailureError),\n/* harmony export */   TezosToolkit: () => (/* binding */ TezosToolkit),\n/* harmony export */   TransactionOperation: () => (/* binding */ TransactionOperation),\n/* harmony export */   TransactionWalletOperation: () => (/* binding */ TransactionWalletOperation),\n/* harmony export */   UnconfiguredGlobalConstantsProviderError: () => (/* binding */ UnconfiguredGlobalConstantsProviderError),\n/* harmony export */   UnitValue: () => (/* reexport safe */ _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.UnitValue),\n/* harmony export */   VIEW_LAMBDA: () => (/* binding */ VIEW_LAMBDA),\n/* harmony export */   ViewSimulationError: () => (/* binding */ ViewSimulationError),\n/* harmony export */   Wallet: () => (/* binding */ Wallet),\n/* harmony export */   WalletOperation: () => (/* binding */ WalletOperation),\n/* harmony export */   WalletOperationBatch: () => (/* binding */ WalletOperationBatch),\n/* harmony export */   compose: () => (/* binding */ compose),\n/* harmony export */   createActivationOperation: () => (/* binding */ createActivationOperation),\n/* harmony export */   createBallotOperation: () => (/* binding */ createBallotOperation),\n/* harmony export */   createDrainDelegateOperation: () => (/* binding */ createDrainDelegateOperation),\n/* harmony export */   createIncreasePaidStorageOperation: () => (/* binding */ createIncreasePaidStorageOperation),\n/* harmony export */   createOriginationOperation: () => (/* binding */ createOriginationOperation),\n/* harmony export */   createProposalsOperation: () => (/* binding */ createProposalsOperation),\n/* harmony export */   createRegisterDelegateOperation: () => (/* binding */ createRegisterDelegateOperation),\n/* harmony export */   createRegisterGlobalConstantOperation: () => (/* binding */ createRegisterGlobalConstantOperation),\n/* harmony export */   createRevealOperation: () => (/* binding */ createRevealOperation),\n/* harmony export */   createSetDelegateOperation: () => (/* binding */ createSetDelegateOperation),\n/* harmony export */   createSmartRollupAddMessagesOperation: () => (/* binding */ createSmartRollupAddMessagesOperation),\n/* harmony export */   createSmartRollupOriginateOperation: () => (/* binding */ createSmartRollupOriginateOperation),\n/* harmony export */   createTransferOperation: () => (/* binding */ createTransferOperation),\n/* harmony export */   createTransferTicketOperation: () => (/* binding */ createTransferTicketOperation),\n/* harmony export */   createUpdateConsensusKeyOperation: () => (/* binding */ createUpdateConsensusKeyOperation),\n/* harmony export */   defaultConfigConfirmation: () => (/* binding */ defaultConfigConfirmation),\n/* harmony export */   getRevealGasLimit: () => (/* binding */ getRevealGasLimit),\n/* harmony export */   protocols: () => (/* binding */ protocols),\n/* harmony export */   smartContractAbstractionSemantic: () => (/* binding */ smartContractAbstractionSemantic),\n/* harmony export */   validateAndExtractFailwith: () => (/* binding */ validateAndExtractFailwith)\n/* harmony export */ });\n/* harmony import */ var _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @taquito/rpc */ \"(ssr)/./node_modules/@taquito/rpc/dist/taquito-rpc.es6.js\");\n/* harmony import */ var _taquito_http_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @taquito/http-utils */ \"(ssr)/./node_modules/@taquito/http-utils/dist/taquito-http-utils.es6.js\");\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Observable.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/ReplaySubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/BehaviorSubject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/throwError.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/defer.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/range.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/of.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/empty.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/combineLatest.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/from.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/concat.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/Subject.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/never.js\");\n/* harmony import */ var _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! __barrel_optimize__?names=BehaviorSubject,EMPTY,NEVER,Observable,ReplaySubject,Subject,combineLatest,concat,defer,from,of,range,throwError,timer!=!rxjs */ \"(ssr)/./node_modules/rxjs/dist/esm5/internal/observable/timer.js\");\n/* harmony import */ var rxjs_operators__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! rxjs/operators */ \"(ssr)/./node_modules/rxjs/dist/cjs/operators/index.js\");\n/* harmony import */ var _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @taquito/michelson-encoder */ \"(ssr)/./node_modules/@taquito/michelson-encoder/dist/taquito-michelson-encoder.es6.js\");\n/* harmony import */ var _taquito_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @taquito/utils */ \"(ssr)/./node_modules/@taquito/utils/dist/taquito-utils.es6.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var _taquito_michel_codec__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @taquito/michel-codec */ \"(ssr)/./node_modules/@taquito/michel-codec/dist/taquito-michel-codec.es6.js\");\n/* harmony import */ var _taquito_local_forging__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @taquito/local-forging */ \"(ssr)/./node_modules/@taquito/local-forging/dist/taquito-local-forging.es6.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */ /* global Reflect, Promise, SuppressedError, Symbol */ function __rest(s, e) {\n    var t = {};\n    for(var p in s)if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for(var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++){\n        if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n    }\n    return t;\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n    function adopt(value) {\n        return value instanceof P ? value : new P(function(resolve) {\n            resolve(value);\n        });\n    }\n    return new (P || (P = Promise))(function(resolve, reject) {\n        function fulfilled(value) {\n            try {\n                step(generator.next(value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function rejected(value) {\n            try {\n                step(generator[\"throw\"](value));\n            } catch (e) {\n                reject(e);\n            }\n        }\n        function step(result) {\n            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n        }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n}\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function(error, suppressed, message) {\n    var e = new Error(message);\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nfunction formatErrorMessage(error, stringToReplace) {\n    const body = JSON.parse(error.body);\n    if (body[0] && body[0].kind && body[0].msg) {\n        const newBody = JSON.stringify({\n            kind: body[0].kind,\n            id: body[0].id,\n            msg: body[0].msg.replace(stringToReplace, \"\")\n        });\n        return new _taquito_http_utils__WEBPACK_IMPORTED_MODULE_1__.HttpResponseError(`Http error response: (${error.status}) ${newBody}`, error.status, error.statusText, newBody, error.url);\n    } else {\n        return error;\n    }\n}\nclass RpcInjector {\n    constructor(context){\n        this.context = context;\n    }\n    inject(signedOperationBytes) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let hash;\n            try {\n                hash = yield this.context.rpc.injectOperation(signedOperationBytes);\n            } catch (error) {\n                const stringToStrip = \". You may want to use --replace to provide adequate fee and replace it\";\n                if (error instanceof _taquito_http_utils__WEBPACK_IMPORTED_MODULE_1__.HttpResponseError && error.message.includes(stringToStrip)) {\n                    throw formatErrorMessage(error, stringToStrip);\n                } else {\n                    throw error;\n                }\n            }\n            return hash;\n        });\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates no signer has been configured in the TezosToolkit instance\n */ class UnconfiguredSignerError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TezosToolkitConfigError {\n    constructor(){\n        super();\n        this.name = \"UnconfiguredSignerError\";\n        this.message = \"No signer has been configured. Please configure one by calling setProvider({signer}) on your TezosToolkit instance.\";\n    }\n}\n/**\n * @description Default signer implementation which does nothing and produce invalid signature\n * @throw {@link UnconfiguredSignerError}\n */ class NoopSigner {\n    publicKey() {\n        return __awaiter(this, void 0, void 0, function*() {\n            throw new UnconfiguredSignerError();\n        });\n    }\n    publicKeyHash() {\n        return __awaiter(this, void 0, void 0, function*() {\n            throw new UnconfiguredSignerError();\n        });\n    }\n    secretKey() {\n        return __awaiter(this, void 0, void 0, function*() {\n            throw new UnconfiguredSignerError();\n        });\n    }\n    sign(_bytes, _watermark) {\n        return __awaiter(this, void 0, void 0, function*() {\n            throw new UnconfiguredSignerError();\n        });\n    }\n}\nfunction createObservableFromSubscription(sub) {\n    return new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable((subscriber)=>{\n        sub.on(\"data\", (data)=>{\n            subscriber.next(data);\n        });\n        sub.on(\"error\", (error)=>{\n            subscriber.error(error);\n        });\n        sub.on(\"close\", ()=>{\n            subscriber.complete();\n        });\n        return ()=>{\n            sub.close();\n        };\n    });\n}\nconst DEFAULT_GAS_LIMIT = {\n    DELEGATION: 10600,\n    ORIGINATION: 10600,\n    TRANSFER: 10600,\n    /* This is used for gas_limit. There is no harm in setting a higher limit.\n     Only if an account has a balance that is very close to the total gas consumption,\n     then this margin can fail the operation.\n     Another benefit of this higher value is that then Dapps build with Taquito 17 can\n     still work with Mumbainet, as this value is higher than the reveal cost in Mumbai.\n    */ REVEAL_TZ1: 1000,\n    REVEAL_TZ2: 1000,\n    REVEAL_TZ3: 2000,\n    REVEAL_TZ4: 2000\n};\nconst DEFAULT_FEE = {\n    DELEGATION: 1257,\n    ORIGINATION: 10000,\n    TRANSFER: 10000,\n    REVEAL: 374\n};\nconst DEFAULT_STORAGE_LIMIT = {\n    DELEGATION: 0,\n    ORIGINATION: 257,\n    TRANSFER: 257,\n    REVEAL: 0\n};\nconst COST_PER_BYTE = 250;\nvar Protocols;\n(function(Protocols) {\n    Protocols[\"Pt24m4xi\"] = \"Pt24m4xiPbLDhVgVfABUjirbmda3yohdN82Sp9FeuAXJ4eV9otd\";\n    Protocols[\"PsBABY5H\"] = \"PsBABY5HQTSkA4297zNHfsZNKtxULfL18y95qb3m53QJiXGmrbU\";\n    Protocols[\"PsBabyM1\"] = \"PsBabyM1eUXZseaJdmXFApDSBqj8YBfwELoxZHHW77EMcAbbwAS\";\n    Protocols[\"PsCARTHA\"] = \"PsCARTHAGazKbHtnKfLzQg3kms52kSRpgnDY982a9oYsSXRLQEb\";\n    Protocols[\"PsDELPH1\"] = \"PsDELPH1Kxsxt8f9eWbxQeRxkjfbxoqM52jvs5Y5fBxWWh4ifpo\";\n    Protocols[\"PtEdo2Zk\"] = \"PtEdo2ZkT9oKpimTah6x2embF25oss54njMuPzkJTEi5RqfdZFA\";\n    Protocols[\"PsFLorena\"] = \"PsFLorenaUUuikDWvMDr6fGBRG8kt3e3D3fHoXK1j1BFRxeSH4i\";\n    Protocols[\"PtGRANADs\"] = \"PtGRANADsDU8R9daYKAgWnQYAJ64omN1o3KMGVCykShA97vQbvV\";\n    Protocols[\"PtHangz2\"] = \"PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx\";\n    Protocols[\"PsiThaCa\"] = \"PsiThaCaT47Zboaw71QWScM8sXeMM7bbQFncK9FLqYc6EKdpjVP\";\n    Protocols[\"Psithaca2\"] = \"Psithaca2MLRFYargivpo7YvUr7wUDqyxrdhC5CQq78mRvimz6A\";\n    Protocols[\"PtJakart2\"] = \"PtJakart2xVj7pYXJBXrqHgd82rdkLey5ZeeGwDgPp9rhQUbSqY\";\n    Protocols[\"PtKathman\"] = \"PtKathmankSpLLDALzWw7CGD2j2MtyveTwboEYokqUCP4a1LxMg\";\n    Protocols[\"PtLimaPtL\"] = \"PtLimaPtLMwfNinJi9rCfDPWea8dFgTZ1MeJ9f1m2SRic6ayiwW\";\n    Protocols[\"PtMumbaii\"] = \"PtMumbaiiFFEGbew1rRjzSPyzRbA51Tm3RVZL5suHPxSZYDhCEc\";\n    Protocols[\"PtMumbai2\"] = \"PtMumbai2TmsJHNGRkD8v8YDbtao7BLUC3wjASn1inAKLFCjaH1\";\n    Protocols[\"PtNairobi\"] = \"PtNairobiyssHuh87hEhfVBGCVrK3WnS8Z2FT4ymB5tAa4r1nQf\";\n    Protocols[\"ProxfordY\"] = \"ProxfordYmVfjWnRcgjWH36fW6PArwqykTFzotUxRs6gmTcZDuH\";\n    Protocols[\"ProtoALpha\"] = \"ProtoALphaALphaALphaALphaALphaALphaALphaALphaDdp3zK\";\n})(Protocols || (Protocols = {}));\nconst protocols = {\n    \"004\": [\n        Protocols.Pt24m4xi\n    ],\n    \"005\": [\n        Protocols.PsBABY5H,\n        Protocols.PsBabyM1\n    ],\n    \"006\": [\n        Protocols.PsCARTHA\n    ],\n    \"007\": [\n        Protocols.PsDELPH1\n    ],\n    \"008\": [\n        Protocols.PtEdo2Zk\n    ],\n    \"009\": [\n        Protocols.PsFLorena\n    ],\n    \"010\": [\n        Protocols.PtGRANADs\n    ],\n    \"011\": [\n        Protocols.PtHangz2\n    ],\n    \"012\": [\n        Protocols.PsiThaCa,\n        Protocols.Psithaca2\n    ],\n    \"013\": [\n        Protocols.PtJakart2\n    ],\n    \"014\": [\n        Protocols.PtKathman\n    ],\n    \"015\": [\n        Protocols.PtLimaPtL\n    ],\n    \"016\": [\n        Protocols.PtMumbai2\n    ],\n    \"017\": [\n        Protocols.PtNairobi\n    ],\n    \"019\": [\n        Protocols.ProxfordY\n    ],\n    \"020\": [\n        Protocols.ProtoALpha\n    ]\n};\nvar ChainIds;\n(function(ChainIds) {\n    ChainIds[\"MAINNET\"] = \"NetXdQprcVkpaWU\";\n    ChainIds[\"CARTHAGENET\"] = \"NetXjD3HPJJjmcd\";\n    ChainIds[\"DELPHINET\"] = \"NetXm8tYqnMWky1\";\n    ChainIds[\"EDONET\"] = \"NetXSgo1ZT2DRUG\";\n    ChainIds[\"FLORENCENET\"] = \"NetXxkAx4woPLyu\";\n    ChainIds[\"GRANADANET\"] = \"NetXz969SFaFn8k\";\n    ChainIds[\"HANGZHOUNET\"] = \"NetXZSsxBpMQeAT\";\n    ChainIds[\"ITHACANET\"] = \"NetXbhmtAbMukLc\";\n    ChainIds[\"ITHACANET2\"] = \"NetXnHfVqm9iesp\";\n    ChainIds[\"JAKARTANET2\"] = \"NetXLH1uAxK7CCh\";\n    ChainIds[\"KATHMANDUNET\"] = \"NetXazhm4yetmff\";\n    ChainIds[\"LIMANET\"] = \"NetXizpkH94bocH\";\n    ChainIds[\"MUMBAINET\"] = \"NetXQw6nWSnrJ5t\";\n    ChainIds[\"MUMBAINET2\"] = \"NetXgbcrNtXD2yA\";\n    ChainIds[\"NAIROBINET\"] = \"NetXyuzvDo2Ugzb\";\n    ChainIds[\"OXFORDNET2\"] = \"NetXxWsskGahzQB\";\n})(ChainIds || (ChainIds = {}));\nconst getRevealGasLimit = (address)=>Math.round(getRevealGasLimitInternal(address) * 11 / 10);\nconst getRevealGasLimitInternal = (address)=>{\n    switch(address.substring(0, 3)){\n        case \"tz1\":\n            return DEFAULT_GAS_LIMIT.REVEAL_TZ1;\n        case \"tz2\":\n            return DEFAULT_GAS_LIMIT.REVEAL_TZ2;\n        case \"tz3\":\n            return DEFAULT_GAS_LIMIT.REVEAL_TZ3;\n        case \"tz4\":\n            return DEFAULT_GAS_LIMIT.REVEAL_TZ4;\n        default:\n            throw new Error(`Cannot estimate reveal gas limit for ${address}`);\n    }\n};\n/**\n *  @category Error\n *  @description Error that indicates invalid smart contract parameters being passed or used\n */ class InvalidParameterError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(smartContractMethodName, sigs, invalidParams){\n        super();\n        this.smartContractMethodName = smartContractMethodName;\n        this.sigs = sigs;\n        this.invalidParams = invalidParams;\n        this.name = \"InvalidParameterError\";\n        this.message = `${smartContractMethodName} Received ${invalidParams.length} arguments while expecting one of the following signatures (${JSON.stringify(sigs)})`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid delegation source contract address being passed or used\n */ class InvalidDelegationSource extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(source){\n        super();\n        this.source = source;\n        this.name = `InvalidDelegationSource`;\n        this.message = `Since Babylon delegation source can no longer be a contract address ${source}. Please use the smart contract abstraction to set your delegate.`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid smart contract code parameter being passed or used\n */ class InvalidCodeParameter extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(message, data){\n        super();\n        this.message = message;\n        this.data = data;\n        this.name = \"InvalidCodeParameter\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid smart contract init parameter being passed or used\n */ class InvalidInitParameter extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(message, data){\n        super();\n        this.message = message;\n        this.data = data;\n        this.name = \"InvalidInitParameter\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a failure when conducting a view simulation\n */ class ViewSimulationError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.RpcError {\n    constructor(message, viewName, failWith, cause){\n        super();\n        this.message = message;\n        this.viewName = viewName;\n        this.failWith = failWith;\n        this.cause = cause;\n        this.name = \"ViewSimulationError\";\n    }\n}\nconst validateAndExtractFailwith = (error)=>{\n    if (isJsonString(error.body)) {\n        const parsedError = JSON.parse(error.body);\n        if (Array.isArray(parsedError) && \"with\" in parsedError[parsedError.length - 1]) {\n            return parsedError[parsedError.length - 1].with;\n        }\n    }\n};\nconst isJsonString = (str)=>{\n    try {\n        JSON.parse(str);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n/**\n *  @category Error\n *  @description Error that indicates invalid or unconfigured context when executing a view\n */ class InvalidViewSimulationContext extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(info){\n        super();\n        this.info = info;\n        this.name = \"InvalidViewSimulationContext\";\n        this.message = `${info} Please configure the context of the view execution in the executeView method.`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a mistake happening during the reveal operation\n */ class RevealOperationError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.RpcError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"RevealOperationError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a mistake in the parameters in the preparation of an Origination operation\n */ class OriginationParameterError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid balance being passed or used\n */ class InvalidBalanceError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"InvalidBalanceError\";\n    }\n}\nconst createActivationOperation = ({ pkh, secret })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ACTIVATION,\n            pkh,\n            secret\n        };\n    });\nconst createOriginationOperation = ({ code, init, balance = \"0\", delegate, storage, fee = DEFAULT_FEE.ORIGINATION, gasLimit = DEFAULT_GAS_LIMIT.ORIGINATION, storageLimit = DEFAULT_STORAGE_LIMIT.ORIGINATION, mutez = false })=>__awaiter(void 0, void 0, void 0, function*() {\n        if (storage !== undefined && init !== undefined) {\n            throw new OriginationParameterError(\"Storage and Init cannot be set a the same time. Please either use storage or init but not both.\");\n        }\n        if (!Array.isArray(code)) {\n            throw new InvalidCodeParameter(\"Wrong code parameter type, expected an array\", code);\n        }\n        let contractStorage;\n        if (storage !== undefined) {\n            const storageType = code.find((p)=>\"prim\" in p && p.prim === \"storage\");\n            if ((storageType === null || storageType === void 0 ? void 0 : storageType.args) === undefined) {\n                throw new InvalidCodeParameter(\"The storage section is missing from the script\", code);\n            }\n            const schema = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema(storageType.args[0]); // TODO\n            contractStorage = schema.Encode(storage);\n        } else if (init !== undefined && typeof init === \"object\") {\n            contractStorage = init;\n        } else {\n            throw new InvalidInitParameter(\"Wrong init parameter type, expected JSON Michelson\", init);\n        }\n        const script = {\n            code,\n            storage: contractStorage\n        };\n        if (isNaN(Number(balance))) {\n            throw new InvalidBalanceError(`Invalid Balance \"${balance}\", cannot be converted to a number`);\n        }\n        const operation = {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            balance: mutez ? balance.toString() : (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.format)(\"tz\", \"mutez\", balance).toString(),\n            script\n        };\n        if (delegate) {\n            operation.delegate = delegate;\n        }\n        return operation;\n    });\nconst createTransferOperation = ({ to, amount, parameter, fee = DEFAULT_FEE.TRANSFER, gasLimit = DEFAULT_GAS_LIMIT.TRANSFER, storageLimit = DEFAULT_STORAGE_LIMIT.TRANSFER, mutez = false })=>__awaiter(void 0, void 0, void 0, function*() {\n        const operation = {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            amount: mutez ? amount.toString() : (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.format)(\"tz\", \"mutez\", amount).toString(),\n            destination: to,\n            parameters: parameter\n        };\n        return operation;\n    });\nconst createSetDelegateOperation = ({ delegate, source, fee = DEFAULT_FEE.DELEGATION, gasLimit = DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION })=>__awaiter(void 0, void 0, void 0, function*() {\n        const operation = {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION,\n            source,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            delegate\n        };\n        return operation;\n    });\nconst createRegisterDelegateOperation = ({ fee = DEFAULT_FEE.DELEGATION, gasLimit = DEFAULT_GAS_LIMIT.DELEGATION, storageLimit = DEFAULT_STORAGE_LIMIT.DELEGATION }, source)=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            delegate: source\n        };\n    });\nconst createRevealOperation = ({ fee = DEFAULT_FEE.REVEAL, gasLimit = undefined, storageLimit = DEFAULT_STORAGE_LIMIT.REVEAL }, source, publicKey)=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL,\n            fee,\n            public_key: publicKey,\n            source,\n            gas_limit: gasLimit !== null && gasLimit !== void 0 ? gasLimit : getRevealGasLimit(source),\n            storage_limit: storageLimit\n        };\n    });\nconst createRegisterGlobalConstantOperation = ({ value, source, fee, gasLimit, storageLimit })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REGISTER_GLOBAL_CONSTANT,\n            value,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            source\n        };\n    });\nconst createTransferTicketOperation = ({ ticketContents, ticketTy, ticketTicketer, ticketAmount, destination, entrypoint, source, fee, gasLimit, storageLimit })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            source,\n            ticket_contents: ticketContents,\n            ticket_ty: ticketTy,\n            ticket_ticketer: ticketTicketer,\n            ticket_amount: ticketAmount,\n            destination,\n            entrypoint\n        };\n    });\nconst createIncreasePaidStorageOperation = ({ source, fee, gasLimit, storageLimit, amount, destination })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE,\n            source,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            amount,\n            destination\n        };\n    });\nconst createDrainDelegateOperation = ({ consensus_key, delegate, destination })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DRAIN_DELEGATE,\n            consensus_key,\n            delegate,\n            destination\n        };\n    });\nconst createBallotOperation = ({ source, proposal, ballot })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.BALLOT,\n            source,\n            proposal,\n            ballot\n        };\n    });\nconst createProposalsOperation = ({ source, proposals })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.PROPOSALS,\n            source,\n            proposals\n        };\n    });\nconst createUpdateConsensusKeyOperation = ({ source, fee, gasLimit, storageLimit, pk })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.UPDATE_CONSENSUS_KEY,\n            source,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            pk\n        };\n    });\nconst createSmartRollupAddMessagesOperation = ({ source, fee, gasLimit, storageLimit, message })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ADD_MESSAGES,\n            source,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            message\n        };\n    });\nconst createSmartRollupOriginateOperation = ({ source, fee, gasLimit, storageLimit, pvmKind, kernel, parametersType })=>__awaiter(void 0, void 0, void 0, function*() {\n        return {\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE,\n            source,\n            fee,\n            gas_limit: gasLimit,\n            storage_limit: storageLimit,\n            pvm_kind: pvmKind,\n            kernel,\n            parameters_ty: parametersType\n        };\n    });\nconst attachKind = (op, kind)=>{\n    return Object.assign(Object.assign({}, op), {\n        kind\n    });\n};\nconst findWithKind = (arr, kind)=>{\n    if (Array.isArray(arr)) {\n        const found = arr.find((op)=>op.kind === kind);\n        if (found && isKind(found, kind)) {\n            return found;\n        }\n    }\n};\nconst isKind = (op, kind)=>{\n    return op.kind === kind;\n};\nconst isOpWithFee = (op)=>{\n    return [\n        \"transaction\",\n        \"delegation\",\n        \"origination\",\n        \"reveal\",\n        \"register_global_constant\",\n        \"increase_paid_storage\",\n        \"transfer_ticket\",\n        \"update_consensus_key\",\n        \"smart_rollup_add_messages\",\n        \"smart_rollup_originate\"\n    ].indexOf(op.kind) !== -1;\n};\nconst isOpRequireReveal = (op)=>{\n    return [\n        \"transaction\",\n        \"delegation\",\n        \"origination\",\n        \"register_global_constant\",\n        \"increase_paid_storage\",\n        \"transfer_ticket\",\n        \"update_consensus_key\",\n        \"smart_rollup_add_messages\",\n        \"smart_rollup_originate\"\n    ].indexOf(op.kind) !== -1;\n};\nconst hasMetadata = (op)=>{\n    return \"metadata\" in op;\n};\nconst hasMetadataWithResult = (op)=>{\n    return hasMetadata(op) && \"operation_result\" in op.metadata;\n};\nconst hasMetadataWithInternalOperationResult = (op)=>{\n    return hasMetadata(op) && \"internal_operation_results\" in op.metadata;\n};\nconst isErrorWithMessage = (error)=>{\n    return \"with\" in error;\n};\n/**\n *  @category Error\n *  @description Generic tezos error that will be thrown when a mistake occurs when doing an operation; more details here https://tezos.gitlab.io/api/errors.html\n */ class TezosOperationError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.RpcError {\n    constructor(errors, errorDetails, operationsWithResults){\n        super();\n        this.errors = errors;\n        this.errorDetails = errorDetails;\n        this.operationsWithResults = operationsWithResults;\n        this.name = \"TezosOperationError\";\n        // Last error is 'often' the one with more detail\n        this.lastError = errors[errors.length - 1];\n        this.message = `(${this.kind}) ${this.id}`;\n        if (isErrorWithMessage(this.lastError)) {\n            if (this.lastError.with.string) {\n                this.message = this.lastError.with.string;\n            } else if (this.lastError.with.int) {\n                this.message = this.lastError.with.int;\n            } else {\n                this.message = JSON.stringify(this.lastError.with);\n            }\n        }\n    }\n    get id() {\n        return this.lastError.id;\n    }\n    get kind() {\n        return this.lastError.kind;\n    }\n}\n/**\n *  @category Error\n *  @description Tezos error that will be thrown when a mistake happens during the preapply stage\n */ class TezosPreapplyFailureError extends Error {\n    constructor(result){\n        super();\n        this.result = result;\n        this.name = \"TezosPreapplyFailureError\";\n        this.message = \"Preapply returned an unexpected result\";\n    }\n}\n// Flatten all operation content results and internal operation results into a single array\n// Some cases where we can have multiple operation results or internal operation results are:\n// - When an operation includes a reveal operation\n// - When an operation is made using the batch API\n// - Smart contract call can contains internal operation results when they call other smart contract internally or originate contracts\nconst flattenOperationResult = (response)=>{\n    const results = Array.isArray(response) ? response : [\n        response\n    ];\n    const returnedResults = [];\n    for(let i = 0; i < results.length; i++){\n        for(let j = 0; j < results[i].contents.length; j++){\n            const content = results[i].contents[j];\n            if (hasMetadataWithResult(content) && \"fee\" in content) {\n                returnedResults.push(Object.assign({\n                    fee: content.fee\n                }, content.metadata.operation_result));\n                if (Array.isArray(content.metadata.internal_operation_results)) {\n                    content.metadata.internal_operation_results.forEach((x)=>returnedResults.push(x.result));\n                }\n            }\n        }\n    }\n    return returnedResults;\n};\n/***\n * @description Flatten all error from preapply response (including internal error)\n */ const flattenErrors = (response, status = \"failed\")=>{\n    const results = Array.isArray(response) ? response : [\n        response\n    ];\n    let errors = [];\n    // Transaction that do not fail will be backtracked in case one failure occur\n    for(let i = 0; i < results.length; i++){\n        for(let j = 0; j < results[i].contents.length; j++){\n            const content = results[i].contents[j];\n            if (hasMetadata(content)) {\n                if (hasMetadataWithResult(content) && content.metadata.operation_result.status === status) {\n                    errors = errors.concat(content.metadata.operation_result.errors || []);\n                }\n                if (hasMetadataWithInternalOperationResult(content) && Array.isArray(content.metadata.internal_operation_results)) {\n                    for (const internalResult of content.metadata.internal_operation_results){\n                        if (\"result\" in internalResult && internalResult.result.status === status) {\n                            errors = errors.concat(internalResult.result.errors || []);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    return errors;\n};\n/**\n *  @category Error\n *  @description Error that indicates a general failure happening during an origination operation.\n */ class OriginationOperationError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TaquitoError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"OriginationOperationError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid estimate value being passed\n */ class InvalidEstimateValueError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"InvalidEstimateValueError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid confirmation count has been passed or configured\n */ class InvalidConfirmationCountError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(invalidConfirmations){\n        super();\n        this.invalidConfirmations = invalidConfirmations;\n        this.name = \"InvalidConfirmationCountError\";\n        this.message = `Invalid confirmation count ${invalidConfirmations} expecting at least 1`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates that confirmation polling timed out\n */ class ConfirmationTimeoutError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.NetworkError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"ConfirmationTimeoutError\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an error being returned from the RPC response\n */ class RPCResponseError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.RpcError {\n    constructor(message, cause){\n        super();\n        this.message = message;\n        this.cause = cause;\n        this.name = \"RPCResponseError\";\n    }\n}\n/**\n * @description Utility class to interact with Tezos operations\n */ class Operation {\n    get includedInBlock() {\n        return this._foundAt;\n    }\n    /**\n     *\n     * @param hash Operation hash\n     * @param raw Raw operation that was injected\n     * @param context Taquito context allowing access to rpc and signer\n     * @throws {@link InvalidOperationHashError}\n     */ constructor(hash, raw, results, context){\n        this.hash = hash;\n        this.raw = raw;\n        this.results = results;\n        this.context = context;\n        this._pollingConfig$ = new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_9__.ReplaySubject(1);\n        this.currentHead$ = this._pollingConfig$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)((config)=>{\n            return new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_11__.BehaviorSubject(config).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.timeout)({\n                each: config.timeout * 1000,\n                with: ()=>(0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_12__.throwError)(()=>new ConfirmationTimeoutError(`Confirmation polling timed out`))\n            }));\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)(()=>{\n            return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_13__.defer)(()=>createObservableFromSubscription(this.context.stream.subscribeBlock(\"head\"))).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)((newHead)=>{\n                var _a, _b;\n                const prevHead = (_b = (_a = this.lastHead) === null || _a === void 0 ? void 0 : _a.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;\n                return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_14__.range)(prevHead + 1, newHead.header.level - prevHead - 1).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.concatMap)((level)=>this.context.readProvider.getBlock(level)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.endWith)(newHead));\n            }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.tap)((newHead)=>this.lastHead = newHead));\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.shareReplay)({\n            refCount: true\n        }));\n        // Observable that emit once operation is seen in a block\n        this.confirmed$ = this.currentHead$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.map)((head)=>{\n            for(let i = 3; i >= 0; i--){\n                head.operations[i].forEach((op)=>{\n                    if (op.hash === this.hash) {\n                        this._foundAt = head.header.level;\n                    }\n                });\n            }\n            if (head.header.level - this._foundAt >= 0) {\n                return this._foundAt;\n            }\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.filter)((x)=>x !== undefined), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.shareReplay)());\n        this._foundAt = Number.POSITIVE_INFINITY;\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateOperation)(this.hash) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidOperationHashError(this.hash);\n        }\n        this.confirmed$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.catchError)(()=>{\n            return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_15__.of)(_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_16__.EMPTY);\n        })).subscribe();\n    }\n    get revealOperation() {\n        return Array.isArray(this.results) && this.results.find((op)=>op.kind === \"reveal\");\n    }\n    get revealStatus() {\n        if (this.revealOperation) {\n            return this.revealOperation.metadata.operation_result.status;\n        } else {\n            return \"unknown\";\n        }\n    }\n    get status() {\n        return this.results.map((result)=>{\n            if (hasMetadataWithResult(result)) {\n                return result.metadata.operation_result.status;\n            } else {\n                return \"unknown\";\n            }\n        })[0] || \"unknown\";\n    }\n    /**\n     *\n     * @param confirmations [0] Number of confirmation to wait for\n     * @param timeout [180] Timeout\n     */ confirmation(confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (typeof confirmations !== \"undefined\" && confirmations < 1) {\n                throw new InvalidConfirmationCountError(confirmations);\n            }\n            const { defaultConfirmationCount, confirmationPollingTimeoutSecond } = this.context.config;\n            this._pollingConfig$.next({\n                timeout: timeout || confirmationPollingTimeoutSecond\n            });\n            const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n            return new Promise((resolve, reject)=>{\n                this.confirmed$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)(()=>this.currentHead$), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.filter)((head)=>head.header.level - this._foundAt >= conf - 1), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)()).subscribe((_)=>{\n                    resolve(this._foundAt + (conf - 1));\n                }, reject);\n            });\n        });\n    }\n}\nclass BatchOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    sumProp(arr, prop) {\n        return arr.reduce((prev, current)=>{\n            return prop in current ? Number(current[prop]) + prev : prev;\n        }, 0);\n    }\n    getOriginatedContractAddresses() {\n        const originationOpResults = this.results.filter((x)=>x.kind === \"origination\");\n        let addresses = [];\n        for (const res of originationOpResults){\n            if (res.metadata.operation_result.originated_contracts) {\n                addresses = [\n                    ...addresses,\n                    ...res.metadata.operation_result.originated_contracts\n                ];\n            }\n        }\n        return addresses;\n    }\n    get status() {\n        return this.results.filter((result)=>BATCH_KINDS.indexOf(result.kind) !== -1).map((result)=>{\n            if (hasMetadataWithResult(result)) {\n                const opResult = result.metadata.operation_result;\n                return opResult.status;\n            } else {\n                return \"unknown\";\n            }\n        })[0] || \"unknown\";\n    }\n    get fee() {\n        return this.sumProp(this.params, \"fee\");\n    }\n    get gasLimit() {\n        return this.sumProp(this.params, \"gas_limit\");\n    }\n    get storageLimit() {\n        return this.sumProp(this.params, \"storage_limit\");\n    }\n    get consumedGas() {\n        bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].config({\n            DECIMAL_PLACES: 0,\n            ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ROUND_UP\n        });\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.consumedMilliGas).dividedBy(1000).toString();\n    }\n    get consumedMilliGas() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.results\n        }), \"consumed_milligas\"));\n    }\n    get storageDiff() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.results\n        }), \"paid_storage_size_diff\"));\n    }\n    get errors() {\n        return flattenErrors({\n            contents: this.results\n        });\n    }\n}\nclass Provider {\n    get rpc() {\n        return this.context.rpc;\n    }\n    get signer() {\n        return this.context.signer;\n    }\n    constructor(context){\n        this.context = context;\n    }\n    forge({ opOb: { branch, contents, protocol }, counter }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const forgedBytes = yield this.context.forger.forge({\n                branch,\n                contents\n            });\n            return {\n                opbytes: forgedBytes,\n                opOb: {\n                    branch,\n                    contents,\n                    protocol\n                },\n                counter\n            };\n        });\n    }\n    estimate(_a, estimator) {\n        var { fee, gasLimit, storageLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"gasLimit\",\n            \"storageLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            let calculatedFee = fee;\n            let calculatedGas = gasLimit;\n            let calculatedStorage = storageLimit;\n            if (calculatedFee && calculatedFee % 1 !== 0) {\n                throw new InvalidEstimateValueError(`Fee value must not be a decimal: ${calculatedFee}`);\n            }\n            if (calculatedGas && calculatedGas % 1 !== 0) {\n                throw new InvalidEstimateValueError(`Gas Limit value must not be a decimal: ${calculatedGas}`);\n            }\n            if (calculatedStorage && calculatedStorage % 1 !== 0) {\n                throw new InvalidEstimateValueError(`Storage Limit value must not be a decimal: ${calculatedStorage}`);\n            }\n            if (fee === undefined || gasLimit === undefined || storageLimit === undefined) {\n                const estimation = yield estimator(Object.assign({\n                    fee,\n                    gasLimit,\n                    storageLimit\n                }, rest));\n                calculatedFee !== null && calculatedFee !== void 0 ? calculatedFee : calculatedFee = estimation.suggestedFeeMutez;\n                calculatedGas !== null && calculatedGas !== void 0 ? calculatedGas : calculatedGas = estimation.gasLimit;\n                calculatedStorage !== null && calculatedStorage !== void 0 ? calculatedStorage : calculatedStorage = estimation.storageLimit;\n            }\n            return {\n                fee: calculatedFee,\n                gasLimit: calculatedGas,\n                storageLimit: calculatedStorage\n            };\n        });\n    }\n    getRPCOp(param) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(param.kind){\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION:\n                    return createTransferOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION:\n                    return createOriginationOperation((yield this.context.parser.prepareCodeOrigination(Object.assign({}, param))));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION:\n                    return createSetDelegateOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REGISTER_GLOBAL_CONSTANT:\n                    return createRegisterGlobalConstantOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE:\n                    return createIncreasePaidStorageOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET:\n                    return createTransferTicketOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ADD_MESSAGES:\n                    return createSmartRollupAddMessagesOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE:\n                    return createSmartRollupOriginateOperation(Object.assign({}, param));\n                default:\n                    throw new _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.InvalidOperationKindError(param.kind);\n            }\n        });\n    }\n    runOperation(op) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return {\n                opResponse: yield this.rpc.runOperation(op),\n                op,\n                context: this.context.clone()\n            };\n        });\n    }\n    simulate(op) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return {\n                opResponse: yield this.rpc.simulateOperation(op),\n                op,\n                context: this.context.clone()\n            };\n        });\n    }\n    isRevealOpNeeded(op, pkh) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return !(yield this.isAccountRevealRequired(pkh)) || !this.isRevealRequiredForOpType(op) ? false : true;\n        });\n    }\n    isAccountRevealRequired(publicKeyHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return !(yield this.context.readProvider.isAccountRevealed(publicKeyHash, \"head\"));\n        });\n    }\n    isRevealRequiredForOpType(op) {\n        let opRequireReveal = false;\n        for (const operation of op){\n            if (isOpRequireReveal(operation)) {\n                opRequireReveal = true;\n            }\n        }\n        return opRequireReveal;\n    }\n    signAndInject(forgedBytes) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const signed = yield this.signer.sign(forgedBytes.opbytes, new Uint8Array([\n                3\n            ]));\n            forgedBytes.opbytes = signed.sbytes;\n            forgedBytes.opOb.signature = signed.prefixSig;\n            const opResponse = [];\n            const results = yield this.rpc.preapplyOperations([\n                forgedBytes.opOb\n            ]);\n            if (!Array.isArray(results)) {\n                throw new TezosPreapplyFailureError(results);\n            }\n            for(let i = 0; i < results.length; i++){\n                for(let j = 0; j < results[i].contents.length; j++){\n                    opResponse.push(results[i].contents[j]);\n                }\n            }\n            const errors = flattenErrors(results);\n            if (errors.length) {\n                throw new TezosOperationError(errors, \"Error occurred during validation simulation of operation\", opResponse);\n            }\n            return {\n                hash: yield this.context.injector.inject(forgedBytes.opbytes),\n                forgedBytes,\n                opResponse,\n                context: this.context.clone()\n            };\n        });\n    }\n}\nclass WalletOperationBatch {\n    constructor(walletProvider, context){\n        this.walletProvider = walletProvider;\n        this.context = context;\n        this.operations = [];\n    }\n    /**\n     *\n     * @description Add a transaction operation to the batch\n     *\n     * @param params Transfer operation parameter\n     */ withTransfer(params) {\n        const toValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.to);\n        if (toValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.to, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(toValidation));\n        }\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add a contract call to the batch\n     *\n     * @param params Call a contract method\n     * @param options Generic operation parameters\n     */ withContractCall(params, options = {}) {\n        return this.withTransfer(params.toTransferParams(options));\n    }\n    /**\n     *\n     * @description Add a delegation operation to the batch\n     *\n     * @param params Delegation operation parameter\n     */ withDelegation(params) {\n        var _a;\n        const delegateValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.delegate) !== null && _a !== void 0 ? _a : \"\");\n        if (params.delegate && delegateValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.delegate, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(delegateValidation));\n        }\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add an origination operation to the batch\n     *\n     * @param params Origination operation parameter\n     */ withOrigination(params) {\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add an IncreasePaidStorage operation to the batch\n     *\n     * @param param IncreasePaidStorage operation parameter\n     */ withIncreasePaidStorage(params) {\n        const destinationValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.destination);\n        if (destinationValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.destination, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(destinationValidation));\n        }\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE\n        }, params));\n        return this;\n    }\n    mapOperation(param) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(param.kind){\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION:\n                    return this.walletProvider.mapTransferParamsToWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                            return param;\n                        }));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION:\n                    return this.walletProvider.mapOriginateParamsToWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                            return this.context.parser.prepareCodeOrigination(Object.assign({}, param));\n                        }));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION:\n                    return this.walletProvider.mapDelegateParamsToWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                            return param;\n                        }));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE:\n                    return this.walletProvider.mapIncreasePaidStorageWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                            return param;\n                        }));\n                default:\n                    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidOperationKindError(JSON.stringify(param.kind));\n            }\n        });\n    }\n    /**\n     *\n     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n     *\n     * @param params Operations parameter\n     * @throws {@link InvalidOperationKindError}\n     */ with(params) {\n        for (const param of params){\n            switch(param.kind){\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION:\n                    this.withTransfer(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION:\n                    this.withOrigination(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION:\n                    this.withDelegation(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE:\n                    this.withIncreasePaidStorage(param);\n                    break;\n                default:\n                    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidOperationKindError(JSON.stringify(param.kind));\n            }\n        }\n        return this;\n    }\n    /**\n     *\n     * @description Submit batch operation to wallet\n     *\n     */ send() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const ops = [];\n            for (const op of this.operations){\n                ops.push((yield this.mapOperation(op)));\n            }\n            const opHash = yield this.walletProvider.sendOperations(ops);\n            return this.context.operationFactory.createBatchOperation(opHash);\n        });\n    }\n}\nclass Wallet {\n    constructor(context){\n        this.context = context;\n        this.walletCommand = (send)=>{\n            return {\n                send\n            };\n        };\n    }\n    get walletProvider() {\n        return this.context.walletProvider;\n    }\n    /**\n     * @description Retrieve the PKH of the account that is currently in use by the wallet\n     *\n     * @param option Option to use while fetching the PKH.\n     * If forceRefetch is specified the wallet provider implementation will refetch the PKH from the wallet\n     */ pkh({ forceRefetch } = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._pkh || forceRefetch) {\n                this._pkh = yield this.walletProvider.getPKH();\n            }\n            return this._pkh;\n        });\n    }\n    /**\n     * @description Retrieve the PK of the account that is currently in use by the wallet\n     *\n     * @param option Option to use while fetching the PK.\n     * If forceRefetch is specified the wallet provider implementation will refetch the PK from the wallet\n     */ pk({ forceRefetch } = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._pk || forceRefetch) {\n                this._pk = yield this.walletProvider.getPK();\n            }\n            return this._pk;\n        });\n    }\n    /**\n     *\n     * @description Originate a new contract according to the script in parameters.\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param originateParams Originate operation parameter\n     */ originate(params) {\n        return this.walletCommand(()=>__awaiter(this, void 0, void 0, function*() {\n                const mappedParams = yield this.walletProvider.mapOriginateParamsToWalletParams(()=>this.context.parser.prepareCodeOrigination(Object.assign({}, params)));\n                const opHash = yield this.walletProvider.sendOperations([\n                    mappedParams\n                ]);\n                return this.context.operationFactory.createOriginationOperation(opHash);\n            }));\n    }\n    /**\n     *\n     * @description Set the delegate for a contract.\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param delegateParams operation parameter\n     */ setDelegate(params) {\n        var _a;\n        const delegateValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.delegate) !== null && _a !== void 0 ? _a : \"\");\n        if (params.delegate && delegateValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.delegate, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(delegateValidation));\n        }\n        return this.walletCommand(()=>__awaiter(this, void 0, void 0, function*() {\n                const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                        return params;\n                    }));\n                const opHash = yield this.walletProvider.sendOperations([\n                    mappedParams\n                ]);\n                return this.context.operationFactory.createDelegationOperation(opHash);\n            }));\n    }\n    /**\n     *\n     * @description failing_noop operation that is guaranteed to fail. DISCLAIMER: Not all wallets support signing failing_noop operations.\n     *\n     * @returns Signature for a failing_noop\n     *\n     * @param params operation parameter\n     */ signFailingNoop(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const op = {\n                kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.FAILING_NOOP,\n                arbitrary: params.arbitrary\n            };\n            const hash = yield this.context.readProvider.getBlockHash(params.basedOnBlock);\n            const forgedBytes = yield this.context.forger.forge({\n                branch: hash,\n                contents: [\n                    op\n                ]\n            });\n            const signature = yield this.walletProvider.sign(forgedBytes, Uint8Array.from([\n                3\n            ]));\n            return {\n                signature,\n                bytes: forgedBytes,\n                signedContent: {\n                    branch: hash,\n                    contents: [\n                        {\n                            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.FAILING_NOOP,\n                            arbitrary: params.arbitrary\n                        }\n                    ]\n                }\n            };\n        });\n    }\n    /**\n     *\n     * @description Register the current address as delegate.\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     */ registerDelegate() {\n        return this.walletCommand(()=>__awaiter(this, void 0, void 0, function*() {\n                const mappedParams = yield this.walletProvider.mapDelegateParamsToWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                        const delegate = yield this.pkh();\n                        return {\n                            delegate\n                        };\n                    }));\n                const opHash = yield this.walletProvider.sendOperations([\n                    mappedParams\n                ]);\n                return this.context.operationFactory.createDelegationOperation(opHash);\n            }));\n    }\n    /**\n     *\n     * @description Transfer tezos tokens from current address to a specific address or call a smart contract.\n     *\n     * @returns A wallet command from which we can send the operation to the wallet\n     *\n     * @param params operation parameter\n     */ transfer(params) {\n        const toValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.to);\n        if (toValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.to, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(toValidation));\n        }\n        return this.walletCommand(()=>__awaiter(this, void 0, void 0, function*() {\n                const mappedParams = yield this.walletProvider.mapTransferParamsToWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                        return params;\n                    }));\n                const opHash = yield this.walletProvider.sendOperations([\n                    mappedParams\n                ]);\n                return this.context.operationFactory.createTransactionOperation(opHash);\n            }));\n    }\n    /**\n     *\n     * @description\n     *\n     * @returns\n     *\n     * @param params\n     */ increasePaidStorage(params) {\n        const destinationValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.destination);\n        if (destinationValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.destination, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(destinationValidation));\n        }\n        return this.walletCommand(()=>__awaiter(this, void 0, void 0, function*() {\n                const mappedParams = yield this.walletProvider.mapIncreasePaidStorageWalletParams(()=>__awaiter(this, void 0, void 0, function*() {\n                        return params;\n                    }));\n                const opHash = yield this.walletProvider.sendOperations([\n                    mappedParams\n                ]);\n                return this.context.operationFactory.createIncreasePaidStorageOperation(opHash);\n            }));\n    }\n    /**\n     *\n     * @description Create a batch of operation\n     *\n     * @returns A batch object from which we can add more operation or send a command to the wallet to execute the batch\n     *\n     * @param params List of operation to initialize the batch with\n     */ batch(params) {\n        const batch = new WalletOperationBatch(this.walletProvider, this.context);\n        if (Array.isArray(params)) {\n            batch.with(params);\n        }\n        return batch;\n    }\n    /**\n     *\n     * @description Create an smart contract abstraction for the address specified. Calling entrypoints with the returned\n     * smart contract abstraction will leverage the wallet provider to make smart contract calls\n     *\n     * @param address Smart contract address\n     * @throws {@link InvalidContractAddressError} If the contract address is not valid\n     */ at(address, contractAbstractionComposer = (x)=>x) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateContractAddress)(address);\n            if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidContractAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(addressValidation));\n            }\n            const rpc = this.context.withExtensions().rpc;\n            const readProvider = this.context.withExtensions().readProvider;\n            const script = yield readProvider.getScript(address, \"head\");\n            const entrypoints = yield readProvider.getEntrypoints(address);\n            const abs = new ContractAbstraction(address, script, this, this.context.contract, entrypoints, rpc, readProvider);\n            return contractAbstractionComposer(abs, this.context);\n        });\n    }\n    /**\n     * @deprecated Deprecated in favor of {@link Wallet.pk} will be removed in v19.1\n     * @description Retrieve the PK of the account that is currently in use by the wallet\n     */ getPK() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return yield this.pk();\n        });\n    }\n}\nconst receiptFromOperation = (op, { ALLOCATION_BURN, ORIGINATION_BURN } = {\n    ALLOCATION_BURN: 257,\n    ORIGINATION_BURN: 257\n})=>{\n    bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].config({\n        DECIMAL_PLACES: 0,\n        ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ROUND_UP\n    });\n    const operationResults = flattenOperationResult({\n        contents: op\n    });\n    let totalMilliGas = new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](0);\n    let totalStorage = new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](0);\n    let totalFee = new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](0);\n    let totalOriginationBurn = new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](0);\n    let totalAllocationBurn = new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](0);\n    let totalPaidStorageDiff = new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](0);\n    operationResults.forEach((result)=>{\n        totalFee = totalFee.plus(result.fee || 0);\n        totalOriginationBurn = totalOriginationBurn.plus(Array.isArray(result.originated_contracts) ? result.originated_contracts.length * ORIGINATION_BURN : 0);\n        totalAllocationBurn = totalAllocationBurn.plus(\"allocated_destination_contract\" in result ? ALLOCATION_BURN : 0);\n        totalMilliGas = totalMilliGas.plus(result.consumed_milligas || 0);\n        totalPaidStorageDiff = totalPaidStorageDiff.plus(\"paid_storage_size_diff\" in result ? Number(result.paid_storage_size_diff) || 0 : 0);\n    });\n    totalStorage = totalStorage.plus(totalAllocationBurn).plus(totalOriginationBurn).plus(totalPaidStorageDiff);\n    return {\n        totalFee,\n        totalMilliGas,\n        totalGas: totalMilliGas.dividedBy(1000),\n        totalStorage,\n        totalAllocationBurn,\n        totalOriginationBurn,\n        totalPaidStorageDiff,\n        totalStorageBurn: new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](totalStorage.multipliedBy(COST_PER_BYTE))\n    };\n};\n/**\n *  @category Error\n *  @description Error that indicates undefined confirmation has not been specified or configured\n */ class ConfirmationUndefinedError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TezosToolkitConfigError {\n    constructor(){\n        super();\n        this.name = \"ConfirmationUndefinedError\";\n        this.message = \"Default confirmation count can not be undefined\";\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates a generic failure when trying to fetch an observable\n */ class ObservableError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.NetworkError {\n    constructor(message){\n        super();\n        this.message = message;\n        this.name = \"ObservableError\";\n    }\n}\nconst MAX_BRANCH_ANCESTORS = 60;\n/**\n * @description WalletOperation allows to monitor operation inclusion on chains and surface information related to the operation\n */ class WalletOperation {\n    operationResults() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this._operationResult.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)()).toPromise();\n        });\n    }\n    /**\n     * @description Receipt expose the total amount of tezos token burn and spent on fees\n     * The promise returned by receipt will resolve only once the transaction is included\n     */ receipt() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield this.operationResults();\n            if (!results) {\n                throw new ObservableError(\"Unable to get operation results\");\n            }\n            return receiptFromOperation(results);\n        });\n    }\n    /**\n     *\n     * @param opHash Operation hash\n     * @param raw Raw operation that was injected\n     * @param context Taquito context allowing access to rpc and signer\n     * @throws {InvalidOperationHashError}\n     */ constructor(opHash, context, _newHead$){\n        this.opHash = opHash;\n        this.context = context;\n        this._newHead$ = _newHead$;\n        this._operationResult = new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_9__.ReplaySubject(1);\n        this._includedInBlock = new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_9__.ReplaySubject(1);\n        this._included = false;\n        this.newHead$ = this._newHead$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)((newHead)=>{\n            var _a, _b;\n            const prevHead = (_b = (_a = this.lastHead) === null || _a === void 0 ? void 0 : _a.header.level) !== null && _b !== void 0 ? _b : newHead.header.level - 1;\n            return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_14__.range)(prevHead + 1, newHead.header.level - prevHead - 1).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.concatMap)((level)=>this.context.readProvider.getBlock(level)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.endWith)(newHead));\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.tap)((newHead)=>this.lastHead = newHead), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.share)({\n            connector: ()=>new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_9__.ReplaySubject(1),\n            resetOnError: false,\n            resetOnComplete: false,\n            resetOnRefCountZero: false\n        }));\n        // Observable that emit once operation is seen in a block\n        this.confirmed$ = this.newHead$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.map)((head)=>{\n            for (const opGroup of head.operations){\n                for (const op of opGroup){\n                    if (op.hash === this.opHash) {\n                        this._included = true;\n                        this._includedInBlock.next(head);\n                        this._operationResult.next(op.contents);\n                        // Return the block where the operation was found\n                        return head;\n                    }\n                }\n            }\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.filter)((x)=>{\n            return typeof x !== \"undefined\";\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.share)({\n            connector: ()=>new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_9__.ReplaySubject(1),\n            resetOnError: false,\n            resetOnComplete: false,\n            resetOnRefCountZero: false\n        }));\n        if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateOperation)(this.opHash) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidOperationHashError(this.opHash);\n        }\n        this.confirmed$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.catchError)(()=>(0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_15__.of)(undefined))).subscribe();\n    }\n    getCurrentConfirmation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._included) {\n                return 0;\n            }\n            return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.combineLatest)([\n                this._includedInBlock,\n                (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.from)(this.context.readProvider.getBlock(\"head\"))\n            ]).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.map)(([foundAtBlock, head])=>{\n                return head.header.level - foundAtBlock.header.level + 1;\n            }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)()).toPromise();\n        });\n    }\n    isInCurrentBranch(tipBlockIdentifier = \"head\") {\n        return __awaiter(this, void 0, void 0, function*() {\n            // By default it is assumed that the operation is in the current branch\n            if (!this._included) {\n                return true;\n            }\n            const tipBlockHeaderLevel = yield this.context.readProvider.getBlockLevel(tipBlockIdentifier);\n            const inclusionBlock = yield this._includedInBlock.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)()).toPromise();\n            if (!inclusionBlock) {\n                throw new ObservableError(\"Inclusion block is undefined\");\n            }\n            const levelDiff = tipBlockHeaderLevel - inclusionBlock.header.level;\n            // Block produced before the operation is included are assumed to be part of the current branch\n            if (levelDiff <= 0) {\n                return true;\n            }\n            const tipBlockLevel = Math.min(inclusionBlock.header.level + levelDiff, inclusionBlock.header.level + MAX_BRANCH_ANCESTORS);\n            const blocks = new Set((yield this.context.readProvider.getLiveBlocks(tipBlockLevel)));\n            return blocks.has(inclusionBlock.hash);\n        });\n    }\n    confirmationObservable(confirmations) {\n        if (typeof confirmations !== \"undefined\" && confirmations < 1) {\n            throw new InvalidConfirmationCountError(confirmations);\n        }\n        const { defaultConfirmationCount } = this.context.config;\n        const conf = confirmations !== undefined ? confirmations : defaultConfirmationCount;\n        if (conf === undefined) {\n            throw new ConfirmationUndefinedError();\n        }\n        return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_17__.combineLatest)([\n            this._includedInBlock,\n            this.newHead$\n        ]).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.distinctUntilChanged)(([, previousHead], [, newHead])=>{\n            return previousHead.hash === newHead.hash;\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.map)(([foundAtBlock, head])=>{\n            return {\n                block: head,\n                expectedConfirmation: conf,\n                currentConfirmation: head.header.level - foundAtBlock.header.level + 1,\n                completed: head.header.level - foundAtBlock.header.level >= conf - 1,\n                isInCurrentBranch: ()=>this.isInCurrentBranch(head.hash)\n            };\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.takeWhile)(({ completed })=>!completed, true));\n    }\n    /**\n     *\n     * @param confirmations [0] Number of confirmation to wait for\n     */ confirmation(confirmations) {\n        return this.confirmationObservable(confirmations).toPromise();\n    }\n}\nclass TransactionWalletOperation extends WalletOperation {\n    constructor(opHash, context, newHead$){\n        super(opHash, context, newHead$);\n        this.opHash = opHash;\n        this.context = context;\n    }\n    revealOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (!operationResult) {\n                throw new ObservableError(\"operationResult returned undefined\");\n            }\n            return operationResult.find((x)=>x.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL);\n        });\n    }\n    transactionOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (!operationResult) {\n                throw new ObservableError(\"operationResult returned undefined\");\n            }\n            return operationResult.find((x)=>x.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION);\n        });\n    }\n    status() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._included) {\n                return \"pending\";\n            }\n            const op = yield this.transactionOperation();\n            if (!op) {\n                return \"unknown\";\n            }\n            return op.metadata.operation_result.status;\n        });\n    }\n}\nclass OriginationWalletOperation extends WalletOperation {\n    constructor(opHash, context, newHead$){\n        super(opHash, context, newHead$);\n        this.opHash = opHash;\n        this.context = context;\n    }\n    originationOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (operationResult) {\n                return findWithKind(operationResult, _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION);\n            } else {\n                throw new ObservableError(\"Unable to fetch operation result\");\n            }\n        });\n    }\n    revealOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (operationResult) {\n                return findWithKind(operationResult, _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL);\n            } else {\n                throw new ObservableError(\"Unable to fetch operation result\");\n            }\n        });\n    }\n    status() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._included) {\n                return \"pending\";\n            }\n            const op = yield this.originationOperation();\n            if (!op) {\n                return \"unknown\";\n            }\n            return op.metadata.operation_result.status;\n        });\n    }\n    contract() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const op = yield this.originationOperation();\n            const address = ((op === null || op === void 0 ? void 0 : op.metadata.operation_result.originated_contracts) || [])[0];\n            return this.context.wallet.at(address);\n        });\n    }\n}\nclass DelegationWalletOperation extends WalletOperation {\n    constructor(opHash, context, newHead$){\n        super(opHash, context, newHead$);\n        this.opHash = opHash;\n        this.context = context;\n    }\n    revealOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (operationResult) {\n                return operationResult.find((x)=>x.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL);\n            } else {\n                throw new ObservableError(\"Unable to fetch operation result\");\n            }\n        });\n    }\n    delegationOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (operationResult) {\n                return operationResult.find((x)=>x.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION);\n            } else {\n                throw new ObservableError(\"Unable to fetch operation result\");\n            }\n        });\n    }\n    status() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._included) {\n                return \"pending\";\n            }\n            const op = yield this.delegationOperation();\n            if (!op) {\n                return \"unknown\";\n            }\n            return op.metadata.operation_result.status;\n        });\n    }\n}\nclass LegacyWalletProvider {\n    constructor(context){\n        this.context = context;\n    }\n    getPKH() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.context.signer.publicKeyHash();\n        });\n    }\n    getPK() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.context.signer.publicKey();\n        });\n    }\n    mapTransferParamsToWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return attachKind((yield params()), _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION);\n        });\n    }\n    mapOriginateParamsToWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return attachKind((yield params()), _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION);\n        });\n    }\n    mapDelegateParamsToWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return attachKind((yield params()), _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION);\n        });\n    }\n    mapIncreasePaidStorageWalletParams(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return attachKind((yield params()), _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE);\n        });\n    }\n    sendOperations(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const op = yield this.context.batch.batch(params).send();\n            return op.hash;\n        });\n    }\n    sign(bytes, watermark) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { prefixSig } = yield this.context.signer.sign(bytes, watermark);\n            return prefixSig;\n        });\n    }\n}\n/**\n * @description Utility class to send smart contract operation\n * The format for the arguments is the object representation\n */ class ContractMethodObject {\n    constructor(provider, address, parameterSchema, name, args = \"unit\", isMultipleEntrypoint = true, isAnonymous = false){\n        this.provider = provider;\n        this.address = address;\n        this.parameterSchema = parameterSchema;\n        this.name = name;\n        this.args = args;\n        this.isMultipleEntrypoint = isMultipleEntrypoint;\n        this.isAnonymous = isAnonymous;\n    }\n    /**\n     * @description Get the signature of the smart contract method\n     */ getSignature() {\n        return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();\n    }\n    /**\n     *\n     * @description Send the smart contract operation\n     *\n     * @param Options generic operation parameter\n     */ send(params = {}) {\n        if (this.provider instanceof Wallet) {\n            return this.provider.transfer(this.toTransferParams(params)).send();\n        } else {\n            return this.provider.transfer(this.toTransferParams(params));\n        }\n    }\n    /**\n     *\n     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n     *\n     * @param Options generic transfer operation parameters\n     */ toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false } = {}) {\n        const fullTransferParams = {\n            to: this.address,\n            amount,\n            fee,\n            mutez,\n            source,\n            gasLimit,\n            storageLimit,\n            parameter: {\n                entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,\n                value: this.isAnonymous ? this.parameterSchema.EncodeObject({\n                    [this.name]: this.args\n                }) : this.parameterSchema.EncodeObject(this.args)\n            }\n        };\n        return fullTransferParams;\n    }\n}\n/**\n * @description Utility class to send smart contract operation\n * The format for the arguments is the flattened representation\n */ class ContractMethod {\n    constructor(provider, address, parameterSchema, name, args, isMultipleEntrypoint = true, isAnonymous = false){\n        this.provider = provider;\n        this.address = address;\n        this.parameterSchema = parameterSchema;\n        this.name = name;\n        this.args = args;\n        this.isMultipleEntrypoint = isMultipleEntrypoint;\n        this.isAnonymous = isAnonymous;\n    }\n    validateArgs(args, schema, name) {\n        const sigs = schema.ExtractSignatures();\n        if (!sigs.find((x)=>x.length === args.length)) {\n            throw new InvalidParameterError(name, sigs, args);\n        }\n    }\n    /**\n     * @description Get the schema of the smart contract method\n     */ get schema() {\n        return this.isAnonymous ? this.parameterSchema.ExtractSchema()[this.name] : this.parameterSchema.ExtractSchema();\n    }\n    /**\n     * @description Get the signature of the smart contract method\n     */ getSignature() {\n        if (this.isAnonymous) {\n            const sig = this.parameterSchema.ExtractSignatures().find((x)=>x[0] === this.name);\n            if (sig) {\n                sig.shift();\n                return sig;\n            }\n        } else {\n            const sig = this.parameterSchema.ExtractSignatures();\n            return sig.length == 1 ? sig[0] : sig;\n        }\n    }\n    /**\n     *\n     * @description Send the smart contract operation\n     *\n     * @param Options generic operation parameter\n     */ send(params = {}) {\n        if (this.provider instanceof Wallet) {\n            return this.provider.transfer(this.toTransferParams(params)).send();\n        } else {\n            return this.provider.transfer(this.toTransferParams(params));\n        }\n    }\n    /**\n     *\n     * @description Create transfer params to be used with TezosToolkit.contract.transfer methods\n     *\n     * @param Options generic transfer operation parameters\n     */ toTransferParams({ fee, gasLimit, storageLimit, source, amount = 0, mutez = false } = {}) {\n        const fullTransferParams = {\n            to: this.address,\n            amount,\n            fee,\n            mutez,\n            source,\n            gasLimit,\n            storageLimit,\n            parameter: {\n                entrypoint: this.isMultipleEntrypoint ? this.name : DEFAULT_SMART_CONTRACT_METHOD_NAME,\n                value: this.isAnonymous ? this.parameterSchema.Encode(this.name, ...this.args) : this.parameterSchema.Encode(...this.args)\n            }\n        };\n        return fullTransferParams;\n    }\n}\nclass OnChainView {\n    constructor(_rpc, _readProvider, _contractAddress, _smartContractViewSchema, _contractStorageType, _args = \"Unit\"){\n        this._rpc = _rpc;\n        this._readProvider = _readProvider;\n        this._contractAddress = _contractAddress;\n        this._smartContractViewSchema = _smartContractViewSchema;\n        this._contractStorageType = _contractStorageType;\n        this._args = _args;\n    }\n    /**\n     * @description Get the signature of the smart contract view\n     */ getSignature() {\n        return {\n            parameter: this._smartContractViewSchema.extractArgsSchema(),\n            result: this._smartContractViewSchema.extractResultSchema()\n        };\n    }\n    /**\n     * @description Get the result of the view simulation\n     * @param executionContext.source the public key hash of the account who initialized this view execution.\n     * @param executionContext.viewCaller the contract address which is the caller of view.\n     */ executeView(executionContext) {\n        return __awaiter(this, void 0, void 0, function*() {\n            this.verifyContextExecution(executionContext);\n            const chainId = yield this._readProvider.getChainId();\n            const viewArgs = this.transformArgsToMichelson();\n            const scriptView = {\n                contract: this._contractAddress,\n                view: this._smartContractViewSchema.viewName,\n                input: viewArgs,\n                chain_id: chainId,\n                source: executionContext.viewCaller\n            };\n            if (executionContext.source) {\n                scriptView.payer = executionContext.source;\n            }\n            return this.executeViewAndDecodeResult(scriptView);\n        });\n    }\n    verifyContextExecution(executionContext) {\n        if (executionContext.source && (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(executionContext.source) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new InvalidViewSimulationContext(`The source account who initialized the view execution is invalid: ${executionContext.source}.`);\n        }\n        if (!executionContext.viewCaller || (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(executionContext.viewCaller) !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new InvalidViewSimulationContext(`The contract which is the caller of view is invalid: ${executionContext.viewCaller}.`);\n        }\n    }\n    transformArgsToMichelson() {\n        try {\n            return this._smartContractViewSchema.encodeViewArgs(this._args);\n        } catch (error) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidViewParameterError(this._smartContractViewSchema.viewName, this.getSignature(), this._args, error);\n        }\n    }\n    /**\n     * @description Loops through the view's instructions and replace BALANCE, SENDER, SELF_ADDRESS and AMOUNT with Michelson expressions that match the current context, if applicable.\n     *\n     * Certain specific instructions have different semantics in view:\n     * BALANCE represents the current amount of mutez held by the contract where view is;\n     * SENDER represents the contract which is the caller of view;\n     * SELF_ADDRESS represents the contract where view is;\n     * AMOUNT is always 0 mutez.\n     *\n     */ adaptViewCodeToContext(instructions, viewCaller, contractBalance) {\n        const instructionsToReplace = {\n            BALANCE: [\n                {\n                    prim: \"PUSH\",\n                    args: [\n                        {\n                            prim: \"mutez\"\n                        },\n                        {\n                            int: contractBalance\n                        }\n                    ]\n                }\n            ],\n            SENDER: [\n                {\n                    prim: \"PUSH\",\n                    args: [\n                        {\n                            prim: \"address\"\n                        },\n                        {\n                            string: viewCaller\n                        }\n                    ]\n                }\n            ],\n            SELF_ADDRESS: [\n                {\n                    prim: \"PUSH\",\n                    args: [\n                        {\n                            prim: \"address\"\n                        },\n                        {\n                            string: this._contractAddress\n                        }\n                    ]\n                }\n            ],\n            AMOUNT: [\n                {\n                    prim: \"PUSH\",\n                    args: [\n                        {\n                            prim: \"mutez\"\n                        },\n                        {\n                            int: \"0\"\n                        }\n                    ]\n                }\n            ]\n        };\n        instructions.forEach((inst, i)=>{\n            if (inst.prim in instructionsToReplace) {\n                instructions[i] = Object(instructionsToReplace)[inst.prim];\n            }\n            if (inst.args && inst.args.length !== 0) {\n                this.adaptViewCodeToContext(inst.args, viewCaller, contractBalance);\n            } else if (Array.isArray(inst)) {\n                this.adaptViewCodeToContext(inst, viewCaller, contractBalance);\n            }\n        });\n        return instructions;\n    }\n    executeViewAndDecodeResult(viewScript) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let storage;\n            try {\n                storage = (yield this._rpc.runScriptView(viewScript)).data;\n            } catch (error) {\n                const failWith = validateAndExtractFailwith(error);\n                throw failWith ? new ViewSimulationError(`The simulation of the on-chain view named ${this._smartContractViewSchema.viewName} failed with: ${JSON.stringify(failWith)}`, this._smartContractViewSchema.viewName, failWith, error) : error;\n            }\n            return this._smartContractViewSchema.decodeViewResult(storage);\n        });\n    }\n}\nclass ContractMethodFactory {\n    constructor(provider, contractAddress){\n        this.provider = provider;\n        this.contractAddress = contractAddress;\n    }\n    createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {\n        return new ContractMethod(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);\n    }\n    createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint = true, isAnonymous = false) {\n        return new ContractMethodObject(this.provider, this.contractAddress, smartContractMethodSchema, smartContractMethodName, args, isMultipleEntrypoint, isAnonymous);\n    }\n    createContractViewObjectParam(rpc, readProvider, smartContractViewSchema, contractStorageType, viewArgs) {\n        return new OnChainView(rpc, readProvider, this.contractAddress, smartContractViewSchema, contractStorageType, viewArgs);\n    }\n}\nconst DEFAULT_SMART_CONTRACT_METHOD_NAME = \"default\";\n/**\n * @description Utility class to retrieve data from a smart contract's storage without incurring fees via a contract's view method\n */ class ContractView {\n    constructor(currentContract, name, callbackParametersSchema, parameterSchema, args, rpc, readProvider){\n        this.currentContract = currentContract;\n        this.name = name;\n        this.callbackParametersSchema = callbackParametersSchema;\n        this.parameterSchema = parameterSchema;\n        this.args = args;\n        this.rpc = rpc;\n        this.readProvider = readProvider;\n    }\n    read(chainId) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const chainIdValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateChain)(chainId !== null && chainId !== void 0 ? chainId : \"\");\n            if ((0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateContractAddress)(chainId !== null && chainId !== void 0 ? chainId : \"\") == _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.DeprecationError(`Since version 12, the lambda view no longer depends on a lambda contract. The read method no longer accepts a contract address as a parameter.`);\n            } else if (chainId && chainIdValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidChainIdError(chainId, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(chainIdValidation));\n            }\n            const arg = this.parameterSchema.Encode(...this.args);\n            const result = yield this.rpc.runView({\n                contract: this.currentContract.address,\n                entrypoint: this.name,\n                input: arg,\n                chain_id: chainId ? chainId : yield this.readProvider.getChainId()\n            });\n            return this.callbackParametersSchema.Execute(result.data);\n        });\n    }\n}\nconst validateArgs = (args, schema, name)=>{\n    const sigs = schema.ExtractSignatures();\n    if (!sigs.find((x)=>x.length === args.length)) {\n        throw new InvalidParameterError(name, sigs, args);\n    }\n};\n// lambda view tzip4\nconst isView = (entrypoint)=>{\n    let isView = false;\n    if (\"prim\" in entrypoint && entrypoint.prim === \"pair\" && entrypoint.args) {\n        const lastElement = entrypoint.args[entrypoint.args.length - 1];\n        if (\"prim\" in lastElement && lastElement.prim === \"contract\") {\n            isView = true;\n        }\n    }\n    return isView;\n};\n/**\n * @description Smart contract abstraction\n */ class ContractAbstraction {\n    constructor(address, script, provider, storageProvider, entrypoints, rpc, readProvider){\n        this.address = address;\n        this.script = script;\n        this.storageProvider = storageProvider;\n        this.entrypoints = entrypoints;\n        this.rpc = rpc;\n        this.readProvider = readProvider;\n        /**\n         * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n         * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n         *\n         */ this.methods = {};\n        /**\n         * @description Contains methods that are implemented by the target Tezos Smart Contract, and offers the user to call the Smart Contract methods as if they were native TS/JS methods.\n         * `methodsObject` serves the exact same purpose as the `methods` member. The difference is that it allows passing the parameter in an object format when calling the smart contract method (instead of the flattened representation)\n         * NB: if the contract contains annotation it will include named properties; if not it will be indexed by a number.\n         *\n         */ this.methodsObject = {};\n        /**\n         * @description Contains lamda views (tzip4) that are implemented by the target Tezos Smart Contract, and offers the user to call the lambda views as if they were native TS/JS methods.\n         * NB: These are the view defined in the tzip4 standard, not the views introduced by the Hangzhou protocol.\n         */ this.views = {};\n        /**\n         * @description Contains on-chain views that are defined by the target Tezos Smart Contract, and offers the user to simulate the views execution as if they were native TS/JS methods.\n         * NB: the expected format for the parameter when calling a smart contract view is the object format (same format as for the storage) and not the flattened representation.\n         *\n         */ this.contractViews = {};\n        this.contractMethodFactory = new ContractMethodFactory(provider, address);\n        this.schema = _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema.fromRPCResponse({\n            script: this.script\n        });\n        this.parameterSchema = _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.ParameterSchema.fromRPCResponse({\n            script: this.script\n        });\n        this.viewSchema = _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.ViewSchema.fromRPCResponse({\n            script: this.script\n        });\n        if (this.viewSchema.length !== 0) {\n            this._initializeOnChainViews(this, rpc, this.readProvider, this.viewSchema);\n        }\n        this.eventSchema = _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.EventSchema.fromRPCResponse({\n            script: this.script\n        });\n        this._initializeMethods(this, this.entrypoints.entrypoints, this.rpc, this.readProvider);\n    }\n    _initializeMethods(currentContract, entrypoints, rpc, readProvider) {\n        const parameterSchema = this.parameterSchema;\n        const keys = Object.keys(entrypoints);\n        if (parameterSchema.isMultipleEntryPoint) {\n            keys.forEach((smartContractMethodName)=>{\n                const smartContractMethodSchema = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.ParameterSchema(entrypoints[smartContractMethodName]);\n                this.methods[smartContractMethodName] = function(...args) {\n                    return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, smartContractMethodName, args);\n                };\n                this.methodsObject[smartContractMethodName] = function(args) {\n                    return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, smartContractMethodName, args);\n                };\n                if (isView(entrypoints[smartContractMethodName])) {\n                    const view = function(...args) {\n                        const entrypointParamWithoutCallback = entrypoints[smartContractMethodName].args[0];\n                        const smartContractMethodSchemaWithoutCallback = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.ParameterSchema(entrypointParamWithoutCallback);\n                        const parametersCallback = entrypoints[smartContractMethodName].args[1].args[0];\n                        const smartContractMethodCallbackSchema = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.ParameterSchema(parametersCallback);\n                        validateArgs(args, smartContractMethodSchemaWithoutCallback, smartContractMethodName);\n                        return new ContractView(currentContract, smartContractMethodName, smartContractMethodCallbackSchema, smartContractMethodSchemaWithoutCallback, args, rpc, readProvider);\n                    };\n                    this.views[smartContractMethodName] = view;\n                }\n            });\n            // Deal with methods with no annotations which were not discovered by the RPC endpoint\n            // Methods with no annotations are discovered using parameter schema\n            const anonymousMethods = Object.keys(parameterSchema.ExtractSchema()).filter((key)=>Object.keys(entrypoints).indexOf(key) === -1);\n            anonymousMethods.forEach((smartContractMethodName)=>{\n                this.methods[smartContractMethodName] = function(...args) {\n                    return currentContract.contractMethodFactory.createContractMethodFlatParams(parameterSchema, smartContractMethodName, args, false, true);\n                };\n                this.methodsObject[smartContractMethodName] = function(args) {\n                    return currentContract.contractMethodFactory.createContractMethodObjectParam(parameterSchema, smartContractMethodName, args, false, true);\n                };\n            });\n        } else {\n            const smartContractMethodSchema = this.parameterSchema;\n            this.methods[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function(...args) {\n                return currentContract.contractMethodFactory.createContractMethodFlatParams(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);\n            };\n            this.methodsObject[DEFAULT_SMART_CONTRACT_METHOD_NAME] = function(args) {\n                return currentContract.contractMethodFactory.createContractMethodObjectParam(smartContractMethodSchema, DEFAULT_SMART_CONTRACT_METHOD_NAME, args, false);\n            };\n        }\n    }\n    _initializeOnChainViews(currentContract, rpc, readProvider, allContractViews) {\n        const storageType = this.schema.val;\n        allContractViews.forEach((viewSchema)=>{\n            this.contractViews[viewSchema.viewName] = function(args) {\n                return currentContract.contractMethodFactory.createContractViewObjectParam(rpc, readProvider, viewSchema, storageType, args);\n            };\n        });\n    }\n    /**\n     * @description Return a friendly representation of the smart contract storage\n     */ storage() {\n        return this.storageProvider.getStorage(this.address, this.schema);\n    }\n    /**\n     *\n     * @description Return a friendly representation of the smart contract big map value\n     *\n     * @param key BigMap key to fetch\n     *\n     * @deprecated getBigMapKey has been deprecated in favor of getBigMapKeyByID\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */ bigMap(key) {\n        return this.storageProvider.getBigMapKey(this.address, key, this.schema);\n    }\n}\nconst setDelegate = (key)=>{\n    return [\n        {\n            prim: \"DROP\"\n        },\n        {\n            prim: \"NIL\",\n            args: [\n                {\n                    prim: \"operation\"\n                }\n            ]\n        },\n        {\n            prim: \"PUSH\",\n            args: [\n                {\n                    prim: \"key_hash\"\n                },\n                {\n                    string: key\n                }\n            ]\n        },\n        {\n            prim: \"SOME\"\n        },\n        {\n            prim: \"SET_DELEGATE\"\n        },\n        {\n            prim: \"CONS\"\n        }\n    ];\n};\nconst transferImplicit = (key, mutez)=>{\n    return [\n        {\n            prim: \"DROP\"\n        },\n        {\n            prim: \"NIL\",\n            args: [\n                {\n                    prim: \"operation\"\n                }\n            ]\n        },\n        {\n            prim: \"PUSH\",\n            args: [\n                {\n                    prim: \"key_hash\"\n                },\n                {\n                    string: key\n                }\n            ]\n        },\n        {\n            prim: \"IMPLICIT_ACCOUNT\"\n        },\n        {\n            prim: \"PUSH\",\n            args: [\n                {\n                    prim: \"mutez\"\n                },\n                {\n                    int: `${mutez}`\n                }\n            ]\n        },\n        {\n            prim: \"UNIT\"\n        },\n        {\n            prim: \"TRANSFER_TOKENS\"\n        },\n        {\n            prim: \"CONS\"\n        }\n    ];\n};\nconst removeDelegate = ()=>{\n    return [\n        {\n            prim: \"DROP\"\n        },\n        {\n            prim: \"NIL\",\n            args: [\n                {\n                    prim: \"operation\"\n                }\n            ]\n        },\n        {\n            prim: \"NONE\",\n            args: [\n                {\n                    prim: \"key_hash\"\n                }\n            ]\n        },\n        {\n            prim: \"SET_DELEGATE\"\n        },\n        {\n            prim: \"CONS\"\n        }\n    ];\n};\nconst transferToContract = (key, amount)=>{\n    return [\n        {\n            prim: \"DROP\"\n        },\n        {\n            prim: \"NIL\",\n            args: [\n                {\n                    prim: \"operation\"\n                }\n            ]\n        },\n        {\n            prim: \"PUSH\",\n            args: [\n                {\n                    prim: \"address\"\n                },\n                {\n                    string: key\n                }\n            ]\n        },\n        {\n            prim: \"CONTRACT\",\n            args: [\n                {\n                    prim: \"unit\"\n                }\n            ]\n        },\n        {\n            prim: \"IF_NONE\",\n            args: [\n                [\n                    {\n                        prim: \"UNIT\"\n                    },\n                    {\n                        prim: \"FAILWITH\"\n                    }\n                ],\n                []\n            ]\n        },\n        {\n            prim: \"PUSH\",\n            args: [\n                {\n                    prim: \"mutez\"\n                },\n                {\n                    int: `${amount}`\n                }\n            ]\n        },\n        {\n            prim: \"UNIT\"\n        },\n        {\n            prim: \"TRANSFER_TOKENS\"\n        },\n        {\n            prim: \"CONS\"\n        }\n    ];\n};\nconst MANAGER_LAMBDA = {\n    setDelegate,\n    removeDelegate,\n    transferImplicit,\n    transferToContract\n};\nconst code = [\n    {\n        prim: \"parameter\",\n        args: [\n            {\n                prim: \"lambda\",\n                args: [\n                    {\n                        prim: \"unit\"\n                    },\n                    {\n                        prim: \"pair\",\n                        args: [\n                            {\n                                prim: \"list\",\n                                args: [\n                                    {\n                                        prim: \"operation\"\n                                    }\n                                ]\n                            },\n                            {\n                                prim: \"unit\"\n                            }\n                        ]\n                    }\n                ]\n            }\n        ]\n    },\n    {\n        prim: \"storage\",\n        args: [\n            {\n                prim: \"unit\"\n            }\n        ]\n    },\n    {\n        prim: \"code\",\n        args: [\n            [\n                {\n                    prim: \"CAR\"\n                },\n                {\n                    prim: \"UNIT\"\n                },\n                {\n                    prim: \"EXEC\"\n                }\n            ]\n        ]\n    }\n];\nconst storage = \"Unit\";\nconst VIEW_LAMBDA = {\n    code,\n    storage\n};\nfunction compose(functioncomposer1, functioncomposer2) {\n    return (contractAbstraction, context)=>functioncomposer2(functioncomposer1(contractAbstraction, context), context);\n}\nclass SaplingStateAbstraction {\n    constructor(id, provider){\n        this.id = id;\n        this.provider = provider;\n    }\n    /**\n     *\n     * @description Fetch the sapling state\n     *\n     * @param block optional block level to fetch the values from (head will be use by default)\n     * @returns Return a json object of the sapling_state\n     *\n     */ getSaplingDiff(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.provider.getSaplingDiffByID(this.id.toString(), block);\n        });\n    }\n    getId() {\n        return this.id.toString();\n    }\n}\nclass BigMapAbstraction {\n    constructor(id, schema, provider){\n        this.id = id;\n        this.schema = schema;\n        this.provider = provider;\n    }\n    /**\n     *\n     * @description Fetch one value in a big map\n     *\n     * @param keysToEncode Key to query (will be encoded properly according to the schema)\n     * @param block optional block level to fetch the values from (head will be use by default)\n     * @returns Return a well formatted json object of a big map value or undefined if the key is not found in the big map\n     *\n     */ get(keyToEncode, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                const id = yield this.provider.getBigMapKeyByID(this.id.toString(), keyToEncode, this.schema, block);\n                return id;\n            } catch (e) {\n                if (e instanceof _taquito_http_utils__WEBPACK_IMPORTED_MODULE_1__.HttpResponseError && e.status === _taquito_http_utils__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODE.NOT_FOUND) {\n                    return undefined;\n                } else {\n                    throw e;\n                }\n            }\n        });\n    }\n    /**\n     *\n     * @description Fetch multiple values in a big map\n     * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\n     * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n     * If one of the keys does not exist in the big map, its value will be set to undefined.\n     *\n     * @param keysToEncode Array of keys to query (will be encoded properly according to the schema)\n     * @param block optional block level to fetch the values from\n     * @param batchSize optional batch size representing the number of requests to execute in parallel\n     * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n     *\n     */ getMultipleValues(keysToEncode, block, batchSize = 5) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.provider.getBigMapKeysByID(this.id.toString(), keysToEncode, this.schema, block, batchSize);\n        });\n    }\n    toJSON() {\n        return this.id.toString();\n    }\n    toString() {\n        return this.id.toString();\n    }\n}\n/**\n * @description Override the default michelson encoder semantic to provide richer abstraction over storage properties\n * @param provider ContractProvider (contract API)\n */ // Override the default michelson encoder semantic to provide richer abstraction over storage properties\nconst smartContractAbstractionSemantic = (provider)=>({\n        // Provide a specific abstraction for BigMaps\n        big_map: (val, code)=>{\n            if (!val || !(\"int\" in val) || val.int === undefined) {\n                // Return an empty object in case of missing big map ID\n                return {};\n            } else {\n                const schema = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema(code);\n                return new BigMapAbstraction(new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](val.int), schema, provider);\n            }\n        },\n        sapling_state: (val)=>{\n            if (!val || !(\"int\" in val) || val.int === undefined) {\n                // Return an empty object in case of missing sapling state ID\n                return {};\n            } else {\n                return new SaplingStateAbstraction(new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](val.int), provider);\n            }\n        }\n    });\nvar _PrepareProvider_counters;\nconst mergeLimits = (userDefinedLimit, defaultLimits)=>{\n    var _a, _b, _c;\n    return {\n        fee: (_a = userDefinedLimit.fee) !== null && _a !== void 0 ? _a : defaultLimits.fee,\n        gasLimit: (_b = userDefinedLimit.gasLimit) !== null && _b !== void 0 ? _b : defaultLimits.gasLimit,\n        storageLimit: (_c = userDefinedLimit.storageLimit) !== null && _c !== void 0 ? _c : defaultLimits.storageLimit\n    };\n};\n/**\n * @description PrepareProvider is a utility class to output the prepared format of an operation\n */ class PrepareProvider extends Provider {\n    constructor(context){\n        super(context);\n        this.context = context;\n        _PrepareProvider_counters.set(this, void 0);\n        __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n    }\n    getBlockHash(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.context.readProvider.getBlockHash(block !== null && block !== void 0 ? block : \"head~2\");\n        });\n    }\n    getProtocolHash() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.context.readProvider.getNextProtocol(\"head\");\n        });\n    }\n    getHeadCounter(pkh) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            return (_a = this.context.readProvider.getCounter(pkh, \"head\")) !== null && _a !== void 0 ? _a : \"0\";\n        });\n    }\n    adjustGasForBatchOperation(gasLimitBlock, gaslimitOp, numberOfOps) {\n        return bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].min(gaslimitOp, gasLimitBlock.div(numberOfOps + 1));\n    }\n    getAccountLimits(pkh, constants, numberOfOps) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const balance = yield this.context.readProvider.getBalance(pkh, \"head\");\n            const { hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte } = constants;\n            return {\n                fee: 0,\n                gasLimit: numberOfOps ? Math.floor(this.adjustGasForBatchOperation(hard_gas_limit_per_block, hard_gas_limit_per_operation, numberOfOps).toNumber()) : hard_gas_limit_per_operation.toNumber(),\n                storageLimit: Math.floor(bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].min(balance.dividedBy(cost_per_byte), hard_storage_limit_per_operation).toNumber())\n            };\n        });\n    }\n    getFee(op, pkh, headCounter) {\n        if (!__classPrivateFieldGet(this, _PrepareProvider_counters, \"f\")[pkh] || __classPrivateFieldGet(this, _PrepareProvider_counters, \"f\")[pkh] < headCounter) {\n            __classPrivateFieldGet(this, _PrepareProvider_counters, \"f\")[pkh] = headCounter;\n        }\n        const opCounter = ++__classPrivateFieldGet(this, _PrepareProvider_counters, \"f\")[pkh];\n        return {\n            counter: `${opCounter}`,\n            fee: typeof op.fee === \"undefined\" ? \"0\" : `${op.fee}`,\n            gas_limit: typeof op.gas_limit === \"undefined\" ? \"0\" : `${op.gas_limit}`,\n            storage_limit: typeof op.storage_limit === \"undefined\" ? \"0\" : `${op.storage_limit}`\n        };\n    }\n    getSource(op, pkh, source) {\n        return {\n            source: typeof op.source === \"undefined\" ? source || pkh : op.source\n        };\n    }\n    addRevealOperationIfNeeded(operation, publicKeyHash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (isOpRequireReveal(operation)) {\n                const ops = [\n                    operation\n                ];\n                const { publicKey, pkh } = yield this.getKeys();\n                if (yield this.isAccountRevealRequired(publicKeyHash)) {\n                    if (!publicKey) {\n                        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.PublicKeyNotFoundError(pkh);\n                    }\n                    ops.unshift((yield createRevealOperation({\n                        fee: DEFAULT_FEE.REVEAL,\n                        storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL,\n                        gasLimit: getRevealGasLimit(pkh)\n                    }, publicKeyHash, publicKey)));\n                    return ops;\n                }\n            }\n            return operation;\n        });\n    }\n    getKeys() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const isSignerConfigured = this.context.isAnySignerConfigured();\n            return {\n                pkh: isSignerConfigured ? yield this.signer.publicKeyHash() : yield this.context.walletProvider.getPKH(),\n                publicKey: isSignerConfigured ? yield this.signer.publicKey() : undefined\n            };\n        });\n    }\n    convertIntoArray(op) {\n        if (Array.isArray(op)) {\n            return [\n                ...op\n            ];\n        } else {\n            return [\n                op\n            ];\n        }\n    }\n    constructOpContents(ops, headCounter, pkh, source, currentVotingPeriod) {\n        return ops.map((op)=>{\n            switch(op.kind){\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ACTIVATION:\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DRAIN_DELEGATE:\n                    return Object.assign({}, op);\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION:\n                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), {\n                        balance: typeof op.balance !== \"undefined\" ? `${op.balance}` : \"0\"\n                    }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION:\n                    {\n                        const cops = Object.assign(Object.assign(Object.assign(Object.assign({}, op), {\n                            amount: typeof op.amount !== \"undefined\" ? `${op.amount}` : \"0\"\n                        }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));\n                        if (cops.source.toLowerCase().startsWith(\"kt1\")) {\n                            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.DeprecationError(`KT1 addresses are not supported as source since ${Protocols.PsBabyM1}`);\n                        }\n                        return cops;\n                    }\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL:\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION:\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REGISTER_GLOBAL_CONSTANT:\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.UPDATE_CONSENSUS_KEY:\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ADD_MESSAGES:\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE:\n                    return Object.assign(Object.assign(Object.assign({}, op), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET:\n                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), {\n                        ticket_amount: `${op.ticket_amount}`\n                    }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE:\n                    return Object.assign(Object.assign(Object.assign(Object.assign({}, op), {\n                        amount: `${op.amount}`\n                    }), this.getSource(op, pkh, source)), this.getFee(op, pkh, headCounter));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.BALLOT:\n                    if (currentVotingPeriod === undefined) {\n                        throw new RPCResponseError(`Failed to get the current voting period index`);\n                    }\n                    return Object.assign(Object.assign({}, op), {\n                        period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index\n                    });\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.PROPOSALS:\n                    if (currentVotingPeriod === undefined) {\n                        throw new RPCResponseError(`Failed to get the current voting period index`);\n                    }\n                    return Object.assign(Object.assign({}, op), {\n                        period: currentVotingPeriod === null || currentVotingPeriod === void 0 ? void 0 : currentVotingPeriod.voting_period.index\n                    });\n                default:\n                    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidOperationKindError(op.kind);\n            }\n        });\n    }\n    /**\n     *\n     * @description Method to prepare an activation operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ activate({ pkh, secret }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const op = yield createActivationOperation({\n                pkh,\n                secret\n            });\n            const ops = this.convertIntoArray(op);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a reveal operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ reveal({ fee, gasLimit, storageLimit }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh, publicKey } = yield this.getKeys();\n            if (!publicKey) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.PublicKeyNotFoundError(pkh);\n            }\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const mergedEstimates = mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS);\n            const op = yield createRevealOperation({\n                fee: mergedEstimates.fee,\n                gasLimit: mergedEstimates.gasLimit,\n                storageLimit: mergedEstimates.storageLimit\n            }, pkh, publicKey);\n            const ops = this.convertIntoArray(op);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare an origination operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ originate(_a, source) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createOriginationOperation((yield this.context.parser.prepareCodeOrigination(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)))));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a transaction operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ transaction(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createTransferOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a delegation operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ delegation(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createSetDelegateOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a register delegate operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ registerDelegate({ fee, storageLimit, gasLimit }, source) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const mergedEstimates = mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS);\n            const op = yield createRegisterDelegateOperation({\n                fee: mergedEstimates.fee,\n                storageLimit: mergedEstimates.storageLimit,\n                gasLimit: mergedEstimates.gasLimit\n            }, pkh);\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a register_global_constant operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ registerGlobalConstant(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createRegisterGlobalConstantOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare an update_consensus_key operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ updateConsensusKey(_a, source) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createUpdateConsensusKeyOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare an increase_paid_storage operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ increasePaidStorage(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createIncreasePaidStorageOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a ballot operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */ ballot(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const op = yield createBallotOperation(Object.assign({}, params));\n            const ops = this.convertIntoArray(op);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            let currentVotingPeriod;\n            try {\n                currentVotingPeriod = yield this.rpc.getCurrentPeriod();\n            } catch (e) {\n                throw new RPCResponseError(\"Failed to get the current voting period index\");\n            }\n            const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a proposals operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */ proposals(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const op = yield createProposalsOperation(Object.assign({}, params));\n            const ops = this.convertIntoArray(op);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            let currentVotingPeriod;\n            try {\n                currentVotingPeriod = yield this.rpc.getCurrentPeriod();\n            } catch (e) {\n                throw new RPCResponseError(\"Failed to get the current voting period index\");\n            }\n            const contents = this.constructOpContents(ops, headCounter, pkh, undefined, currentVotingPeriod);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a drain_delegate operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */ drainDelegate(params, source) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const op = yield createDrainDelegateOperation(Object.assign({}, params));\n            const ops = this.convertIntoArray(op);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a transfer_ticket operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ transferTicket(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createTransferTicketOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a smart_rollup_add_messages operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @param source string or undefined source pkh\n     * @returns a PreparedOperation object\n     */ smartRollupAddMessages(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createSmartRollupAddMessagesOperation(Object.assign(Object.assign({}, rest), mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a smart_rollup_originate operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */ smartRollupOriginate(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const op = yield createSmartRollupOriginateOperation(Object.assign(Object.assign({}, mergeLimits({\n                fee,\n                storageLimit,\n                gasLimit\n            }, DEFAULT_PARAMS)), rest));\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh, rest.source);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a batch operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */ batch(batchParams, estimates) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { pkh, publicKey } = yield this.getKeys();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants, batchParams.length);\n            const revealNeeded = yield this.isRevealOpNeeded(batchParams, pkh);\n            const ops = [];\n            if (!estimates) {\n                for (const op of batchParams){\n                    if (isOpWithFee(op)) {\n                        const limits = mergeLimits(op, DEFAULT_PARAMS);\n                        ops.push((yield this.getRPCOp(Object.assign(Object.assign({}, op), limits))));\n                    } else {\n                        ops.push(Object.assign({}, op));\n                    }\n                }\n            } else {\n                for (const op of batchParams){\n                    if (isOpWithFee(op)) {\n                        const e = estimates.shift();\n                        const limits = mergeLimits(op, {\n                            fee: e.suggestedFeeMutez,\n                            storageLimit: e.storageLimit,\n                            gasLimit: e.gasLimit\n                        });\n                        ops.push((yield this.getRPCOp(Object.assign(Object.assign({}, op), limits))));\n                    } else {\n                        ops.push(Object.assign({}, op));\n                    }\n                }\n            }\n            if (revealNeeded) {\n                if (!publicKey) {\n                    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.PublicKeyNotFoundError(pkh);\n                }\n                ops.unshift((yield createRevealOperation({\n                    fee: DEFAULT_FEE.REVEAL,\n                    storageLimit: DEFAULT_STORAGE_LIMIT.REVEAL,\n                    gasLimit: getRevealGasLimit(pkh)\n                }, pkh, publicKey)));\n            }\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const contents = this.constructOpContents(ops, headCounter, pkh);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to prepare a batch operation\n     * @param operation RPCOperation object or RPCOperation array\n     * @returns a PreparedOperation object\n     */ contractCall(contractMethod) {\n        var _a, _b, _c;\n        return __awaiter(this, void 0, void 0, function*() {\n            const hash = yield this.getBlockHash();\n            const protocol = yield this.getProtocolHash();\n            const { pkh } = yield this.getKeys();\n            __classPrivateFieldSet(this, _PrepareProvider_counters, {}, \"f\");\n            const headCounter = parseInt((yield this.getHeadCounter(pkh)), 10);\n            const params = contractMethod.toTransferParams();\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const DEFAULT_PARAMS = yield this.getAccountLimits(pkh, protocolConstants);\n            const estimateLimits = mergeLimits({\n                fee: params.fee,\n                storageLimit: params.storageLimit,\n                gasLimit: params.gasLimit\n            }, DEFAULT_PARAMS);\n            const op = {\n                kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION,\n                fee: (_a = params.fee) !== null && _a !== void 0 ? _a : estimateLimits.fee,\n                gas_limit: (_b = params.gasLimit) !== null && _b !== void 0 ? _b : estimateLimits.gasLimit,\n                storage_limit: (_c = params.storageLimit) !== null && _c !== void 0 ? _c : estimateLimits.storageLimit,\n                amount: String(params.amount),\n                destination: params.to,\n                parameters: params.parameter\n            };\n            const operation = yield this.addRevealOperationIfNeeded(op, pkh);\n            const ops = this.convertIntoArray(operation);\n            const contents = this.constructOpContents(ops, headCounter, pkh);\n            return {\n                opOb: {\n                    branch: hash,\n                    contents,\n                    protocol\n                },\n                counter: headCounter\n            };\n        });\n    }\n    /**\n     *\n     * @description Method to convert a PreparedOperation to the params needed for the preapplyOperation method\n     * @param prepared a Prepared Operation\n     * @returns a PreapplyParams object\n     */ toPreapply(prepared) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { opOb: { contents, branch, protocol } } = prepared;\n            const forgeParams = this.toForge(prepared);\n            const forged = yield this.context.forger.forge(forgeParams);\n            const sig = yield this.context.signer.sign(forged, new Uint8Array([\n                3\n            ]));\n            return [\n                {\n                    contents,\n                    branch,\n                    protocol,\n                    signature: sig.prefixSig\n                }\n            ];\n        });\n    }\n    /**\n     *\n     * @description Method to convert a PreparedOperation to the params needed for forging\n     * @param param a Prepared Operation\n     * @returns a ForgeParams object\n     */ toForge({ opOb: { contents, branch } }) {\n        return {\n            branch,\n            contents\n        };\n    }\n}\n_PrepareProvider_counters = new WeakMap();\nconst BATCH_KINDS = [\n    _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ACTIVATION,\n    _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION,\n    _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION,\n    _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION\n];\nclass OperationBatch extends Provider {\n    constructor(context, estimator){\n        super(context);\n        this.estimator = estimator;\n        this.operations = [];\n        this.prepare = new PrepareProvider(this.context);\n    }\n    /**\n     *\n     * @description Add a transaction operation to the batch\n     *\n     * @param params Transfer operation parameter\n     */ withTransfer(params) {\n        const toValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.to);\n        if (params.amount < 0) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAmountError(params.amount.toString());\n        }\n        if (toValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.to, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(toValidation));\n        }\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Transfer tickets from a Tezos address (tz1,tz2 or tz3) to a smart contract address( KT1)\n     *\n     * @param params Transfer operation parameter\n     */ withTransferTicket(params) {\n        const destinationValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.destination);\n        if (destinationValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.destination, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(destinationValidation));\n        }\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add a contract call to the batch\n     *\n     * @param params Call a contract method\n     * @param options Generic operation parameters\n     */ withContractCall(params, options = {}) {\n        return this.withTransfer(params.toTransferParams(options));\n    }\n    /**\n     *\n     * @description Add a delegation operation to the batch\n     *\n     * @param params Delegation operation parameter\n     */ withDelegation(params) {\n        var _a;\n        const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.source);\n        if (params.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n        }\n        const delegateValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.delegate) !== null && _a !== void 0 ? _a : \"\");\n        if (params.delegate && delegateValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.delegate, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(delegateValidation));\n        }\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add an activation operation to the batch\n     *\n     * @param params Activation operation parameter\n     * @throws {@link InvalidKeyHashError}\n     */ withActivation({ pkh, secret }) {\n        const pkhValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateKeyHash)(pkh);\n        if (pkhValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n            throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidKeyHashError(pkh, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(pkhValidation));\n        }\n        this.operations.push({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ACTIVATION,\n            pkh,\n            secret\n        });\n        return this;\n    }\n    /**\n     *\n     * @description Add an origination operation to the batch\n     *\n     * @param params Origination operation parameter\n     */ withOrigination(params) {\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add a register a global constant operation to the batch\n     *\n     * @param params RegisterGlobalConstant operation parameter\n     */ withRegisterGlobalConstant(params) {\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REGISTER_GLOBAL_CONSTANT\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add an increase paid storage operation to the batch\n     *\n     * @param params IncreasePaidStorage operation parameter\n     */ withIncreasePaidStorage(params) {\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add a smart rollup add messages operation to the batch\n     *\n     * @param params Rollup origination operation parameter\n     */ withSmartRollupAddMessages(params) {\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ADD_MESSAGES\n        }, params));\n        return this;\n    }\n    /**\n     *\n     * @description Add a smart rollup originate operation to the batch\n     *\n     * @param params Smart Rollup Originate operation parameter\n     */ withSmartRollupOriginate(params) {\n        this.operations.push(Object.assign({\n            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE\n        }, params));\n        return this;\n    }\n    getRPCOp(param) {\n        return __awaiter(this, void 0, void 0, function*() {\n            switch(param.kind){\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION:\n                    return createTransferOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION:\n                    return createOriginationOperation((yield this.context.parser.prepareCodeOrigination(Object.assign({}, param))));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION:\n                    return createSetDelegateOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REGISTER_GLOBAL_CONSTANT:\n                    return createRegisterGlobalConstantOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE:\n                    return createIncreasePaidStorageOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET:\n                    return createTransferTicketOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ADD_MESSAGES:\n                    return createSmartRollupAddMessagesOperation(Object.assign({}, param));\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE:\n                    return createSmartRollupOriginateOperation(Object.assign({}, param));\n                default:\n                    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidOperationKindError(JSON.stringify(param.kind));\n            }\n        });\n    }\n    /**\n     *\n     * @description Add a group operation to the batch. Operation will be applied in the order they are in the params array\n     *\n     * @param params Operations parameter\n     * @throws {@link InvalidOperationKindError}\n     */ with(params) {\n        for (const param of params){\n            switch(param.kind){\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION:\n                    this.withTransfer(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION:\n                    this.withOrigination(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION:\n                    this.withDelegation(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ACTIVATION:\n                    this.withActivation(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REGISTER_GLOBAL_CONSTANT:\n                    this.withRegisterGlobalConstant(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE:\n                    this.withIncreasePaidStorage(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET:\n                    this.withTransferTicket(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ADD_MESSAGES:\n                    this.withSmartRollupAddMessages(param);\n                    break;\n                case _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE:\n                    this.withSmartRollupOriginate(param);\n                    break;\n                default:\n                    throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidOperationKindError(JSON.stringify(param.kind));\n            }\n        }\n        return this;\n    }\n    /**\n     *\n     * @description Forge and Inject the operation batch\n     *\n     * @param params Optionally specify the source of the operation\n     */ send(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const source = params && params.source || publicKeyHash;\n            const estimates = yield this.estimator.batch(this.operations);\n            if (estimates.length !== this.operations.length) {\n                estimates.shift();\n            }\n            const preparedOp = yield this.prepare.batch(this.operations, estimates);\n            const opBytes = yield this.forge(preparedOp);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new BatchOperation(hash, preparedOp.opOb.contents, source, forgedBytes, opResponse, context);\n        });\n    }\n}\nclass RPCBatchProvider {\n    constructor(context, estimator){\n        this.context = context;\n        this.estimator = estimator;\n    }\n    /***\n     *\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n     *\n     * @param params List of operation to batch together\n     */ batch(params) {\n        const batch = new OperationBatch(this.context, this.estimator);\n        if (Array.isArray(params)) {\n            batch.with(params);\n        }\n        return batch;\n    }\n}\nclass BatchWalletOperation extends WalletOperation {\n    constructor(opHash, context, newHead$){\n        super(opHash, context, newHead$);\n        this.opHash = opHash;\n        this.context = context;\n        this.getOriginatedContractAddresses = ()=>__awaiter(this, void 0, void 0, function*() {\n                const opResult = yield this.operationResults();\n                if (!opResult) {\n                    throw new ObservableError(\"Unable to fetch operation results\");\n                } else {\n                    const originationOpResults = opResult.filter((x)=>x.kind === \"origination\");\n                    let addresses = [];\n                    for (const res of originationOpResults){\n                        if (res.metadata.operation_result.originated_contracts) {\n                            addresses = [\n                                ...addresses,\n                                ...res.metadata.operation_result.originated_contracts\n                            ];\n                        }\n                    }\n                    return addresses;\n                }\n            });\n    }\n    revealOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (!operationResult) {\n                throw new ObservableError(\"Unable to fetch operation results\");\n            } else {\n                return operationResult.find((x)=>x.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL);\n            }\n        });\n    }\n    status() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._included) {\n                return \"pending\";\n            }\n            const op = yield this.operationResults();\n            if (op) {\n                return op.filter((result)=>BATCH_KINDS.indexOf(result.kind) !== -1).map((result)=>{\n                    if (hasMetadataWithResult(result)) {\n                        const opResult = result.metadata.operation_result;\n                        return opResult.status;\n                    } else {\n                        return \"unknown\";\n                    }\n                })[0] || \"unknown\";\n            } else {\n                throw new ObservableError(\"Unable to fetch operation results\");\n            }\n        });\n    }\n}\nclass IncreasePaidStorageWalletOperation extends WalletOperation {\n    constructor(opHash, context, newHead$){\n        super(opHash, context, newHead$);\n        this.opHash = opHash;\n        this.context = context;\n    }\n    revealOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (!operationResult) {\n                throw new ObservableError(\"Unable to fetch operation result\");\n            } else {\n                return operationResult.find((x)=>x.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL);\n            }\n        });\n    }\n    increasePaidStorageOperation() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const operationResult = yield this.operationResults();\n            if (!operationResult) {\n                throw new ObservableError(\"Unable to fetch operation result\");\n            } else {\n                return operationResult.find((x)=>x.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE);\n            }\n        });\n    }\n    status() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this._included) {\n                return \"pending\";\n            }\n            const op = yield this.increasePaidStorageOperation();\n            if (!op) {\n                return \"unknown\";\n            }\n            return op.metadata.operation_result.status;\n        });\n    }\n}\nfunction timeoutAfter(timeoutMillisec) {\n    return function inner(source) {\n        return new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_11__.BehaviorSubject(null).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.timeout)({\n            each: timeoutMillisec,\n            with: ()=>(0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_12__.throwError)(()=>new ConfirmationTimeoutError(`Confirmation polling timed out`))\n        }), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.mergeMap)(()=>source));\n    };\n}\nconst createNewPollingBasedHeadObservable = (sharedHeadOb, context, _scheduler)=>{\n    return sharedHeadOb.pipe(timeoutAfter(context.config.confirmationPollingTimeoutSecond * 1000), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.share)({\n        connector: ()=>new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_9__.ReplaySubject(1),\n        resetOnError: false,\n        resetOnComplete: false,\n        resetOnRefCountZero: false\n    }));\n};\nclass OperationFactory {\n    constructor(context){\n        this.context = context;\n        // Cache the last block for one second across all operations\n        this.sharedHeadObs = (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_13__.defer)(()=>{\n            return createObservableFromSubscription(this.context.stream.subscribeBlock(\"head\"));\n        });\n    }\n    createNewHeadObservable() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return createNewPollingBasedHeadObservable(this.sharedHeadObs, this.context);\n        });\n    }\n    createPastBlockWalker(startBlock, count = 1) {\n        return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.from)(this.context.readProvider.getBlock(startBlock)).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)((block)=>{\n            if (count === 1) {\n                return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_15__.of)(block);\n            }\n            return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_14__.range)(block.header.level, count - 1).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.startWith)(block), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.concatMap)((level)=>__awaiter(this, void 0, void 0, function*() {\n                    return this.context.readProvider.getBlock(typeof level === \"number\" ? level : level.header.level);\n                })));\n        }));\n    }\n    createHeadObservableFromConfig({ blockIdentifier }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const observableSequence = [];\n            if (blockIdentifier) {\n                observableSequence.push(this.createPastBlockWalker(blockIdentifier));\n            }\n            observableSequence.push((yield this.createNewHeadObservable()));\n            return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_19__.concat)(...observableSequence);\n        });\n    }\n    createOperation(hash, config = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new WalletOperation(hash, this.context.clone(), (yield this.createHeadObservableFromConfig(config)));\n        });\n    }\n    createBatchOperation(hash, config = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new BatchWalletOperation(hash, this.context.clone(), (yield this.createHeadObservableFromConfig(config)));\n        });\n    }\n    createTransactionOperation(hash, config = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new TransactionWalletOperation(hash, this.context.clone(), (yield this.createHeadObservableFromConfig(config)));\n        });\n    }\n    createDelegationOperation(hash, config = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new DelegationWalletOperation(hash, this.context.clone(), (yield this.createHeadObservableFromConfig(config)));\n        });\n    }\n    createOriginationOperation(hash, config = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new OriginationWalletOperation(hash, this.context.clone(), (yield this.createHeadObservableFromConfig(config)));\n        });\n    }\n    createIncreasePaidStorageOperation(hash, config = {}) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return new IncreasePaidStorageWalletOperation(hash, this.context.clone(), (yield this.createHeadObservableFromConfig(config)));\n        });\n    }\n}\nclass RpcTzProvider extends Provider {\n    constructor(context){\n        super(context);\n        this.prepare = new PrepareProvider(this.context);\n    }\n    getBalance(address) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(address);\n            if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(addressValidation));\n            }\n            return this.context.readProvider.getBalance(address, \"head\");\n        });\n    }\n    getDelegate(address) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(address);\n            if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(addressValidation));\n            }\n            return this.context.readProvider.getDelegate(address, \"head\");\n        });\n    }\n    activate(pkh, secret) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const pkhValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateKeyHash)(pkh);\n            if (pkhValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.InvalidKeyHashError(pkh, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(pkhValidation));\n            }\n            const prepared = yield this.prepare.activate({\n                pkh,\n                secret\n            });\n            const forgedBytes = yield this.forge(prepared);\n            const bytes = `${forgedBytes.opbytes}00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000`;\n            return new Operation((yield this.rpc.injectOperation(bytes)), Object.assign(Object.assign({}, forgedBytes), {\n                opbytes: bytes\n            }), [], this.context.clone());\n        });\n    }\n}\nconst MINIMAL_FEE_MUTEZ = 100;\nconst MINIMAL_FEE_PER_BYTE_MUTEZ = 1;\nconst MINIMAL_FEE_PER_GAS_MUTEZ = 0.1;\nconst GAS_BUFFER = 100;\n/**\n * Examples of use :\n *\n *  Estimate a transfer operation :\n * ```\n * // Assuming that provider and signer are already configured...\n *\n * const amount = 2;\n * const address = 'tz1h3rQ8wBxFd8L9B3d7Jhaawu6Z568XU3xY';\n *\n * // Estimate gasLimit, storageLimit and fees for a transfer operation\n * const est = await Tezos.estimate.transfer({ to: address, amount: amount })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *  est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n *\n * Estimate a contract origination :\n * ```\n * // generic.json is referring to a Michelson Smart Contract\n *\n * const genericMultisigJSON = require('./generic.json')\n * const est = await Tezos.estimate.originate({\n *   code: genericMultisigJSON,\n *   storage: {\n *     stored_counter: 0,\n *     threshold: 1,\n *     keys: ['edpkuLxx9PQD8fZ45eUzrK3BhfDZJHhBuK4Zi49DcEGANwd2rpX82t']\n *   }\n * })\n * console.log(est.burnFeeMutez, est.gasLimit, est.minimalFeeMutez, est.storageLimit,\n *   est.suggestedFeeMutez, est.totalCost, est.usingBaseFeeMutez)\n *\n * ```\n */ class Estimate {\n    constructor(_milligasLimit, _storageLimit, opSize, minimalFeePerStorageByteMutez, /**\n     * @description Base fee in mutez (1 mutez = 1e10−6 tez)\n     */ baseFeeMutez = MINIMAL_FEE_MUTEZ){\n        this._milligasLimit = _milligasLimit;\n        this._storageLimit = _storageLimit;\n        this.opSize = opSize;\n        this.minimalFeePerStorageByteMutez = minimalFeePerStorageByteMutez;\n        this.baseFeeMutez = baseFeeMutez;\n    }\n    /**\n     * @description The number of Mutez that will be burned for the storage of the [operation](https://tezos.gitlab.io/user/glossary.html#operations). (Storage + Allocation fees)\n     */ get burnFeeMutez() {\n        return this.roundUp(Number(this.storageLimit) * Number(this.minimalFeePerStorageByteMutez));\n    }\n    /**\n     * @description  The limit on the amount of storage an [operation](https://tezos.gitlab.io/user/glossary.html#operations) can use.\n     */ get storageLimit() {\n        const limit = Math.max(Number(this._storageLimit), 0);\n        return limit > 0 ? limit : 0;\n    }\n    /**\n     * @description The limit on the amount of [gas](https://tezos.gitlab.io/user/glossary.html#gas) a given operation can consume.\n     */ get gasLimit() {\n        return this.roundUp(Number(this._milligasLimit) / 1000 + GAS_BUFFER);\n    }\n    get operationFeeMutez() {\n        return (Number(this._milligasLimit) / 1000 + GAS_BUFFER) * MINIMAL_FEE_PER_GAS_MUTEZ + Number(this.opSize) * MINIMAL_FEE_PER_BYTE_MUTEZ;\n    }\n    roundUp(nanotez) {\n        return Math.ceil(Number(nanotez));\n    }\n    /**\n     * @description Minimum fees for the [operation](https://tezos.gitlab.io/user/glossary.html#operations) according to [baker](https://tezos.gitlab.io/user/glossary.html#baker) defaults.\n     */ get minimalFeeMutez() {\n        return this.roundUp(MINIMAL_FEE_MUTEZ + this.operationFeeMutez);\n    }\n    /**\n     * @description The suggested fee for the operation which includes minimal fees and a small buffer.\n     */ get suggestedFeeMutez() {\n        return this.roundUp(this.operationFeeMutez + MINIMAL_FEE_MUTEZ * 2);\n    }\n    /**\n     * @description Fees according to your specified base fee will ensure that at least minimum fees are used.\n     */ get usingBaseFeeMutez() {\n        return Math.max(Number(this.baseFeeMutez), MINIMAL_FEE_MUTEZ) + this.roundUp(this.operationFeeMutez);\n    }\n    /**\n     * @description The sum of `minimalFeeMutez` + `burnFeeMutez`.\n     */ get totalCost() {\n        return this.minimalFeeMutez + this.burnFeeMutez;\n    }\n    /**\n     * @description Since Delphinet, consumed gas is provided in milligas for more precision.\n     * This function returns an estimation of the gas that operation will consume in milligas.\n     */ get consumedMilligas() {\n        return Number(this._milligasLimit);\n    }\n    static createEstimateInstanceFromProperties(estimateProperties) {\n        let milligasLimit = 0;\n        let storageLimit = 0;\n        let opSize = 0;\n        let minimalFeePerStorageByteMutez = 0;\n        let baseFeeMutez;\n        estimateProperties.forEach((estimate)=>{\n            milligasLimit += estimate.milligasLimit;\n            storageLimit += estimate.storageLimit;\n            opSize += estimate.opSize;\n            minimalFeePerStorageByteMutez = Math.max(estimate.minimalFeePerStorageByteMutez, minimalFeePerStorageByteMutez);\n            if (estimate.baseFeeMutez) {\n                baseFeeMutez = baseFeeMutez ? baseFeeMutez + estimate.baseFeeMutez : estimate.baseFeeMutez;\n            }\n        });\n        return new Estimate(milligasLimit, storageLimit, opSize, minimalFeePerStorageByteMutez, baseFeeMutez);\n    }\n    static createArrayEstimateInstancesFromProperties(estimateProperties) {\n        return estimateProperties.map((x)=>new Estimate(x.milligasLimit, x.storageLimit, x.opSize, x.minimalFeePerStorageByteMutez, x.baseFeeMutez));\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates unable to get public key to estimate reveal operation in Wallet API\n */ class RevealEstimateError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TaquitoError {\n    constructor(){\n        super();\n        this.name = \"RevealEstimateError\";\n        this.message = \"Public key is unknown, unable to estimate the reveal operation in Wallet API.\";\n    }\n}\nclass RPCEstimateProvider extends Provider {\n    constructor(){\n        super(...arguments);\n        this.ALLOCATION_STORAGE = 257;\n        this.ORIGINATION_STORAGE = 257;\n        this.OP_SIZE_REVEAL = 128;\n        this.prepare = new PrepareProvider(this.context);\n    }\n    getKeys() {\n        return __awaiter(this, void 0, void 0, function*() {\n            const isSignerConfigured = this.context.isAnySignerConfigured();\n            return {\n                publicKeyHash: isSignerConfigured ? yield this.signer.publicKeyHash() : yield this.context.walletProvider.getPKH(),\n                publicKey: isSignerConfigured ? yield this.signer.publicKey() : undefined\n            };\n        });\n    }\n    getEstimationPropertiesFromOperationContent(content, size, costPerByte) {\n        const operationResults = flattenOperationResult({\n            contents: [\n                content\n            ]\n        });\n        let totalMilligas = 0;\n        let totalStorage = 0;\n        operationResults.forEach((result)=>{\n            totalStorage += \"originated_contracts\" in result && typeof result.originated_contracts !== \"undefined\" ? result.originated_contracts.length * this.ORIGINATION_STORAGE : 0;\n            totalStorage += \"allocated_destination_contract\" in result ? this.ALLOCATION_STORAGE : 0;\n            totalMilligas += Number(result.consumed_milligas) || 0;\n            totalStorage += \"paid_storage_size_diff\" in result ? Number(result.paid_storage_size_diff) || 0 : 0;\n            totalStorage += \"storage_size\" in result && \"global_address\" in result ? Number(result.storage_size) || 0 : 0;\n            totalStorage += \"genesis_commitment_hash\" in result ? Number(result.size) : 0;\n        });\n        if (isOpWithFee(content)) {\n            return {\n                milligasLimit: totalMilligas || 0,\n                storageLimit: Number(totalStorage || 0),\n                opSize: size,\n                minimalFeePerStorageByteMutez: costPerByte.toNumber()\n            };\n        } else {\n            return {\n                milligasLimit: 0,\n                storageLimit: 0,\n                opSize: size,\n                minimalFeePerStorageByteMutez: costPerByte.toNumber(),\n                baseFeeMutez: 0\n            };\n        }\n    }\n    calculateEstimates(op, constants) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { opbytes, opOb: { branch, contents } } = yield this.forge(op);\n            const operation = {\n                operation: {\n                    branch,\n                    contents\n                },\n                chain_id: yield this.context.readProvider.getChainId()\n            };\n            const { opResponse } = yield this.simulate(operation);\n            const { cost_per_byte } = constants;\n            const errors = [\n                ...flattenErrors(opResponse, \"backtracked\"),\n                ...flattenErrors(opResponse)\n            ];\n            // Fail early in case of errors\n            if (errors.length) {\n                throw new TezosOperationError(errors, \"Error occurred during estimation\", opResponse.contents);\n            }\n            let numberOfOps = 1;\n            if (Array.isArray(op.opOb.contents) && op.opOb.contents.length > 1) {\n                numberOfOps = opResponse.contents[0].kind === \"reveal\" ? op.opOb.contents.length - 1 : op.opOb.contents.length;\n            }\n            return opResponse.contents.map((x)=>{\n                return this.getEstimationPropertiesFromOperationContent(x, // TODO: Calculate a specific opSize for each operation.\n                x.kind === \"reveal\" ? this.OP_SIZE_REVEAL / 2 : opbytes.length / 2 / numberOfOps, cost_per_byte);\n            });\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an origination operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param OriginationOperation Originate operation parameter\n     */ originate(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const preparedOperation = yield this.prepare.originate(params);\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an transfer operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param TransferOperation Originate operation parameter\n     */ transfer(_a) {\n        var _b;\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const toValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(rest.to);\n            if (toValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(rest.to, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(toValidation));\n            }\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_b = rest.source) !== null && _b !== void 0 ? _b : \"\");\n            if (rest.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(rest.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            if (rest.amount < 0) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAmountError(rest.amount.toString());\n            }\n            const preparedOperation = yield this.prepare.transaction(Object.assign({\n                fee,\n                storageLimit,\n                gasLimit\n            }, rest));\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a transferTicket operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param TransferTicketParams operation parameter\n     */ transferTicket(_a) {\n        var _b;\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const destinationValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(rest.destination);\n            if (destinationValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(rest.destination, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(destinationValidation));\n            }\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_b = rest.source) !== null && _b !== void 0 ? _b : \"\");\n            if (rest.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(rest.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const preparedOperation = yield this.prepare.transferTicket(Object.assign({\n                fee,\n                storageLimit,\n                gasLimit\n            }, rest));\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */ setDelegate(_a) {\n        var _b;\n        var { fee, gasLimit, storageLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"gasLimit\",\n            \"storageLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(rest.source);\n            if (rest.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(rest.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            const delegateValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_b = rest.delegate) !== null && _b !== void 0 ? _b : \"\");\n            if (rest.delegate && delegateValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(rest.delegate, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(delegateValidation));\n            }\n            const preparedOperation = yield this.prepare.delegation(Object.assign({\n                fee,\n                storageLimit,\n                gasLimit\n            }, rest));\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a each operation in the batch\n     *\n     * @returns An array of Estimate objects. If a reveal operation is needed, the first element of the array is the Estimate for the reveal operation.\n     */ batch(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const preparedOperations = yield this.prepare.batch(params);\n            const estimateProperties = yield this.calculateEstimates(preparedOperations, protocolConstants);\n            return Estimate.createArrayEstimateInstancesFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a delegate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */ registerDelegate(_a, source) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const pkh = (yield this.getKeys()).publicKeyHash;\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const checkSource = source || pkh;\n            const preparedOperation = yield this.prepare.registerDelegate(Object.assign({\n                fee,\n                storageLimit,\n                gasLimit\n            }, rest), checkSource);\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees to reveal the current account\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation or undefined if the account is already revealed\n     *\n     * @param Estimate\n     */ reveal(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { publicKeyHash, publicKey } = yield this.getKeys();\n            if (!publicKey) {\n                throw new RevealEstimateError();\n            }\n            if (yield this.isAccountRevealRequired(publicKeyHash)) {\n                const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n                const preparedOperation = params ? yield this.prepare.reveal(params) : yield this.prepare.reveal({});\n                const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n                return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n            }\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an registerGlobalConstant operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param params registerGlobalConstant operation parameter\n     */ registerGlobalConstant(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            const preparedOperation = yield this.prepare.registerGlobalConstant(Object.assign({\n                fee,\n                storageLimit,\n                gasLimit\n            }, rest));\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit, and fees for an increasePaidStorage operation\n     *\n     * @returns An estimation of gasLimit, storageLimit, and fees for the operation\n     *\n     * @param params increasePaidStorage operation parameters\n     */ increasePaidStorage(_a) {\n        var { fee, storageLimit, gasLimit } = _a, rest = __rest(_a, [\n            \"fee\",\n            \"storageLimit\",\n            \"gasLimit\"\n        ]);\n        return __awaiter(this, void 0, void 0, function*() {\n            if (rest.amount < 0) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAmountError(rest.amount.toString());\n            }\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const preparedOperation = yield this.prepare.increasePaidStorage(Object.assign({\n                fee,\n                storageLimit,\n                gasLimit\n            }, rest));\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Update Consensus Key operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */ updateConsensusKey(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const preparedOperation = yield this.prepare.updateConsensusKey(params);\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for a smart_rollup_add_messages operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param Estimate\n     */ smartRollupAddMessages(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const preparedOperation = yield this.prepare.smartRollupAddMessages(params);\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for an Smart Rollup Originate operation\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the operation\n     *\n     * @param SmartRollupOriginateParams\n     */ smartRollupOriginate(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const preparedOperation = yield this.prepare.smartRollupOriginate(params);\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n    /**\n     *\n     * @description Estimate gasLimit, storageLimit and fees for contract call\n     *\n     * @returns An estimation of gasLimit, storageLimit and fees for the contract call\n     *\n     * @param Estimate\n     */ contractCall(contractMethod) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const protocolConstants = yield this.context.readProvider.getProtocolConstants(\"head\");\n            const preparedOperation = yield this.prepare.contractCall(contractMethod);\n            const estimateProperties = yield this.calculateEstimates(preparedOperation, protocolConstants);\n            if (preparedOperation.opOb.contents[0].kind === \"reveal\") {\n                estimateProperties.shift();\n            }\n            return Estimate.createEstimateInstanceFromProperties(estimateProperties);\n        });\n    }\n}\n/**\n * @description Delegation operation provide utility function to fetch newly issued delegation\n *\n * @warn Currently support only one delegation per operation\n */ class DelegateOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const delegationOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"delegation\");\n        const result = delegationOp && delegationOp.metadata && delegationOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get delegate() {\n        return this.params.delegate;\n    }\n    get isRegisterOperation() {\n        return this.delegate === this.source;\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get consumedGas() {\n        bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.config({\n            DECIMAL_PLACES: 0,\n            ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.ROUND_UP\n        });\n        return this.consumedMilliGas ? new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(this.consumedMilliGas).dividedBy(1000).toString() : undefined;\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n    get errors() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;\n    }\n}\n/**\n * @description Origination operation provide utility function to fetch newly originated contract\n *\n * @warn Currently support only one origination per operation\n */ class OriginationOperation extends Operation {\n    constructor(hash, params, raw, results, context, contractProvider){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.contractProvider = contractProvider;\n        const originatedContracts = this.operationResults && this.operationResults.originated_contracts;\n        if (Array.isArray(originatedContracts)) {\n            this.contractAddress = originatedContracts[0];\n        }\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get operationResults() {\n        const originationOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"origination\");\n        const result = originationOp && hasMetadataWithResult(originationOp) && originationOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get consumedGas() {\n        bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.config({\n            DECIMAL_PLACES: 0,\n            ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.ROUND_UP\n        });\n        return this.consumedMilliGas ? new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(this.consumedMilliGas).dividedBy(1000).toString() : undefined;\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n    get storageDiff() {\n        const storageDiff = this.operationResults && this.operationResults.paid_storage_size_diff;\n        return storageDiff ? storageDiff : undefined;\n    }\n    get storageSize() {\n        const storageSize = this.operationResults && this.operationResults.storage_size;\n        return storageSize ? storageSize : undefined;\n    }\n    get errors() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;\n    }\n    /**\n     * @description Provide the contract abstract of the newly originated contract\n     * @throws {@link OriginationOperationError}\n     */ contract(confirmations, timeout) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.contractAddress) {\n                throw new OriginationOperationError(\"No contract was originated in this operation\");\n            }\n            yield this.confirmation(confirmations, timeout);\n            return this.contractProvider.at(this.contractAddress);\n        });\n    }\n}\n/**\n * @description RegisterGlobalConstantOperation provides utility functions to fetch a newly issued operation of kind register_global_constant\n */ class RegisterGlobalConstantOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n        this.globalConstantHash = this.operationResults && this.operationResults.global_address;\n    }\n    get operationResults() {\n        const registerGlobalConstantOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"register_global_constant\");\n        const result = registerGlobalConstantOp && registerGlobalConstantOp.metadata && registerGlobalConstantOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get registeredExpression() {\n        return this.params.value;\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get errors() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;\n    }\n    get consumedGas() {\n        bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.config({\n            DECIMAL_PLACES: 0,\n            ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.ROUND_UP\n        });\n        return this.consumedMilliGas ? new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(this.consumedMilliGas).dividedBy(1000).toString() : undefined;\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n}\n/**\n * @description Reveal operation provides utility functions to fetch a newly issued revelation\n */ class RevealOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const revealOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"reveal\");\n        return revealOp ? [\n            revealOp\n        ] : [];\n    }\n    get status() {\n        const operationResults = this.operationResults;\n        const txResult = operationResults[0];\n        if (txResult) {\n            return txResult.metadata.operation_result.status;\n        } else {\n            return \"unknown\";\n        }\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get publicKey() {\n        return this.params.public_key;\n    }\n    sumProp(arr, prop) {\n        return arr.reduce((prev, current)=>{\n            return prop in current ? Number(current[prop]) + prev : prev;\n        }, 0);\n    }\n    get consumedGas() {\n        bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.config({\n            DECIMAL_PLACES: 0,\n            ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.ROUND_UP\n        });\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(this.consumedMilliGas).dividedBy(1000).toString();\n    }\n    get consumedMilliGas() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.operationResults\n        }), \"consumed_milligas\"));\n    }\n    get storageDiff() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.operationResults\n        }), \"paid_storage_size_diff\"));\n    }\n    get storageSize() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.operationResults\n        }), \"storage_size\"));\n    }\n    get errors() {\n        return flattenErrors({\n            contents: this.operationResults\n        });\n    }\n}\n/**\n * @description Transaction operation provides utility functions to fetch a newly issued transaction\n *\n * @warn Currently supports one transaction per operation\n */ class TransactionOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const transactionOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"transaction\");\n        return transactionOp ? [\n            transactionOp\n        ] : [];\n    }\n    get status() {\n        const operationResults = this.operationResults;\n        const txResult = operationResults[0];\n        if (txResult) {\n            return txResult.metadata.operation_result.status;\n        } else {\n            return \"unknown\";\n        }\n    }\n    get amount() {\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.params.amount);\n    }\n    get destination() {\n        return this.params.destination;\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    sumProp(arr, prop) {\n        return arr.reduce((prev, current)=>{\n            return prop in current ? Number(current[prop]) + prev : prev;\n        }, 0);\n    }\n    get consumedGas() {\n        bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].config({\n            DECIMAL_PLACES: 0,\n            ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].ROUND_UP\n        });\n        return new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](this.consumedMilliGas).dividedBy(1000).toString();\n    }\n    get consumedMilliGas() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.operationResults\n        }), \"consumed_milligas\"));\n    }\n    get storageDiff() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.operationResults\n        }), \"paid_storage_size_diff\"));\n    }\n    get storageSize() {\n        return String(this.sumProp(flattenOperationResult({\n            contents: this.operationResults\n        }), \"storage_size\"));\n    }\n    get errors() {\n        return flattenErrors({\n            contents: this.operationResults\n        });\n    }\n}\n/**\n *\n * @description BallotOperation provides utility functions to fetch a new operation of kind ballot\n *\n */ class BallotOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const ballotOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"ballot\");\n        const result = ballotOp;\n        return result ? result : undefined;\n    }\n    get period() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.period;\n    }\n    get proposal() {\n        return this.params.proposal;\n    }\n    get ballot() {\n        return this.params.ballot;\n    }\n}\n/**\n *\n * @description DrainDelegateOperation provides utility functions to fetch a new operation of kind drain_delegate\n *\n */ class DrainDelegateOperation extends Operation {\n    constructor(hash, params, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n    }\n    get operationResults() {\n        const drainDelegateOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"drain_delegate\");\n        const result = drainDelegateOp && drainDelegateOp.metadata && drainDelegateOp.metadata.balance_updates;\n        return result ? result : undefined;\n    }\n    get consensusKey() {\n        return this.params.consensus_key;\n    }\n    get delegate() {\n        return this.params.delegate;\n    }\n    get destination() {\n        return this.params.destination;\n    }\n}\n/**\n *\n * @description Transfer tickets from a Tezos address (tz1, tz2 or tz3) to a smart contract address (KT1) (everything on layer 1 at this step)\n *\n * @warn Currently only supports one L2 ticket holder transfer at once. ie. one collection of tickets owned by tz1, tz2 or tz3 to a smart contract.\n */ class TransferTicketOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const transferOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET);\n        const result = transferOp && transferOp.metadata && transferOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get consumedGas() {\n        bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.config({\n            DECIMAL_PLACES: 0,\n            ROUNDING_MODE: bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber.ROUND_UP\n        });\n        return this.consumedMilliGas ? new bignumber_js__WEBPACK_IMPORTED_MODULE_5__.BigNumber(this.consumedMilliGas).dividedBy(1000).toString() : undefined;\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n}\n/**\n *\n * @description IncreasePaidStorageOperation provides utility functions to fetch a new operation of kind increase_paid_storage\n *\n */ class IncreasePaidStorageOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const increasePaidStorageOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"increase_paid_storage\");\n        const result = increasePaidStorageOp && increasePaidStorageOp.metadata && increasePaidStorageOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get errors() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n    get amount() {\n        return this.params.amount;\n    }\n    get destination() {\n        return this.params.destination;\n    }\n}\n/**\n *\n * @description ProposalsOperation provides utility functions to fetch a new operation of kind proposals\n *\n */ class ProposalsOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const proposalsOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"proposals\");\n        const result = proposalsOp;\n        return result ? result : undefined;\n    }\n    get proposals() {\n        return this.params.proposals;\n    }\n    get period() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.period;\n    }\n}\n/**\n *\n * @description UpdateConsensusKeyOperation provides utility to fetch properties for Operation of kind UpdateConsensusKey\n *\n */ class UpdateConsensusKeyOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const updateConsensusKeyOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"update_consensus_key\");\n        const result = updateConsensusKeyOp && updateConsensusKeyOp.metadata && updateConsensusKeyOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get pk() {\n        return this.params.pk;\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n    get errors() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;\n    }\n}\n/**\n * @description SmartRollupAddMessagesOperation provides utility to fetch properties of SmartRollupAddMessages\n */ class SmartRollupAddMessagesOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const smartRollupAddMessagesOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === \"smart_rollup_add_messages\");\n        const result = smartRollupAddMessagesOp && smartRollupAddMessagesOp.metadata && smartRollupAddMessagesOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get message() {\n        return this.params.message;\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n    get errors() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;\n    }\n}\n/**\n *\n * @description SmartRollupOriginate Operation provides utility to fetch properties for Operation of kind SmartRollupOriginate\n *\n */ class SmartRollupOriginateOperation extends Operation {\n    constructor(hash, params, source, raw, results, context){\n        super(hash, raw, results, context);\n        this.params = params;\n        this.source = source;\n    }\n    get operationResults() {\n        const smartRollupOriginateOp = Array.isArray(this.results) && this.results.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE);\n        const result = smartRollupOriginateOp && smartRollupOriginateOp.metadata && smartRollupOriginateOp.metadata.operation_result;\n        return result ? result : undefined;\n    }\n    get status() {\n        var _a, _b;\n        return (_b = (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.status) !== null && _b !== void 0 ? _b : \"unknown\";\n    }\n    get fee() {\n        return Number(this.params.fee);\n    }\n    get gasLimit() {\n        return Number(this.params.gas_limit);\n    }\n    get storageLimit() {\n        return Number(this.params.storage_limit);\n    }\n    get consumedMilliGas() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.consumed_milligas;\n    }\n    get pvmKind() {\n        return this.params.pvm_kind;\n    }\n    get kernel() {\n        return this.params.kernel;\n    }\n    get errors() {\n        var _a;\n        return (_a = this.operationResults) === null || _a === void 0 ? void 0 : _a.errors;\n    }\n}\nclass RpcContractProvider extends Provider {\n    constructor(context, estimator){\n        super(context);\n        this.estimator = estimator;\n        this.contractProviderTypeSymbol = Symbol.for(\"taquito-contract-provider-type-symbol\");\n        this.prepare = new PrepareProvider(this.context);\n    }\n    /**\n     *\n     * @description Return a well formatted json object of the contract storage\n     *\n     * @param contract contract address you want to get the storage from\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n     * @throws {@link InvalidContractAddressError}\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-contracts-contract-id-script\n     */ getStorage(contract, schema) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const contractValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateContractAddress)(contract);\n            if (contractValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidContractAddressError(contract, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(contractValidation));\n            }\n            const script = yield this.context.readProvider.getScript(contract, \"head\");\n            if (!schema) {\n                schema = script;\n            }\n            let contractSchema;\n            if (_taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema.isSchema(schema)) {\n                contractSchema = schema;\n            } else {\n                contractSchema = _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema.fromRPCResponse({\n                    script: schema\n                });\n            }\n            return contractSchema.Execute(script.storage, smartContractAbstractionSemantic(this)); // Cast into T because only the caller can know the true type of the storage\n        });\n    }\n    /**\n     *\n     * @description Return a well formatted json object of the contract big map storage\n     *\n     * @param contract contract address you want to get the storage from\n     * @param key contract big map key to fetch value from\n     * @param schema optional schema can either be the contract script rpc response or a michelson-encoder schema\n     * @throws {@link InvalidContractAddressError}\n     * @deprecated Deprecated in favor of getBigMapKeyByID\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#post-block-id-context-contracts-contract-id-big-map-get\n     */ getBigMapKey(contract, key, schema) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const contractValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateContractAddress)(contract);\n            if (contractValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidContractAddressError(contract, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(contractValidation));\n            }\n            if (!schema) {\n                schema = (yield this.rpc.getContract(contract)).script;\n            }\n            let contractSchema;\n            if (_taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema.isSchema(schema)) {\n                contractSchema = schema;\n            } else {\n                contractSchema = _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema.fromRPCResponse({\n                    script: schema\n                });\n            }\n            const encodedKey = contractSchema.EncodeBigMapKey(key);\n            const val = yield this.rpc.getBigMapKey(contract, encodedKey);\n            return contractSchema.ExecuteOnBigMapValue(val); // Cast into T because only the caller can know the true type of the storage\n        });\n    }\n    /**\n     *\n     * @description Return a well formatted json object of a big map value\n     *\n     * @param id Big Map ID\n     * @param keyToEncode key to query (will be encoded properly according to the schema)\n     * @param schema Big Map schema (can be determined using your contract type)\n     * @param block optional block level to fetch the values from\n     *\n     * @see https://tezos.gitlab.io/api/rpc.html#get-block-id-context-big-maps-big-map-id-script-expr\n     */ getBigMapKeyByID(id, keyToEncode, schema, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { key, type } = schema.EncodeBigMapKey(keyToEncode);\n            const { packed } = yield this.context.packer.packData({\n                data: key,\n                type\n            });\n            const encodedExpr = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.encodeExpr)(packed);\n            const bigMapValue = block ? yield this.context.readProvider.getBigMapValue({\n                id: id.toString(),\n                expr: encodedExpr\n            }, block) : yield this.context.readProvider.getBigMapValue({\n                id: id.toString(),\n                expr: encodedExpr\n            }, \"head\");\n            return schema.ExecuteOnBigMapValue(bigMapValue, smartContractAbstractionSemantic(this));\n        });\n    }\n    /**\n     *\n     * @description Fetch multiple values in a big map\n     * All values will be fetched on the same block level. If a block is specified in the request, the values will be fetched at it.\n     * Otherwise, a first request will be done to the node to fetch the level of the head and all values will be fetched at this level.\n     * If one of the keys does not exist in the big map, its value will be set to undefined.\n     *\n     * @param id Big Map ID\n     * @param keys Array of keys to query (will be encoded properly according to the schema)\n     * @param schema Big Map schema (can be determined using your contract type)\n     * @param block optional block level to fetch the values from\n     * @param batchSize optional batch size representing the number of requests to execute in parallel\n     * @returns A MichelsonMap containing the keys queried in the big map and their value in a well-formatted JSON object format\n     *\n     */ getBigMapKeysByID(id, keys, schema, block, batchSize = 5) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const level = yield this.getBlockForRequest(keys, block);\n            const bigMapValues = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.MichelsonMap();\n            // Execute batch of promises in series\n            let position = 0;\n            let results = [];\n            while(position < keys.length){\n                const keysBatch = keys.slice(position, position + batchSize);\n                const batch = keysBatch.map((keyToEncode)=>this.getBigMapValueOrUndefined(keyToEncode, id, schema, level));\n                results = [\n                    ...results,\n                    ...yield Promise.all(batch)\n                ];\n                position += batchSize;\n            }\n            for(let i = 0; i < results.length; i++){\n                bigMapValues.set(keys[i], results[i]);\n            }\n            return bigMapValues;\n        });\n    }\n    getBlockForRequest(keys, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return keys.length === 1 || typeof block !== \"undefined\" ? block : yield this.context.readProvider.getBlockLevel(\"head\");\n        });\n    }\n    getBigMapValueOrUndefined(keyToEncode, id, schema, level) {\n        return __awaiter(this, void 0, void 0, function*() {\n            try {\n                return yield this.getBigMapKeyByID(id, keyToEncode, schema, level);\n            } catch (ex) {\n                if (ex instanceof _taquito_http_utils__WEBPACK_IMPORTED_MODULE_1__.HttpResponseError && ex.status === _taquito_http_utils__WEBPACK_IMPORTED_MODULE_1__.STATUS_CODE.NOT_FOUND) {\n                    return;\n                } else {\n                    throw ex;\n                }\n            }\n        });\n    }\n    /**\n     *\n     * @description Return a well formatted json object of a sapling state\n     *\n     * @param id Sapling state ID\n     * @param block optional block level to fetch the value from\n     *\n     */ getSaplingDiffByID(id, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const saplingState = block ? yield this.context.readProvider.getSaplingDiffById({\n                id: id.toString()\n            }, block) : yield this.context.readProvider.getSaplingDiffById({\n                id: id.toString()\n            }, \"head\");\n            return saplingState;\n        });\n    }\n    /**\n     *\n     * @description Originate a new contract according to the script in parameters. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @warn You cannot specify storage and init at the same time (use init to pass the raw michelson representation of storage)\n     *\n     * @param OriginationOperation Originate operation parameter\n     */ originate(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const estimate = yield this.estimate(params, this.estimator.originate.bind(this.estimator));\n            const preparedOrigination = yield this.prepare.originate(Object.assign(Object.assign({}, params), estimate));\n            const content = preparedOrigination.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.ORIGINATION);\n            const forgedOrigination = yield this.forge(preparedOrigination);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(forgedOrigination);\n            return new OriginationOperation(hash, content, forgedBytes, opResponse, context, this);\n        });\n    }\n    /**\n     *\n     * @description Set the delegate for a contract. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param SetDelegate operation parameter\n     */ setDelegate(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.source);\n            if (params.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            const delegateValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.delegate) !== null && _a !== void 0 ? _a : \"\");\n            if (params.delegate && delegateValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.delegate, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(delegateValidation));\n            }\n            // Since babylon delegation source cannot smart contract\n            if (/kt1/i.test(params.source)) {\n                throw new InvalidDelegationSource(params.source);\n            }\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const sourceOrDefault = params.source || publicKeyHash;\n            const estimate = yield this.estimate(params, this.estimator.setDelegate.bind(this.estimator));\n            const preparedDelegation = yield this.prepare.delegation(Object.assign(Object.assign({}, params), estimate));\n            const content = preparedDelegation.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION);\n            const opBytes = yield this.forge(preparedDelegation);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new DelegateOperation(hash, content, sourceOrDefault, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Register the current address as delegate. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param RegisterDelegate operation parameter\n     */ registerDelegate(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const estimate = yield this.estimate(params, this.estimator.registerDelegate.bind(this.estimator));\n            const source = yield this.signer.publicKeyHash();\n            const prepared = yield this.prepare.registerDelegate(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DELEGATION);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new DelegateOperation(hash, content, source, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Transfer tz from current address to a specific address. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param Transfer operation parameter\n     */ transfer(params) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function*() {\n            const toValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.to);\n            if (toValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.to, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(toValidation));\n            }\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.source) !== null && _a !== void 0 ? _a : \"\");\n            if (params.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            if (params.amount < 0) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAmountError(params.amount.toString());\n            }\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const estimate = yield this.estimate(params, this.estimator.transfer.bind(this.estimator));\n            const source = params.source || publicKeyHash;\n            const prepared = yield this.prepare.transaction(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSACTION);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new TransactionOperation(hash, content, source, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Transfer Tickets to a smart contract address\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param TransferTicketParams operation parameter\n     */ transferTicket(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const destinationValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)(params.destination);\n            if (destinationValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.destination, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(destinationValidation));\n            }\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.source) !== null && _a !== void 0 ? _a : \"\");\n            if (params.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const source = (_b = params.source) !== null && _b !== void 0 ? _b : publicKeyHash;\n            const estimate = yield this.estimate(params, this.estimator.transferTicket.bind(this.estimator));\n            const prepared = yield this.prepare.transferTicket(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.TRANSFER_TICKET);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new TransferTicketOperation(hash, content, source, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Reveal the current address. Will throw an error if the address is already revealed.\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param RevealParams operation parameter\n     */ reveal(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const estimateReveal = yield this.estimator.reveal(params);\n            if (estimateReveal) {\n                const estimated = yield this.estimate(params, ()=>__awaiter(this, void 0, void 0, function*() {\n                        return estimateReveal;\n                    }));\n                const prepared = yield this.prepare.reveal(Object.assign(Object.assign({}, params), estimated));\n                const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REVEAL);\n                const opBytes = yield this.forge(prepared);\n                const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n                return new RevealOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n            } else {\n                throw new RevealOperationError(`The publicKeyHash '${publicKeyHash}' has already been revealed.`);\n            }\n        });\n    }\n    /**\n     *\n     * @description Register a Micheline expression in a global table of constants. Will sign and inject an operation using the current context\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params registerGlobalConstant operation parameter\n     */ registerGlobalConstant(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const estimate = yield this.estimate(params, this.estimator.registerGlobalConstant.bind(this.estimator));\n            const prepared = yield this.prepare.registerGlobalConstant(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.REGISTER_GLOBAL_CONSTANT);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new RegisterGlobalConstantOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Increase the paid storage of a smart contract\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params increasePaidStorage operation parameter\n     */ increasePaidStorage(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (params.amount < 0) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAmountError(params.amount.toString());\n            }\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const estimate = yield this.estimate(params, this.estimator.increasePaidStorage.bind(this.estimator));\n            const prepared = yield this.prepare.increasePaidStorage(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.INCREASE_PAID_STORAGE);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new IncreasePaidStorageOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Transfers the spendable balance of the delegate to destination when consensus_key is the active consensus key of delegate\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param params drainDelegate operation parameter\n     */ drainDelegate(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const prepared = yield this.prepare.drainDelegate(params);\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.DRAIN_DELEGATE);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new DrainDelegateOperation(hash, content, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Submit a ballot vote to a specified proposal\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param BallotParams Ballot operation parameter\n     */ ballot(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.source) !== null && _a !== void 0 ? _a : \"\");\n            if (params.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            const source = (_b = params.source) !== null && _b !== void 0 ? _b : publicKeyHash;\n            const prepared = yield this.prepare.ballot(Object.assign(Object.assign({}, params), {\n                source\n            }));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.BALLOT);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new BallotOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Submit or upvote a proposal during the Proposal period\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param ProposalsParams Proposals operation parameter\n     */ proposals(params) {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const sourceValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateAddress)((_a = params.source) !== null && _a !== void 0 ? _a : \"\");\n            if (params.source && sourceValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidAddressError(params.source, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(sourceValidation));\n            }\n            const source = (_b = params.source) !== null && _b !== void 0 ? _b : publicKeyHash;\n            const prepared = yield this.prepare.proposals(Object.assign(Object.assign({}, params), {\n                source\n            }));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.PROPOSALS);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new ProposalsOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description Updates the consensus key of the baker to public_key starting from the current cycle plus PRESERVED_CYCLES + 1\n     *\n     * @returns An operation handle with the result from the rpc node\n     *\n     * @param UpdateConsensusKeyParams\n     */ updateConsensusKey(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const estimate = yield this.estimate(params, this.estimator.updateConsensusKey.bind(this.estimator));\n            const prepared = yield this.prepare.updateConsensusKey(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.UPDATE_CONSENSUS_KEY);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new UpdateConsensusKeyOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     * @description Adds messages to the rollup inbox that can be executed/claimed after it gets cemented\n     * @param SmartRollupAddMessagesParams\n     * @returns An operation handle with results from the RPC node\n     */ smartRollupAddMessages(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const estimate = yield this.estimate(params, this.estimator.smartRollupAddMessages.bind(this.estimator));\n            const prepared = yield this.prepare.smartRollupAddMessages(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ADD_MESSAGES);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new SmartRollupAddMessagesOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     * @description Creates a smart rollup originate operation\n     * @param SmartRollupOriginateParams\n     * @returns An operation handle with results from the RPC node\n     */ smartRollupOriginate(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const publicKeyHash = yield this.signer.publicKeyHash();\n            const estimate = yield this.estimate(params, this.estimator.smartRollupOriginate.bind(this.estimator));\n            const prepared = yield this.prepare.smartRollupOriginate(Object.assign(Object.assign({}, params), estimate));\n            const content = prepared.opOb.contents.find((op)=>op.kind === _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.SMART_ROLLUP_ORIGINATE);\n            const opBytes = yield this.forge(prepared);\n            const { hash, context, forgedBytes, opResponse } = yield this.signAndInject(opBytes);\n            return new SmartRollupOriginateOperation(hash, content, publicKeyHash, forgedBytes, opResponse, context);\n        });\n    }\n    /**\n     *\n     * @description A failing_noop operation that is guaranteed to fail.\n     *\n     * @returns A FailingNoopOperation object representing the signed failing_noop operation\n     *\n     * @param params failingNoop operation parameter\n     */ failingNoop(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const op = {\n                kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.FAILING_NOOP,\n                arbitrary: params.arbitrary\n            };\n            const hash = yield this.context.readProvider.getBlockHash(params.basedOnBlock);\n            const forged = yield this.context.forger.forge({\n                branch: hash,\n                contents: [\n                    op\n                ]\n            });\n            const { prefixSig } = yield this.signer.sign(forged, new Uint8Array([\n                3\n            ]));\n            return {\n                signature: prefixSig,\n                bytes: forged,\n                signedContent: {\n                    branch: hash,\n                    contents: [\n                        {\n                            kind: _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.OpKind.FAILING_NOOP,\n                            arbitrary: params.arbitrary\n                        }\n                    ]\n                }\n            };\n        });\n    }\n    /**\n     *\n     * @description Create an smart contract abstraction for the address specified.\n     *\n     * @param address Smart contract address\n     * @throws {@link InvalidContractAddressError}\n     */ at(address, contractAbstractionComposer = (x)=>x) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const addressValidation = (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.validateContractAddress)(address);\n            if (addressValidation !== _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.ValidationResult.VALID) {\n                throw new _taquito_core__WEBPACK_IMPORTED_MODULE_2__.InvalidContractAddressError(address, (0,_taquito_utils__WEBPACK_IMPORTED_MODULE_4__.invalidDetail)(addressValidation));\n            }\n            const rpc = this.context.withExtensions().rpc;\n            const readProvider = this.context.withExtensions().readProvider;\n            const script = yield readProvider.getScript(address, \"head\");\n            const entrypoints = yield readProvider.getEntrypoints(address);\n            const abs = new ContractAbstraction(address, script, this, this, entrypoints, rpc, readProvider);\n            return contractAbstractionComposer(abs, this.context);\n        });\n    }\n    /**\n     *\n     * @description Batch a group of operation together. Operations will be applied in the order in which they are added to the batch\n     *\n     * @returns A batch object from which we can add more operation or send a command to execute the batch\n     *\n     * @param params List of operation to batch together\n     */ batch(params) {\n        const batch = new OperationBatch(this.context, this.estimator);\n        if (Array.isArray(params)) {\n            batch.with(params);\n        }\n        return batch;\n    }\n}\nclass MichelCodecParser {\n    constructor(context){\n        this.context = context;\n    }\n    getNextProto() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.context.proto) {\n                const nextProto = yield this.context.readProvider.getNextProtocol(\"head\");\n                this.context.proto = nextProto;\n            }\n            return this.context.proto;\n        });\n    }\n    parseScript(src) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const parser = new _taquito_michel_codec__WEBPACK_IMPORTED_MODULE_6__.Parser({\n                protocol: yield this.getNextProto()\n            });\n            return parser.parseScript(src);\n        });\n    }\n    parseMichelineExpression(src) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const parser = new _taquito_michel_codec__WEBPACK_IMPORTED_MODULE_6__.Parser({\n                protocol: yield this.getNextProto()\n            });\n            return parser.parseMichelineExpression(src);\n        });\n    }\n    parseJSON(src) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const parser = new _taquito_michel_codec__WEBPACK_IMPORTED_MODULE_6__.Parser({\n                protocol: yield this.getNextProto()\n            });\n            return parser.parseJSON(src);\n        });\n    }\n    prepareCodeOrigination(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const parsedParams = params;\n            parsedParams.code = yield this.formatCodeParam(params.code);\n            if (params.init) {\n                parsedParams.init = yield this.formatInitParam(params.init);\n            } else if (params.storage) {\n                const storageType = parsedParams.code.find((p)=>\"prim\" in p && p.prim === \"storage\");\n                if (!(storageType === null || storageType === void 0 ? void 0 : storageType.args)) {\n                    throw new InvalidCodeParameter(\"The storage section is missing from the script\", params.code);\n                }\n                const schema = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema(storageType.args[0]);\n                const globalconstantsHashAndValue = yield this.findGlobalConstantsHashAndValue(schema);\n                if (Object.keys(globalconstantsHashAndValue).length !== 0) {\n                    // If there are global constants in the storage part of the contract code,\n                    // they need to be locally expanded in order to encode the storage arguments\n                    const p = new _taquito_michel_codec__WEBPACK_IMPORTED_MODULE_6__.Parser({\n                        expandGlobalConstant: globalconstantsHashAndValue\n                    });\n                    const storageTypeNoGlobalConst = p.parseJSON(storageType.args[0]);\n                    const schemaNoGlobalConst = new _taquito_michelson_encoder__WEBPACK_IMPORTED_MODULE_3__.Schema(storageTypeNoGlobalConst);\n                    parsedParams.init = schemaNoGlobalConst.Encode(params.storage);\n                } else {\n                    parsedParams.init = schema.Encode(params.storage);\n                }\n                delete parsedParams.storage;\n            }\n            return parsedParams;\n        });\n    }\n    formatCodeParam(code) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let parsedCode;\n            if (typeof code === \"string\") {\n                const c = yield this.parseScript(code);\n                if (c === null) {\n                    throw new InvalidCodeParameter(\"Unable to parse\", code);\n                }\n                parsedCode = c;\n            } else {\n                const c = yield this.parseJSON(code);\n                const order = [\n                    \"parameter\",\n                    \"storage\",\n                    \"code\"\n                ];\n                // Ensure correct ordering for RPC\n                parsedCode = c.sort((a, b)=>order.indexOf(a.prim) - order.indexOf(b.prim));\n            }\n            return parsedCode;\n        });\n    }\n    formatInitParam(init) {\n        return __awaiter(this, void 0, void 0, function*() {\n            let parsedInit;\n            if (typeof init === \"string\") {\n                const c = yield this.parseMichelineExpression(init);\n                if (c === null) {\n                    throw new InvalidInitParameter(\"Invalid init parameter\", init);\n                }\n                parsedInit = c;\n            } else {\n                parsedInit = yield this.parseJSON(init);\n            }\n            return parsedInit;\n        });\n    }\n    findGlobalConstantsHashAndValue(schema) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const globalConstantTokens = schema.findToken(\"constant\");\n            const globalConstantsHashAndValue = {};\n            if (globalConstantTokens.length !== 0) {\n                for (const token of globalConstantTokens){\n                    const tokenArgs = token.tokenVal.args;\n                    if (tokenArgs) {\n                        const expression = tokenArgs[0];\n                        if (expression.string) {\n                            const hash = expression.string;\n                            const michelineValue = yield this.context.globalConstantsProvider.getGlobalConstantByHash(hash);\n                            Object.assign(globalConstantsHashAndValue, {\n                                [hash]: michelineValue\n                            });\n                        }\n                    }\n                }\n            }\n            return globalConstantsHashAndValue;\n        });\n    }\n}\nclass RpcPacker {\n    constructor(context){\n        this.context = context;\n    }\n    packData(data) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.context.rpc.packData(data);\n        });\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates that a global constant does not exist\n */ class GlobalConstantNotFound extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TaquitoError {\n    constructor(hash){\n        super();\n        this.hash = hash;\n        this.name = \"GlobalConstantNotFound\";\n        this.message = `Please load the value associated with the constant ${hash} using the loadGlobalConstant method of the DefaultGlobalConstantsProvider.`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates the global constant provider not being configured under TezosToolkit\n */ class UnconfiguredGlobalConstantsProviderError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TezosToolkitConfigError {\n    constructor(){\n        super();\n        this.name = \"UnconfiguredGlobalConstantsProviderError\";\n        this.message = \"No global constants provider has been configured. Please configure one by calling setGlobalConstantsProvider({globalConstantsProvider}) on your TezosToolkit instance.\";\n    }\n}\nclass NoopGlobalConstantsProvider {\n    getGlobalConstantByHash(_hash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            throw new UnconfiguredGlobalConstantsProviderError();\n        });\n    }\n}\n/**\n * @description Converts calls from TzReadProvider into calls to the wrapped RpcClient in a format it can understand.\n */ class RpcReadAdapter {\n    constructor(rpc){\n        this.rpc = rpc;\n    }\n    /**\n     * @description Access the balance of a contract.\n     * @param address address from which we want to retrieve the balance\n     * @param block from which we want to retrieve the balance\n     * @returns the balance in mutez\n     */ getBalance(address, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getBalance(address, {\n                block: String(block)\n            });\n        });\n    }\n    /**\n     * @description Access the delegate of a contract, if any.\n     * @param address contract address from which we want to retrieve the delegate (baker)\n     * @param block from which we want to retrieve the delegate\n     * @returns the public key hash of the delegate or null if no delegate\n     */ getDelegate(address, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getDelegate(address, {\n                block: String(block)\n            });\n        });\n    }\n    /**\n     * @description Access the next protocol hash\n     * @param block from which we want to retrieve the next protocol hash\n     */ getNextProtocol(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const protocols = yield this.rpc.getProtocols({\n                block: String(block)\n            });\n            return protocols.next_protocol;\n        });\n    }\n    /**\n     * @description Access protocol constants used in Taquito\n     * @param block from which we want to retrieve the constants\n     */ getProtocolConstants(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { time_between_blocks, minimal_block_delay, hard_gas_limit_per_operation, hard_gas_limit_per_block, hard_storage_limit_per_operation, cost_per_byte, smart_rollup_origination_size } = yield this.rpc.getConstants({\n                block: String(block)\n            });\n            return {\n                time_between_blocks,\n                minimal_block_delay,\n                hard_gas_limit_per_operation,\n                hard_gas_limit_per_block,\n                hard_storage_limit_per_operation,\n                cost_per_byte,\n                smart_rollup_origination_size\n            };\n        });\n    }\n    /**\n     * @description Access the script (code and storage) of a smart contract\n     * @param contract contract address from which we want to retrieve the script\n     * @param block from which we want to retrieve the storage value\n     * @returns Note: The code must be in the JSON format and not contain global constant\n     */ getScript(contract, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { script } = yield this.rpc.getContract(contract, {\n                block: String(block)\n            });\n            return script;\n        });\n    }\n    /**\n     * @description Access the storage value of a contract\n     * @param contract contract address from which we want to retrieve the storage\n     * @param block from which we want to retrieve the storage value\n     */ getStorage(contract, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getStorage(contract, {\n                block: String(block)\n            });\n        });\n    }\n    /**\n     * @description Access the block hash\n     */ getBlockHash(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { hash } = yield this.rpc.getBlockHeader({\n                block: String(block)\n            });\n            return hash;\n        });\n    }\n    /**\n     * @description Access the block level\n     */ getBlockLevel(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { level } = yield this.rpc.getBlockHeader({\n                block: String(block)\n            });\n            return level;\n        });\n    }\n    /**\n     * @description Access the counter of an address\n     * @param pkh from which we want to retrieve the counter\n     * @param block from which we want to retrieve the counter\n     */ getCounter(pkh, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { counter } = yield this.rpc.getContract(pkh, {\n                block: String(block)\n            });\n            return counter || \"0\";\n        });\n    }\n    /**\n     * @description Access the timestamp of a block\n     * @param block from which we want to retrieve the timestamp\n     * @returns date ISO format zero UTC offset (\"2022-01-19T22:37:07Z\")\n     */ getBlockTimestamp(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { timestamp } = yield this.rpc.getBlockHeader({\n                block: String(block)\n            });\n            return timestamp;\n        });\n    }\n    /**\n     * @description Access the value associated with a key in a big map.\n     * @param bigMapQuery Big Map ID and Expression hash to query (A b58check encoded Blake2b hash of the expression)\n     * @param block from which we want to retrieve the big map value\n     */ getBigMapValue(bigMapQuery, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getBigMapExpr(bigMapQuery.id, bigMapQuery.expr, {\n                block: String(block)\n            });\n        });\n    }\n    /**\n     * @description Access the value associated with a sapling state ID.\n     * @param id Sapling state ID\n     * @param block from which we want to retrieve the sapling state\n     */ getSaplingDiffById(saplingStateQuery, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getSaplingDiffById(saplingStateQuery.id, {\n                block: String(block)\n            });\n        });\n    }\n    /**\n     * @description Access the sapling state of a smart contract.\n     * @param contractAddress The address of the smart contract\n     * @param block The block you want to retrieve the sapling state from\n     */ getSaplingDiffByContract(contractAddress, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getSaplingDiffByContract(contractAddress, {\n                block: String(block)\n            });\n        });\n    }\n    /**\n     * @description Return the list of entrypoints of the contract\n     * @param contract address of the contract we want to get the entrypoints of\n     */ getEntrypoints(contract) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getEntrypoints(contract);\n        });\n    }\n    /**\n     * @description Access the chain id\n     */ getChainId() {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getChainId();\n        });\n    }\n    /**\n     * @description Indicate if an account is revealed\n     * @param publicKeyHash of the account\n     * @param block from which we want to know if the account is revealed\n     */ isAccountRevealed(publicKeyHash, block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const manager = yield this.rpc.getManagerKey(publicKeyHash, {\n                block: String(block)\n            });\n            const haveManager = manager && typeof manager === \"object\" ? !!manager.key : !!manager;\n            return haveManager;\n        });\n    }\n    /**\n     * @description Return all the information about a block\n     * @param block from which we want to retrieve the information\n     */ getBlock(block) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return this.rpc.getBlock({\n                block: String(block)\n            });\n        });\n    }\n    /**\n     * @description Return a list of the ancestors of the given block which, if referred to as the branch in an operation header, are recent enough for that operation to be included in the current block.\n     * @param block from which we want to retrieve the information\n     */ getLiveBlocks(block) {\n        return this.rpc.getLiveBlocks({\n            block: String(block)\n        });\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an unsupported event being passed or used\n */ class UnsupportedEventError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(type){\n        super();\n        this.type = type;\n        this.name = \"UnsupportedEventError\";\n        this.message = `Unsupported event type \"${type}\" expecting one of the \"data\", \"error\", or \"close\".`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates an invalid filter expression being passed or used\n */ class InvalidFilterExpressionError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.ParameterValidationError {\n    constructor(invalidExpression){\n        super();\n        this.invalidExpression = invalidExpression;\n        this.name = \"InvalidFilterExpressionError\";\n        this.message = `Invalid filter expression expecting the object to contain either and/or property`;\n    }\n}\nconst opHashFilter = (op, filter)=>op.hash === filter.opHash;\nconst sourceFilter = (x, filter)=>{\n    switch(x.kind){\n        case \"attestation\":\n            return \"metadata\" in x && x.metadata.delegate === filter.source;\n        case \"endorsement\":\n            return \"metadata\" in x && x.metadata.delegate === filter.source;\n        case \"activate_account\":\n            return \"metadata\" in x && x.pkh === filter.source;\n        default:\n            return \"source\" in x && x.source === filter.source;\n    }\n};\nconst kindFilter = (x, filter)=>\"kind\" in x && x.kind === filter.kind;\nconst destinationFilter = (x, filter)=>{\n    switch(x.kind){\n        case \"delegation\":\n            return x.delegate === filter.destination;\n        case \"origination\":\n            if (\"metadata\" in x && \"operation_result\" in x.metadata && \"originated_contracts\" in x.metadata.operation_result && Array.isArray(x.metadata.operation_result.originated_contracts)) {\n                return x.metadata.operation_result.originated_contracts.some((contract)=>contract === filter.destination);\n            }\n            break;\n        case \"transaction\":\n            return x.destination === filter.destination;\n        default:\n            return false;\n    }\n};\nconst eventFilter = (result, address, tag, excludeFailedOperations)=>{\n    if (result.kind !== \"event\") {\n        return false;\n    }\n    if (tag && result.tag !== tag) {\n        return false;\n    }\n    if (address && result.source !== address) {\n        return false;\n    }\n    if (excludeFailedOperations && result.result.status !== \"applied\") {\n        return false;\n    }\n    return true;\n};\nconst evaluateOpFilter = (op, filter)=>{\n    if (\"opHash\" in filter) {\n        return opHashFilter(op, filter);\n    } else if (\"source\" in filter) {\n        return sourceFilter(op, filter);\n    } else if (\"kind\" in filter) {\n        return kindFilter(op, filter);\n    } else if (\"destination\" in filter) {\n        return destinationFilter(op, filter);\n    }\n    return false;\n};\nconst evaluateExpression = (op, exp)=>{\n    if (Array.isArray(exp.and)) {\n        return exp.and.every((x)=>evaluateFilter(op, x));\n    } else if (Array.isArray(exp.or)) {\n        return exp.or.some((x)=>evaluateFilter(op, x));\n    } else {\n        throw new InvalidFilterExpressionError(exp);\n    }\n};\nconst evaluateFilter = (op, filter)=>{\n    const filters = [];\n    if (!Array.isArray(filter)) {\n        filters.push(filter);\n    } else {\n        filters.push(...filter);\n    }\n    return filters.every((filterOrExp)=>{\n        if (\"and\" in filterOrExp || \"or\" in filterOrExp) {\n            return evaluateExpression(op, filterOrExp);\n        } else {\n            return evaluateOpFilter(op, filterOrExp);\n        }\n    });\n};\n/* eslint-disable no-dupe-class-members */ class ObservableSubscription {\n    constructor(obs, shouldRetry = false, operatorFunction = (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.retry)()){\n        this.shouldRetry = shouldRetry;\n        this.operatorFunction = operatorFunction;\n        this.errorListeners = [];\n        this.messageListeners = [];\n        this.closeListeners = [];\n        this.completed$ = new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_20__.Subject();\n        obs.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.takeUntil)(this.completed$), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.tap)((data)=>{\n            this.call(this.messageListeners, data);\n        }, (error)=>{\n            this.call(this.errorListeners, error);\n        }, ()=>{\n            this.call(this.closeListeners);\n        }), this.shouldRetry ? operatorFunction : (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.tap)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.catchError)(()=>_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_21__.NEVER)).subscribe();\n    }\n    call(listeners, value) {\n        for (const l of listeners){\n            try {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                l(value);\n            } catch (ex) {\n                console.error(ex);\n            }\n        }\n    }\n    remove(listeners, value) {\n        const idx = listeners.indexOf(value);\n        if (idx !== -1) {\n            listeners.splice(idx, 1);\n        }\n    }\n    on(type, cb) {\n        switch(type){\n            case \"data\":\n                this.messageListeners.push(cb);\n                break;\n            case \"error\":\n                this.errorListeners.push(cb);\n                break;\n            case \"close\":\n                this.closeListeners.push(cb);\n                break;\n            default:\n                throw new UnsupportedEventError(type);\n        }\n    }\n    off(type, cb) {\n        switch(type){\n            case \"data\":\n                this.remove(this.messageListeners, cb);\n                break;\n            case \"error\":\n                this.remove(this.errorListeners, cb);\n                break;\n            case \"close\":\n                this.remove(this.closeListeners, cb);\n                break;\n            default:\n                throw new UnsupportedEventError(type);\n        }\n    }\n    close() {\n        this.completed$.next();\n    }\n}\nconst defaultConfigStreamer = {\n    shouldObservableSubscriptionRetry: false,\n    observableSubscriptionRetryFunction: (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.retry)()\n};\nconst getLastBlock = (context)=>{\n    return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.from)(context.rpc.getBlock()).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.first)());\n};\nconst applyFilter = (filter)=>(0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.concatMap)((block)=>{\n        return new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable((sub)=>{\n            for (const ops of block.operations){\n                for (const op of ops){\n                    for (const content of op.contents){\n                        if (evaluateFilter(Object.assign({\n                            hash: op.hash\n                        }, content), filter)) {\n                            sub.next(Object.assign({\n                                hash: op.hash\n                            }, content));\n                        }\n                    }\n                }\n            }\n            sub.complete();\n        });\n    });\nconst applyEventFilter = (filter)=>(0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.concatMap)((block)=>{\n        return new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_8__.Observable((sub)=>{\n            for (const ops of block.operations){\n                for (const op of ops){\n                    for (const content of op.contents){\n                        const tx = content;\n                        const internalOpResults = tx.metadata.internal_operation_results;\n                        if (internalOpResults) {\n                            for (const event of internalOpResults){\n                                if (eventFilter(event, filter === null || filter === void 0 ? void 0 : filter.address, filter === null || filter === void 0 ? void 0 : filter.tag, filter === null || filter === void 0 ? void 0 : filter.excludeFailedOperations)) {\n                                    sub.next(Object.assign({\n                                        opHash: op.hash,\n                                        blockHash: block.hash,\n                                        level: block.header.level\n                                    }, event));\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            sub.complete();\n        });\n    });\nclass PollingSubscribeProvider {\n    constructor(context, config = {}){\n        this.context = context;\n        this._config$ = new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_11__.BehaviorSubject(Object.assign(Object.assign({}, defaultConfigStreamer), config));\n        this.timer$ = this._config$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.pluck)(\"pollingIntervalMilliseconds\"), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)((pollingIntervalMilliseconds)=>{\n            if (!pollingIntervalMilliseconds) {\n                return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_18__.from)(this.getConfirmationPollingInterval()).pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)((interval)=>{\n                    return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.timer)(0, interval);\n                }));\n            } else {\n                return (0,_barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_22__.timer)(0, pollingIntervalMilliseconds);\n            }\n        }));\n        this.newBlock$ = this.timer$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.switchMap)(()=>getLastBlock(this.context)), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.distinctUntilKeyChanged)(\"hash\"), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.publish)(), (0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.refCount)());\n    }\n    get config() {\n        return this._config$.getValue();\n    }\n    getConfirmationPollingInterval() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.config.pollingIntervalMilliseconds) {\n                const defaultIntervalTestnetsMainnet = 5000;\n                const defaultIntervalSandbox = 1000;\n                try {\n                    const constants = yield this.context.readProvider.getProtocolConstants(\"head\");\n                    const blockTime = constants.minimal_block_delay ? constants.minimal_block_delay.multipliedBy(1000) : constants.time_between_blocks ? constants.time_between_blocks[0].multipliedBy(1000) : new bignumber_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"](defaultIntervalTestnetsMainnet);\n                    const confirmationPollingInterval = blockTime.dividedBy(3);\n                    this.config.pollingIntervalMilliseconds = confirmationPollingInterval.toNumber() === 0 ? defaultIntervalSandbox : confirmationPollingInterval.toNumber();\n                } catch (exception) {\n                    return defaultIntervalTestnetsMainnet;\n                }\n            }\n            return this.config.pollingIntervalMilliseconds;\n        });\n    }\n    subscribeBlock(_filter) {\n        return new ObservableSubscription(this.newBlock$, this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);\n    }\n    subscribe(_filter) {\n        return new ObservableSubscription(this.newBlock$.pipe((0,rxjs_operators__WEBPACK_IMPORTED_MODULE_10__.pluck)(\"hash\")), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);\n    }\n    subscribeOperation(filter) {\n        return new ObservableSubscription(this.newBlock$.pipe(applyFilter(filter)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);\n    }\n    subscribeEvent(eventFilter) {\n        return new ObservableSubscription(this.newBlock$.pipe(applyEventFilter(eventFilter)), this.config.shouldObservableSubscriptionRetry, this.config.observableSubscriptionRetryFunction);\n    }\n}\nclass TaquitoLocalForger {\n    constructor(context){\n        this.context = context;\n    }\n    getNextProto() {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (!this.context.proto) {\n                const nextProto = yield this.context.readProvider.getNextProtocol(\"head\");\n                this.context.proto = nextProto;\n            }\n            return this.context.proto;\n        });\n    }\n    forge({ branch, contents }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const forger = new _taquito_local_forging__WEBPACK_IMPORTED_MODULE_7__.LocalForger((yield this.getNextProto()));\n            return forger.forge({\n                branch,\n                contents\n            });\n        });\n    }\n}\nconst defaultConfigConfirmation = {\n    defaultConfirmationCount: 1,\n    confirmationPollingTimeoutSecond: 180\n};\n/**\n * @description Encapsulate common service used throughout different part of the library\n */ class Context {\n    constructor(_rpc, _signer = new NoopSigner(), _proto, _config = new _barrel_optimize_names_BehaviorSubject_EMPTY_NEVER_Observable_ReplaySubject_Subject_combineLatest_concat_defer_from_of_range_throwError_timer_rxjs__WEBPACK_IMPORTED_MODULE_11__.BehaviorSubject(Object.assign({}, defaultConfigConfirmation)), forger, injector, packer, wallet, parser, globalConstantsProvider, readProvider, stream){\n        this._rpc = _rpc;\n        this._signer = _signer;\n        this._proto = _proto;\n        this._config = _config;\n        this.providerDecorator = [];\n        this.tz = new RpcTzProvider(this);\n        this.estimate = new RPCEstimateProvider(this);\n        this.contract = new RpcContractProvider(this, this.estimate);\n        this.prepare = new PrepareProvider(this);\n        this.batch = new RPCBatchProvider(this, this.estimate);\n        this.wallet = new Wallet(this);\n        /**\n         * @description Applies the decorators on a cloned instance of the context and returned this cloned instance.\n         * The decorators are functions that inject logic into the context.\n         * They are provided by the extensions set on the TezosToolkit by calling the registerProviderDecorator method.\n         */ this.withExtensions = ()=>{\n            let clonedContext = this.clone();\n            this.providerDecorator.forEach((decorator)=>{\n                clonedContext = decorator(clonedContext);\n            });\n            return clonedContext;\n        };\n        if (typeof this._rpc === \"string\") {\n            this._rpcClient = new _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.RpcClient(this._rpc);\n        } else {\n            this._rpcClient = this._rpc;\n        }\n        this._forger = forger ? forger : new TaquitoLocalForger(this);\n        this._injector = injector ? injector : new RpcInjector(this);\n        this.operationFactory = new OperationFactory(this);\n        this._walletProvider = wallet ? wallet : new LegacyWalletProvider(this);\n        this._parser = parser ? parser : new MichelCodecParser(this);\n        this._packer = packer ? packer : new RpcPacker(this);\n        this._globalConstantsProvider = globalConstantsProvider ? globalConstantsProvider : new NoopGlobalConstantsProvider();\n        this._readProvider = readProvider ? readProvider : new RpcReadAdapter(this._rpcClient);\n        this._stream = stream ? stream : new PollingSubscribeProvider(this);\n    }\n    get config() {\n        return this._config.getValue();\n    }\n    set config(value) {\n        this._config.next(Object.assign({}, value));\n    }\n    setPartialConfig(value) {\n        this._config.next(Object.assign(Object.assign({}, this._config.getValue()), value));\n    }\n    get rpc() {\n        return this._rpcClient;\n    }\n    set rpc(value) {\n        this._rpcClient = value;\n    }\n    get injector() {\n        return this._injector;\n    }\n    set injector(value) {\n        this._injector = value;\n    }\n    get forger() {\n        return this._forger;\n    }\n    set forger(value) {\n        this._forger = value;\n    }\n    get signer() {\n        return this._signer;\n    }\n    set signer(value) {\n        this._signer = value;\n    }\n    get walletProvider() {\n        return this._walletProvider;\n    }\n    set walletProvider(value) {\n        this._walletProvider = value;\n    }\n    set proto(value) {\n        this._proto = value;\n    }\n    get proto() {\n        return this._proto;\n    }\n    get parser() {\n        return this._parser;\n    }\n    set parser(value) {\n        this._parser = value;\n    }\n    get packer() {\n        return this._packer;\n    }\n    set packer(value) {\n        this._packer = value;\n    }\n    get globalConstantsProvider() {\n        return this._globalConstantsProvider;\n    }\n    set globalConstantsProvider(value) {\n        this._globalConstantsProvider = value;\n    }\n    get readProvider() {\n        return this._readProvider;\n    }\n    set readProvider(value) {\n        this._readProvider = value;\n    }\n    get stream() {\n        return this._stream;\n    }\n    set stream(value) {\n        this._stream = value;\n    }\n    isAnyProtocolActive(protocol = []) {\n        return __awaiter(this, void 0, void 0, function*() {\n            if (this._proto) {\n                return protocol.includes(this._proto);\n            } else {\n                const next_protocol = yield this.readProvider.getNextProtocol(\"head\");\n                return protocol.includes(next_protocol);\n            }\n        });\n    }\n    isAnySignerConfigured() {\n        return !(this.signer instanceof NoopSigner);\n    }\n    /**\n     * @description Create a copy of the current context. Useful when you have long running operation and you do not want a context change to affect the operation\n     */ clone() {\n        return new Context(this.rpc, this.signer, this.proto, this._config, this.forger, this._injector, this.packer, this._walletProvider, this._parser, this._globalConstantsProvider, this._readProvider, this._stream);\n    }\n    /**\n     * @description Allows extensions set on the TezosToolkit to inject logic into the context\n     */ registerProviderDecorator(fx) {\n        this.providerDecorator.push(fx);\n    }\n}\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\n/**\n *  @category Error\n *  @description Error that indicates CompositeForger.forge() results doesn't match each other\n */ class ForgingMismatchError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TaquitoError {\n    constructor(results){\n        super();\n        this.results = results;\n        this.name = \"ForgingMismatchError\";\n        this.message = `Forging mismatch error`;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates no forger has been configured for CompositeForger\n */ class UnspecifiedForgerError extends _taquito_core__WEBPACK_IMPORTED_MODULE_2__.TezosToolkitConfigError {\n    constructor(){\n        super();\n        this.name = \"UnspecifiedForgerError\";\n        this.message = \"No forger has been configured. Please configure new CompositeForger([rpcForger, localForger]) with your TezosToolkit instance.\";\n    }\n}\nclass CompositeForger {\n    constructor(forgers){\n        this.forgers = forgers;\n        if (forgers.length === 0) {\n            throw new UnspecifiedForgerError();\n        }\n    }\n    forge({ branch, contents }) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const results = yield Promise.all(this.forgers.map((forger)=>{\n                return forger.forge({\n                    branch,\n                    contents\n                });\n            }));\n            if (results.length === 0) {\n                throw new UnspecifiedForgerError();\n            }\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            let lastResult = results.pop(); // Assumed to be more than one since we\n            while(results.length){\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const currentResult = results.pop();\n                if (currentResult !== lastResult) {\n                    throw new ForgingMismatchError([\n                        lastResult,\n                        currentResult\n                    ]);\n                }\n                lastResult = currentResult;\n            }\n            return lastResult;\n        });\n    }\n}\nclass RpcForger {\n    constructor(context){\n        this.context = context;\n    }\n    forge({ branch, contents }) {\n        return this.context.rpc.forgeOperations({\n            branch,\n            contents\n        });\n    }\n}\nclass NoopParser {\n    prepareCodeOrigination(params) {\n        return __awaiter(this, void 0, void 0, function*() {\n            return params;\n        });\n    }\n}\nclass MichelCodecPacker {\n    packData(data) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const { bytes } = (0,_taquito_michel_codec__WEBPACK_IMPORTED_MODULE_6__.packDataBytes)(data.data, data.type);\n            return {\n                packed: bytes\n            };\n        });\n    }\n}\nclass DefaultGlobalConstantsProvider {\n    constructor(){\n        this._globalConstantsLibrary = {};\n    }\n    /**\n     *\n     * @description Allows to load global constant hashes and their corresponding Michelson JSON values\n     */ loadGlobalConstant(globalConstant) {\n        for(const hash in globalConstant){\n            Object.assign(this._globalConstantsLibrary, {\n                [hash]: globalConstant[hash]\n            });\n        }\n    }\n    /**\n     *\n     * @description Retrieve the Michelson value of a global constant based on its hash\n     *\n     * @param hash a string representing the global constant hash\n     * @returns Expr, the JSON Michelson value\n     */ getGlobalConstantByHash(hash) {\n        return __awaiter(this, void 0, void 0, function*() {\n            const value = this._globalConstantsLibrary[hash];\n            if (!value) {\n                throw new GlobalConstantNotFound(hash);\n            }\n            return value;\n        });\n    }\n}\n/**\n * @packageDocumentation\n * @module @taquito/taquito\n */ /**\n * @description Facade class that surfaces all of the libraries capability and allow it's configuration\n *\n * @param _rpc The RPC server to use\n */ class TezosToolkit {\n    constructor(_rpc){\n        this._rpc = _rpc;\n        this._options = {};\n        this.format = _taquito_utils__WEBPACK_IMPORTED_MODULE_4__.format;\n        if (typeof this._rpc === \"string\") {\n            this._rpcClient = new _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.RpcClient(this._rpc);\n        } else {\n            this._rpcClient = this._rpc;\n        }\n        this._context = new Context(_rpc);\n        this._wallet = new Wallet(this._context);\n        this.setProvider({\n            rpc: this._rpcClient\n        });\n        this.batch = this._context.batch.batch.bind(this._context.batch);\n    }\n    /**\n     * @description Sets configuration on the Tezos Taquito instance. Allows user to choose which signer, rpc client, rpc url, forger and so forth\n     *\n     * @param options rpc url or rpcClient to use to interact with the Tezos network\n     *\n     * @example Tezos.setProvider({rpc: 'https://mainnet.ecadinfra.com/', signer: new InMemorySigner.fromSecretKey(“edsk...”)})\n     * @example Tezos.setProvider({ config: { confirmationPollingTimeoutSecond: 300 }})\n     *\n     */ setProvider({ rpc, stream, signer, protocol, config, forger, wallet, packer, globalConstantsProvider, readProvider, parserProvider, injectorProvider }) {\n        this.setRpcProvider(rpc);\n        this.setStreamProvider(stream);\n        this.setSignerProvider(signer);\n        this.setForgerProvider(forger);\n        this.setWalletProvider(wallet);\n        this.setPackerProvider(packer);\n        this.setGlobalConstantsProvider(globalConstantsProvider);\n        this.setReadProvider(readProvider);\n        this.setParserProvider(parserProvider);\n        this.setInjectorProvider(injectorProvider);\n        this._context.proto = protocol;\n        if (config) {\n            this._context.setPartialConfig(config);\n        }\n    }\n    /**\n     * @description Sets signer provider on the Tezos Taquito instance.\n     *\n     * @param options signer to use to interact with the Tezos network\n     *\n     * @example Tezos.setSignerProvider(new InMemorySigner.fromSecretKey('edsk...'))\n     *\n     */ setSignerProvider(signer) {\n        if (!this._options.signer && typeof signer === \"undefined\") {\n            this._context.signer = new NoopSigner();\n            this._options.signer = signer;\n        } else if (typeof signer !== \"undefined\") {\n            this._context.signer = signer;\n            this._options.signer = signer;\n        }\n    }\n    /**\n     * @description Sets rpc provider on the Tezos Taquito instance\n     *\n     * @param options rpc url or rpcClient to use to interact with the Tezos network\n     *\n     * @example Tezos.setRpcProvider('https://mainnet.ecadinfra.com/')\n     *\n     */ setRpcProvider(rpc) {\n        if (typeof rpc === \"string\") {\n            this._rpcClient = new _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.RpcClient(rpc);\n        } else if (rpc === undefined) ;\n        else {\n            this._rpcClient = rpc;\n        }\n        this._options.rpc = this._rpcClient;\n        this._context.rpc = this._rpcClient;\n    }\n    /**\n     * @description Sets forger provider on the Tezos Taquito instance\n     * The `LocalForger` from `@taquito/local-forging` is set by default.\n     *\n     * @param options forger to use to interact with the Tezos network\n     *\n     * @example Tezos.setForgerProvider(this.getFactory(RpcForger)())\n     *\n     */ setForgerProvider(forger) {\n        if (typeof forger !== \"undefined\") {\n            this._options.forger = forger;\n            this._context.forger = forger;\n        } else if (this._options.forger === undefined) {\n            const f = this.getFactory(TaquitoLocalForger)();\n            this._options.forger = f;\n            this._context.forger = f;\n        }\n    }\n    /**\n     * @description Sets stream provider on the Tezos Taquito instance\n     *\n     * @param options stream to use to interact with the Tezos network\n     *\n     * @example Tezos.setStreamProvider(...)\n     *\n     */ setStreamProvider(stream) {\n        if (typeof stream === \"string\") {\n            const s = new PollingSubscribeProvider(new Context(new _taquito_rpc__WEBPACK_IMPORTED_MODULE_0__.RpcClient(stream)));\n            this._options.stream = s;\n            this._context.stream = s;\n        } else if (typeof stream !== \"undefined\") {\n            this._options.stream = stream;\n            this._context.stream = stream;\n        } else if (this._options.stream === undefined) {\n            const s = this.getFactory(PollingSubscribeProvider)();\n            this._options.stream = s;\n            this._context.stream = s;\n        }\n    }\n    /**\n     * @description Sets wallet provider on the Tezos Taquito instance\n     *\n     * @param options wallet to use to interact with the Tezos network\n     *\n     * @example Tezos.setWalletProvider(...)\n     *\n     */ setWalletProvider(wallet) {\n        if (!this._options.wallet && typeof wallet === \"undefined\") {\n            const w = this.getFactory(LegacyWalletProvider)();\n            this._options.wallet = w;\n            this._context.walletProvider = w;\n        } else if (typeof wallet !== \"undefined\") {\n            this._options.wallet = wallet;\n            this._context.walletProvider = wallet;\n        }\n    }\n    /**\n     * @description Sets Packer provider on the Tezos Taquito instance\n     *\n     * @param options packer to use to interact with the Tezos network\n     *\n     * @example Tezos.setPackerProvider(new MichelCodecPacker())\n     *\n     */ setPackerProvider(packer) {\n        if (!this._options.packer && typeof packer === \"undefined\") {\n            const p = this.getFactory(RpcPacker)();\n            this._context.packer = p;\n            this._options.packer = p;\n        } else if (typeof packer !== \"undefined\") {\n            this._context.packer = packer;\n            this._options.packer = packer;\n        }\n    }\n    /**\n     * @description Sets global constants provider on the Tezos Taquito instance\n     *\n     * @param options globalConstantsProvider to use to interact with the Tezos network\n     *\n     * @example\n     * ```\n     * const globalConst = new DefaultGlobalConstantsProvider();\n     * globalConst.loadGlobalConstant({\n     *  \"expruu5BTdW7ajqJ9XPTF3kgcV78pRiaBW3Gq31mgp3WSYjjUBYxre\": { prim: \"int\" },\n     *  // ...\n     * })\n     * Tezos.setGlobalConstantsProvider(globalConst);\n     * ```\n     *\n     */ setGlobalConstantsProvider(globalConstantsProvider) {\n        if (!this._options.globalConstantsProvider && typeof globalConstantsProvider === \"undefined\") {\n            const g = new NoopGlobalConstantsProvider();\n            this._context.globalConstantsProvider = g;\n            this._options.globalConstantsProvider = g;\n        } else if (typeof globalConstantsProvider !== \"undefined\") {\n            this._context.globalConstantsProvider = globalConstantsProvider;\n            this._options.globalConstantsProvider = globalConstantsProvider;\n        }\n    }\n    /**\n     * @description Sets read provider on the Tezos Taquito instance\n     * By default reads are done from the RPC usign the RpcReadAdapter class, this can be overridden to read from an indexer that implements the TzReadProvider interface\n     *\n     * @param options TzReadProvider to use to interact with the Tezos network\n     *\n     */ setReadProvider(readProvider) {\n        const readP = readProvider ? readProvider : new RpcReadAdapter(this._context.rpc);\n        this._options.readProvider = readP;\n        this._context.readProvider = readP;\n    }\n    /**\n     * @description Sets parser provider on the Tezos Taquito instance\n     *\n     * @param options parserProvider to use to interact with the Tezos network\n     *\n     */ setParserProvider(parserProvider) {\n        if (!this._options.parserProvider && typeof parserProvider === \"undefined\") {\n            const p = new MichelCodecParser(this._context);\n            this._context.parser = p;\n            this._options.parserProvider = p;\n        } else if (typeof parserProvider !== \"undefined\") {\n            this._context.parser = parserProvider;\n            this._options.parserProvider = parserProvider;\n        }\n    }\n    /**\n     * @description Sets injector provider on the Tezos Taquito instance\n     *\n     * @param options Injector to use to interact with the Tezos network by default RpcInjector\n     *\n     */ setInjectorProvider(injectorProvider) {\n        if (!this._options.injectorProvider && typeof injectorProvider === \"undefined\") {\n            const i = new RpcInjector(this._context);\n            this._context.injector = i;\n            this._options.injectorProvider = i;\n        } else if (typeof injectorProvider !== \"undefined\") {\n            this._context.injector = injectorProvider;\n            this._options.injectorProvider = injectorProvider;\n        }\n    }\n    /**\n     * @description Provide access to tezos account management\n     */ get tz() {\n        return this._context.tz;\n    }\n    /**\n     * @description Provide access to smart contract utilities\n     */ get contract() {\n        return this._context.contract;\n    }\n    /**\n     * @description Provide access to tezos operation preparation utilities\n     */ get prepare() {\n        return this._context.prepare;\n    }\n    get wallet() {\n        return this._wallet;\n    }\n    get operation() {\n        return this._context.operationFactory;\n    }\n    /**\n     * @description Provide access to operation estimation utilities\n     */ get estimate() {\n        return this._context.estimate;\n    }\n    /**\n     * @description Provide access to streaming utilities backed by an streamer implementation\n     */ get stream() {\n        return this._context.stream;\n    }\n    /**\n     * @description Provide access to the currently used rpc client\n     */ get rpc() {\n        return this._context.rpc;\n    }\n    /**\n     * @description Provide access to the currently used signer\n     */ get signer() {\n        return this._context.signer;\n    }\n    /**\n     * @description Provide access to the currently used globalConstantsProvider\n     */ get globalConstants() {\n        return this._context.globalConstantsProvider;\n    }\n    /**\n     * @description Allow to add a module to the TezosToolkit instance. This method adds the appropriate Providers(s) required by the module to the internal context.\n     *\n     * @param module extension to add to the TezosToolkit instance\n     *\n     * @example Tezos.addExtension(new Tzip16Module());\n     */ addExtension(module) {\n        if (Array.isArray(module)) {\n            module.forEach((extension)=>extension.configureContext(this._context));\n        } else {\n            module.configureContext(this._context);\n        }\n    }\n    getFactory(ctor) {\n        return (...args)=>{\n            return new ctor(this._context, ...args);\n        };\n    }\n    /**\n     * @description Gets an object containing the version of Taquito library and git sha of the commit this library is compiled from\n     */ getVersionInfo() {\n        return VERSION;\n    }\n}\n //# sourceMappingURL=taquito.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vdGFxdWl0by9kaXN0L3RhcXVpdG8uZXM2LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBaUQ7QUFDWDtBQUMrQjtBQUM2VDtBQUN2TztBQUNpRztBQUNoSjtBQUN2QztBQUNzTDtBQUN4TDtBQUNMO0FBQ1Q7QUFFckQ7Ozs7Ozs7Ozs7Ozs7OEVBYThFLEdBQzlFLG9EQUFvRCxHQUdwRCxTQUFTNEUsT0FBT0MsQ0FBQyxFQUFFQyxDQUFDO0lBQ2hCLElBQUlDLElBQUksQ0FBQztJQUNULElBQUssSUFBSUMsS0FBS0gsRUFBRyxJQUFJSSxPQUFPQyxTQUFTLENBQUNDLGNBQWMsQ0FBQ0MsSUFBSSxDQUFDUCxHQUFHRyxNQUFNRixFQUFFTyxPQUFPLENBQUNMLEtBQUssR0FDOUVELENBQUMsQ0FBQ0MsRUFBRSxHQUFHSCxDQUFDLENBQUNHLEVBQUU7SUFDZixJQUFJSCxLQUFLLFFBQVEsT0FBT0ksT0FBT0sscUJBQXFCLEtBQUssWUFDckQsSUFBSyxJQUFJQyxJQUFJLEdBQUdQLElBQUlDLE9BQU9LLHFCQUFxQixDQUFDVCxJQUFJVSxJQUFJUCxFQUFFUSxNQUFNLEVBQUVELElBQUs7UUFDcEUsSUFBSVQsRUFBRU8sT0FBTyxDQUFDTCxDQUFDLENBQUNPLEVBQUUsSUFBSSxLQUFLTixPQUFPQyxTQUFTLENBQUNPLG9CQUFvQixDQUFDTCxJQUFJLENBQUNQLEdBQUdHLENBQUMsQ0FBQ08sRUFBRSxHQUN6RVIsQ0FBQyxDQUFDQyxDQUFDLENBQUNPLEVBQUUsQ0FBQyxHQUFHVixDQUFDLENBQUNHLENBQUMsQ0FBQ08sRUFBRSxDQUFDO0lBQ3pCO0lBQ0osT0FBT1I7QUFDWDtBQUVBLFNBQVNXLFVBQVVDLE9BQU8sRUFBRUMsVUFB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InNvdXJjZXMiOlsid2VicGFjazovL3B3cnBlcmtzLy4vbm9kZV9tb2R1bGVzL0B0YXF1aXRvL3RhcXVpdG8vZGlzdC90YXF1aXRvLmVzNi5qcz80YWFhIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE9wS2luZCwgUnBjQ2xpZW50IH0gZnJvbSAnQHRhcXVpdG8vcnBjJztcbmV4cG9ydCB7IE9wS2luZCB9IGZyb20gJ0B0YXF1aXRvL3JwYyc7XG5pbXBvcnQgeyBIdHRwUmVzcG9uc2VFcnJvciwgU1RBVFVTX0NPREUgfSBmcm9tICdAdGFxdWl0by9odHRwLXV0aWxzJztcbmltcG9ydCB7IFRlem9zVG9vbGtpdENvbmZpZ0Vycm9yLCBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3IsIFJwY0Vycm9yLCBUYXF1aXRvRXJyb3IsIE5ldHdvcmtFcnJvciwgSW52YWxpZE9wZXJhdGlvbkhhc2hFcnJvciwgSW52YWxpZEFkZHJlc3NFcnJvciwgSW52YWxpZE9wZXJhdGlvbktpbmRFcnJvciBhcyBJbnZhbGlkT3BlcmF0aW9uS2luZEVycm9yJDEsIEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvciwgSW52YWxpZFZpZXdQYXJhbWV0ZXJFcnJvciwgRGVwcmVjYXRpb25FcnJvciwgSW52YWxpZENoYWluSWRFcnJvciwgUHVibGljS2V5Tm90Rm91bmRFcnJvciwgSW52YWxpZEFtb3VudEVycm9yLCBJbnZhbGlkS2V5SGFzaEVycm9yIH0gZnJvbSAnQHRhcXVpdG8vY29yZSc7XG5pbXBvcnQgeyBPYnNlcnZhYmxlLCBSZXBsYXlTdWJqZWN0LCBCZWhhdmlvclN1YmplY3QsIHRocm93RXJyb3IsIGRlZmVyLCByYW5nZSwgb2YsIEVNUFRZLCBjb21iaW5lTGF0ZXN0LCBmcm9tLCBjb25jYXQsIFN1YmplY3QsIE5FVkVSLCB0aW1lciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgc3dpdGNoTWFwLCB0aW1lb3V0LCBjb25jYXRNYXAsIGVuZFdpdGgsIHRhcCwgc2hhcmVSZXBsYXksIG1hcCwgZmlsdGVyLCBmaXJzdCwgY2F0Y2hFcnJvciwgc2hhcmUsIGRpc3RpbmN0VW50aWxDaGFuZ2VkLCB0YWtlV2hpbGUsIHN0YXJ0V2l0aCwgbWVyZ2VNYXAsIHRha2VVbnRpbCwgcmV0cnksIHBsdWNrLCBkaXN0aW5jdFVudGlsS2V5Q2hhbmdlZCwgcHVibGlzaCwgcmVmQ291bnQgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBTY2hlbWEsIFBhcmFtZXRlclNjaGVtYSwgVmlld1NjaGVtYSwgRXZlbnRTY2hlbWEsIE1pY2hlbHNvbk1hcCB9IGZyb20gJ0B0YXF1aXRvL21pY2hlbHNvbi1lbmNvZGVyJztcbmV4cG9ydCB7IE1pY2hlbHNvbk1hcCwgVW5pdFZhbHVlIH0gZnJvbSAnQHRhcXVpdG8vbWljaGVsc29uLWVuY29kZXInO1xuaW1wb3J0IHsgZm9ybWF0LCB2YWxpZGF0ZU9wZXJhdGlvbiwgVmFsaWRhdGlvblJlc3VsdCwgSW52YWxpZE9wZXJhdGlvbktpbmRFcnJvciwgdmFsaWRhdGVBZGRyZXNzLCBpbnZhbGlkRGV0YWlsLCB2YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcywgdmFsaWRhdGVDaGFpbiwgdmFsaWRhdGVLZXlIYXNoLCBJbnZhbGlkS2V5SGFzaEVycm9yIGFzIEludmFsaWRLZXlIYXNoRXJyb3IkMSwgZW5jb2RlRXhwciB9IGZyb20gJ0B0YXF1aXRvL3V0aWxzJztcbmltcG9ydCBCaWdOdW1iZXIsIHsgQmlnTnVtYmVyIGFzIEJpZ051bWJlciQxIH0gZnJvbSAnYmlnbnVtYmVyLmpzJztcbmltcG9ydCB7IFBhcnNlciwgcGFja0RhdGFCeXRlcyB9IGZyb20gJ0B0YXF1aXRvL21pY2hlbC1jb2RlYyc7XG5pbXBvcnQgeyBMb2NhbEZvcmdlciB9IGZyb20gJ0B0YXF1aXRvL2xvY2FsLWZvcmdpbmcnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuLyogZ2xvYmFsIFJlZmxlY3QsIFByb21pc2UsIFN1cHByZXNzZWRFcnJvciwgU3ltYm9sICovXHJcblxyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHJlY2VpdmVyLCBzdGF0ZSwgdmFsdWUsIGtpbmQsIGYpIHtcclxuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcclxuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIHNldHRlclwiKTtcclxuICAgIGlmICh0eXBlb2Ygc3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IHJlY2VpdmVyICE9PSBzdGF0ZSB8fCAhZiA6ICFzdGF0ZS5oYXMocmVjZWl2ZXIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IHdyaXRlIHByaXZhdGUgbWVtYmVyIHRvIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcclxufVxyXG5cclxudHlwZW9mIFN1cHByZXNzZWRFcnJvciA9PT0gXCJmdW5jdGlvblwiID8gU3VwcHJlc3NlZEVycm9yIDogZnVuY3Rpb24gKGVycm9yLCBzdXBwcmVzc2VkLCBtZXNzYWdlKSB7XHJcbiAgICB2YXIgZSA9IG5ldyBFcnJvcihtZXNzYWdlKTtcclxuICAgIHJldHVybiBlLm5hbWUgPSBcIlN1cHByZXNzZWRFcnJvclwiLCBlLmVycm9yID0gZXJyb3IsIGUuc3VwcHJlc3NlZCA9IHN1cHByZXNzZWQsIGU7XHJcbn07XG5cbmZ1bmN0aW9uIGZvcm1hdEVycm9yTWVzc2FnZShlcnJvciwgc3RyaW5nVG9SZXBsYWNlKSB7XG4gICAgY29uc3QgYm9keSA9IEpTT04ucGFyc2UoZXJyb3IuYm9keSk7XG4gICAgaWYgKGJvZHlbMF0gJiYgYm9keVswXS5raW5kICYmIGJvZHlbMF0ubXNnKSB7XG4gICAgICAgIGNvbnN0IG5ld0JvZHkgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBraW5kOiBib2R5WzBdLmtpbmQsXG4gICAgICAgICAgICBpZDogYm9keVswXS5pZCxcbiAgICAgICAgICAgIG1zZzogYm9keVswXS5tc2cucmVwbGFjZShzdHJpbmdUb1JlcGxhY2UsICcnKSxcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgSHR0cFJlc3BvbnNlRXJyb3IoYEh0dHAgZXJyb3IgcmVzcG9uc2U6ICgke2Vycm9yLnN0YXR1c30pICR7bmV3Qm9keX1gLCBlcnJvci5zdGF0dXMsIGVycm9yLnN0YXR1c1RleHQsIG5ld0JvZHksIGVycm9yLnVybCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgfVxufVxuXG5jbGFzcyBScGNJbmplY3RvciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBpbmplY3Qoc2lnbmVkT3BlcmF0aW9uQnl0ZXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBoYXNoO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBoYXNoID0geWllbGQgdGhpcy5jb250ZXh0LnJwYy5pbmplY3RPcGVyYXRpb24oc2lnbmVkT3BlcmF0aW9uQnl0ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RyaW5nVG9TdHJpcCA9ICcuIFlvdSBtYXkgd2FudCB0byB1c2UgLS1yZXBsYWNlIHRvIHByb3ZpZGUgYWRlcXVhdGUgZmVlIGFuZCByZXBsYWNlIGl0JztcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2VFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKHN0cmluZ1RvU3RyaXApKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGZvcm1hdEVycm9yTWVzc2FnZShlcnJvciwgc3RyaW5nVG9TdHJpcCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgbm8gc2lnbmVyIGhhcyBiZWVuIGNvbmZpZ3VyZWQgaW4gdGhlIFRlem9zVG9vbGtpdCBpbnN0YW5jZVxuICovXG5jbGFzcyBVbmNvbmZpZ3VyZWRTaWduZXJFcnJvciBleHRlbmRzIFRlem9zVG9vbGtpdENvbmZpZ0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1VuY29uZmlndXJlZFNpZ25lckVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID1cbiAgICAgICAgICAgICdObyBzaWduZXIgaGFzIGJlZW4gY29uZmlndXJlZC4gUGxlYXNlIGNvbmZpZ3VyZSBvbmUgYnkgY2FsbGluZyBzZXRQcm92aWRlcih7c2lnbmVyfSkgb24geW91ciBUZXpvc1Rvb2xraXQgaW5zdGFuY2UuJztcbiAgICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlZmF1bHQgc2lnbmVyIGltcGxlbWVudGF0aW9uIHdoaWNoIGRvZXMgbm90aGluZyBhbmQgcHJvZHVjZSBpbnZhbGlkIHNpZ25hdHVyZVxuICogQHRocm93IHtAbGluayBVbmNvbmZpZ3VyZWRTaWduZXJFcnJvcn1cbiAqL1xuY2xhc3MgTm9vcFNpZ25lciB7XG4gICAgcHVibGljS2V5KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuY29uZmlndXJlZFNpZ25lckVycm9yKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwdWJsaWNLZXlIYXNoKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFVuY29uZmlndXJlZFNpZ25lckVycm9yKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZWNyZXRLZXkoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5jb25maWd1cmVkU2lnbmVyRXJyb3IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ24oX2J5dGVzLCBfd2F0ZXJtYXJrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5jb25maWd1cmVkU2lnbmVyRXJyb3IoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVPYnNlcnZhYmxlRnJvbVN1YnNjcmlwdGlvbihzdWIpIHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YnNjcmliZXIpID0+IHtcbiAgICAgICAgc3ViLm9uKCdkYXRhJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIubmV4dChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN1Yi5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc3ViLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgICAgIHN1YnNjcmliZXIuY29tcGxldGUoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdWIuY2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cblxuY29uc3QgREVGQVVMVF9HQVNfTElNSVQgPSB7XG4gICAgREVMRUdBVElPTjogMTA2MDAsXG4gICAgT1JJR0lOQVRJT046IDEwNjAwLFxuICAgIFRSQU5TRkVSOiAxMDYwMCxcbiAgICAvKiBUaGlzIGlzIHVzZWQgZm9yIGdhc19saW1pdC4gVGhlcmUgaXMgbm8gaGFybSBpbiBzZXR0aW5nIGEgaGlnaGVyIGxpbWl0LlxuICAgICBPbmx5IGlmIGFuIGFjY291bnQgaGFzIGEgYmFsYW5jZSB0aGF0IGlzIHZlcnkgY2xvc2UgdG8gdGhlIHRvdGFsIGdhcyBjb25zdW1wdGlvbixcbiAgICAgdGhlbiB0aGlzIG1hcmdpbiBjYW4gZmFpbCB0aGUgb3BlcmF0aW9uLlxuICAgICBBbm90aGVyIGJlbmVmaXQgb2YgdGhpcyBoaWdoZXIgdmFsdWUgaXMgdGhhdCB0aGVuIERhcHBzIGJ1aWxkIHdpdGggVGFxdWl0byAxNyBjYW5cbiAgICAgc3RpbGwgd29yayB3aXRoIE11bWJhaW5ldCwgYXMgdGhpcyB2YWx1ZSBpcyBoaWdoZXIgdGhhbiB0aGUgcmV2ZWFsIGNvc3QgaW4gTXVtYmFpLlxuICAgICovXG4gICAgUkVWRUFMX1RaMTogMTAwMCxcbiAgICBSRVZFQUxfVFoyOiAxMDAwLFxuICAgIFJFVkVBTF9UWjM6IDIwMDAsXG4gICAgUkVWRUFMX1RaNDogMjAwMCxcbn07XG5jb25zdCBERUZBVUxUX0ZFRSA9IHtcbiAgICBERUxFR0FUSU9OOiAxMjU3LFxuICAgIE9SSUdJTkFUSU9OOiAxMDAwMCxcbiAgICBUUkFOU0ZFUjogMTAwMDAsXG4gICAgUkVWRUFMOiAzNzQsXG59O1xuY29uc3QgREVGQVVMVF9TVE9SQUdFX0xJTUlUID0ge1xuICAgIERFTEVHQVRJT046IDAsXG4gICAgT1JJR0lOQVRJT046IDI1NyxcbiAgICBUUkFOU0ZFUjogMjU3LFxuICAgIFJFVkVBTDogMCxcbn07XG5jb25zdCBDT1NUX1BFUl9CWVRFID0gMjUwO1xudmFyIFByb3RvY29scztcbihmdW5jdGlvbiAoUHJvdG9jb2xzKSB7XG4gICAgUHJvdG9jb2xzW1wiUHQyNG00eGlcIl0gPSBcIlB0MjRtNHhpUGJMRGhWZ1ZmQUJVamlyYm1kYTN5b2hkTjgyU3A5RmV1QVhKNGVWOW90ZFwiO1xuICAgIFByb3RvY29sc1tcIlBzQkFCWTVIXCJdID0gXCJQc0JBQlk1SFFUU2tBNDI5N3pOSGZzWk5LdHhVTGZMMTh5OTVxYjNtNTNRSmlYR21yYlVcIjtcbiAgICBQcm90b2NvbHNbXCJQc0JhYnlNMVwiXSA9IFwiUHNCYWJ5TTFlVVhac2VhSmRtWEZBcERTQnFqOFlCZndFTG94WkhIVzc3RU1jQWJid0FTXCI7XG4gICAgUHJvdG9jb2xzW1wiUHNDQVJUSEFcIl0gPSBcIlBzQ0FSVEhBR2F6S2JIdG5LZkx6UWcza21zNTJrU1JwZ25EWTk4MmE5b1lzU1hSTFFFYlwiO1xuICAgIFByb3RvY29sc1tcIlBzREVMUEgxXCJdID0gXCJQc0RFTFBIMUt4c3h0OGY5ZVdieFFlUnhramZieG9xTTUyanZzNVk1ZkJ4V1doNGlmcG9cIjtcbiAgICBQcm90b2NvbHNbXCJQdEVkbzJaa1wiXSA9IFwiUHRFZG8yWmtUOW9LcGltVGFoNngyZW1iRjI1b3NzNTRuak11UHprSlRFaTVScWZkWkZBXCI7XG4gICAgUHJvdG9jb2xzW1wiUHNGTG9yZW5hXCJdID0gXCJQc0ZMb3JlbmFVVXVpa0RXdk1EcjZmR0JSRzhrdDNlM0QzZkhvWEsxajFCRlJ4ZVNINGlcIjtcbiAgICBQcm90b2NvbHNbXCJQdEdSQU5BRHNcIl0gPSBcIlB0R1JBTkFEc0RVOFI5ZGFZS0FnV25RWUFKNjRvbU4xbzNLTUdWQ3lrU2hBOTd2UWJ2VlwiO1xuICAgIFByb3RvY29sc1tcIlB0SGFuZ3oyXCJdID0gXCJQdEhhbmd6MmFSbmd5d21TUkdHdnJjVHlNYmJkcFdkcEZLdVM0dU1XeGcyUmFIOWkxcXhcIjtcbiAgICBQcm90b2NvbHNbXCJQc2lUaGFDYVwiXSA9IFwiUHNpVGhhQ2FUNDdaYm9hdzcxUVdTY004c1hlTU03YmJRRm5jSzlGTHFZYzZFS2RwalZQXCI7XG4gICAgUHJvdG9jb2xzW1wiUHNpdGhhY2EyXCJdID0gXCJQc2l0aGFjYTJNTFJGWWFyZ2l2cG83WXZVcjd3VURxeXhyZGhDNUNRcTc4bVJ2aW16NkFcIjtcbiAgICBQcm90b2NvbHNbXCJQdEpha2FydDJcIl0gPSBcIlB0SmFrYXJ0MnhWajdwWVhKQlhycUhnZDgycmRrTGV5NVplZUd3RGdQcDlyaFFVYlNxWVwiO1xuICAgIFByb3RvY29sc1tcIlB0S2F0aG1hblwiXSA9IFwiUHRLYXRobWFua1NwTExEQUx6V3c3Q0dEMmoyTXR5dmVUd2JvRVlva3FVQ1A0YTFMeE1nXCI7XG4gICAgUHJvdG9jb2xzW1wiUHRMaW1hUHRMXCJdID0gXCJQdExpbWFQdExNd2ZOaW5KaTlyQ2ZEUFdlYThkRmdUWjFNZUo5ZjFtMlNSaWM2YXlpd1dcIjtcbiAgICBQcm90b2NvbHNbXCJQdE11bWJhaWlcIl0gPSBcIlB0TXVtYmFpaUZGRUdiZXcxclJqelNQeXpSYkE1MVRtM1JWWkw1c3VIUHhTWllEaENFY1wiO1xuICAgIFByb3RvY29sc1tcIlB0TXVtYmFpMlwiXSA9IFwiUHRNdW1iYWkyVG1zSkhOR1JrRDh2OFlEYnRhbzdCTFVDM3dqQVNuMWluQUtMRkNqYUgxXCI7XG4gICAgUHJvdG9jb2xzW1wiUHROYWlyb2JpXCJdID0gXCJQdE5haXJvYml5c3NIdWg4N2hFaGZWQkdDVnJLM1duUzhaMkZUNHltQjV0QWE0cjFuUWZcIjtcbiAgICBQcm90b2NvbHNbXCJQcm94Zm9yZFlcIl0gPSBcIlByb3hmb3JkWW1WZmpXblJjZ2pXSDM2Zlc2UEFyd3F5a1RGem90VXhSczZnbVRjWkR1SFwiO1xuICAgIFByb3RvY29sc1tcIlByb3RvQUxwaGFcIl0gPSBcIlByb3RvQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYUFMcGhhQUxwaGFBTHBoYURkcDN6S1wiO1xufSkoUHJvdG9jb2xzIHx8IChQcm90b2NvbHMgPSB7fSkpO1xuY29uc3QgcHJvdG9jb2xzID0ge1xuICAgICcwMDQnOiBbUHJvdG9jb2xzLlB0MjRtNHhpXSxcbiAgICAnMDA1JzogW1Byb3RvY29scy5Qc0JBQlk1SCwgUHJvdG9jb2xzLlBzQmFieU0xXSxcbiAgICAnMDA2JzogW1Byb3RvY29scy5Qc0NBUlRIQV0sXG4gICAgJzAwNyc6IFtQcm90b2NvbHMuUHNERUxQSDFdLFxuICAgICcwMDgnOiBbUHJvdG9jb2xzLlB0RWRvMlprXSxcbiAgICAnMDA5JzogW1Byb3RvY29scy5Qc0ZMb3JlbmFdLFxuICAgICcwMTAnOiBbUHJvdG9jb2xzLlB0R1JBTkFEc10sXG4gICAgJzAxMSc6IFtQcm90b2NvbHMuUHRIYW5nejJdLFxuICAgICcwMTInOiBbUHJvdG9jb2xzLlBzaVRoYUNhLCBQcm90b2NvbHMuUHNpdGhhY2EyXSxcbiAgICAnMDEzJzogW1Byb3RvY29scy5QdEpha2FydDJdLFxuICAgICcwMTQnOiBbUHJvdG9jb2xzLlB0S2F0aG1hbl0sXG4gICAgJzAxNSc6IFtQcm90b2NvbHMuUHRMaW1hUHRMXSxcbiAgICAnMDE2JzogW1Byb3RvY29scy5QdE11bWJhaTJdLFxuICAgICcwMTcnOiBbUHJvdG9jb2xzLlB0TmFpcm9iaV0sXG4gICAgJzAxOSc6IFtQcm90b2NvbHMuUHJveGZvcmRZXSxcbiAgICAnMDIwJzogW1Byb3RvY29scy5Qcm90b0FMcGhhXSxcbn07XG52YXIgQ2hhaW5JZHM7XG4oZnVuY3Rpb24gKENoYWluSWRzKSB7XG4gICAgQ2hhaW5JZHNbXCJNQUlOTkVUXCJdID0gXCJOZXRYZFFwcmNWa3BhV1VcIjtcbiAgICBDaGFpbklkc1tcIkNBUlRIQUdFTkVUXCJdID0gXCJOZXRYakQzSFBKSmptY2RcIjtcbiAgICBDaGFpbklkc1tcIkRFTFBISU5FVFwiXSA9IFwiTmV0WG04dFlxbk1Xa3kxXCI7XG4gICAgQ2hhaW5JZHNbXCJFRE9ORVRcIl0gPSBcIk5ldFhTZ28xWlQyRFJVR1wiO1xuICAgIENoYWluSWRzW1wiRkxPUkVOQ0VORVRcIl0gPSBcIk5ldFh4a0F4NHdvUEx5dVwiO1xuICAgIENoYWluSWRzW1wiR1JBTkFEQU5FVFwiXSA9IFwiTmV0WHo5NjlTRmFGbjhrXCI7XG4gICAgQ2hhaW5JZHNbXCJIQU5HWkhPVU5FVFwiXSA9IFwiTmV0WFpTc3hCcE1RZUFUXCI7XG4gICAgQ2hhaW5JZHNbXCJJVEhBQ0FORVRcIl0gPSBcIk5ldFhiaG10QWJNdWtMY1wiO1xuICAgIENoYWluSWRzW1wiSVRIQUNBTkVUMlwiXSA9IFwiTmV0WG5IZlZxbTlpZXNwXCI7XG4gICAgQ2hhaW5JZHNbXCJKQUtBUlRBTkVUMlwiXSA9IFwiTmV0WExIMXVBeEs3Q0NoXCI7XG4gICAgQ2hhaW5JZHNbXCJLQVRITUFORFVORVRcIl0gPSBcIk5ldFhhemhtNHlldG1mZlwiO1xuICAgIENoYWluSWRzW1wiTElNQU5FVFwiXSA9IFwiTmV0WGl6cGtIOTRib2NIXCI7XG4gICAgQ2hhaW5JZHNbXCJNVU1CQUlORVRcIl0gPSBcIk5ldFhRdzZuV1Nucko1dFwiO1xuICAgIENoYWluSWRzW1wiTVVNQkFJTkVUMlwiXSA9IFwiTmV0WGdiY3JOdFhEMnlBXCI7XG4gICAgQ2hhaW5JZHNbXCJOQUlST0JJTkVUXCJdID0gXCJOZXRYeXV6dkRvMlVnemJcIjtcbiAgICBDaGFpbklkc1tcIk9YRk9SRE5FVDJcIl0gPSBcIk5ldFh4V3Nza0dhaHpRQlwiO1xufSkoQ2hhaW5JZHMgfHwgKENoYWluSWRzID0ge30pKTtcbmNvbnN0IGdldFJldmVhbEdhc0xpbWl0ID0gKGFkZHJlc3MpID0+IE1hdGgucm91bmQoKGdldFJldmVhbEdhc0xpbWl0SW50ZXJuYWwoYWRkcmVzcykgKiAxMSkgLyAxMCk7XG5jb25zdCBnZXRSZXZlYWxHYXNMaW1pdEludGVybmFsID0gKGFkZHJlc3MpID0+IHtcbiAgICBzd2l0Y2ggKGFkZHJlc3Muc3Vic3RyaW5nKDAsIDMpKSB7XG4gICAgICAgIGNhc2UgJ3R6MSc6XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9HQVNfTElNSVQuUkVWRUFMX1RaMTtcbiAgICAgICAgY2FzZSAndHoyJzpcbiAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0dBU19MSU1JVC5SRVZFQUxfVFoyO1xuICAgICAgICBjYXNlICd0ejMnOlxuICAgICAgICAgICAgcmV0dXJuIERFRkFVTFRfR0FTX0xJTUlULlJFVkVBTF9UWjM7XG4gICAgICAgIGNhc2UgJ3R6NCc6XG4gICAgICAgICAgICByZXR1cm4gREVGQVVMVF9HQVNfTElNSVQuUkVWRUFMX1RaNDtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGVzdGltYXRlIHJldmVhbCBnYXMgbGltaXQgZm9yICR7YWRkcmVzc31gKTtcbiAgICB9XG59O1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgaW52YWxpZCBzbWFydCBjb250cmFjdCBwYXJhbWV0ZXJzIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRQYXJhbWV0ZXJFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3Ioc21hcnRDb250cmFjdE1ldGhvZE5hbWUsIHNpZ3MsIGludmFsaWRQYXJhbXMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zbWFydENvbnRyYWN0TWV0aG9kTmFtZSA9IHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lO1xuICAgICAgICB0aGlzLnNpZ3MgPSBzaWdzO1xuICAgICAgICB0aGlzLmludmFsaWRQYXJhbXMgPSBpbnZhbGlkUGFyYW1zO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFBhcmFtZXRlckVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7c21hcnRDb250cmFjdE1ldGhvZE5hbWV9IFJlY2VpdmVkICR7aW52YWxpZFBhcmFtcy5sZW5ndGh9IGFyZ3VtZW50cyB3aGlsZSBleHBlY3Rpbmcgb25lIG9mIHRoZSBmb2xsb3dpbmcgc2lnbmF0dXJlcyAoJHtKU09OLnN0cmluZ2lmeShzaWdzKX0pYDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBkZWxlZ2F0aW9uIHNvdXJjZSBjb250cmFjdCBhZGRyZXNzIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWREZWxlZ2F0aW9uU291cmNlIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihzb3VyY2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICAgIHRoaXMubmFtZSA9IGBJbnZhbGlkRGVsZWdhdGlvblNvdXJjZWA7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBTaW5jZSBCYWJ5bG9uIGRlbGVnYXRpb24gc291cmNlIGNhbiBubyBsb25nZXIgYmUgYSBjb250cmFjdCBhZGRyZXNzICR7c291cmNlfS4gUGxlYXNlIHVzZSB0aGUgc21hcnQgY29udHJhY3QgYWJzdHJhY3Rpb24gdG8gc2V0IHlvdXIgZGVsZWdhdGUuYDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBzbWFydCBjb250cmFjdCBjb2RlIHBhcmFtZXRlciBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkQ29kZVBhcmFtZXRlciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgZGF0YSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmRhdGEgPSBkYXRhO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZENvZGVQYXJhbWV0ZXInO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBpbnZhbGlkIHNtYXJ0IGNvbnRyYWN0IGluaXQgcGFyYW1ldGVyIGJlaW5nIHBhc3NlZCBvciB1c2VkXG4gKi9cbmNsYXNzIEludmFsaWRJbml0UGFyYW1ldGVyIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBkYXRhKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkSW5pdFBhcmFtZXRlcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZmFpbHVyZSB3aGVuIGNvbmR1Y3RpbmcgYSB2aWV3IHNpbXVsYXRpb25cbiAqL1xuY2xhc3MgVmlld1NpbXVsYXRpb25FcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCB2aWV3TmFtZSwgZmFpbFdpdGgsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMudmlld05hbWUgPSB2aWV3TmFtZTtcbiAgICAgICAgdGhpcy5mYWlsV2l0aCA9IGZhaWxXaXRoO1xuICAgICAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdWaWV3U2ltdWxhdGlvbkVycm9yJztcbiAgICB9XG59XG5jb25zdCB2YWxpZGF0ZUFuZEV4dHJhY3RGYWlsd2l0aCA9IChlcnJvcikgPT4ge1xuICAgIGlmIChpc0pzb25TdHJpbmcoZXJyb3IuYm9keSkpIHtcbiAgICAgICAgY29uc3QgcGFyc2VkRXJyb3IgPSBKU09OLnBhcnNlKGVycm9yLmJvZHkpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWRFcnJvcikgJiYgJ3dpdGgnIGluIHBhcnNlZEVycm9yW3BhcnNlZEVycm9yLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkRXJyb3JbcGFyc2VkRXJyb3IubGVuZ3RoIC0gMV0ud2l0aDtcbiAgICAgICAgfVxuICAgIH1cbn07XG5jb25zdCBpc0pzb25TdHJpbmcgPSAoc3RyKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgICAgSlNPTi5wYXJzZShzdHIpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBpbnZhbGlkIG9yIHVuY29uZmlndXJlZCBjb250ZXh0IHdoZW4gZXhlY3V0aW5nIGEgdmlld1xuICovXG5jbGFzcyBJbnZhbGlkVmlld1NpbXVsYXRpb25Db250ZXh0IGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpbmZvKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaW5mbyA9IGluZm87XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkVmlld1NpbXVsYXRpb25Db250ZXh0JztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYCR7aW5mb30gUGxlYXNlIGNvbmZpZ3VyZSB0aGUgY29udGV4dCBvZiB0aGUgdmlldyBleGVjdXRpb24gaW4gdGhlIGV4ZWN1dGVWaWV3IG1ldGhvZC5gO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhIG1pc3Rha2UgaGFwcGVuaW5nIGR1cmluZyB0aGUgcmV2ZWFsIG9wZXJhdGlvblxuICovXG5jbGFzcyBSZXZlYWxPcGVyYXRpb25FcnJvciBleHRlbmRzIFJwY0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdSZXZlYWxPcGVyYXRpb25FcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgbWlzdGFrZSBpbiB0aGUgcGFyYW1ldGVycyBpbiB0aGUgcHJlcGFyYXRpb24gb2YgYW4gT3JpZ2luYXRpb24gb3BlcmF0aW9uXG4gKi9cbmNsYXNzIE9yaWdpbmF0aW9uUGFyYW1ldGVyRXJyb3IgZXh0ZW5kcyBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIGJhbGFuY2UgYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZEJhbGFuY2VFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZEJhbGFuY2VFcnJvcic7XG4gICAgfVxufVxuXG5jb25zdCBjcmVhdGVBY3RpdmF0aW9uT3BlcmF0aW9uID0gKHsgcGtoLCBzZWNyZXQgfSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogT3BLaW5kLkFDVElWQVRJT04sXG4gICAgICAgIHBraCxcbiAgICAgICAgc2VjcmV0LFxuICAgIH07XG59KTtcbmNvbnN0IGNyZWF0ZU9yaWdpbmF0aW9uT3BlcmF0aW9uID0gKHsgY29kZSwgaW5pdCwgYmFsYW5jZSA9ICcwJywgZGVsZWdhdGUsIHN0b3JhZ2UsIGZlZSA9IERFRkFVTFRfRkVFLk9SSUdJTkFUSU9OLCBnYXNMaW1pdCA9IERFRkFVTFRfR0FTX0xJTUlULk9SSUdJTkFUSU9OLCBzdG9yYWdlTGltaXQgPSBERUZBVUxUX1NUT1JBR0VfTElNSVQuT1JJR0lOQVRJT04sIG11dGV6ID0gZmFsc2UsIH0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGlmIChzdG9yYWdlICE9PSB1bmRlZmluZWQgJiYgaW5pdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBPcmlnaW5hdGlvblBhcmFtZXRlckVycm9yKCdTdG9yYWdlIGFuZCBJbml0IGNhbm5vdCBiZSBzZXQgYSB0aGUgc2FtZSB0aW1lLiBQbGVhc2UgZWl0aGVyIHVzZSBzdG9yYWdlIG9yIGluaXQgYnV0IG5vdCBib3RoLicpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29kZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb2RlUGFyYW1ldGVyKCdXcm9uZyBjb2RlIHBhcmFtZXRlciB0eXBlLCBleHBlY3RlZCBhbiBhcnJheScsIGNvZGUpO1xuICAgIH1cbiAgICBsZXQgY29udHJhY3RTdG9yYWdlO1xuICAgIGlmIChzdG9yYWdlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZVR5cGUgPSBjb2RlLmZpbmQoKHApID0+ICdwcmltJyBpbiBwICYmIHAucHJpbSA9PT0gJ3N0b3JhZ2UnKTtcbiAgICAgICAgaWYgKChzdG9yYWdlVHlwZSA9PT0gbnVsbCB8fCBzdG9yYWdlVHlwZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogc3RvcmFnZVR5cGUuYXJncykgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb2RlUGFyYW1ldGVyKCdUaGUgc3RvcmFnZSBzZWN0aW9uIGlzIG1pc3NpbmcgZnJvbSB0aGUgc2NyaXB0JywgY29kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2NoZW1hID0gbmV3IFNjaGVtYShzdG9yYWdlVHlwZS5hcmdzWzBdKTsgLy8gVE9ET1xuICAgICAgICBjb250cmFjdFN0b3JhZ2UgPSBzY2hlbWEuRW5jb2RlKHN0b3JhZ2UpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpbml0ICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGluaXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGNvbnRyYWN0U3RvcmFnZSA9IGluaXQ7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEluaXRQYXJhbWV0ZXIoJ1dyb25nIGluaXQgcGFyYW1ldGVyIHR5cGUsIGV4cGVjdGVkIEpTT04gTWljaGVsc29uJywgaW5pdCk7XG4gICAgfVxuICAgIGNvbnN0IHNjcmlwdCA9IHtcbiAgICAgICAgY29kZSxcbiAgICAgICAgc3RvcmFnZTogY29udHJhY3RTdG9yYWdlLFxuICAgIH07XG4gICAgaWYgKGlzTmFOKE51bWJlcihiYWxhbmNlKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRCYWxhbmNlRXJyb3IoYEludmFsaWQgQmFsYW5jZSBcIiR7YmFsYW5jZX1cIiwgY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIG51bWJlcmApO1xuICAgIH1cbiAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICAgIGtpbmQ6IE9wS2luZC5PUklHSU5BVElPTixcbiAgICAgICAgZmVlLFxuICAgICAgICBnYXNfbGltaXQ6IGdhc0xpbWl0LFxuICAgICAgICBzdG9yYWdlX2xpbWl0OiBzdG9yYWdlTGltaXQsXG4gICAgICAgIGJhbGFuY2U6IG11dGV6ID8gYmFsYW5jZS50b1N0cmluZygpIDogZm9ybWF0KCd0eicsICdtdXRleicsIGJhbGFuY2UpLnRvU3RyaW5nKCksXG4gICAgICAgIHNjcmlwdCxcbiAgICB9O1xuICAgIGlmIChkZWxlZ2F0ZSkge1xuICAgICAgICBvcGVyYXRpb24uZGVsZWdhdGUgPSBkZWxlZ2F0ZTtcbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdGlvbjtcbn0pO1xuY29uc3QgY3JlYXRlVHJhbnNmZXJPcGVyYXRpb24gPSAoeyB0bywgYW1vdW50LCBwYXJhbWV0ZXIsIGZlZSA9IERFRkFVTFRfRkVFLlRSQU5TRkVSLCBnYXNMaW1pdCA9IERFRkFVTFRfR0FTX0xJTUlULlRSQU5TRkVSLCBzdG9yYWdlTGltaXQgPSBERUZBVUxUX1NUT1JBR0VfTElNSVQuVFJBTlNGRVIsIG11dGV6ID0gZmFsc2UsIH0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAga2luZDogT3BLaW5kLlRSQU5TQUNUSU9OLFxuICAgICAgICBmZWUsXG4gICAgICAgIGdhc19saW1pdDogZ2FzTGltaXQsXG4gICAgICAgIHN0b3JhZ2VfbGltaXQ6IHN0b3JhZ2VMaW1pdCxcbiAgICAgICAgYW1vdW50OiBtdXRleiA/IGFtb3VudC50b1N0cmluZygpIDogZm9ybWF0KCd0eicsICdtdXRleicsIGFtb3VudCkudG9TdHJpbmcoKSxcbiAgICAgICAgZGVzdGluYXRpb246IHRvLFxuICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbWV0ZXIsXG4gICAgfTtcbiAgICByZXR1cm4gb3BlcmF0aW9uO1xufSk7XG5jb25zdCBjcmVhdGVTZXREZWxlZ2F0ZU9wZXJhdGlvbiA9ICh7IGRlbGVnYXRlLCBzb3VyY2UsIGZlZSA9IERFRkFVTFRfRkVFLkRFTEVHQVRJT04sIGdhc0xpbWl0ID0gREVGQVVMVF9HQVNfTElNSVQuREVMRUdBVElPTiwgc3RvcmFnZUxpbWl0ID0gREVGQVVMVF9TVE9SQUdFX0xJTUlULkRFTEVHQVRJT04sIH0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAga2luZDogT3BLaW5kLkRFTEVHQVRJT04sXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgZmVlLFxuICAgICAgICBnYXNfbGltaXQ6IGdhc0xpbWl0LFxuICAgICAgICBzdG9yYWdlX2xpbWl0OiBzdG9yYWdlTGltaXQsXG4gICAgICAgIGRlbGVnYXRlLFxuICAgIH07XG4gICAgcmV0dXJuIG9wZXJhdGlvbjtcbn0pO1xuY29uc3QgY3JlYXRlUmVnaXN0ZXJEZWxlZ2F0ZU9wZXJhdGlvbiA9ICh7IGZlZSA9IERFRkFVTFRfRkVFLkRFTEVHQVRJT04sIGdhc0xpbWl0ID0gREVGQVVMVF9HQVNfTElNSVQuREVMRUdBVElPTiwgc3RvcmFnZUxpbWl0ID0gREVGQVVMVF9TVE9SQUdFX0xJTUlULkRFTEVHQVRJT04sIH0sIHNvdXJjZSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogT3BLaW5kLkRFTEVHQVRJT04sXG4gICAgICAgIGZlZSxcbiAgICAgICAgZ2FzX2xpbWl0OiBnYXNMaW1pdCxcbiAgICAgICAgc3RvcmFnZV9saW1pdDogc3RvcmFnZUxpbWl0LFxuICAgICAgICBkZWxlZ2F0ZTogc291cmNlLFxuICAgIH07XG59KTtcbmNvbnN0IGNyZWF0ZVJldmVhbE9wZXJhdGlvbiA9ICh7IGZlZSA9IERFRkFVTFRfRkVFLlJFVkVBTCwgZ2FzTGltaXQgPSB1bmRlZmluZWQsIHN0b3JhZ2VMaW1pdCA9IERFRkFVTFRfU1RPUkFHRV9MSU1JVC5SRVZFQUwsIH0sIHNvdXJjZSwgcHVibGljS2V5KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBPcEtpbmQuUkVWRUFMLFxuICAgICAgICBmZWUsXG4gICAgICAgIHB1YmxpY19rZXk6IHB1YmxpY0tleSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBnYXNfbGltaXQ6IGdhc0xpbWl0ICE9PSBudWxsICYmIGdhc0xpbWl0ICE9PSB2b2lkIDAgPyBnYXNMaW1pdCA6IGdldFJldmVhbEdhc0xpbWl0KHNvdXJjZSksXG4gICAgICAgIHN0b3JhZ2VfbGltaXQ6IHN0b3JhZ2VMaW1pdCxcbiAgICB9O1xufSk7XG5jb25zdCBjcmVhdGVSZWdpc3Rlckdsb2JhbENvbnN0YW50T3BlcmF0aW9uID0gKHsgdmFsdWUsIHNvdXJjZSwgZmVlLCBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0LCB9KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBPcEtpbmQuUkVHSVNURVJfR0xPQkFMX0NPTlNUQU5ULFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgZmVlLFxuICAgICAgICBnYXNfbGltaXQ6IGdhc0xpbWl0LFxuICAgICAgICBzdG9yYWdlX2xpbWl0OiBzdG9yYWdlTGltaXQsXG4gICAgICAgIHNvdXJjZSxcbiAgICB9O1xufSk7XG5jb25zdCBjcmVhdGVUcmFuc2ZlclRpY2tldE9wZXJhdGlvbiA9ICh7IHRpY2tldENvbnRlbnRzLCB0aWNrZXRUeSwgdGlja2V0VGlja2V0ZXIsIHRpY2tldEFtb3VudCwgZGVzdGluYXRpb24sIGVudHJ5cG9pbnQsIHNvdXJjZSwgZmVlLCBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0LCB9KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBPcEtpbmQuVFJBTlNGRVJfVElDS0VULFxuICAgICAgICBmZWUsXG4gICAgICAgIGdhc19saW1pdDogZ2FzTGltaXQsXG4gICAgICAgIHN0b3JhZ2VfbGltaXQ6IHN0b3JhZ2VMaW1pdCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICB0aWNrZXRfY29udGVudHM6IHRpY2tldENvbnRlbnRzLFxuICAgICAgICB0aWNrZXRfdHk6IHRpY2tldFR5LFxuICAgICAgICB0aWNrZXRfdGlja2V0ZXI6IHRpY2tldFRpY2tldGVyLFxuICAgICAgICB0aWNrZXRfYW1vdW50OiB0aWNrZXRBbW91bnQsXG4gICAgICAgIGRlc3RpbmF0aW9uLFxuICAgICAgICBlbnRyeXBvaW50LFxuICAgIH07XG59KTtcbmNvbnN0IGNyZWF0ZUluY3JlYXNlUGFpZFN0b3JhZ2VPcGVyYXRpb24gPSAoeyBzb3VyY2UsIGZlZSwgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCwgYW1vdW50LCBkZXN0aW5hdGlvbiwgfSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogT3BLaW5kLklOQ1JFQVNFX1BBSURfU1RPUkFHRSxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBmZWUsXG4gICAgICAgIGdhc19saW1pdDogZ2FzTGltaXQsXG4gICAgICAgIHN0b3JhZ2VfbGltaXQ6IHN0b3JhZ2VMaW1pdCxcbiAgICAgICAgYW1vdW50LFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICB9O1xufSk7XG5jb25zdCBjcmVhdGVEcmFpbkRlbGVnYXRlT3BlcmF0aW9uID0gKHsgY29uc2Vuc3VzX2tleSwgZGVsZWdhdGUsIGRlc3RpbmF0aW9uLCB9KSA9PiBfX2F3YWl0ZXIodm9pZCAwLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBraW5kOiBPcEtpbmQuRFJBSU5fREVMRUdBVEUsXG4gICAgICAgIGNvbnNlbnN1c19rZXksXG4gICAgICAgIGRlbGVnYXRlLFxuICAgICAgICBkZXN0aW5hdGlvbixcbiAgICB9O1xufSk7XG5jb25zdCBjcmVhdGVCYWxsb3RPcGVyYXRpb24gPSAoeyBzb3VyY2UsIHByb3Bvc2FsLCBiYWxsb3QgfSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogT3BLaW5kLkJBTExPVCxcbiAgICAgICAgc291cmNlLFxuICAgICAgICBwcm9wb3NhbCxcbiAgICAgICAgYmFsbG90LFxuICAgIH07XG59KTtcbmNvbnN0IGNyZWF0ZVByb3Bvc2Fsc09wZXJhdGlvbiA9ICh7IHNvdXJjZSwgcHJvcG9zYWxzIH0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IE9wS2luZC5QUk9QT1NBTFMsXG4gICAgICAgIHNvdXJjZSxcbiAgICAgICAgcHJvcG9zYWxzLFxuICAgIH07XG59KTtcbmNvbnN0IGNyZWF0ZVVwZGF0ZUNvbnNlbnN1c0tleU9wZXJhdGlvbiA9ICh7IHNvdXJjZSwgZmVlLCBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0LCBwaywgfSkgPT4gX19hd2FpdGVyKHZvaWQgMCwgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAga2luZDogT3BLaW5kLlVQREFURV9DT05TRU5TVVNfS0VZLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGZlZSxcbiAgICAgICAgZ2FzX2xpbWl0OiBnYXNMaW1pdCxcbiAgICAgICAgc3RvcmFnZV9saW1pdDogc3RvcmFnZUxpbWl0LFxuICAgICAgICBwayxcbiAgICB9O1xufSk7XG5jb25zdCBjcmVhdGVTbWFydFJvbGx1cEFkZE1lc3NhZ2VzT3BlcmF0aW9uID0gKHsgc291cmNlLCBmZWUsIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQsIG1lc3NhZ2UsIH0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IE9wS2luZC5TTUFSVF9ST0xMVVBfQUREX01FU1NBR0VTLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGZlZSxcbiAgICAgICAgZ2FzX2xpbWl0OiBnYXNMaW1pdCxcbiAgICAgICAgc3RvcmFnZV9saW1pdDogc3RvcmFnZUxpbWl0LFxuICAgICAgICBtZXNzYWdlLFxuICAgIH07XG59KTtcbmNvbnN0IGNyZWF0ZVNtYXJ0Um9sbHVwT3JpZ2luYXRlT3BlcmF0aW9uID0gKHsgc291cmNlLCBmZWUsIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQsIHB2bUtpbmQsIGtlcm5lbCwgcGFyYW1ldGVyc1R5cGUsIH0pID0+IF9fYXdhaXRlcih2b2lkIDAsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGtpbmQ6IE9wS2luZC5TTUFSVF9ST0xMVVBfT1JJR0lOQVRFLFxuICAgICAgICBzb3VyY2UsXG4gICAgICAgIGZlZSxcbiAgICAgICAgZ2FzX2xpbWl0OiBnYXNMaW1pdCxcbiAgICAgICAgc3RvcmFnZV9saW1pdDogc3RvcmFnZUxpbWl0LFxuICAgICAgICBwdm1fa2luZDogcHZtS2luZCxcbiAgICAgICAga2VybmVsLFxuICAgICAgICBwYXJhbWV0ZXJzX3R5OiBwYXJhbWV0ZXJzVHlwZSxcbiAgICB9O1xufSk7XG5cbmNvbnN0IGF0dGFjaEtpbmQgPSAob3AsIGtpbmQpID0+IHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcCksIHsga2luZCB9KTtcbn07XG5jb25zdCBmaW5kV2l0aEtpbmQgPSAoYXJyLCBraW5kKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkge1xuICAgICAgICBjb25zdCBmb3VuZCA9IGFyci5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0ga2luZCk7XG4gICAgICAgIGlmIChmb3VuZCAmJiBpc0tpbmQoZm91bmQsIGtpbmQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZm91bmQ7XG4gICAgICAgIH1cbiAgICB9XG59O1xuY29uc3QgaXNLaW5kID0gKG9wLCBraW5kKSA9PiB7XG4gICAgcmV0dXJuIG9wLmtpbmQgPT09IGtpbmQ7XG59O1xuY29uc3QgaXNPcFdpdGhGZWUgPSAob3ApID0+IHtcbiAgICByZXR1cm4gKFtcbiAgICAgICAgJ3RyYW5zYWN0aW9uJyxcbiAgICAgICAgJ2RlbGVnYXRpb24nLFxuICAgICAgICAnb3JpZ2luYXRpb24nLFxuICAgICAgICAncmV2ZWFsJyxcbiAgICAgICAgJ3JlZ2lzdGVyX2dsb2JhbF9jb25zdGFudCcsXG4gICAgICAgICdpbmNyZWFzZV9wYWlkX3N0b3JhZ2UnLFxuICAgICAgICAndHJhbnNmZXJfdGlja2V0JyxcbiAgICAgICAgJ3VwZGF0ZV9jb25zZW5zdXNfa2V5JyxcbiAgICAgICAgJ3NtYXJ0X3JvbGx1cF9hZGRfbWVzc2FnZXMnLFxuICAgICAgICAnc21hcnRfcm9sbHVwX29yaWdpbmF0ZScsXG4gICAgXS5pbmRleE9mKG9wLmtpbmQpICE9PSAtMSk7XG59O1xuY29uc3QgaXNPcFJlcXVpcmVSZXZlYWwgPSAob3ApID0+IHtcbiAgICByZXR1cm4gKFtcbiAgICAgICAgJ3RyYW5zYWN0aW9uJyxcbiAgICAgICAgJ2RlbGVnYXRpb24nLFxuICAgICAgICAnb3JpZ2luYXRpb24nLFxuICAgICAgICAncmVnaXN0ZXJfZ2xvYmFsX2NvbnN0YW50JyxcbiAgICAgICAgJ2luY3JlYXNlX3BhaWRfc3RvcmFnZScsXG4gICAgICAgICd0cmFuc2Zlcl90aWNrZXQnLFxuICAgICAgICAndXBkYXRlX2NvbnNlbnN1c19rZXknLFxuICAgICAgICAnc21hcnRfcm9sbHVwX2FkZF9tZXNzYWdlcycsXG4gICAgICAgICdzbWFydF9yb2xsdXBfb3JpZ2luYXRlJyxcbiAgICBdLmluZGV4T2Yob3Aua2luZCkgIT09IC0xKTtcbn07XG5jb25zdCBoYXNNZXRhZGF0YSA9IChvcCkgPT4ge1xuICAgIHJldHVybiAnbWV0YWRhdGEnIGluIG9wO1xufTtcbmNvbnN0IGhhc01ldGFkYXRhV2l0aFJlc3VsdCA9IChvcCkgPT4ge1xuICAgIHJldHVybiBoYXNNZXRhZGF0YShvcCkgJiYgJ29wZXJhdGlvbl9yZXN1bHQnIGluIG9wLm1ldGFkYXRhO1xufTtcbmNvbnN0IGhhc01ldGFkYXRhV2l0aEludGVybmFsT3BlcmF0aW9uUmVzdWx0ID0gKG9wKSA9PiB7XG4gICAgcmV0dXJuIGhhc01ldGFkYXRhKG9wKSAmJiAnaW50ZXJuYWxfb3BlcmF0aW9uX3Jlc3VsdHMnIGluIG9wLm1ldGFkYXRhO1xufTtcblxuY29uc3QgaXNFcnJvcldpdGhNZXNzYWdlID0gKGVycm9yKSA9PiB7XG4gICAgcmV0dXJuICd3aXRoJyBpbiBlcnJvcjtcbn07XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gR2VuZXJpYyB0ZXpvcyBlcnJvciB0aGF0IHdpbGwgYmUgdGhyb3duIHdoZW4gYSBtaXN0YWtlIG9jY3VycyB3aGVuIGRvaW5nIGFuIG9wZXJhdGlvbjsgbW9yZSBkZXRhaWxzIGhlcmUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL2Vycm9ycy5odG1sXG4gKi9cbmNsYXNzIFRlem9zT3BlcmF0aW9uRXJyb3IgZXh0ZW5kcyBScGNFcnJvciB7XG4gICAgY29uc3RydWN0b3IoZXJyb3JzLCBlcnJvckRldGFpbHMsIG9wZXJhdGlvbnNXaXRoUmVzdWx0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgdGhpcy5lcnJvckRldGFpbHMgPSBlcnJvckRldGFpbHM7XG4gICAgICAgIHRoaXMub3BlcmF0aW9uc1dpdGhSZXN1bHRzID0gb3BlcmF0aW9uc1dpdGhSZXN1bHRzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVGV6b3NPcGVyYXRpb25FcnJvcic7XG4gICAgICAgIC8vIExhc3QgZXJyb3IgaXMgJ29mdGVuJyB0aGUgb25lIHdpdGggbW9yZSBkZXRhaWxcbiAgICAgICAgdGhpcy5sYXN0RXJyb3IgPSBlcnJvcnNbZXJyb3JzLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgKCR7dGhpcy5raW5kfSkgJHt0aGlzLmlkfWA7XG4gICAgICAgIGlmIChpc0Vycm9yV2l0aE1lc3NhZ2UodGhpcy5sYXN0RXJyb3IpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5sYXN0RXJyb3Iud2l0aC5zdHJpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmxhc3RFcnJvci53aXRoLnN0cmluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubGFzdEVycm9yLndpdGguaW50KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXNzYWdlID0gdGhpcy5sYXN0RXJyb3Iud2l0aC5pbnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeSh0aGlzLmxhc3RFcnJvci53aXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RFcnJvci5pZDtcbiAgICB9XG4gICAgZ2V0IGtpbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxhc3RFcnJvci5raW5kO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBUZXpvcyBlcnJvciB0aGF0IHdpbGwgYmUgdGhyb3duIHdoZW4gYSBtaXN0YWtlIGhhcHBlbnMgZHVyaW5nIHRoZSBwcmVhcHBseSBzdGFnZVxuICovXG5jbGFzcyBUZXpvc1ByZWFwcGx5RmFpbHVyZUVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKHJlc3VsdCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Rlem9zUHJlYXBwbHlGYWlsdXJlRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnUHJlYXBwbHkgcmV0dXJuZWQgYW4gdW5leHBlY3RlZCByZXN1bHQnO1xuICAgIH1cbn1cbi8vIEZsYXR0ZW4gYWxsIG9wZXJhdGlvbiBjb250ZW50IHJlc3VsdHMgYW5kIGludGVybmFsIG9wZXJhdGlvbiByZXN1bHRzIGludG8gYSBzaW5nbGUgYXJyYXlcbi8vIFNvbWUgY2FzZXMgd2hlcmUgd2UgY2FuIGhhdmUgbXVsdGlwbGUgb3BlcmF0aW9uIHJlc3VsdHMgb3IgaW50ZXJuYWwgb3BlcmF0aW9uIHJlc3VsdHMgYXJlOlxuLy8gLSBXaGVuIGFuIG9wZXJhdGlvbiBpbmNsdWRlcyBhIHJldmVhbCBvcGVyYXRpb25cbi8vIC0gV2hlbiBhbiBvcGVyYXRpb24gaXMgbWFkZSB1c2luZyB0aGUgYmF0Y2ggQVBJXG4vLyAtIFNtYXJ0IGNvbnRyYWN0IGNhbGwgY2FuIGNvbnRhaW5zIGludGVybmFsIG9wZXJhdGlvbiByZXN1bHRzIHdoZW4gdGhleSBjYWxsIG90aGVyIHNtYXJ0IGNvbnRyYWN0IGludGVybmFsbHkgb3Igb3JpZ2luYXRlIGNvbnRyYWN0c1xuY29uc3QgZmxhdHRlbk9wZXJhdGlvblJlc3VsdCA9IChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSA/IHJlc3BvbnNlIDogW3Jlc3BvbnNlXTtcbiAgICBjb25zdCByZXR1cm5lZFJlc3VsdHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHRzW2ldLmNvbnRlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmVzdWx0c1tpXS5jb250ZW50c1tqXTtcbiAgICAgICAgICAgIGlmIChoYXNNZXRhZGF0YVdpdGhSZXN1bHQoY29udGVudCkgJiYgJ2ZlZScgaW4gY29udGVudCkge1xuICAgICAgICAgICAgICAgIHJldHVybmVkUmVzdWx0cy5wdXNoKE9iamVjdC5hc3NpZ24oeyBmZWU6IGNvbnRlbnQuZmVlIH0sIGNvbnRlbnQubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdCkpO1xuICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbnRlbnQubWV0YWRhdGEuaW50ZXJuYWxfb3BlcmF0aW9uX3Jlc3VsdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQubWV0YWRhdGEuaW50ZXJuYWxfb3BlcmF0aW9uX3Jlc3VsdHMuZm9yRWFjaCgoeCkgPT4gcmV0dXJuZWRSZXN1bHRzLnB1c2goeC5yZXN1bHQpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJldHVybmVkUmVzdWx0cztcbn07XG4vKioqXG4gKiBAZGVzY3JpcHRpb24gRmxhdHRlbiBhbGwgZXJyb3IgZnJvbSBwcmVhcHBseSByZXNwb25zZSAoaW5jbHVkaW5nIGludGVybmFsIGVycm9yKVxuICovXG5jb25zdCBmbGF0dGVuRXJyb3JzID0gKHJlc3BvbnNlLCBzdGF0dXMgPSAnZmFpbGVkJykgPT4ge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBBcnJheS5pc0FycmF5KHJlc3BvbnNlKSA/IHJlc3BvbnNlIDogW3Jlc3BvbnNlXTtcbiAgICBsZXQgZXJyb3JzID0gW107XG4gICAgLy8gVHJhbnNhY3Rpb24gdGhhdCBkbyBub3QgZmFpbCB3aWxsIGJlIGJhY2t0cmFja2VkIGluIGNhc2Ugb25lIGZhaWx1cmUgb2NjdXJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCByZXN1bHRzW2ldLmNvbnRlbnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcmVzdWx0c1tpXS5jb250ZW50c1tqXTtcbiAgICAgICAgICAgIGlmIChoYXNNZXRhZGF0YShjb250ZW50KSkge1xuICAgICAgICAgICAgICAgIGlmIChoYXNNZXRhZGF0YVdpdGhSZXN1bHQoY29udGVudCkgJiZcbiAgICAgICAgICAgICAgICAgICAgY29udGVudC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0LnN0YXR1cyA9PT0gc3RhdHVzKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoY29udGVudC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0LmVycm9ycyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChoYXNNZXRhZGF0YVdpdGhJbnRlcm5hbE9wZXJhdGlvblJlc3VsdChjb250ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICBBcnJheS5pc0FycmF5KGNvbnRlbnQubWV0YWRhdGEuaW50ZXJuYWxfb3BlcmF0aW9uX3Jlc3VsdHMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZXN1bHQgb2YgY29udGVudC5tZXRhZGF0YS5pbnRlcm5hbF9vcGVyYXRpb25fcmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCdyZXN1bHQnIGluIGludGVybmFsUmVzdWx0ICYmIGludGVybmFsUmVzdWx0LnJlc3VsdC5zdGF0dXMgPT09IHN0YXR1cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9ycyA9IGVycm9ycy5jb25jYXQoaW50ZXJuYWxSZXN1bHQucmVzdWx0LmVycm9ycyB8fCBbXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGVycm9ycztcbn07XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYSBnZW5lcmFsIGZhaWx1cmUgaGFwcGVuaW5nIGR1cmluZyBhbiBvcmlnaW5hdGlvbiBvcGVyYXRpb24uXG4gKi9cbmNsYXNzIE9yaWdpbmF0aW9uT3BlcmF0aW9uRXJyb3IgZXh0ZW5kcyBUYXF1aXRvRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ09yaWdpbmF0aW9uT3BlcmF0aW9uRXJyb3InO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBhbiBpbnZhbGlkIGVzdGltYXRlIHZhbHVlIGJlaW5nIHBhc3NlZFxuICovXG5jbGFzcyBJbnZhbGlkRXN0aW1hdGVWYWx1ZUVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkRXN0aW1hdGVWYWx1ZUVycm9yJztcbiAgICB9XG59XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBpbnZhbGlkIGNvbmZpcm1hdGlvbiBjb3VudCBoYXMgYmVlbiBwYXNzZWQgb3IgY29uZmlndXJlZFxuICovXG5jbGFzcyBJbnZhbGlkQ29uZmlybWF0aW9uQ291bnRFcnJvciBleHRlbmRzIFBhcmFtZXRlclZhbGlkYXRpb25FcnJvciB7XG4gICAgY29uc3RydWN0b3IoaW52YWxpZENvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pbnZhbGlkQ29uZmlybWF0aW9ucyA9IGludmFsaWRDb25maXJtYXRpb25zO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZENvbmZpcm1hdGlvbkNvdW50RXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgSW52YWxpZCBjb25maXJtYXRpb24gY291bnQgJHtpbnZhbGlkQ29uZmlybWF0aW9uc30gZXhwZWN0aW5nIGF0IGxlYXN0IDFgO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyB0aGF0IGNvbmZpcm1hdGlvbiBwb2xsaW5nIHRpbWVkIG91dFxuICovXG5jbGFzcyBDb25maXJtYXRpb25UaW1lb3V0RXJyb3IgZXh0ZW5kcyBOZXR3b3JrRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0NvbmZpcm1hdGlvblRpbWVvdXRFcnJvcic7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGFuIGVycm9yIGJlaW5nIHJldHVybmVkIGZyb20gdGhlIFJQQyByZXNwb25zZVxuICovXG5jbGFzcyBSUENSZXNwb25zZUVycm9yIGV4dGVuZHMgUnBjRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UsIGNhdXNlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JQQ1Jlc3BvbnNlRXJyb3InO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVXRpbGl0eSBjbGFzcyB0byBpbnRlcmFjdCB3aXRoIFRlem9zIG9wZXJhdGlvbnNcbiAqL1xuY2xhc3MgT3BlcmF0aW9uIHtcbiAgICBnZXQgaW5jbHVkZWRJbkJsb2NrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm91bmRBdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaGFzaCBPcGVyYXRpb24gaGFzaFxuICAgICAqIEBwYXJhbSByYXcgUmF3IG9wZXJhdGlvbiB0aGF0IHdhcyBpbmplY3RlZFxuICAgICAqIEBwYXJhbSBjb250ZXh0IFRhcXVpdG8gY29udGV4dCBhbGxvd2luZyBhY2Nlc3MgdG8gcnBjIGFuZCBzaWduZXJcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkT3BlcmF0aW9uSGFzaEVycm9yfVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCkge1xuICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB0aGlzLnJhdyA9IHJhdztcbiAgICAgICAgdGhpcy5yZXN1bHRzID0gcmVzdWx0cztcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5fcG9sbGluZ0NvbmZpZyQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbiAgICAgICAgdGhpcy5jdXJyZW50SGVhZCQgPSB0aGlzLl9wb2xsaW5nQ29uZmlnJC5waXBlKHN3aXRjaE1hcCgoY29uZmlnKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJlaGF2aW9yU3ViamVjdChjb25maWcpLnBpcGUodGltZW91dCh7XG4gICAgICAgICAgICAgICAgZWFjaDogY29uZmlnLnRpbWVvdXQgKiAxMDAwLFxuICAgICAgICAgICAgICAgIHdpdGg6ICgpID0+IHRocm93RXJyb3IoKCkgPT4gbmV3IENvbmZpcm1hdGlvblRpbWVvdXRFcnJvcihgQ29uZmlybWF0aW9uIHBvbGxpbmcgdGltZWQgb3V0YCkpLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KSwgc3dpdGNoTWFwKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkZWZlcigoKSA9PiBjcmVhdGVPYnNlcnZhYmxlRnJvbVN1YnNjcmlwdGlvbih0aGlzLmNvbnRleHQuc3RyZWFtLnN1YnNjcmliZUJsb2NrKCdoZWFkJykpKS5waXBlKHN3aXRjaE1hcCgobmV3SGVhZCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJldkhlYWQgPSAoX2IgPSAoX2EgPSB0aGlzLmxhc3RIZWFkKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaGVhZGVyLmxldmVsKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBuZXdIZWFkLmhlYWRlci5sZXZlbCAtIDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJhbmdlKHByZXZIZWFkICsgMSwgbmV3SGVhZC5oZWFkZXIubGV2ZWwgLSBwcmV2SGVhZCAtIDEpLnBpcGUoY29uY2F0TWFwKChsZXZlbCkgPT4gdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRCbG9jayhsZXZlbCkpLCBlbmRXaXRoKG5ld0hlYWQpKTtcbiAgICAgICAgICAgIH0pLCB0YXAoKG5ld0hlYWQpID0+ICh0aGlzLmxhc3RIZWFkID0gbmV3SGVhZCkpKTtcbiAgICAgICAgfSksIHNoYXJlUmVwbGF5KHsgcmVmQ291bnQ6IHRydWUgfSkpO1xuICAgICAgICAvLyBPYnNlcnZhYmxlIHRoYXQgZW1pdCBvbmNlIG9wZXJhdGlvbiBpcyBzZWVuIGluIGEgYmxvY2tcbiAgICAgICAgdGhpcy5jb25maXJtZWQkID0gdGhpcy5jdXJyZW50SGVhZCQucGlwZShtYXAoKGhlYWQpID0+IHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgICAgIGhlYWQub3BlcmF0aW9uc1tpXS5mb3JFYWNoKChvcCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAob3AuaGFzaCA9PT0gdGhpcy5oYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3VuZEF0ID0gaGVhZC5oZWFkZXIubGV2ZWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoZWFkLmhlYWRlci5sZXZlbCAtIHRoaXMuX2ZvdW5kQXQgPj0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mb3VuZEF0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgZmlsdGVyKCh4KSA9PiB4ICE9PSB1bmRlZmluZWQpLCBmaXJzdCgpLCBzaGFyZVJlcGxheSgpKTtcbiAgICAgICAgdGhpcy5fZm91bmRBdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcbiAgICAgICAgaWYgKHZhbGlkYXRlT3BlcmF0aW9uKHRoaXMuaGFzaCkgIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3BlcmF0aW9uSGFzaEVycm9yKHRoaXMuaGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maXJtZWQkXG4gICAgICAgICAgICAucGlwZShmaXJzdCgpLCBjYXRjaEVycm9yKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBvZihFTVBUWSk7XG4gICAgICAgIH0pKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBnZXQgcmV2ZWFsT3BlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gKEFycmF5LmlzQXJyYXkodGhpcy5yZXN1bHRzKSAmJlxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSAncmV2ZWFsJykpO1xuICAgIH1cbiAgICBnZXQgcmV2ZWFsU3RhdHVzKCkge1xuICAgICAgICBpZiAodGhpcy5yZXZlYWxPcGVyYXRpb24pIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJldmVhbE9wZXJhdGlvbi5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0LnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlc3VsdHMubWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGlmIChoYXNNZXRhZGF0YVdpdGhSZXN1bHQocmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdC5zdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVswXSB8fCAndW5rbm93bicpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maXJtYXRpb25zIFswXSBOdW1iZXIgb2YgY29uZmlybWF0aW9uIHRvIHdhaXQgZm9yXG4gICAgICogQHBhcmFtIHRpbWVvdXQgWzE4MF0gVGltZW91dFxuICAgICAqL1xuICAgIGNvbmZpcm1hdGlvbihjb25maXJtYXRpb25zLCB0aW1lb3V0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbmZpcm1hdGlvbnMgIT09ICd1bmRlZmluZWQnICYmIGNvbmZpcm1hdGlvbnMgPCAxKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb25maXJtYXRpb25Db3VudEVycm9yKGNvbmZpcm1hdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyBkZWZhdWx0Q29uZmlybWF0aW9uQ291bnQsIGNvbmZpcm1hdGlvblBvbGxpbmdUaW1lb3V0U2Vjb25kIH0gPSB0aGlzLmNvbnRleHQuY29uZmlnO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGluZ0NvbmZpZyQubmV4dCh7XG4gICAgICAgICAgICAgICAgdGltZW91dDogdGltZW91dCB8fCBjb25maXJtYXRpb25Qb2xsaW5nVGltZW91dFNlY29uZCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29uZiA9IGNvbmZpcm1hdGlvbnMgIT09IHVuZGVmaW5lZCA/IGNvbmZpcm1hdGlvbnMgOiBkZWZhdWx0Q29uZmlybWF0aW9uQ291bnQ7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuY29uZmlybWVkJFxuICAgICAgICAgICAgICAgICAgICAucGlwZShzd2l0Y2hNYXAoKCkgPT4gdGhpcy5jdXJyZW50SGVhZCQpLCBmaWx0ZXIoKGhlYWQpID0+IGhlYWQuaGVhZGVyLmxldmVsIC0gdGhpcy5fZm91bmRBdCA+PSBjb25mIC0gMSksIGZpcnN0KCkpXG4gICAgICAgICAgICAgICAgICAgIC5zdWJzY3JpYmUoKF8pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLl9mb3VuZEF0ICsgKGNvbmYgLSAxKSk7XG4gICAgICAgICAgICAgICAgfSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIEJhdGNoT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBwYXJhbXMsIHNvdXJjZSwgcmF3LCByZXN1bHRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgc3VtUHJvcChhcnIsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wIGluIGN1cnJlbnQgPyBOdW1iZXIoY3VycmVudFtwcm9wXSkgKyBwcmV2IDogcHJldjtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGdldE9yaWdpbmF0ZWRDb250cmFjdEFkZHJlc3NlcygpIHtcbiAgICAgICAgY29uc3Qgb3JpZ2luYXRpb25PcFJlc3VsdHMgPSB0aGlzLnJlc3VsdHMuZmlsdGVyKCh4KSA9PiB4LmtpbmQgPT09ICdvcmlnaW5hdGlvbicpO1xuICAgICAgICBsZXQgYWRkcmVzc2VzID0gW107XG4gICAgICAgIGZvciAoY29uc3QgcmVzIG9mIG9yaWdpbmF0aW9uT3BSZXN1bHRzKSB7XG4gICAgICAgICAgICBpZiAocmVzLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQub3JpZ2luYXRlZF9jb250cmFjdHMpIHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzZXMgPSBbLi4uYWRkcmVzc2VzLCAuLi5yZXMubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdC5vcmlnaW5hdGVkX2NvbnRyYWN0c107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3NlcztcbiAgICB9XG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnJlc3VsdHNcbiAgICAgICAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gQkFUQ0hfS0lORFMuaW5kZXhPZihyZXN1bHQua2luZCkgIT09IC0xKVxuICAgICAgICAgICAgLm1hcCgocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICBpZiAoaGFzTWV0YWRhdGFXaXRoUmVzdWx0KHJlc3VsdCkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcFJlc3VsdCA9IHJlc3VsdC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0O1xuICAgICAgICAgICAgICAgIHJldHVybiBvcFJlc3VsdC5zdGF0dXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KVswXSB8fCAndW5rbm93bicpO1xuICAgIH1cbiAgICBnZXQgZmVlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdW1Qcm9wKHRoaXMucGFyYW1zLCAnZmVlJyk7XG4gICAgfVxuICAgIGdldCBnYXNMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3VtUHJvcCh0aGlzLnBhcmFtcywgJ2dhc19saW1pdCcpO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZUxpbWl0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdW1Qcm9wKHRoaXMucGFyYW1zLCAnc3RvcmFnZV9saW1pdCcpO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRHYXMoKSB7XG4gICAgICAgIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUzogMCwgUk9VTkRJTkdfTU9ERTogQmlnTnVtYmVyLlJPVU5EX1VQIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih0aGlzLmNvbnN1bWVkTWlsbGlHYXMpLmRpdmlkZWRCeSgxMDAwKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRNaWxsaUdhcygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnN1bVByb3AoZmxhdHRlbk9wZXJhdGlvblJlc3VsdCh7IGNvbnRlbnRzOiB0aGlzLnJlc3VsdHMgfSksICdjb25zdW1lZF9taWxsaWdhcycpKTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VEaWZmKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3VtUHJvcChmbGF0dGVuT3BlcmF0aW9uUmVzdWx0KHsgY29udGVudHM6IHRoaXMucmVzdWx0cyB9KSwgJ3BhaWRfc3RvcmFnZV9zaXplX2RpZmYnKSk7XG4gICAgfVxuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiBmbGF0dGVuRXJyb3JzKHsgY29udGVudHM6IHRoaXMucmVzdWx0cyB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFByb3ZpZGVyIHtcbiAgICBnZXQgcnBjKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJwYztcbiAgICB9XG4gICAgZ2V0IHNpZ25lcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zaWduZXI7XG4gICAgfVxuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgZm9yZ2UoeyBvcE9iOiB7IGJyYW5jaCwgY29udGVudHMsIHByb3RvY29sIH0sIGNvdW50ZXIgfSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZm9yZ2VkQnl0ZXMgPSB5aWVsZCB0aGlzLmNvbnRleHQuZm9yZ2VyLmZvcmdlKHsgYnJhbmNoLCBjb250ZW50cyB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BieXRlczogZm9yZ2VkQnl0ZXMsXG4gICAgICAgICAgICAgICAgb3BPYjoge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2gsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXN0aW1hdGUoX2EsIGVzdGltYXRvcikge1xuICAgICAgICB2YXIgeyBmZWUsIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJmZWVcIiwgXCJnYXNMaW1pdFwiLCBcInN0b3JhZ2VMaW1pdFwiXSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgY2FsY3VsYXRlZEZlZSA9IGZlZTtcbiAgICAgICAgICAgIGxldCBjYWxjdWxhdGVkR2FzID0gZ2FzTGltaXQ7XG4gICAgICAgICAgICBsZXQgY2FsY3VsYXRlZFN0b3JhZ2UgPSBzdG9yYWdlTGltaXQ7XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlZEZlZSAmJiBjYWxjdWxhdGVkRmVlICUgMSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRXN0aW1hdGVWYWx1ZUVycm9yKGBGZWUgdmFsdWUgbXVzdCBub3QgYmUgYSBkZWNpbWFsOiAke2NhbGN1bGF0ZWRGZWV9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlZEdhcyAmJiBjYWxjdWxhdGVkR2FzICUgMSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRXN0aW1hdGVWYWx1ZUVycm9yKGBHYXMgTGltaXQgdmFsdWUgbXVzdCBub3QgYmUgYSBkZWNpbWFsOiAke2NhbGN1bGF0ZWRHYXN9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlZFN0b3JhZ2UgJiYgY2FsY3VsYXRlZFN0b3JhZ2UgJSAxICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRFc3RpbWF0ZVZhbHVlRXJyb3IoYFN0b3JhZ2UgTGltaXQgdmFsdWUgbXVzdCBub3QgYmUgYSBkZWNpbWFsOiAke2NhbGN1bGF0ZWRTdG9yYWdlfWApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZlZSA9PT0gdW5kZWZpbmVkIHx8IGdhc0xpbWl0ID09PSB1bmRlZmluZWQgfHwgc3RvcmFnZUxpbWl0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0aW9uID0geWllbGQgZXN0aW1hdG9yKE9iamVjdC5hc3NpZ24oeyBmZWUsIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgfSwgcmVzdCkpO1xuICAgICAgICAgICAgICAgIGNhbGN1bGF0ZWRGZWUgIT09IG51bGwgJiYgY2FsY3VsYXRlZEZlZSAhPT0gdm9pZCAwID8gY2FsY3VsYXRlZEZlZSA6IChjYWxjdWxhdGVkRmVlID0gZXN0aW1hdGlvbi5zdWdnZXN0ZWRGZWVNdXRleik7XG4gICAgICAgICAgICAgICAgY2FsY3VsYXRlZEdhcyAhPT0gbnVsbCAmJiBjYWxjdWxhdGVkR2FzICE9PSB2b2lkIDAgPyBjYWxjdWxhdGVkR2FzIDogKGNhbGN1bGF0ZWRHYXMgPSBlc3RpbWF0aW9uLmdhc0xpbWl0KTtcbiAgICAgICAgICAgICAgICBjYWxjdWxhdGVkU3RvcmFnZSAhPT0gbnVsbCAmJiBjYWxjdWxhdGVkU3RvcmFnZSAhPT0gdm9pZCAwID8gY2FsY3VsYXRlZFN0b3JhZ2UgOiAoY2FsY3VsYXRlZFN0b3JhZ2UgPSBlc3RpbWF0aW9uLnN0b3JhZ2VMaW1pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZlZTogY2FsY3VsYXRlZEZlZSxcbiAgICAgICAgICAgICAgICBnYXNMaW1pdDogY2FsY3VsYXRlZEdhcyxcbiAgICAgICAgICAgICAgICBzdG9yYWdlTGltaXQ6IGNhbGN1bGF0ZWRTdG9yYWdlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJQQ09wKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5UUkFOU0FDVElPTjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVRyYW5zZmVyT3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuT1JJR0lOQVRJT046XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVPcmlnaW5hdGlvbk9wZXJhdGlvbih5aWVsZCB0aGlzLmNvbnRleHQucGFyc2VyLnByZXBhcmVDb2RlT3JpZ2luYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW0pKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuREVMRUdBVElPTjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNldERlbGVnYXRlT3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuUkVHSVNURVJfR0xPQkFMX0NPTlNUQU5UOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlUmVnaXN0ZXJHbG9iYWxDb25zdGFudE9wZXJhdGlvbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLklOQ1JFQVNFX1BBSURfU1RPUkFHRTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZUluY3JlYXNlUGFpZFN0b3JhZ2VPcGVyYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW0pKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5UUkFOU0ZFUl9USUNLRVQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2ZlclRpY2tldE9wZXJhdGlvbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlNNQVJUX1JPTExVUF9BRERfTUVTU0FHRVM6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTbWFydFJvbGx1cEFkZE1lc3NhZ2VzT3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuU01BUlRfUk9MTFVQX09SSUdJTkFURTpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVNtYXJ0Um9sbHVwT3JpZ2luYXRlT3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25LaW5kRXJyb3IocGFyYW0ua2luZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBydW5PcGVyYXRpb24ob3ApIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BSZXNwb25zZTogeWllbGQgdGhpcy5ycGMucnVuT3BlcmF0aW9uKG9wKSxcbiAgICAgICAgICAgICAgICBvcCxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB0aGlzLmNvbnRleHQuY2xvbmUoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzaW11bGF0ZShvcCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcFJlc3BvbnNlOiB5aWVsZCB0aGlzLnJwYy5zaW11bGF0ZU9wZXJhdGlvbihvcCksXG4gICAgICAgICAgICAgICAgb3AsXG4gICAgICAgICAgICAgICAgY29udGV4dDogdGhpcy5jb250ZXh0LmNsb25lKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNSZXZlYWxPcE5lZWRlZChvcCwgcGtoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gISh5aWVsZCB0aGlzLmlzQWNjb3VudFJldmVhbFJlcXVpcmVkKHBraCkpIHx8ICF0aGlzLmlzUmV2ZWFsUmVxdWlyZWRGb3JPcFR5cGUob3ApXG4gICAgICAgICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgICAgICAgIDogdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzQWNjb3VudFJldmVhbFJlcXVpcmVkKHB1YmxpY0tleUhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiAhKHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuaXNBY2NvdW50UmV2ZWFsZWQocHVibGljS2V5SGFzaCwgJ2hlYWQnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBpc1JldmVhbFJlcXVpcmVkRm9yT3BUeXBlKG9wKSB7XG4gICAgICAgIGxldCBvcFJlcXVpcmVSZXZlYWwgPSBmYWxzZTtcbiAgICAgICAgZm9yIChjb25zdCBvcGVyYXRpb24gb2Ygb3ApIHtcbiAgICAgICAgICAgIGlmIChpc09wUmVxdWlyZVJldmVhbChvcGVyYXRpb24pKSB7XG4gICAgICAgICAgICAgICAgb3BSZXF1aXJlUmV2ZWFsID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BSZXF1aXJlUmV2ZWFsO1xuICAgIH1cbiAgICBzaWduQW5kSW5qZWN0KGZvcmdlZEJ5dGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduZWQgPSB5aWVsZCB0aGlzLnNpZ25lci5zaWduKGZvcmdlZEJ5dGVzLm9wYnl0ZXMsIG5ldyBVaW50OEFycmF5KFszXSkpO1xuICAgICAgICAgICAgZm9yZ2VkQnl0ZXMub3BieXRlcyA9IHNpZ25lZC5zYnl0ZXM7XG4gICAgICAgICAgICBmb3JnZWRCeXRlcy5vcE9iLnNpZ25hdHVyZSA9IHNpZ25lZC5wcmVmaXhTaWc7XG4gICAgICAgICAgICBjb25zdCBvcFJlc3BvbnNlID0gW107XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgdGhpcy5ycGMucHJlYXBwbHlPcGVyYXRpb25zKFtmb3JnZWRCeXRlcy5vcE9iXSk7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVGV6b3NQcmVhcHBseUZhaWx1cmVFcnJvcihyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgcmVzdWx0c1tpXS5jb250ZW50cy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBvcFJlc3BvbnNlLnB1c2gocmVzdWx0c1tpXS5jb250ZW50c1tqXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXJyb3JzID0gZmxhdHRlbkVycm9ycyhyZXN1bHRzKTtcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRlem9zT3BlcmF0aW9uRXJyb3IoZXJyb3JzLCAnRXJyb3Igb2NjdXJyZWQgZHVyaW5nIHZhbGlkYXRpb24gc2ltdWxhdGlvbiBvZiBvcGVyYXRpb24nLCBvcFJlc3BvbnNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgaGFzaDogeWllbGQgdGhpcy5jb250ZXh0LmluamVjdG9yLmluamVjdChmb3JnZWRCeXRlcy5vcGJ5dGVzKSxcbiAgICAgICAgICAgICAgICBmb3JnZWRCeXRlcyxcbiAgICAgICAgICAgICAgICBvcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHRoaXMuY29udGV4dC5jbG9uZSgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBXYWxsZXRPcGVyYXRpb25CYXRjaCB7XG4gICAgY29uc3RydWN0b3Iod2FsbGV0UHJvdmlkZXIsIGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy53YWxsZXRQcm92aWRlciA9IHdhbGxldFByb3ZpZGVyO1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMgPSBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGEgdHJhbnNhY3Rpb24gb3BlcmF0aW9uIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUcmFuc2ZlciBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgd2l0aFRyYW5zZmVyKHBhcmFtcykge1xuICAgICAgICBjb25zdCB0b1ZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MocGFyYW1zLnRvKTtcbiAgICAgICAgaWYgKHRvVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IocGFyYW1zLnRvLCBpbnZhbGlkRGV0YWlsKHRvVmFsaWRhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKE9iamVjdC5hc3NpZ24oeyBraW5kOiBPcEtpbmQuVFJBTlNBQ1RJT04gfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYSBjb250cmFjdCBjYWxsIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBDYWxsIGEgY29udHJhY3QgbWV0aG9kXG4gICAgICogQHBhcmFtIG9wdGlvbnMgR2VuZXJpYyBvcGVyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIHdpdGhDb250cmFjdENhbGwocGFyYW1zLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2l0aFRyYW5zZmVyKHBhcmFtcy50b1RyYW5zZmVyUGFyYW1zKG9wdGlvbnMpKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGEgZGVsZWdhdGlvbiBvcGVyYXRpb24gdG8gdGhlIGJhdGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIERlbGVnYXRpb24gb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHdpdGhEZWxlZ2F0aW9uKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcygoX2EgPSBwYXJhbXMuZGVsZWdhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgaWYgKHBhcmFtcy5kZWxlZ2F0ZSAmJiBkZWxlZ2F0ZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHBhcmFtcy5kZWxlZ2F0ZSwgaW52YWxpZERldGFpbChkZWxlZ2F0ZVZhbGlkYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsga2luZDogT3BLaW5kLkRFTEVHQVRJT04gfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYW4gb3JpZ2luYXRpb24gb3BlcmF0aW9uIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBPcmlnaW5hdGlvbiBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgd2l0aE9yaWdpbmF0aW9uKHBhcmFtcykge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsga2luZDogT3BLaW5kLk9SSUdJTkFUSU9OIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGFuIEluY3JlYXNlUGFpZFN0b3JhZ2Ugb3BlcmF0aW9uIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtIEluY3JlYXNlUGFpZFN0b3JhZ2Ugb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHdpdGhJbmNyZWFzZVBhaWRTdG9yYWdlKHBhcmFtcykge1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvblZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MocGFyYW1zLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IocGFyYW1zLmRlc3RpbmF0aW9uLCBpbnZhbGlkRGV0YWlsKGRlc3RpbmF0aW9uVmFsaWRhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKE9iamVjdC5hc3NpZ24oeyBraW5kOiBPcEtpbmQuSU5DUkVBU0VfUEFJRF9TVE9SQUdFIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgbWFwT3BlcmF0aW9uKHBhcmFtKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKHBhcmFtLmtpbmQpIHtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5UUkFOU0FDVElPTjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0UHJvdmlkZXIubWFwVHJhbnNmZXJQYXJhbXNUb1dhbGxldFBhcmFtcygoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBwYXJhbTsgfSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLk9SSUdJTkFUSU9OOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRQcm92aWRlci5tYXBPcmlnaW5hdGVQYXJhbXNUb1dhbGxldFBhcmFtcygoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnBhcnNlci5wcmVwYXJlQ29kZU9yaWdpbmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5ERUxFR0FUSU9OOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRQcm92aWRlci5tYXBEZWxlZ2F0ZVBhcmFtc1RvV2FsbGV0UGFyYW1zKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIHBhcmFtOyB9KSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuSU5DUkVBU0VfUEFJRF9TVE9SQUdFOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRQcm92aWRlci5tYXBJbmNyZWFzZVBhaWRTdG9yYWdlV2FsbGV0UGFyYW1zKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHsgcmV0dXJuIHBhcmFtOyB9KSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25LaW5kRXJyb3IkMShKU09OLnN0cmluZ2lmeShwYXJhbS5raW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYSBncm91cCBvcGVyYXRpb24gdG8gdGhlIGJhdGNoLiBPcGVyYXRpb24gd2lsbCBiZSBhcHBsaWVkIGluIHRoZSBvcmRlciB0aGV5IGFyZSBpbiB0aGUgcGFyYW1zIGFycmF5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIE9wZXJhdGlvbnMgcGFyYW1ldGVyXG4gICAgICogQHRocm93cyB7QGxpbmsgSW52YWxpZE9wZXJhdGlvbktpbmRFcnJvcn1cbiAgICAgKi9cbiAgICB3aXRoKHBhcmFtcykge1xuICAgICAgICBmb3IgKGNvbnN0IHBhcmFtIG9mIHBhcmFtcykge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbS5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuVFJBTlNBQ1RJT046XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2l0aFRyYW5zZmVyKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuT1JJR0lOQVRJT046XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2l0aE9yaWdpbmF0aW9uKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuREVMRUdBVElPTjpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aXRoRGVsZWdhdGlvbihwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLklOQ1JFQVNFX1BBSURfU1RPUkFHRTpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy53aXRoSW5jcmVhc2VQYWlkU3RvcmFnZShwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3BlcmF0aW9uS2luZEVycm9yJDEoSlNPTi5zdHJpbmdpZnkocGFyYW0ua2luZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJtaXQgYmF0Y2ggb3BlcmF0aW9uIHRvIHdhbGxldFxuICAgICAqXG4gICAgICovXG4gICAgc2VuZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBvcCBvZiB0aGlzLm9wZXJhdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBvcHMucHVzaCh5aWVsZCB0aGlzLm1hcE9wZXJhdGlvbihvcCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3BIYXNoID0geWllbGQgdGhpcy53YWxsZXRQcm92aWRlci5zZW5kT3BlcmF0aW9ucyhvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5vcGVyYXRpb25GYWN0b3J5LmNyZWF0ZUJhdGNoT3BlcmF0aW9uKG9wSGFzaCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFdhbGxldCB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICB0aGlzLndhbGxldENvbW1hbmQgPSAoc2VuZCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzZW5kLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZ2V0IHdhbGxldFByb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LndhbGxldFByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgdGhlIFBLSCBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhlIHdhbGxldFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbiBPcHRpb24gdG8gdXNlIHdoaWxlIGZldGNoaW5nIHRoZSBQS0guXG4gICAgICogSWYgZm9yY2VSZWZldGNoIGlzIHNwZWNpZmllZCB0aGUgd2FsbGV0IHByb3ZpZGVyIGltcGxlbWVudGF0aW9uIHdpbGwgcmVmZXRjaCB0aGUgUEtIIGZyb20gdGhlIHdhbGxldFxuICAgICAqL1xuICAgIHBraCh7IGZvcmNlUmVmZXRjaCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGtoIHx8IGZvcmNlUmVmZXRjaCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BraCA9IHlpZWxkIHRoaXMud2FsbGV0UHJvdmlkZXIuZ2V0UEtIKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGtoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHJpZXZlIHRoZSBQSyBvZiB0aGUgYWNjb3VudCB0aGF0IGlzIGN1cnJlbnRseSBpbiB1c2UgYnkgdGhlIHdhbGxldFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbiBPcHRpb24gdG8gdXNlIHdoaWxlIGZldGNoaW5nIHRoZSBQSy5cbiAgICAgKiBJZiBmb3JjZVJlZmV0Y2ggaXMgc3BlY2lmaWVkIHRoZSB3YWxsZXQgcHJvdmlkZXIgaW1wbGVtZW50YXRpb24gd2lsbCByZWZldGNoIHRoZSBQSyBmcm9tIHRoZSB3YWxsZXRcbiAgICAgKi9cbiAgICBwayh7IGZvcmNlUmVmZXRjaCB9ID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGsgfHwgZm9yY2VSZWZldGNoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGsgPSB5aWVsZCB0aGlzLndhbGxldFByb3ZpZGVyLmdldFBLKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcGs7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hdGUgYSBuZXcgY29udHJhY3QgYWNjb3JkaW5nIHRvIHRoZSBzY3JpcHQgaW4gcGFyYW1ldGVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9wZXJhdGlvbiBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IGZyb20gdGhlIHJwYyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3JpZ2luYXRlUGFyYW1zIE9yaWdpbmF0ZSBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgb3JpZ2luYXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRDb21tYW5kKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFBhcmFtcyA9IHlpZWxkIHRoaXMud2FsbGV0UHJvdmlkZXIubWFwT3JpZ2luYXRlUGFyYW1zVG9XYWxsZXRQYXJhbXMoKCkgPT4gdGhpcy5jb250ZXh0LnBhcnNlci5wcmVwYXJlQ29kZU9yaWdpbmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcykpKTtcbiAgICAgICAgICAgIGNvbnN0IG9wSGFzaCA9IHlpZWxkIHRoaXMud2FsbGV0UHJvdmlkZXIuc2VuZE9wZXJhdGlvbnMoW21hcHBlZFBhcmFtc10pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5vcGVyYXRpb25GYWN0b3J5LmNyZWF0ZU9yaWdpbmF0aW9uT3BlcmF0aW9uKG9wSGFzaCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0IHRoZSBkZWxlZ2F0ZSBmb3IgYSBjb250cmFjdC5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9wZXJhdGlvbiBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IGZyb20gdGhlIHJwYyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZGVsZWdhdGVQYXJhbXMgb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHNldERlbGVnYXRlKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGNvbnN0IGRlbGVnYXRlVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcygoX2EgPSBwYXJhbXMuZGVsZWdhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgaWYgKHBhcmFtcy5kZWxlZ2F0ZSAmJiBkZWxlZ2F0ZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHBhcmFtcy5kZWxlZ2F0ZSwgaW52YWxpZERldGFpbChkZWxlZ2F0ZVZhbGlkYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy53YWxsZXRDb21tYW5kKCgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hcHBlZFBhcmFtcyA9IHlpZWxkIHRoaXMud2FsbGV0UHJvdmlkZXIubWFwRGVsZWdhdGVQYXJhbXNUb1dhbGxldFBhcmFtcygoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7IHJldHVybiBwYXJhbXM7IH0pKTtcbiAgICAgICAgICAgIGNvbnN0IG9wSGFzaCA9IHlpZWxkIHRoaXMud2FsbGV0UHJvdmlkZXIuc2VuZE9wZXJhdGlvbnMoW21hcHBlZFBhcmFtc10pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5vcGVyYXRpb25GYWN0b3J5LmNyZWF0ZURlbGVnYXRpb25PcGVyYXRpb24ob3BIYXNoKTtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBmYWlsaW5nX25vb3Agb3BlcmF0aW9uIHRoYXQgaXMgZ3VhcmFudGVlZCB0byBmYWlsLiBESVNDTEFJTUVSOiBOb3QgYWxsIHdhbGxldHMgc3VwcG9ydCBzaWduaW5nIGZhaWxpbmdfbm9vcCBvcGVyYXRpb25zLlxuICAgICAqXG4gICAgICogQHJldHVybnMgU2lnbmF0dXJlIGZvciBhIGZhaWxpbmdfbm9vcFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgc2lnbkZhaWxpbmdOb29wKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICAgICAga2luZDogT3BLaW5kLkZBSUxJTkdfTk9PUCxcbiAgICAgICAgICAgICAgICBhcmJpdHJhcnk6IHBhcmFtcy5hcmJpdHJhcnksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0QmxvY2tIYXNoKHBhcmFtcy5iYXNlZE9uQmxvY2spO1xuICAgICAgICAgICAgY29uc3QgZm9yZ2VkQnl0ZXMgPSB5aWVsZCB0aGlzLmNvbnRleHQuZm9yZ2VyLmZvcmdlKHtcbiAgICAgICAgICAgICAgICBicmFuY2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgY29udGVudHM6IFtvcF0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHNpZ25hdHVyZSA9IHlpZWxkIHRoaXMud2FsbGV0UHJvdmlkZXIuc2lnbihmb3JnZWRCeXRlcywgVWludDhBcnJheS5mcm9tKFszXSkpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzaWduYXR1cmUsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IGZvcmdlZEJ5dGVzLFxuICAgICAgICAgICAgICAgIHNpZ25lZENvbnRlbnQ6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50czogW1xuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtpbmQ6IE9wS2luZC5GQUlMSU5HX05PT1AsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJiaXRyYXJ5OiBwYXJhbXMuYXJiaXRyYXJ5LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFJlZ2lzdGVyIHRoZSBjdXJyZW50IGFkZHJlc3MgYXMgZGVsZWdhdGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvcGVyYXRpb24gaGFuZGxlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBycGMgbm9kZVxuICAgICAqXG4gICAgICovXG4gICAgcmVnaXN0ZXJEZWxlZ2F0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0Q29tbWFuZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWRQYXJhbXMgPSB5aWVsZCB0aGlzLndhbGxldFByb3ZpZGVyLm1hcERlbGVnYXRlUGFyYW1zVG9XYWxsZXRQYXJhbXMoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlbGVnYXRlID0geWllbGQgdGhpcy5wa2goKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyBkZWxlZ2F0ZSB9O1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgY29uc3Qgb3BIYXNoID0geWllbGQgdGhpcy53YWxsZXRQcm92aWRlci5zZW5kT3BlcmF0aW9ucyhbbWFwcGVkUGFyYW1zXSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0Lm9wZXJhdGlvbkZhY3RvcnkuY3JlYXRlRGVsZWdhdGlvbk9wZXJhdGlvbihvcEhhc2gpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFRyYW5zZmVyIHRlem9zIHRva2VucyBmcm9tIGN1cnJlbnQgYWRkcmVzcyB0byBhIHNwZWNpZmljIGFkZHJlc3Mgb3IgY2FsbCBhIHNtYXJ0IGNvbnRyYWN0LlxuICAgICAqXG4gICAgICogQHJldHVybnMgQSB3YWxsZXQgY29tbWFuZCBmcm9tIHdoaWNoIHdlIGNhbiBzZW5kIHRoZSBvcGVyYXRpb24gdG8gdGhlIHdhbGxldFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgdHJhbnNmZXIocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHRvVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcyhwYXJhbXMudG8pO1xuICAgICAgICBpZiAodG9WYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMudG8sIGludmFsaWREZXRhaWwodG9WYWxpZGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0Q29tbWFuZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWRQYXJhbXMgPSB5aWVsZCB0aGlzLndhbGxldFByb3ZpZGVyLm1hcFRyYW5zZmVyUGFyYW1zVG9XYWxsZXRQYXJhbXMoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gcGFyYW1zOyB9KSk7XG4gICAgICAgICAgICBjb25zdCBvcEhhc2ggPSB5aWVsZCB0aGlzLndhbGxldFByb3ZpZGVyLnNlbmRPcGVyYXRpb25zKFttYXBwZWRQYXJhbXNdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQub3BlcmF0aW9uRmFjdG9yeS5jcmVhdGVUcmFuc2FjdGlvbk9wZXJhdGlvbihvcEhhc2gpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJuc1xuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtc1xuICAgICAqL1xuICAgIGluY3JlYXNlUGFpZFN0b3JhZ2UocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGRlc3RpbmF0aW9uVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcyhwYXJhbXMuZGVzdGluYXRpb24pO1xuICAgICAgICBpZiAoZGVzdGluYXRpb25WYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuZGVzdGluYXRpb24sIGludmFsaWREZXRhaWwoZGVzdGluYXRpb25WYWxpZGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMud2FsbGV0Q29tbWFuZCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBtYXBwZWRQYXJhbXMgPSB5aWVsZCB0aGlzLndhbGxldFByb3ZpZGVyLm1hcEluY3JlYXNlUGFpZFN0b3JhZ2VXYWxsZXRQYXJhbXMoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gcGFyYW1zOyB9KSk7XG4gICAgICAgICAgICBjb25zdCBvcEhhc2ggPSB5aWVsZCB0aGlzLndhbGxldFByb3ZpZGVyLnNlbmRPcGVyYXRpb25zKFttYXBwZWRQYXJhbXNdKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQub3BlcmF0aW9uRmFjdG9yeS5jcmVhdGVJbmNyZWFzZVBhaWRTdG9yYWdlT3BlcmF0aW9uKG9wSGFzaCk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgYmF0Y2ggb2Ygb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIGJhdGNoIG9iamVjdCBmcm9tIHdoaWNoIHdlIGNhbiBhZGQgbW9yZSBvcGVyYXRpb24gb3Igc2VuZCBhIGNvbW1hbmQgdG8gdGhlIHdhbGxldCB0byBleGVjdXRlIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBMaXN0IG9mIG9wZXJhdGlvbiB0byBpbml0aWFsaXplIHRoZSBiYXRjaCB3aXRoXG4gICAgICovXG4gICAgYmF0Y2gocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IFdhbGxldE9wZXJhdGlvbkJhdGNoKHRoaXMud2FsbGV0UHJvdmlkZXIsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtcykpIHtcbiAgICAgICAgICAgIGJhdGNoLndpdGgocGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmF0Y2g7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSBhbiBzbWFydCBjb250cmFjdCBhYnN0cmFjdGlvbiBmb3IgdGhlIGFkZHJlc3Mgc3BlY2lmaWVkLiBDYWxsaW5nIGVudHJ5cG9pbnRzIHdpdGggdGhlIHJldHVybmVkXG4gICAgICogc21hcnQgY29udHJhY3QgYWJzdHJhY3Rpb24gd2lsbCBsZXZlcmFnZSB0aGUgd2FsbGV0IHByb3ZpZGVyIHRvIG1ha2Ugc21hcnQgY29udHJhY3QgY2FsbHNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFNtYXJ0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3J9IElmIHRoZSBjb250cmFjdCBhZGRyZXNzIGlzIG5vdCB2YWxpZFxuICAgICAqL1xuICAgIGF0KGFkZHJlc3MsIGNvbnRyYWN0QWJzdHJhY3Rpb25Db21wb3NlciA9ICh4KSA9PiB4KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVmFsaWRhdGlvbiA9IHZhbGlkYXRlQ29udHJhY3RBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3NWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb250cmFjdEFkZHJlc3NFcnJvcihhZGRyZXNzLCBpbnZhbGlkRGV0YWlsKGFkZHJlc3NWYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBycGMgPSB0aGlzLmNvbnRleHQud2l0aEV4dGVuc2lvbnMoKS5ycGM7XG4gICAgICAgICAgICBjb25zdCByZWFkUHJvdmlkZXIgPSB0aGlzLmNvbnRleHQud2l0aEV4dGVuc2lvbnMoKS5yZWFkUHJvdmlkZXI7XG4gICAgICAgICAgICBjb25zdCBzY3JpcHQgPSB5aWVsZCByZWFkUHJvdmlkZXIuZ2V0U2NyaXB0KGFkZHJlc3MsICdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBlbnRyeXBvaW50cyA9IHlpZWxkIHJlYWRQcm92aWRlci5nZXRFbnRyeXBvaW50cyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGNvbnN0IGFicyA9IG5ldyBDb250cmFjdEFic3RyYWN0aW9uKGFkZHJlc3MsIHNjcmlwdCwgdGhpcywgdGhpcy5jb250ZXh0LmNvbnRyYWN0LCBlbnRyeXBvaW50cywgcnBjLCByZWFkUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0QWJzdHJhY3Rpb25Db21wb3NlcihhYnMsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBEZXByZWNhdGVkIGluIGZhdm9yIG9mIHtAbGluayBXYWxsZXQucGt9IHdpbGwgYmUgcmVtb3ZlZCBpbiB2MTkuMVxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXRyaWV2ZSB0aGUgUEsgb2YgdGhlIGFjY291bnQgdGhhdCBpcyBjdXJyZW50bHkgaW4gdXNlIGJ5IHRoZSB3YWxsZXRcbiAgICAgKi9cbiAgICBnZXRQSygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnBrKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY29uc3QgcmVjZWlwdEZyb21PcGVyYXRpb24gPSAob3AsIHsgQUxMT0NBVElPTl9CVVJOLCBPUklHSU5BVElPTl9CVVJOIH0gPSB7XG4gICAgQUxMT0NBVElPTl9CVVJOOiAyNTcsXG4gICAgT1JJR0lOQVRJT05fQlVSTjogMjU3LFxufSkgPT4ge1xuICAgIEJpZ051bWJlci5jb25maWcoeyBERUNJTUFMX1BMQUNFUzogMCwgUk9VTkRJTkdfTU9ERTogQmlnTnVtYmVyLlJPVU5EX1VQIH0pO1xuICAgIGNvbnN0IG9wZXJhdGlvblJlc3VsdHMgPSBmbGF0dGVuT3BlcmF0aW9uUmVzdWx0KHsgY29udGVudHM6IG9wIH0pO1xuICAgIGxldCB0b3RhbE1pbGxpR2FzID0gbmV3IEJpZ051bWJlcigwKTtcbiAgICBsZXQgdG90YWxTdG9yYWdlID0gbmV3IEJpZ051bWJlcigwKTtcbiAgICBsZXQgdG90YWxGZWUgPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgIGxldCB0b3RhbE9yaWdpbmF0aW9uQnVybiA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgbGV0IHRvdGFsQWxsb2NhdGlvbkJ1cm4gPSBuZXcgQmlnTnVtYmVyKDApO1xuICAgIGxldCB0b3RhbFBhaWRTdG9yYWdlRGlmZiA9IG5ldyBCaWdOdW1iZXIoMCk7XG4gICAgb3BlcmF0aW9uUmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgdG90YWxGZWUgPSB0b3RhbEZlZS5wbHVzKHJlc3VsdC5mZWUgfHwgMCk7XG4gICAgICAgIHRvdGFsT3JpZ2luYXRpb25CdXJuID0gdG90YWxPcmlnaW5hdGlvbkJ1cm4ucGx1cyhBcnJheS5pc0FycmF5KHJlc3VsdC5vcmlnaW5hdGVkX2NvbnRyYWN0cylcbiAgICAgICAgICAgID8gcmVzdWx0Lm9yaWdpbmF0ZWRfY29udHJhY3RzLmxlbmd0aCAqIE9SSUdJTkFUSU9OX0JVUk5cbiAgICAgICAgICAgIDogMCk7XG4gICAgICAgIHRvdGFsQWxsb2NhdGlvbkJ1cm4gPSB0b3RhbEFsbG9jYXRpb25CdXJuLnBsdXMoJ2FsbG9jYXRlZF9kZXN0aW5hdGlvbl9jb250cmFjdCcgaW4gcmVzdWx0ID8gQUxMT0NBVElPTl9CVVJOIDogMCk7XG4gICAgICAgIHRvdGFsTWlsbGlHYXMgPSB0b3RhbE1pbGxpR2FzLnBsdXMocmVzdWx0LmNvbnN1bWVkX21pbGxpZ2FzIHx8IDApO1xuICAgICAgICB0b3RhbFBhaWRTdG9yYWdlRGlmZiA9IHRvdGFsUGFpZFN0b3JhZ2VEaWZmLnBsdXMoJ3BhaWRfc3RvcmFnZV9zaXplX2RpZmYnIGluIHJlc3VsdCA/IE51bWJlcihyZXN1bHQucGFpZF9zdG9yYWdlX3NpemVfZGlmZikgfHwgMCA6IDApO1xuICAgIH0pO1xuICAgIHRvdGFsU3RvcmFnZSA9IHRvdGFsU3RvcmFnZVxuICAgICAgICAucGx1cyh0b3RhbEFsbG9jYXRpb25CdXJuKVxuICAgICAgICAucGx1cyh0b3RhbE9yaWdpbmF0aW9uQnVybilcbiAgICAgICAgLnBsdXModG90YWxQYWlkU3RvcmFnZURpZmYpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHRvdGFsRmVlLFxuICAgICAgICB0b3RhbE1pbGxpR2FzLFxuICAgICAgICB0b3RhbEdhczogdG90YWxNaWxsaUdhcy5kaXZpZGVkQnkoMTAwMCksXG4gICAgICAgIHRvdGFsU3RvcmFnZSxcbiAgICAgICAgdG90YWxBbGxvY2F0aW9uQnVybixcbiAgICAgICAgdG90YWxPcmlnaW5hdGlvbkJ1cm4sXG4gICAgICAgIHRvdGFsUGFpZFN0b3JhZ2VEaWZmLFxuICAgICAgICB0b3RhbFN0b3JhZ2VCdXJuOiBuZXcgQmlnTnVtYmVyKHRvdGFsU3RvcmFnZS5tdWx0aXBsaWVkQnkoQ09TVF9QRVJfQllURSkpLFxuICAgIH07XG59O1xuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgdW5kZWZpbmVkIGNvbmZpcm1hdGlvbiBoYXMgbm90IGJlZW4gc3BlY2lmaWVkIG9yIGNvbmZpZ3VyZWRcbiAqL1xuY2xhc3MgQ29uZmlybWF0aW9uVW5kZWZpbmVkRXJyb3IgZXh0ZW5kcyBUZXpvc1Rvb2xraXRDb25maWdFcnJvciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdDb25maXJtYXRpb25VbmRlZmluZWRFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9ICdEZWZhdWx0IGNvbmZpcm1hdGlvbiBjb3VudCBjYW4gbm90IGJlIHVuZGVmaW5lZCc7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIGEgZ2VuZXJpYyBmYWlsdXJlIHdoZW4gdHJ5aW5nIHRvIGZldGNoIGFuIG9ic2VydmFibGVcbiAqL1xuY2xhc3MgT2JzZXJ2YWJsZUVycm9yIGV4dGVuZHMgTmV0d29ya0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIHRoaXMubmFtZSA9ICdPYnNlcnZhYmxlRXJyb3InO1xuICAgIH1cbn1cblxuY29uc3QgTUFYX0JSQU5DSF9BTkNFU1RPUlMgPSA2MDtcbi8qKlxuICogQGRlc2NyaXB0aW9uIFdhbGxldE9wZXJhdGlvbiBhbGxvd3MgdG8gbW9uaXRvciBvcGVyYXRpb24gaW5jbHVzaW9uIG9uIGNoYWlucyBhbmQgc3VyZmFjZSBpbmZvcm1hdGlvbiByZWxhdGVkIHRvIHRoZSBvcGVyYXRpb25cbiAqL1xuY2xhc3MgV2FsbGV0T3BlcmF0aW9uIHtcbiAgICBvcGVyYXRpb25SZXN1bHRzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX29wZXJhdGlvblJlc3VsdC5waXBlKGZpcnN0KCkpLnRvUHJvbWlzZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFJlY2VpcHQgZXhwb3NlIHRoZSB0b3RhbCBhbW91bnQgb2YgdGV6b3MgdG9rZW4gYnVybiBhbmQgc3BlbnQgb24gZmVlc1xuICAgICAqIFRoZSBwcm9taXNlIHJldHVybmVkIGJ5IHJlY2VpcHQgd2lsbCByZXNvbHZlIG9ubHkgb25jZSB0aGUgdHJhbnNhY3Rpb24gaXMgaW5jbHVkZWRcbiAgICAgKi9cbiAgICByZWNlaXB0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0cyA9IHlpZWxkIHRoaXMub3BlcmF0aW9uUmVzdWx0cygpO1xuICAgICAgICAgICAgaWYgKCFyZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9ic2VydmFibGVFcnJvcignVW5hYmxlIHRvIGdldCBvcGVyYXRpb24gcmVzdWx0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHRGcm9tT3BlcmF0aW9uKHJlc3VsdHMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3BIYXNoIE9wZXJhdGlvbiBoYXNoXG4gICAgICogQHBhcmFtIHJhdyBSYXcgb3BlcmF0aW9uIHRoYXQgd2FzIGluamVjdGVkXG4gICAgICogQHBhcmFtIGNvbnRleHQgVGFxdWl0byBjb250ZXh0IGFsbG93aW5nIGFjY2VzcyB0byBycGMgYW5kIHNpZ25lclxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRPcGVyYXRpb25IYXNoRXJyb3J9XG4gICAgICovXG4gICAgY29uc3RydWN0b3Iob3BIYXNoLCBjb250ZXh0LCBfbmV3SGVhZCQpIHtcbiAgICAgICAgdGhpcy5vcEhhc2ggPSBvcEhhc2g7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX25ld0hlYWQkID0gX25ld0hlYWQkO1xuICAgICAgICB0aGlzLl9vcGVyYXRpb25SZXN1bHQgPSBuZXcgUmVwbGF5U3ViamVjdCgxKTtcbiAgICAgICAgdGhpcy5faW5jbHVkZWRJbkJsb2NrID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG4gICAgICAgIHRoaXMuX2luY2x1ZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubmV3SGVhZCQgPSB0aGlzLl9uZXdIZWFkJC5waXBlKHN3aXRjaE1hcCgobmV3SGVhZCkgPT4ge1xuICAgICAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgICAgIGNvbnN0IHByZXZIZWFkID0gKF9iID0gKF9hID0gdGhpcy5sYXN0SGVhZCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmhlYWRlci5sZXZlbCkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogbmV3SGVhZC5oZWFkZXIubGV2ZWwgLSAxO1xuICAgICAgICAgICAgcmV0dXJuIHJhbmdlKHByZXZIZWFkICsgMSwgbmV3SGVhZC5oZWFkZXIubGV2ZWwgLSBwcmV2SGVhZCAtIDEpLnBpcGUoY29uY2F0TWFwKChsZXZlbCkgPT4gdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRCbG9jayhsZXZlbCkpLCBlbmRXaXRoKG5ld0hlYWQpKTtcbiAgICAgICAgfSksIHRhcCgobmV3SGVhZCkgPT4gKHRoaXMubGFzdEhlYWQgPSBuZXdIZWFkKSksIHNoYXJlKHtcbiAgICAgICAgICAgIGNvbm5lY3RvcjogKCkgPT4gbmV3IFJlcGxheVN1YmplY3QoMSksXG4gICAgICAgICAgICByZXNldE9uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgcmVzZXRPbkNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc2V0T25SZWZDb3VudFplcm86IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIC8vIE9ic2VydmFibGUgdGhhdCBlbWl0IG9uY2Ugb3BlcmF0aW9uIGlzIHNlZW4gaW4gYSBibG9ja1xuICAgICAgICB0aGlzLmNvbmZpcm1lZCQgPSB0aGlzLm5ld0hlYWQkLnBpcGUobWFwKChoZWFkKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wR3JvdXAgb2YgaGVhZC5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvcCBvZiBvcEdyb3VwKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcC5oYXNoID09PSB0aGlzLm9wSGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5jbHVkZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5faW5jbHVkZWRJbkJsb2NrLm5leHQoaGVhZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9vcGVyYXRpb25SZXN1bHQubmV4dChvcC5jb250ZW50cyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm4gdGhlIGJsb2NrIHdoZXJlIHRoZSBvcGVyYXRpb24gd2FzIGZvdW5kXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSksIGZpbHRlcigoeCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiB4ICE9PSAndW5kZWZpbmVkJztcbiAgICAgICAgfSksIGZpcnN0KCksIHNoYXJlKHtcbiAgICAgICAgICAgIGNvbm5lY3RvcjogKCkgPT4gbmV3IFJlcGxheVN1YmplY3QoMSksXG4gICAgICAgICAgICByZXNldE9uRXJyb3I6IGZhbHNlLFxuICAgICAgICAgICAgcmVzZXRPbkNvbXBsZXRlOiBmYWxzZSxcbiAgICAgICAgICAgIHJlc2V0T25SZWZDb3VudFplcm86IGZhbHNlLFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh2YWxpZGF0ZU9wZXJhdGlvbih0aGlzLm9wSGFzaCkgIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3BlcmF0aW9uSGFzaEVycm9yKHRoaXMub3BIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpcm1lZCRcbiAgICAgICAgICAgIC5waXBlKGZpcnN0KCksIGNhdGNoRXJyb3IoKCkgPT4gb2YodW5kZWZpbmVkKSkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIGdldEN1cnJlbnRDb25maXJtYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29tYmluZUxhdGVzdChbdGhpcy5faW5jbHVkZWRJbkJsb2NrLCBmcm9tKHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0QmxvY2soJ2hlYWQnKSldKVxuICAgICAgICAgICAgICAgIC5waXBlKG1hcCgoW2ZvdW5kQXRCbG9jaywgaGVhZF0pID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGVhZC5oZWFkZXIubGV2ZWwgLSBmb3VuZEF0QmxvY2suaGVhZGVyLmxldmVsICsgMTtcbiAgICAgICAgICAgIH0pLCBmaXJzdCgpKVxuICAgICAgICAgICAgICAgIC50b1Byb21pc2UoKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlzSW5DdXJyZW50QnJhbmNoKHRpcEJsb2NrSWRlbnRpZmllciA9ICdoZWFkJykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gQnkgZGVmYXVsdCBpdCBpcyBhc3N1bWVkIHRoYXQgdGhlIG9wZXJhdGlvbiBpcyBpbiB0aGUgY3VycmVudCBicmFuY2hcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHRpcEJsb2NrSGVhZGVyTGV2ZWwgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldEJsb2NrTGV2ZWwodGlwQmxvY2tJZGVudGlmaWVyKTtcbiAgICAgICAgICAgIGNvbnN0IGluY2x1c2lvbkJsb2NrID0geWllbGQgdGhpcy5faW5jbHVkZWRJbkJsb2NrLnBpcGUoZmlyc3QoKSkudG9Qcm9taXNlKCk7XG4gICAgICAgICAgICBpZiAoIWluY2x1c2lvbkJsb2NrKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9ic2VydmFibGVFcnJvcignSW5jbHVzaW9uIGJsb2NrIGlzIHVuZGVmaW5lZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgbGV2ZWxEaWZmID0gKHRpcEJsb2NrSGVhZGVyTGV2ZWwgLSBpbmNsdXNpb25CbG9jay5oZWFkZXIubGV2ZWwpO1xuICAgICAgICAgICAgLy8gQmxvY2sgcHJvZHVjZWQgYmVmb3JlIHRoZSBvcGVyYXRpb24gaXMgaW5jbHVkZWQgYXJlIGFzc3VtZWQgdG8gYmUgcGFydCBvZiB0aGUgY3VycmVudCBicmFuY2hcbiAgICAgICAgICAgIGlmIChsZXZlbERpZmYgPD0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdGlwQmxvY2tMZXZlbCA9IE1hdGgubWluKGluY2x1c2lvbkJsb2NrLmhlYWRlci5sZXZlbCArIGxldmVsRGlmZiwgaW5jbHVzaW9uQmxvY2suaGVhZGVyLmxldmVsICsgTUFYX0JSQU5DSF9BTkNFU1RPUlMpO1xuICAgICAgICAgICAgY29uc3QgYmxvY2tzID0gbmV3IFNldCh5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldExpdmVCbG9ja3ModGlwQmxvY2tMZXZlbCkpO1xuICAgICAgICAgICAgcmV0dXJuIGJsb2Nrcy5oYXMoaW5jbHVzaW9uQmxvY2suaGFzaCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb25maXJtYXRpb25PYnNlcnZhYmxlKGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maXJtYXRpb25zICE9PSAndW5kZWZpbmVkJyAmJiBjb25maXJtYXRpb25zIDwgMSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRDb25maXJtYXRpb25Db3VudEVycm9yKGNvbmZpcm1hdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgZGVmYXVsdENvbmZpcm1hdGlvbkNvdW50IH0gPSB0aGlzLmNvbnRleHQuY29uZmlnO1xuICAgICAgICBjb25zdCBjb25mID0gY29uZmlybWF0aW9ucyAhPT0gdW5kZWZpbmVkID8gY29uZmlybWF0aW9ucyA6IGRlZmF1bHRDb25maXJtYXRpb25Db3VudDtcbiAgICAgICAgaWYgKGNvbmYgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IENvbmZpcm1hdGlvblVuZGVmaW5lZEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbWJpbmVMYXRlc3QoW3RoaXMuX2luY2x1ZGVkSW5CbG9jaywgdGhpcy5uZXdIZWFkJF0pLnBpcGUoZGlzdGluY3RVbnRpbENoYW5nZWQoKFssIHByZXZpb3VzSGVhZF0sIFssIG5ld0hlYWRdKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJldmlvdXNIZWFkLmhhc2ggPT09IG5ld0hlYWQuaGFzaDtcbiAgICAgICAgfSksIG1hcCgoW2ZvdW5kQXRCbG9jaywgaGVhZF0pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYmxvY2s6IGhlYWQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb25maXJtYXRpb246IGNvbmYsXG4gICAgICAgICAgICAgICAgY3VycmVudENvbmZpcm1hdGlvbjogaGVhZC5oZWFkZXIubGV2ZWwgLSBmb3VuZEF0QmxvY2suaGVhZGVyLmxldmVsICsgMSxcbiAgICAgICAgICAgICAgICBjb21wbGV0ZWQ6IGhlYWQuaGVhZGVyLmxldmVsIC0gZm91bmRBdEJsb2NrLmhlYWRlci5sZXZlbCA+PSBjb25mIC0gMSxcbiAgICAgICAgICAgICAgICBpc0luQ3VycmVudEJyYW5jaDogKCkgPT4gdGhpcy5pc0luQ3VycmVudEJyYW5jaChoZWFkLmhhc2gpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSksIHRha2VXaGlsZSgoeyBjb21wbGV0ZWQgfSkgPT4gIWNvbXBsZXRlZCwgdHJ1ZSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb25maXJtYXRpb25zIFswXSBOdW1iZXIgb2YgY29uZmlybWF0aW9uIHRvIHdhaXQgZm9yXG4gICAgICovXG4gICAgY29uZmlybWF0aW9uKGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29uZmlybWF0aW9uT2JzZXJ2YWJsZShjb25maXJtYXRpb25zKS50b1Byb21pc2UoKTtcbiAgICB9XG59XG5cbmNsYXNzIFRyYW5zYWN0aW9uV2FsbGV0T3BlcmF0aW9uIGV4dGVuZHMgV2FsbGV0T3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcEhhc2gsIGNvbnRleHQsIG5ld0hlYWQkKSB7XG4gICAgICAgIHN1cGVyKG9wSGFzaCwgY29udGV4dCwgbmV3SGVhZCQpO1xuICAgICAgICB0aGlzLm9wSGFzaCA9IG9wSGFzaDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgcmV2ZWFsT3BlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5vcGVyYXRpb25SZXN1bHRzKCk7XG4gICAgICAgICAgICBpZiAoIW9wZXJhdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPYnNlcnZhYmxlRXJyb3IoJ29wZXJhdGlvblJlc3VsdCByZXR1cm5lZCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQuZmluZCgoeCkgPT4geC5raW5kID09PSBPcEtpbmQuUkVWRUFMKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRyYW5zYWN0aW9uT3BlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5vcGVyYXRpb25SZXN1bHRzKCk7XG4gICAgICAgICAgICBpZiAoIW9wZXJhdGlvblJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPYnNlcnZhYmxlRXJyb3IoJ29wZXJhdGlvblJlc3VsdCByZXR1cm5lZCB1bmRlZmluZWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBvcGVyYXRpb25SZXN1bHQuZmluZCgoeCkgPT4geC5raW5kID09PSBPcEtpbmQuVFJBTlNBQ1RJT04pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGVuZGluZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIHRoaXMudHJhbnNhY3Rpb25PcGVyYXRpb24oKTtcbiAgICAgICAgICAgIGlmICghb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQuc3RhdHVzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIE9yaWdpbmF0aW9uV2FsbGV0T3BlcmF0aW9uIGV4dGVuZHMgV2FsbGV0T3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcEhhc2gsIGNvbnRleHQsIG5ld0hlYWQkKSB7XG4gICAgICAgIHN1cGVyKG9wSGFzaCwgY29udGV4dCwgbmV3SGVhZCQpO1xuICAgICAgICB0aGlzLm9wSGFzaCA9IG9wSGFzaDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgb3JpZ2luYXRpb25PcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLm9wZXJhdGlvblJlc3VsdHMoKTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZFdpdGhLaW5kKG9wZXJhdGlvblJlc3VsdCwgT3BLaW5kLk9SSUdJTkFUSU9OKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPYnNlcnZhYmxlRXJyb3IoJ1VuYWJsZSB0byBmZXRjaCBvcGVyYXRpb24gcmVzdWx0Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXZlYWxPcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLm9wZXJhdGlvblJlc3VsdHMoKTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmluZFdpdGhLaW5kKG9wZXJhdGlvblJlc3VsdCwgT3BLaW5kLlJFVkVBTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT2JzZXJ2YWJsZUVycm9yKCdVbmFibGUgdG8gZmV0Y2ggb3BlcmF0aW9uIHJlc3VsdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGVuZGluZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIHRoaXMub3JpZ2luYXRpb25PcGVyYXRpb24oKTtcbiAgICAgICAgICAgIGlmICghb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQuc3RhdHVzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29udHJhY3QoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIHRoaXMub3JpZ2luYXRpb25PcGVyYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSAoKG9wID09PSBudWxsIHx8IG9wID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0Lm9yaWdpbmF0ZWRfY29udHJhY3RzKSB8fCBbXSlbMF07XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LndhbGxldC5hdChhZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jbGFzcyBEZWxlZ2F0aW9uV2FsbGV0T3BlcmF0aW9uIGV4dGVuZHMgV2FsbGV0T3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcEhhc2gsIGNvbnRleHQsIG5ld0hlYWQkKSB7XG4gICAgICAgIHN1cGVyKG9wSGFzaCwgY29udGV4dCwgbmV3SGVhZCQpO1xuICAgICAgICB0aGlzLm9wSGFzaCA9IG9wSGFzaDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgcmV2ZWFsT3BlcmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uUmVzdWx0ID0geWllbGQgdGhpcy5vcGVyYXRpb25SZXN1bHRzKCk7XG4gICAgICAgICAgICBpZiAob3BlcmF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvblJlc3VsdC5maW5kKCh4KSA9PiB4LmtpbmQgPT09IE9wS2luZC5SRVZFQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9ic2VydmFibGVFcnJvcignVW5hYmxlIHRvIGZldGNoIG9wZXJhdGlvbiByZXN1bHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRlbGVnYXRpb25PcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLm9wZXJhdGlvblJlc3VsdHMoKTtcbiAgICAgICAgICAgIGlmIChvcGVyYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0LmZpbmQoKHgpID0+IHgua2luZCA9PT0gT3BLaW5kLkRFTEVHQVRJT04pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9ic2VydmFibGVFcnJvcignVW5hYmxlIHRvIGZldGNoIG9wZXJhdGlvbiByZXN1bHQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXR1cygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5faW5jbHVkZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3BlbmRpbmcnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgb3AgPSB5aWVsZCB0aGlzLmRlbGVnYXRpb25PcGVyYXRpb24oKTtcbiAgICAgICAgICAgIGlmICghb3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Vua25vd24nO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQuc3RhdHVzO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIExlZ2FjeVdhbGxldFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIGdldFBLSCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQuc2lnbmVyLnB1YmxpY0tleUhhc2goKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFBLKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5zaWduZXIucHVibGljS2V5KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBUcmFuc2ZlclBhcmFtc1RvV2FsbGV0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFjaEtpbmQoeWllbGQgcGFyYW1zKCksIE9wS2luZC5UUkFOU0FDVElPTik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBPcmlnaW5hdGVQYXJhbXNUb1dhbGxldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRhY2hLaW5kKHlpZWxkIHBhcmFtcygpLCBPcEtpbmQuT1JJR0lOQVRJT04pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFwRGVsZWdhdGVQYXJhbXNUb1dhbGxldFBhcmFtcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRhY2hLaW5kKHlpZWxkIHBhcmFtcygpLCBPcEtpbmQuREVMRUdBVElPTik7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXBJbmNyZWFzZVBhaWRTdG9yYWdlV2FsbGV0UGFyYW1zKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIGF0dGFjaEtpbmQoeWllbGQgcGFyYW1zKCksIE9wS2luZC5JTkNSRUFTRV9QQUlEX1NUT1JBR0UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZE9wZXJhdGlvbnMocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIHRoaXMuY29udGV4dC5iYXRjaC5iYXRjaChwYXJhbXMpLnNlbmQoKTtcbiAgICAgICAgICAgIHJldHVybiBvcC5oYXNoO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbihieXRlcywgd2F0ZXJtYXJrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHByZWZpeFNpZyB9ID0geWllbGQgdGhpcy5jb250ZXh0LnNpZ25lci5zaWduKGJ5dGVzLCB3YXRlcm1hcmspO1xuICAgICAgICAgICAgcmV0dXJuIHByZWZpeFNpZztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVdGlsaXR5IGNsYXNzIHRvIHNlbmQgc21hcnQgY29udHJhY3Qgb3BlcmF0aW9uXG4gKiBUaGUgZm9ybWF0IGZvciB0aGUgYXJndW1lbnRzIGlzIHRoZSBvYmplY3QgcmVwcmVzZW50YXRpb25cbiAqL1xuY2xhc3MgQ29udHJhY3RNZXRob2RPYmplY3Qge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBwYXJhbWV0ZXJTY2hlbWEsIG5hbWUsIGFyZ3MgPSAndW5pdCcsIGlzTXVsdGlwbGVFbnRyeXBvaW50ID0gdHJ1ZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyU2NoZW1hID0gcGFyYW1ldGVyU2NoZW1hO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmlzTXVsdGlwbGVFbnRyeXBvaW50ID0gaXNNdWx0aXBsZUVudHJ5cG9pbnQ7XG4gICAgICAgIHRoaXMuaXNBbm9ueW1vdXMgPSBpc0Fub255bW91cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgc2lnbmF0dXJlIG9mIHRoZSBzbWFydCBjb250cmFjdCBtZXRob2RcbiAgICAgKi9cbiAgICBnZXRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQW5vbnltb3VzXG4gICAgICAgICAgICA/IHRoaXMucGFyYW1ldGVyU2NoZW1hLkV4dHJhY3RTY2hlbWEoKVt0aGlzLm5hbWVdXG4gICAgICAgICAgICA6IHRoaXMucGFyYW1ldGVyU2NoZW1hLkV4dHJhY3RTY2hlbWEoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gU2VuZCB0aGUgc21hcnQgY29udHJhY3Qgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT3B0aW9ucyBnZW5lcmljIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBzZW5kKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVyIGluc3RhbmNlb2YgV2FsbGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci50cmFuc2Zlcih0aGlzLnRvVHJhbnNmZXJQYXJhbXMocGFyYW1zKSkuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIudHJhbnNmZXIodGhpcy50b1RyYW5zZmVyUGFyYW1zKHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSB0cmFuc2ZlciBwYXJhbXMgdG8gYmUgdXNlZCB3aXRoIFRlem9zVG9vbGtpdC5jb250cmFjdC50cmFuc2ZlciBtZXRob2RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT3B0aW9ucyBnZW5lcmljIHRyYW5zZmVyIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgdG9UcmFuc2ZlclBhcmFtcyh7IGZlZSwgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCwgc291cmNlLCBhbW91bnQgPSAwLCBtdXRleiA9IGZhbHNlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZnVsbFRyYW5zZmVyUGFyYW1zID0ge1xuICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICAgIGZlZSxcbiAgICAgICAgICAgIG11dGV6LFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgICAgICBzdG9yYWdlTGltaXQsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHtcbiAgICAgICAgICAgICAgICBlbnRyeXBvaW50OiB0aGlzLmlzTXVsdGlwbGVFbnRyeXBvaW50ID8gdGhpcy5uYW1lIDogREVGQVVMVF9TTUFSVF9DT05UUkFDVF9NRVRIT0RfTkFNRSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5pc0Fub255bW91c1xuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGFyYW1ldGVyU2NoZW1hLkVuY29kZU9iamVjdCh7IFt0aGlzLm5hbWVdOiB0aGlzLmFyZ3MgfSlcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnBhcmFtZXRlclNjaGVtYS5FbmNvZGVPYmplY3QodGhpcy5hcmdzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdWxsVHJhbnNmZXJQYXJhbXM7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVdGlsaXR5IGNsYXNzIHRvIHNlbmQgc21hcnQgY29udHJhY3Qgb3BlcmF0aW9uXG4gKiBUaGUgZm9ybWF0IGZvciB0aGUgYXJndW1lbnRzIGlzIHRoZSBmbGF0dGVuZWQgcmVwcmVzZW50YXRpb25cbiAqL1xuY2xhc3MgQ29udHJhY3RNZXRob2Qge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBhZGRyZXNzLCBwYXJhbWV0ZXJTY2hlbWEsIG5hbWUsIGFyZ3MsIGlzTXVsdGlwbGVFbnRyeXBvaW50ID0gdHJ1ZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyU2NoZW1hID0gcGFyYW1ldGVyU2NoZW1hO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzO1xuICAgICAgICB0aGlzLmlzTXVsdGlwbGVFbnRyeXBvaW50ID0gaXNNdWx0aXBsZUVudHJ5cG9pbnQ7XG4gICAgICAgIHRoaXMuaXNBbm9ueW1vdXMgPSBpc0Fub255bW91cztcbiAgICB9XG4gICAgdmFsaWRhdGVBcmdzKGFyZ3MsIHNjaGVtYSwgbmFtZSkge1xuICAgICAgICBjb25zdCBzaWdzID0gc2NoZW1hLkV4dHJhY3RTaWduYXR1cmVzKCk7XG4gICAgICAgIGlmICghc2lncy5maW5kKCh4KSA9PiB4Lmxlbmd0aCA9PT0gYXJncy5sZW5ndGgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFBhcmFtZXRlckVycm9yKG5hbWUsIHNpZ3MsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBHZXQgdGhlIHNjaGVtYSBvZiB0aGUgc21hcnQgY29udHJhY3QgbWV0aG9kXG4gICAgICovXG4gICAgZ2V0IHNjaGVtYSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaXNBbm9ueW1vdXNcbiAgICAgICAgICAgID8gdGhpcy5wYXJhbWV0ZXJTY2hlbWEuRXh0cmFjdFNjaGVtYSgpW3RoaXMubmFtZV1cbiAgICAgICAgICAgIDogdGhpcy5wYXJhbWV0ZXJTY2hlbWEuRXh0cmFjdFNjaGVtYSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBzaWduYXR1cmUgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IG1ldGhvZFxuICAgICAqL1xuICAgIGdldFNpZ25hdHVyZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNpZyA9IHRoaXMucGFyYW1ldGVyU2NoZW1hLkV4dHJhY3RTaWduYXR1cmVzKCkuZmluZCgoeCkgPT4geFswXSA9PT0gdGhpcy5uYW1lKTtcbiAgICAgICAgICAgIGlmIChzaWcpIHtcbiAgICAgICAgICAgICAgICBzaWcuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2lnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2lnID0gdGhpcy5wYXJhbWV0ZXJTY2hlbWEuRXh0cmFjdFNpZ25hdHVyZXMoKTtcbiAgICAgICAgICAgIHJldHVybiBzaWcubGVuZ3RoID09IDEgPyBzaWdbMF0gOiBzaWc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gU2VuZCB0aGUgc21hcnQgY29udHJhY3Qgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT3B0aW9ucyBnZW5lcmljIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBzZW5kKHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIGlmICh0aGlzLnByb3ZpZGVyIGluc3RhbmNlb2YgV2FsbGV0KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlclxuICAgICAgICAgICAgICAgIC50cmFuc2Zlcih0aGlzLnRvVHJhbnNmZXJQYXJhbXMocGFyYW1zKSlcbiAgICAgICAgICAgICAgICAuc2VuZCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIudHJhbnNmZXIodGhpcy50b1RyYW5zZmVyUGFyYW1zKHBhcmFtcykpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIENyZWF0ZSB0cmFuc2ZlciBwYXJhbXMgdG8gYmUgdXNlZCB3aXRoIFRlem9zVG9vbGtpdC5jb250cmFjdC50cmFuc2ZlciBtZXRob2RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT3B0aW9ucyBnZW5lcmljIHRyYW5zZmVyIG9wZXJhdGlvbiBwYXJhbWV0ZXJzXG4gICAgICovXG4gICAgdG9UcmFuc2ZlclBhcmFtcyh7IGZlZSwgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCwgc291cmNlLCBhbW91bnQgPSAwLCBtdXRleiA9IGZhbHNlLCB9ID0ge30pIHtcbiAgICAgICAgY29uc3QgZnVsbFRyYW5zZmVyUGFyYW1zID0ge1xuICAgICAgICAgICAgdG86IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgIGFtb3VudCxcbiAgICAgICAgICAgIGZlZSxcbiAgICAgICAgICAgIG11dGV6LFxuICAgICAgICAgICAgc291cmNlLFxuICAgICAgICAgICAgZ2FzTGltaXQsXG4gICAgICAgICAgICBzdG9yYWdlTGltaXQsXG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHtcbiAgICAgICAgICAgICAgICBlbnRyeXBvaW50OiB0aGlzLmlzTXVsdGlwbGVFbnRyeXBvaW50ID8gdGhpcy5uYW1lIDogREVGQVVMVF9TTUFSVF9DT05UUkFDVF9NRVRIT0RfTkFNRSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogdGhpcy5pc0Fub255bW91c1xuICAgICAgICAgICAgICAgICAgICA/IHRoaXMucGFyYW1ldGVyU2NoZW1hLkVuY29kZSh0aGlzLm5hbWUsIC4uLnRoaXMuYXJncylcbiAgICAgICAgICAgICAgICAgICAgOiB0aGlzLnBhcmFtZXRlclNjaGVtYS5FbmNvZGUoLi4udGhpcy5hcmdzKSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdWxsVHJhbnNmZXJQYXJhbXM7XG4gICAgfVxufVxuXG5jbGFzcyBPbkNoYWluVmlldyB7XG4gICAgY29uc3RydWN0b3IoX3JwYywgX3JlYWRQcm92aWRlciwgX2NvbnRyYWN0QWRkcmVzcywgX3NtYXJ0Q29udHJhY3RWaWV3U2NoZW1hLCBfY29udHJhY3RTdG9yYWdlVHlwZSwgX2FyZ3MgPSAnVW5pdCcpIHtcbiAgICAgICAgdGhpcy5fcnBjID0gX3JwYztcbiAgICAgICAgdGhpcy5fcmVhZFByb3ZpZGVyID0gX3JlYWRQcm92aWRlcjtcbiAgICAgICAgdGhpcy5fY29udHJhY3RBZGRyZXNzID0gX2NvbnRyYWN0QWRkcmVzcztcbiAgICAgICAgdGhpcy5fc21hcnRDb250cmFjdFZpZXdTY2hlbWEgPSBfc21hcnRDb250cmFjdFZpZXdTY2hlbWE7XG4gICAgICAgIHRoaXMuX2NvbnRyYWN0U3RvcmFnZVR5cGUgPSBfY29udHJhY3RTdG9yYWdlVHlwZTtcbiAgICAgICAgdGhpcy5fYXJncyA9IF9hcmdzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0IHRoZSBzaWduYXR1cmUgb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHZpZXdcbiAgICAgKi9cbiAgICBnZXRTaWduYXR1cmUoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXI6IHRoaXMuX3NtYXJ0Q29udHJhY3RWaWV3U2NoZW1hLmV4dHJhY3RBcmdzU2NoZW1hKCksXG4gICAgICAgICAgICByZXN1bHQ6IHRoaXMuX3NtYXJ0Q29udHJhY3RWaWV3U2NoZW1hLmV4dHJhY3RSZXN1bHRTY2hlbWEoKSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEdldCB0aGUgcmVzdWx0IG9mIHRoZSB2aWV3IHNpbXVsYXRpb25cbiAgICAgKiBAcGFyYW0gZXhlY3V0aW9uQ29udGV4dC5zb3VyY2UgdGhlIHB1YmxpYyBrZXkgaGFzaCBvZiB0aGUgYWNjb3VudCB3aG8gaW5pdGlhbGl6ZWQgdGhpcyB2aWV3IGV4ZWN1dGlvbi5cbiAgICAgKiBAcGFyYW0gZXhlY3V0aW9uQ29udGV4dC52aWV3Q2FsbGVyIHRoZSBjb250cmFjdCBhZGRyZXNzIHdoaWNoIGlzIHRoZSBjYWxsZXIgb2Ygdmlldy5cbiAgICAgKi9cbiAgICBleGVjdXRlVmlldyhleGVjdXRpb25Db250ZXh0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeUNvbnRleHRFeGVjdXRpb24oZXhlY3V0aW9uQ29udGV4dCk7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkID0geWllbGQgdGhpcy5fcmVhZFByb3ZpZGVyLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIGNvbnN0IHZpZXdBcmdzID0gdGhpcy50cmFuc2Zvcm1BcmdzVG9NaWNoZWxzb24oKTtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdFZpZXcgPSB7XG4gICAgICAgICAgICAgICAgY29udHJhY3Q6IHRoaXMuX2NvbnRyYWN0QWRkcmVzcyxcbiAgICAgICAgICAgICAgICB2aWV3OiB0aGlzLl9zbWFydENvbnRyYWN0Vmlld1NjaGVtYS52aWV3TmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogdmlld0FyZ3MsXG4gICAgICAgICAgICAgICAgY2hhaW5faWQ6IGNoYWluSWQsXG4gICAgICAgICAgICAgICAgc291cmNlOiBleGVjdXRpb25Db250ZXh0LnZpZXdDYWxsZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQuc291cmNlKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0Vmlldy5wYXllciA9IGV4ZWN1dGlvbkNvbnRleHQuc291cmNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXhlY3V0ZVZpZXdBbmREZWNvZGVSZXN1bHQoc2NyaXB0Vmlldyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICB2ZXJpZnlDb250ZXh0RXhlY3V0aW9uKGV4ZWN1dGlvbkNvbnRleHQpIHtcbiAgICAgICAgaWYgKGV4ZWN1dGlvbkNvbnRleHQuc291cmNlICYmXG4gICAgICAgICAgICB2YWxpZGF0ZUFkZHJlc3MoZXhlY3V0aW9uQ29udGV4dC5zb3VyY2UpICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZpZXdTaW11bGF0aW9uQ29udGV4dChgVGhlIHNvdXJjZSBhY2NvdW50IHdobyBpbml0aWFsaXplZCB0aGUgdmlldyBleGVjdXRpb24gaXMgaW52YWxpZDogJHtleGVjdXRpb25Db250ZXh0LnNvdXJjZX0uYCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFleGVjdXRpb25Db250ZXh0LnZpZXdDYWxsZXIgfHxcbiAgICAgICAgICAgIHZhbGlkYXRlQWRkcmVzcyhleGVjdXRpb25Db250ZXh0LnZpZXdDYWxsZXIpICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFZpZXdTaW11bGF0aW9uQ29udGV4dChgVGhlIGNvbnRyYWN0IHdoaWNoIGlzIHRoZSBjYWxsZXIgb2YgdmlldyBpcyBpbnZhbGlkOiAke2V4ZWN1dGlvbkNvbnRleHQudmlld0NhbGxlcn0uYCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdHJhbnNmb3JtQXJnc1RvTWljaGVsc29uKCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NtYXJ0Q29udHJhY3RWaWV3U2NoZW1hLmVuY29kZVZpZXdBcmdzKHRoaXMuX2FyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRWaWV3UGFyYW1ldGVyRXJyb3IodGhpcy5fc21hcnRDb250cmFjdFZpZXdTY2hlbWEudmlld05hbWUsIHRoaXMuZ2V0U2lnbmF0dXJlKCksIHRoaXMuX2FyZ3MsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gTG9vcHMgdGhyb3VnaCB0aGUgdmlldydzIGluc3RydWN0aW9ucyBhbmQgcmVwbGFjZSBCQUxBTkNFLCBTRU5ERVIsIFNFTEZfQUREUkVTUyBhbmQgQU1PVU5UIHdpdGggTWljaGVsc29uIGV4cHJlc3Npb25zIHRoYXQgbWF0Y2ggdGhlIGN1cnJlbnQgY29udGV4dCwgaWYgYXBwbGljYWJsZS5cbiAgICAgKlxuICAgICAqIENlcnRhaW4gc3BlY2lmaWMgaW5zdHJ1Y3Rpb25zIGhhdmUgZGlmZmVyZW50IHNlbWFudGljcyBpbiB2aWV3OlxuICAgICAqIEJBTEFOQ0UgcmVwcmVzZW50cyB0aGUgY3VycmVudCBhbW91bnQgb2YgbXV0ZXogaGVsZCBieSB0aGUgY29udHJhY3Qgd2hlcmUgdmlldyBpcztcbiAgICAgKiBTRU5ERVIgcmVwcmVzZW50cyB0aGUgY29udHJhY3Qgd2hpY2ggaXMgdGhlIGNhbGxlciBvZiB2aWV3O1xuICAgICAqIFNFTEZfQUREUkVTUyByZXByZXNlbnRzIHRoZSBjb250cmFjdCB3aGVyZSB2aWV3IGlzO1xuICAgICAqIEFNT1VOVCBpcyBhbHdheXMgMCBtdXRlei5cbiAgICAgKlxuICAgICAqL1xuICAgIGFkYXB0Vmlld0NvZGVUb0NvbnRleHQoaW5zdHJ1Y3Rpb25zLCB2aWV3Q2FsbGVyLCBjb250cmFjdEJhbGFuY2UpIHtcbiAgICAgICAgY29uc3QgaW5zdHJ1Y3Rpb25zVG9SZXBsYWNlID0ge1xuICAgICAgICAgICAgQkFMQU5DRTogW3sgcHJpbTogJ1BVU0gnLCBhcmdzOiBbeyBwcmltOiAnbXV0ZXonIH0sIHsgaW50OiBjb250cmFjdEJhbGFuY2UgfV0gfV0sXG4gICAgICAgICAgICBTRU5ERVI6IFt7IHByaW06ICdQVVNIJywgYXJnczogW3sgcHJpbTogJ2FkZHJlc3MnIH0sIHsgc3RyaW5nOiB2aWV3Q2FsbGVyIH1dIH1dLFxuICAgICAgICAgICAgU0VMRl9BRERSRVNTOiBbXG4gICAgICAgICAgICAgICAgeyBwcmltOiAnUFVTSCcsIGFyZ3M6IFt7IHByaW06ICdhZGRyZXNzJyB9LCB7IHN0cmluZzogdGhpcy5fY29udHJhY3RBZGRyZXNzIH1dIH0sXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgQU1PVU5UOiBbeyBwcmltOiAnUFVTSCcsIGFyZ3M6IFt7IHByaW06ICdtdXRleicgfSwgeyBpbnQ6ICcwJyB9XSB9XSxcbiAgICAgICAgfTtcbiAgICAgICAgaW5zdHJ1Y3Rpb25zLmZvckVhY2goKGluc3QsIGkpID0+IHtcbiAgICAgICAgICAgIGlmIChpbnN0LnByaW0gaW4gaW5zdHJ1Y3Rpb25zVG9SZXBsYWNlKSB7XG4gICAgICAgICAgICAgICAgaW5zdHJ1Y3Rpb25zW2ldID0gT2JqZWN0KGluc3RydWN0aW9uc1RvUmVwbGFjZSlbaW5zdC5wcmltXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpbnN0LmFyZ3MgJiYgaW5zdC5hcmdzLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRhcHRWaWV3Q29kZVRvQ29udGV4dChpbnN0LmFyZ3MsIHZpZXdDYWxsZXIsIGNvbnRyYWN0QmFsYW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGluc3QpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hZGFwdFZpZXdDb2RlVG9Db250ZXh0KGluc3QsIHZpZXdDYWxsZXIsIGNvbnRyYWN0QmFsYW5jZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gaW5zdHJ1Y3Rpb25zO1xuICAgIH1cbiAgICBleGVjdXRlVmlld0FuZERlY29kZVJlc3VsdCh2aWV3U2NyaXB0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgc3RvcmFnZTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgc3RvcmFnZSA9ICh5aWVsZCB0aGlzLl9ycGMucnVuU2NyaXB0Vmlldyh2aWV3U2NyaXB0KSlcbiAgICAgICAgICAgICAgICAgICAgLmRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBmYWlsV2l0aCA9IHZhbGlkYXRlQW5kRXh0cmFjdEZhaWx3aXRoKGVycm9yKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBmYWlsV2l0aFxuICAgICAgICAgICAgICAgICAgICA/IG5ldyBWaWV3U2ltdWxhdGlvbkVycm9yKGBUaGUgc2ltdWxhdGlvbiBvZiB0aGUgb24tY2hhaW4gdmlldyBuYW1lZCAke3RoaXMuX3NtYXJ0Q29udHJhY3RWaWV3U2NoZW1hLnZpZXdOYW1lfSBmYWlsZWQgd2l0aDogJHtKU09OLnN0cmluZ2lmeShmYWlsV2l0aCl9YCwgdGhpcy5fc21hcnRDb250cmFjdFZpZXdTY2hlbWEudmlld05hbWUsIGZhaWxXaXRoLCBlcnJvcilcbiAgICAgICAgICAgICAgICAgICAgOiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zbWFydENvbnRyYWN0Vmlld1NjaGVtYS5kZWNvZGVWaWV3UmVzdWx0KHN0b3JhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIENvbnRyYWN0TWV0aG9kRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IocHJvdmlkZXIsIGNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICB0aGlzLnByb3ZpZGVyID0gcHJvdmlkZXI7XG4gICAgICAgIHRoaXMuY29udHJhY3RBZGRyZXNzID0gY29udHJhY3RBZGRyZXNzO1xuICAgIH1cbiAgICBjcmVhdGVDb250cmFjdE1ldGhvZEZsYXRQYXJhbXMoc21hcnRDb250cmFjdE1ldGhvZFNjaGVtYSwgc21hcnRDb250cmFjdE1ldGhvZE5hbWUsIGFyZ3MsIGlzTXVsdGlwbGVFbnRyeXBvaW50ID0gdHJ1ZSwgaXNBbm9ueW1vdXMgPSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0TWV0aG9kKHRoaXMucHJvdmlkZXIsIHRoaXMuY29udHJhY3RBZGRyZXNzLCBzbWFydENvbnRyYWN0TWV0aG9kU2NoZW1hLCBzbWFydENvbnRyYWN0TWV0aG9kTmFtZSwgYXJncywgaXNNdWx0aXBsZUVudHJ5cG9pbnQsIGlzQW5vbnltb3VzKTtcbiAgICB9XG4gICAgY3JlYXRlQ29udHJhY3RNZXRob2RPYmplY3RQYXJhbShzbWFydENvbnRyYWN0TWV0aG9kU2NoZW1hLCBzbWFydENvbnRyYWN0TWV0aG9kTmFtZSwgYXJncywgaXNNdWx0aXBsZUVudHJ5cG9pbnQgPSB0cnVlLCBpc0Fub255bW91cyA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29udHJhY3RNZXRob2RPYmplY3QodGhpcy5wcm92aWRlciwgdGhpcy5jb250cmFjdEFkZHJlc3MsIHNtYXJ0Q29udHJhY3RNZXRob2RTY2hlbWEsIHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lLCBhcmdzLCBpc011bHRpcGxlRW50cnlwb2ludCwgaXNBbm9ueW1vdXMpO1xuICAgIH1cbiAgICBjcmVhdGVDb250cmFjdFZpZXdPYmplY3RQYXJhbShycGMsIHJlYWRQcm92aWRlciwgc21hcnRDb250cmFjdFZpZXdTY2hlbWEsIGNvbnRyYWN0U3RvcmFnZVR5cGUsIHZpZXdBcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgT25DaGFpblZpZXcocnBjLCByZWFkUHJvdmlkZXIsIHRoaXMuY29udHJhY3RBZGRyZXNzLCBzbWFydENvbnRyYWN0Vmlld1NjaGVtYSwgY29udHJhY3RTdG9yYWdlVHlwZSwgdmlld0FyZ3MpO1xuICAgIH1cbn1cblxuY29uc3QgREVGQVVMVF9TTUFSVF9DT05UUkFDVF9NRVRIT0RfTkFNRSA9ICdkZWZhdWx0Jztcbi8qKlxuICogQGRlc2NyaXB0aW9uIFV0aWxpdHkgY2xhc3MgdG8gcmV0cmlldmUgZGF0YSBmcm9tIGEgc21hcnQgY29udHJhY3QncyBzdG9yYWdlIHdpdGhvdXQgaW5jdXJyaW5nIGZlZXMgdmlhIGEgY29udHJhY3QncyB2aWV3IG1ldGhvZFxuICovXG5jbGFzcyBDb250cmFjdFZpZXcge1xuICAgIGNvbnN0cnVjdG9yKGN1cnJlbnRDb250cmFjdCwgbmFtZSwgY2FsbGJhY2tQYXJhbWV0ZXJzU2NoZW1hLCBwYXJhbWV0ZXJTY2hlbWEsIGFyZ3MsIHJwYywgcmVhZFByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuY3VycmVudENvbnRyYWN0ID0gY3VycmVudENvbnRyYWN0O1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLmNhbGxiYWNrUGFyYW1ldGVyc1NjaGVtYSA9IGNhbGxiYWNrUGFyYW1ldGVyc1NjaGVtYTtcbiAgICAgICAgdGhpcy5wYXJhbWV0ZXJTY2hlbWEgPSBwYXJhbWV0ZXJTY2hlbWE7XG4gICAgICAgIHRoaXMuYXJncyA9IGFyZ3M7XG4gICAgICAgIHRoaXMucnBjID0gcnBjO1xuICAgICAgICB0aGlzLnJlYWRQcm92aWRlciA9IHJlYWRQcm92aWRlcjtcbiAgICB9XG4gICAgcmVhZChjaGFpbklkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFpbklkVmFsaWRhdGlvbiA9IHZhbGlkYXRlQ2hhaW4oY2hhaW5JZCAhPT0gbnVsbCAmJiBjaGFpbklkICE9PSB2b2lkIDAgPyBjaGFpbklkIDogJycpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlQ29udHJhY3RBZGRyZXNzKGNoYWluSWQgIT09IG51bGwgJiYgY2hhaW5JZCAhPT0gdm9pZCAwID8gY2hhaW5JZCA6ICcnKSA9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IERlcHJlY2F0aW9uRXJyb3IoYFNpbmNlIHZlcnNpb24gMTIsIHRoZSBsYW1iZGEgdmlldyBubyBsb25nZXIgZGVwZW5kcyBvbiBhIGxhbWJkYSBjb250cmFjdC4gVGhlIHJlYWQgbWV0aG9kIG5vIGxvbmdlciBhY2NlcHRzIGEgY29udHJhY3QgYWRkcmVzcyBhcyBhIHBhcmFtZXRlci5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYWluSWQgJiYgY2hhaW5JZFZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENoYWluSWRFcnJvcihjaGFpbklkLCBpbnZhbGlkRGV0YWlsKGNoYWluSWRWYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLnBhcmFtZXRlclNjaGVtYS5FbmNvZGUoLi4udGhpcy5hcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucnBjLnJ1blZpZXcoe1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0OiB0aGlzLmN1cnJlbnRDb250cmFjdC5hZGRyZXNzLFxuICAgICAgICAgICAgICAgIGVudHJ5cG9pbnQ6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dDogYXJnLFxuICAgICAgICAgICAgICAgIGNoYWluX2lkOiBjaGFpbklkID8gY2hhaW5JZCA6IHlpZWxkIHRoaXMucmVhZFByb3ZpZGVyLmdldENoYWluSWQoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY2FsbGJhY2tQYXJhbWV0ZXJzU2NoZW1hLkV4ZWN1dGUocmVzdWx0LmRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jb25zdCB2YWxpZGF0ZUFyZ3MgPSAoYXJncywgc2NoZW1hLCBuYW1lKSA9PiB7XG4gICAgY29uc3Qgc2lncyA9IHNjaGVtYS5FeHRyYWN0U2lnbmF0dXJlcygpO1xuICAgIGlmICghc2lncy5maW5kKCh4KSA9PiB4Lmxlbmd0aCA9PT0gYXJncy5sZW5ndGgpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkUGFyYW1ldGVyRXJyb3IobmFtZSwgc2lncywgYXJncyk7XG4gICAgfVxufTtcbi8vIGxhbWJkYSB2aWV3IHR6aXA0XG5jb25zdCBpc1ZpZXcgPSAoZW50cnlwb2ludCkgPT4ge1xuICAgIGxldCBpc1ZpZXcgPSBmYWxzZTtcbiAgICBpZiAoJ3ByaW0nIGluIGVudHJ5cG9pbnQgJiYgZW50cnlwb2ludC5wcmltID09PSAncGFpcicgJiYgZW50cnlwb2ludC5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGxhc3RFbGVtZW50ID0gZW50cnlwb2ludC5hcmdzW2VudHJ5cG9pbnQuYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKCdwcmltJyBpbiBsYXN0RWxlbWVudCAmJiBsYXN0RWxlbWVudC5wcmltID09PSAnY29udHJhY3QnKSB7XG4gICAgICAgICAgICBpc1ZpZXcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc1ZpZXc7XG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gU21hcnQgY29udHJhY3QgYWJzdHJhY3Rpb25cbiAqL1xuY2xhc3MgQ29udHJhY3RBYnN0cmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoYWRkcmVzcywgc2NyaXB0LCBwcm92aWRlciwgc3RvcmFnZVByb3ZpZGVyLCBlbnRyeXBvaW50cywgcnBjLCByZWFkUHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5hZGRyZXNzID0gYWRkcmVzcztcbiAgICAgICAgdGhpcy5zY3JpcHQgPSBzY3JpcHQ7XG4gICAgICAgIHRoaXMuc3RvcmFnZVByb3ZpZGVyID0gc3RvcmFnZVByb3ZpZGVyO1xuICAgICAgICB0aGlzLmVudHJ5cG9pbnRzID0gZW50cnlwb2ludHM7XG4gICAgICAgIHRoaXMucnBjID0gcnBjO1xuICAgICAgICB0aGlzLnJlYWRQcm92aWRlciA9IHJlYWRQcm92aWRlcjtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBDb250YWlucyBtZXRob2RzIHRoYXQgYXJlIGltcGxlbWVudGVkIGJ5IHRoZSB0YXJnZXQgVGV6b3MgU21hcnQgQ29udHJhY3QsIGFuZCBvZmZlcnMgdGhlIHVzZXIgdG8gY2FsbCB0aGUgU21hcnQgQ29udHJhY3QgbWV0aG9kcyBhcyBpZiB0aGV5IHdlcmUgbmF0aXZlIFRTL0pTIG1ldGhvZHMuXG4gICAgICAgICAqIE5COiBpZiB0aGUgY29udHJhY3QgY29udGFpbnMgYW5ub3RhdGlvbiBpdCB3aWxsIGluY2x1ZGUgbmFtZWQgcHJvcGVydGllczsgaWYgbm90IGl0IHdpbGwgYmUgaW5kZXhlZCBieSBhIG51bWJlci5cbiAgICAgICAgICpcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubWV0aG9kcyA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIENvbnRhaW5zIG1ldGhvZHMgdGhhdCBhcmUgaW1wbGVtZW50ZWQgYnkgdGhlIHRhcmdldCBUZXpvcyBTbWFydCBDb250cmFjdCwgYW5kIG9mZmVycyB0aGUgdXNlciB0byBjYWxsIHRoZSBTbWFydCBDb250cmFjdCBtZXRob2RzIGFzIGlmIHRoZXkgd2VyZSBuYXRpdmUgVFMvSlMgbWV0aG9kcy5cbiAgICAgICAgICogYG1ldGhvZHNPYmplY3RgIHNlcnZlcyB0aGUgZXhhY3Qgc2FtZSBwdXJwb3NlIGFzIHRoZSBgbWV0aG9kc2AgbWVtYmVyLiBUaGUgZGlmZmVyZW5jZSBpcyB0aGF0IGl0IGFsbG93cyBwYXNzaW5nIHRoZSBwYXJhbWV0ZXIgaW4gYW4gb2JqZWN0IGZvcm1hdCB3aGVuIGNhbGxpbmcgdGhlIHNtYXJ0IGNvbnRyYWN0IG1ldGhvZCAoaW5zdGVhZCBvZiB0aGUgZmxhdHRlbmVkIHJlcHJlc2VudGF0aW9uKVxuICAgICAgICAgKiBOQjogaWYgdGhlIGNvbnRyYWN0IGNvbnRhaW5zIGFubm90YXRpb24gaXQgd2lsbCBpbmNsdWRlIG5hbWVkIHByb3BlcnRpZXM7IGlmIG5vdCBpdCB3aWxsIGJlIGluZGV4ZWQgYnkgYSBudW1iZXIuXG4gICAgICAgICAqXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm1ldGhvZHNPYmplY3QgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBDb250YWlucyBsYW1kYSB2aWV3cyAodHppcDQpIHRoYXQgYXJlIGltcGxlbWVudGVkIGJ5IHRoZSB0YXJnZXQgVGV6b3MgU21hcnQgQ29udHJhY3QsIGFuZCBvZmZlcnMgdGhlIHVzZXIgdG8gY2FsbCB0aGUgbGFtYmRhIHZpZXdzIGFzIGlmIHRoZXkgd2VyZSBuYXRpdmUgVFMvSlMgbWV0aG9kcy5cbiAgICAgICAgICogTkI6IFRoZXNlIGFyZSB0aGUgdmlldyBkZWZpbmVkIGluIHRoZSB0emlwNCBzdGFuZGFyZCwgbm90IHRoZSB2aWV3cyBpbnRyb2R1Y2VkIGJ5IHRoZSBIYW5nemhvdSBwcm90b2NvbC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudmlld3MgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBkZXNjcmlwdGlvbiBDb250YWlucyBvbi1jaGFpbiB2aWV3cyB0aGF0IGFyZSBkZWZpbmVkIGJ5IHRoZSB0YXJnZXQgVGV6b3MgU21hcnQgQ29udHJhY3QsIGFuZCBvZmZlcnMgdGhlIHVzZXIgdG8gc2ltdWxhdGUgdGhlIHZpZXdzIGV4ZWN1dGlvbiBhcyBpZiB0aGV5IHdlcmUgbmF0aXZlIFRTL0pTIG1ldGhvZHMuXG4gICAgICAgICAqIE5COiB0aGUgZXhwZWN0ZWQgZm9ybWF0IGZvciB0aGUgcGFyYW1ldGVyIHdoZW4gY2FsbGluZyBhIHNtYXJ0IGNvbnRyYWN0IHZpZXcgaXMgdGhlIG9iamVjdCBmb3JtYXQgKHNhbWUgZm9ybWF0IGFzIGZvciB0aGUgc3RvcmFnZSkgYW5kIG5vdCB0aGUgZmxhdHRlbmVkIHJlcHJlc2VudGF0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5jb250cmFjdFZpZXdzID0ge307XG4gICAgICAgIHRoaXMuY29udHJhY3RNZXRob2RGYWN0b3J5ID0gbmV3IENvbnRyYWN0TWV0aG9kRmFjdG9yeShwcm92aWRlciwgYWRkcmVzcyk7XG4gICAgICAgIHRoaXMuc2NoZW1hID0gU2NoZW1hLmZyb21SUENSZXNwb25zZSh7IHNjcmlwdDogdGhpcy5zY3JpcHQgfSk7XG4gICAgICAgIHRoaXMucGFyYW1ldGVyU2NoZW1hID0gUGFyYW1ldGVyU2NoZW1hLmZyb21SUENSZXNwb25zZSh7IHNjcmlwdDogdGhpcy5zY3JpcHQgfSk7XG4gICAgICAgIHRoaXMudmlld1NjaGVtYSA9IFZpZXdTY2hlbWEuZnJvbVJQQ1Jlc3BvbnNlKHsgc2NyaXB0OiB0aGlzLnNjcmlwdCB9KTtcbiAgICAgICAgaWYgKHRoaXMudmlld1NjaGVtYS5sZW5ndGggIT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2luaXRpYWxpemVPbkNoYWluVmlld3ModGhpcywgcnBjLCB0aGlzLnJlYWRQcm92aWRlciwgdGhpcy52aWV3U2NoZW1hKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmV2ZW50U2NoZW1hID0gRXZlbnRTY2hlbWEuZnJvbVJQQ1Jlc3BvbnNlKHsgc2NyaXB0OiB0aGlzLnNjcmlwdCB9KTtcbiAgICAgICAgdGhpcy5faW5pdGlhbGl6ZU1ldGhvZHModGhpcywgdGhpcy5lbnRyeXBvaW50cy5lbnRyeXBvaW50cywgdGhpcy5ycGMsIHRoaXMucmVhZFByb3ZpZGVyKTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVNZXRob2RzKGN1cnJlbnRDb250cmFjdCwgZW50cnlwb2ludHMsIHJwYywgcmVhZFByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlclNjaGVtYSA9IHRoaXMucGFyYW1ldGVyU2NoZW1hO1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXMoZW50cnlwb2ludHMpO1xuICAgICAgICBpZiAocGFyYW1ldGVyU2NoZW1hLmlzTXVsdGlwbGVFbnRyeVBvaW50KSB7XG4gICAgICAgICAgICBrZXlzLmZvckVhY2goKHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc21hcnRDb250cmFjdE1ldGhvZFNjaGVtYSA9IG5ldyBQYXJhbWV0ZXJTY2hlbWEoZW50cnlwb2ludHNbc21hcnRDb250cmFjdE1ldGhvZE5hbWVdKTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZHNbc21hcnRDb250cmFjdE1ldGhvZE5hbWVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250cmFjdC5jb250cmFjdE1ldGhvZEZhY3RvcnkuY3JlYXRlQ29udHJhY3RNZXRob2RGbGF0UGFyYW1zKHNtYXJ0Q29udHJhY3RNZXRob2RTY2hlbWEsIHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHRoaXMubWV0aG9kc09iamVjdFtzbWFydENvbnRyYWN0TWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENvbnRyYWN0LmNvbnRyYWN0TWV0aG9kRmFjdG9yeS5jcmVhdGVDb250cmFjdE1ldGhvZE9iamVjdFBhcmFtKHNtYXJ0Q29udHJhY3RNZXRob2RTY2hlbWEsIHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpc1ZpZXcoZW50cnlwb2ludHNbc21hcnRDb250cmFjdE1ldGhvZE5hbWVdKSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB2aWV3ID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVudHJ5cG9pbnRQYXJhbVdpdGhvdXRDYWxsYmFjayA9IGVudHJ5cG9pbnRzW3NtYXJ0Q29udHJhY3RNZXRob2ROYW1lXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5hcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc21hcnRDb250cmFjdE1ldGhvZFNjaGVtYVdpdGhvdXRDYWxsYmFjayA9IG5ldyBQYXJhbWV0ZXJTY2hlbWEoZW50cnlwb2ludFBhcmFtV2l0aG91dENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnNDYWxsYmFjayA9IGVudHJ5cG9pbnRzW3NtYXJ0Q29udHJhY3RNZXRob2ROYW1lXS5hcmdzWzFdXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLmFyZ3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzbWFydENvbnRyYWN0TWV0aG9kQ2FsbGJhY2tTY2hlbWEgPSBuZXcgUGFyYW1ldGVyU2NoZW1hKHBhcmFtZXRlcnNDYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWxpZGF0ZUFyZ3MoYXJncywgc21hcnRDb250cmFjdE1ldGhvZFNjaGVtYVdpdGhvdXRDYWxsYmFjaywgc21hcnRDb250cmFjdE1ldGhvZE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDb250cmFjdFZpZXcoY3VycmVudENvbnRyYWN0LCBzbWFydENvbnRyYWN0TWV0aG9kTmFtZSwgc21hcnRDb250cmFjdE1ldGhvZENhbGxiYWNrU2NoZW1hLCBzbWFydENvbnRyYWN0TWV0aG9kU2NoZW1hV2l0aG91dENhbGxiYWNrLCBhcmdzLCBycGMsIHJlYWRQcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmlld3Nbc21hcnRDb250cmFjdE1ldGhvZE5hbWVdID0gdmlldztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIERlYWwgd2l0aCBtZXRob2RzIHdpdGggbm8gYW5ub3RhdGlvbnMgd2hpY2ggd2VyZSBub3QgZGlzY292ZXJlZCBieSB0aGUgUlBDIGVuZHBvaW50XG4gICAgICAgICAgICAvLyBNZXRob2RzIHdpdGggbm8gYW5ub3RhdGlvbnMgYXJlIGRpc2NvdmVyZWQgdXNpbmcgcGFyYW1ldGVyIHNjaGVtYVxuICAgICAgICAgICAgY29uc3QgYW5vbnltb3VzTWV0aG9kcyA9IE9iamVjdC5rZXlzKHBhcmFtZXRlclNjaGVtYS5FeHRyYWN0U2NoZW1hKCkpLmZpbHRlcigoa2V5KSA9PiBPYmplY3Qua2V5cyhlbnRyeXBvaW50cykuaW5kZXhPZihrZXkpID09PSAtMSk7XG4gICAgICAgICAgICBhbm9ueW1vdXNNZXRob2RzLmZvckVhY2goKHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5tZXRob2RzW3NtYXJ0Q29udHJhY3RNZXRob2ROYW1lXSA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50Q29udHJhY3QuY29udHJhY3RNZXRob2RGYWN0b3J5LmNyZWF0ZUNvbnRyYWN0TWV0aG9kRmxhdFBhcmFtcyhwYXJhbWV0ZXJTY2hlbWEsIHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lLCBhcmdzLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm1ldGhvZHNPYmplY3Rbc21hcnRDb250cmFjdE1ldGhvZE5hbWVdID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250cmFjdC5jb250cmFjdE1ldGhvZEZhY3RvcnkuY3JlYXRlQ29udHJhY3RNZXRob2RPYmplY3RQYXJhbShwYXJhbWV0ZXJTY2hlbWEsIHNtYXJ0Q29udHJhY3RNZXRob2ROYW1lLCBhcmdzLCBmYWxzZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc21hcnRDb250cmFjdE1ldGhvZFNjaGVtYSA9IHRoaXMucGFyYW1ldGVyU2NoZW1hO1xuICAgICAgICAgICAgdGhpcy5tZXRob2RzW0RFRkFVTFRfU01BUlRfQ09OVFJBQ1RfTUVUSE9EX05BTUVdID0gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudENvbnRyYWN0LmNvbnRyYWN0TWV0aG9kRmFjdG9yeS5jcmVhdGVDb250cmFjdE1ldGhvZEZsYXRQYXJhbXMoc21hcnRDb250cmFjdE1ldGhvZFNjaGVtYSwgREVGQVVMVF9TTUFSVF9DT05UUkFDVF9NRVRIT0RfTkFNRSwgYXJncywgZmFsc2UpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMubWV0aG9kc09iamVjdFtERUZBVUxUX1NNQVJUX0NPTlRSQUNUX01FVEhPRF9OQU1FXSA9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250cmFjdC5jb250cmFjdE1ldGhvZEZhY3RvcnkuY3JlYXRlQ29udHJhY3RNZXRob2RPYmplY3RQYXJhbShzbWFydENvbnRyYWN0TWV0aG9kU2NoZW1hLCBERUZBVUxUX1NNQVJUX0NPTlRSQUNUX01FVEhPRF9OQU1FLCBhcmdzLCBmYWxzZSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfaW5pdGlhbGl6ZU9uQ2hhaW5WaWV3cyhjdXJyZW50Q29udHJhY3QsIHJwYywgcmVhZFByb3ZpZGVyLCBhbGxDb250cmFjdFZpZXdzKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gdGhpcy5zY2hlbWEudmFsO1xuICAgICAgICBhbGxDb250cmFjdFZpZXdzLmZvckVhY2goKHZpZXdTY2hlbWEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29udHJhY3RWaWV3c1t2aWV3U2NoZW1hLnZpZXdOYW1lXSA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRDb250cmFjdC5jb250cmFjdE1ldGhvZEZhY3RvcnkuY3JlYXRlQ29udHJhY3RWaWV3T2JqZWN0UGFyYW0ocnBjLCByZWFkUHJvdmlkZXIsIHZpZXdTY2hlbWEsIHN0b3JhZ2VUeXBlLCBhcmdzKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgZnJpZW5kbHkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IHN0b3JhZ2VcbiAgICAgKi9cbiAgICBzdG9yYWdlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlUHJvdmlkZXIuZ2V0U3RvcmFnZSh0aGlzLmFkZHJlc3MsIHRoaXMuc2NoZW1hKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgZnJpZW5kbHkgcmVwcmVzZW50YXRpb24gb2YgdGhlIHNtYXJ0IGNvbnRyYWN0IGJpZyBtYXAgdmFsdWVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBrZXkgQmlnTWFwIGtleSB0byBmZXRjaFxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWQgZ2V0QmlnTWFwS2V5IGhhcyBiZWVuIGRlcHJlY2F0ZWQgaW4gZmF2b3Igb2YgZ2V0QmlnTWFwS2V5QnlJRFxuICAgICAqXG4gICAgICogQHNlZSBodHRwczovL3Rlem9zLmdpdGxhYi5pby9hcGkvcnBjLmh0bWwjcG9zdC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1iaWctbWFwLWdldFxuICAgICAqL1xuICAgIGJpZ01hcChrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZVByb3ZpZGVyLmdldEJpZ01hcEtleSh0aGlzLmFkZHJlc3MsIGtleSwgdGhpcy5zY2hlbWEpO1xuICAgIH1cbn1cblxuY29uc3Qgc2V0RGVsZWdhdGUgPSAoa2V5KSA9PiB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgeyBwcmltOiAnRFJPUCcgfSxcbiAgICAgICAgeyBwcmltOiAnTklMJywgYXJnczogW3sgcHJpbTogJ29wZXJhdGlvbicgfV0gfSxcbiAgICAgICAge1xuICAgICAgICAgICAgcHJpbTogJ1BVU0gnLFxuICAgICAgICAgICAgYXJnczogW3sgcHJpbTogJ2tleV9oYXNoJyB9LCB7IHN0cmluZzoga2V5IH1dLFxuICAgICAgICB9LFxuICAgICAgICB7IHByaW06ICdTT01FJyB9LFxuICAgICAgICB7IHByaW06ICdTRVRfREVMRUdBVEUnIH0sXG4gICAgICAgIHsgcHJpbTogJ0NPTlMnIH0sXG4gICAgXTtcbn07XG5jb25zdCB0cmFuc2ZlckltcGxpY2l0ID0gKGtleSwgbXV0ZXopID0+IHtcbiAgICByZXR1cm4gW1xuICAgICAgICB7IHByaW06ICdEUk9QJyB9LFxuICAgICAgICB7IHByaW06ICdOSUwnLCBhcmdzOiBbeyBwcmltOiAnb3BlcmF0aW9uJyB9XSB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBwcmltOiAnUFVTSCcsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcmltOiAna2V5X2hhc2gnIH0sIHsgc3RyaW5nOiBrZXkgfV0sXG4gICAgICAgIH0sXG4gICAgICAgIHsgcHJpbTogJ0lNUExJQ0lUX0FDQ09VTlQnIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByaW06ICdQVVNIJyxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByaW06ICdtdXRleicgfSwgeyBpbnQ6IGAke211dGV6fWAgfV0sXG4gICAgICAgIH0sXG4gICAgICAgIHsgcHJpbTogJ1VOSVQnIH0sXG4gICAgICAgIHsgcHJpbTogJ1RSQU5TRkVSX1RPS0VOUycgfSxcbiAgICAgICAgeyBwcmltOiAnQ09OUycgfSxcbiAgICBdO1xufTtcbmNvbnN0IHJlbW92ZURlbGVnYXRlID0gKCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICAgIHsgcHJpbTogJ0RST1AnIH0sXG4gICAgICAgIHsgcHJpbTogJ05JTCcsIGFyZ3M6IFt7IHByaW06ICdvcGVyYXRpb24nIH1dIH0sXG4gICAgICAgIHsgcHJpbTogJ05PTkUnLCBhcmdzOiBbeyBwcmltOiAna2V5X2hhc2gnIH1dIH0sXG4gICAgICAgIHsgcHJpbTogJ1NFVF9ERUxFR0FURScgfSxcbiAgICAgICAgeyBwcmltOiAnQ09OUycgfSxcbiAgICBdO1xufTtcbmNvbnN0IHRyYW5zZmVyVG9Db250cmFjdCA9IChrZXksIGFtb3VudCkgPT4ge1xuICAgIHJldHVybiBbXG4gICAgICAgIHsgcHJpbTogJ0RST1AnIH0sXG4gICAgICAgIHsgcHJpbTogJ05JTCcsIGFyZ3M6IFt7IHByaW06ICdvcGVyYXRpb24nIH1dIH0sXG4gICAgICAgIHtcbiAgICAgICAgICAgIHByaW06ICdQVVNIJyxcbiAgICAgICAgICAgIGFyZ3M6IFt7IHByaW06ICdhZGRyZXNzJyB9LCB7IHN0cmluZzoga2V5IH1dLFxuICAgICAgICB9LFxuICAgICAgICB7IHByaW06ICdDT05UUkFDVCcsIGFyZ3M6IFt7IHByaW06ICd1bml0JyB9XSB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBwcmltOiAnSUZfTk9ORScsXG4gICAgICAgICAgICBhcmdzOiBbW3sgcHJpbTogJ1VOSVQnIH0sIHsgcHJpbTogJ0ZBSUxXSVRIJyB9XSwgW11dLFxuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgICBwcmltOiAnUFVTSCcsXG4gICAgICAgICAgICBhcmdzOiBbeyBwcmltOiAnbXV0ZXonIH0sIHsgaW50OiBgJHthbW91bnR9YCB9XSxcbiAgICAgICAgfSxcbiAgICAgICAgeyBwcmltOiAnVU5JVCcgfSxcbiAgICAgICAgeyBwcmltOiAnVFJBTlNGRVJfVE9LRU5TJyB9LFxuICAgICAgICB7IHByaW06ICdDT05TJyB9LFxuICAgIF07XG59O1xuY29uc3QgTUFOQUdFUl9MQU1CREEgPSB7XG4gICAgc2V0RGVsZWdhdGUsXG4gICAgcmVtb3ZlRGVsZWdhdGUsXG4gICAgdHJhbnNmZXJJbXBsaWNpdCxcbiAgICB0cmFuc2ZlclRvQ29udHJhY3QsXG59O1xuXG5jb25zdCBjb2RlID0gW1xuICAgIHtcbiAgICAgICAgcHJpbTogJ3BhcmFtZXRlcicsXG4gICAgICAgIGFyZ3M6IFtcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBwcmltOiAnbGFtYmRhJyxcbiAgICAgICAgICAgICAgICBhcmdzOiBbXG4gICAgICAgICAgICAgICAgICAgIHsgcHJpbTogJ3VuaXQnIH0sXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaW06ICdwYWlyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3M6IFt7IHByaW06ICdsaXN0JywgYXJnczogW3sgcHJpbTogJ29wZXJhdGlvbicgfV0gfSwgeyBwcmltOiAndW5pdCcgfV0sXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIF0sXG4gICAgfSxcbiAgICB7IHByaW06ICdzdG9yYWdlJywgYXJnczogW3sgcHJpbTogJ3VuaXQnIH1dIH0sXG4gICAgeyBwcmltOiAnY29kZScsIGFyZ3M6IFtbeyBwcmltOiAnQ0FSJyB9LCB7IHByaW06ICdVTklUJyB9LCB7IHByaW06ICdFWEVDJyB9XV0gfSxcbl07XG5jb25zdCBzdG9yYWdlID0gJ1VuaXQnO1xuY29uc3QgVklFV19MQU1CREEgPSB7XG4gICAgY29kZSxcbiAgICBzdG9yYWdlXG59O1xuXG5mdW5jdGlvbiBjb21wb3NlKGZ1bmN0aW9uY29tcG9zZXIxLCBmdW5jdGlvbmNvbXBvc2VyMikge1xuICAgIHJldHVybiAoY29udHJhY3RBYnN0cmFjdGlvbiwgY29udGV4dCkgPT4gZnVuY3Rpb25jb21wb3NlcjIoZnVuY3Rpb25jb21wb3NlcjEoY29udHJhY3RBYnN0cmFjdGlvbiwgY29udGV4dCksIGNvbnRleHQpO1xufVxuXG5jbGFzcyBTYXBsaW5nU3RhdGVBYnN0cmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaWQsIHByb3ZpZGVyKSB7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBGZXRjaCB0aGUgc2FwbGluZyBzdGF0ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGJsb2NrIG9wdGlvbmFsIGJsb2NrIGxldmVsIHRvIGZldGNoIHRoZSB2YWx1ZXMgZnJvbSAoaGVhZCB3aWxsIGJlIHVzZSBieSBkZWZhdWx0KVxuICAgICAqIEByZXR1cm5zIFJldHVybiBhIGpzb24gb2JqZWN0IG9mIHRoZSBzYXBsaW5nX3N0YXRlXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRTYXBsaW5nRGlmZihibG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0U2FwbGluZ0RpZmZCeUlEKHRoaXMuaWQudG9TdHJpbmcoKSwgYmxvY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlkLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuXG5jbGFzcyBCaWdNYXBBYnN0cmFjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaWQsIHNjaGVtYSwgcHJvdmlkZXIpIHtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnNjaGVtYSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5wcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBGZXRjaCBvbmUgdmFsdWUgaW4gYSBiaWcgbWFwXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5c1RvRW5jb2RlIEtleSB0byBxdWVyeSAod2lsbCBiZSBlbmNvZGVkIHByb3Blcmx5IGFjY29yZGluZyB0byB0aGUgc2NoZW1hKVxuICAgICAqIEBwYXJhbSBibG9jayBvcHRpb25hbCBibG9jayBsZXZlbCB0byBmZXRjaCB0aGUgdmFsdWVzIGZyb20gKGhlYWQgd2lsbCBiZSB1c2UgYnkgZGVmYXVsdClcbiAgICAgKiBAcmV0dXJucyBSZXR1cm4gYSB3ZWxsIGZvcm1hdHRlZCBqc29uIG9iamVjdCBvZiBhIGJpZyBtYXAgdmFsdWUgb3IgdW5kZWZpbmVkIGlmIHRoZSBrZXkgaXMgbm90IGZvdW5kIGluIHRoZSBiaWcgbWFwXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXQoa2V5VG9FbmNvZGUsIGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlkID0geWllbGQgdGhpcy5wcm92aWRlci5nZXRCaWdNYXBLZXlCeUlEKHRoaXMuaWQudG9TdHJpbmcoKSwga2V5VG9FbmNvZGUsIHRoaXMuc2NoZW1hLCBibG9jayk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGlkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZSBpbnN0YW5jZW9mIEh0dHBSZXNwb25zZUVycm9yICYmIGUuc3RhdHVzID09PSBTVEFUVVNfQ09ERS5OT1RfRk9VTkQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gRmV0Y2ggbXVsdGlwbGUgdmFsdWVzIGluIGEgYmlnIG1hcFxuICAgICAqIEFsbCB2YWx1ZXMgd2lsbCBiZSBmZXRjaGVkIG9uIHRoZSBzYW1lIGJsb2NrIGxldmVsLiBJZiBhIGJsb2NrIGlzIHNwZWNpZmllZCBpbiB0aGUgcmVxdWVzdCwgdGhlIHZhbHVlcyB3aWxsIGJlIGZldGNoZWQgYXQgaXQuXG4gICAgICogT3RoZXJ3aXNlLCBhIGZpcnN0IHJlcXVlc3Qgd2lsbCBiZSBkb25lIHRvIHRoZSBub2RlIHRvIGZldGNoIHRoZSBsZXZlbCBvZiB0aGUgaGVhZCBhbmQgYWxsIHZhbHVlcyB3aWxsIGJlIGZldGNoZWQgYXQgdGhpcyBsZXZlbC5cbiAgICAgKiBJZiBvbmUgb2YgdGhlIGtleXMgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGJpZyBtYXAsIGl0cyB2YWx1ZSB3aWxsIGJlIHNldCB0byB1bmRlZmluZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ga2V5c1RvRW5jb2RlIEFycmF5IG9mIGtleXMgdG8gcXVlcnkgKHdpbGwgYmUgZW5jb2RlZCBwcm9wZXJseSBhY2NvcmRpbmcgdG8gdGhlIHNjaGVtYSlcbiAgICAgKiBAcGFyYW0gYmxvY2sgb3B0aW9uYWwgYmxvY2sgbGV2ZWwgdG8gZmV0Y2ggdGhlIHZhbHVlcyBmcm9tXG4gICAgICogQHBhcmFtIGJhdGNoU2l6ZSBvcHRpb25hbCBiYXRjaCBzaXplIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHJlcXVlc3RzIHRvIGV4ZWN1dGUgaW4gcGFyYWxsZWxcbiAgICAgKiBAcmV0dXJucyBBIE1pY2hlbHNvbk1hcCBjb250YWluaW5nIHRoZSBrZXlzIHF1ZXJpZWQgaW4gdGhlIGJpZyBtYXAgYW5kIHRoZWlyIHZhbHVlIGluIGEgd2VsbC1mb3JtYXR0ZWQgSlNPTiBvYmplY3QgZm9ybWF0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRNdWx0aXBsZVZhbHVlcyhrZXlzVG9FbmNvZGUsIGJsb2NrLCBiYXRjaFNpemUgPSA1KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRCaWdNYXBLZXlzQnlJRCh0aGlzLmlkLnRvU3RyaW5nKCksIGtleXNUb0VuY29kZSwgdGhpcy5zY2hlbWEsIGJsb2NrLCBiYXRjaFNpemUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdG9KU09OKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5pZC50b1N0cmluZygpO1xuICAgIH1cbiAgICB0b1N0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQudG9TdHJpbmcoKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIE92ZXJyaWRlIHRoZSBkZWZhdWx0IG1pY2hlbHNvbiBlbmNvZGVyIHNlbWFudGljIHRvIHByb3ZpZGUgcmljaGVyIGFic3RyYWN0aW9uIG92ZXIgc3RvcmFnZSBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0gcHJvdmlkZXIgQ29udHJhY3RQcm92aWRlciAoY29udHJhY3QgQVBJKVxuICovXG4vLyBPdmVycmlkZSB0aGUgZGVmYXVsdCBtaWNoZWxzb24gZW5jb2RlciBzZW1hbnRpYyB0byBwcm92aWRlIHJpY2hlciBhYnN0cmFjdGlvbiBvdmVyIHN0b3JhZ2UgcHJvcGVydGllc1xuY29uc3Qgc21hcnRDb250cmFjdEFic3RyYWN0aW9uU2VtYW50aWMgPSAocHJvdmlkZXIpID0+ICh7XG4gICAgLy8gUHJvdmlkZSBhIHNwZWNpZmljIGFic3RyYWN0aW9uIGZvciBCaWdNYXBzXG4gICAgYmlnX21hcDogKHZhbCwgY29kZSkgPT4ge1xuICAgICAgICBpZiAoIXZhbCB8fCAhKCdpbnQnIGluIHZhbCkgfHwgdmFsLmludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGluIGNhc2Ugb2YgbWlzc2luZyBiaWcgbWFwIElEXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBzY2hlbWEgPSBuZXcgU2NoZW1hKGNvZGUpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdNYXBBYnN0cmFjdGlvbihuZXcgQmlnTnVtYmVyKHZhbC5pbnQpLCBzY2hlbWEsIHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgc2FwbGluZ19zdGF0ZTogKHZhbCkgPT4ge1xuICAgICAgICBpZiAoIXZhbCB8fCAhKCdpbnQnIGluIHZhbCkgfHwgdmFsLmludCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvLyBSZXR1cm4gYW4gZW1wdHkgb2JqZWN0IGluIGNhc2Ugb2YgbWlzc2luZyBzYXBsaW5nIHN0YXRlIElEXG4gICAgICAgICAgICByZXR1cm4ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNhcGxpbmdTdGF0ZUFic3RyYWN0aW9uKG5ldyBCaWdOdW1iZXIodmFsLmludCksIHByb3ZpZGVyKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLypcbiAgICAvLyBUT0RPOiBlbWJlZCB1c2VmdWwgb3RoZXIgYWJzdHJhY3Rpb25zXG4gICAgJ2NvbnRyYWN0JzogICgpID0+IHt9LFxuICAgICdhZGRyZXNzJzogICgpID0+IHt9XG4gICAgKi9cbn0pO1xuXG52YXIgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycztcbmNvbnN0IG1lcmdlTGltaXRzID0gKHVzZXJEZWZpbmVkTGltaXQsIGRlZmF1bHRMaW1pdHMpID0+IHtcbiAgICB2YXIgX2EsIF9iLCBfYztcbiAgICByZXR1cm4ge1xuICAgICAgICBmZWU6IChfYSA9IHVzZXJEZWZpbmVkTGltaXQuZmVlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiBkZWZhdWx0TGltaXRzLmZlZSxcbiAgICAgICAgZ2FzTGltaXQ6IChfYiA9IHVzZXJEZWZpbmVkTGltaXQuZ2FzTGltaXQpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IGRlZmF1bHRMaW1pdHMuZ2FzTGltaXQsXG4gICAgICAgIHN0b3JhZ2VMaW1pdDogKF9jID0gdXNlckRlZmluZWRMaW1pdC5zdG9yYWdlTGltaXQpICE9PSBudWxsICYmIF9jICE9PSB2b2lkIDAgPyBfYyA6IGRlZmF1bHRMaW1pdHMuc3RvcmFnZUxpbWl0LFxuICAgIH07XG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gUHJlcGFyZVByb3ZpZGVyIGlzIGEgdXRpbGl0eSBjbGFzcyB0byBvdXRwdXQgdGhlIHByZXBhcmVkIGZvcm1hdCBvZiBhbiBvcGVyYXRpb25cbiAqL1xuY2xhc3MgUHJlcGFyZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoY29udGV4dCk7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIF9QcmVwYXJlUHJvdmlkZXJfY291bnRlcnMuc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICB9XG4gICAgZ2V0QmxvY2tIYXNoKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRCbG9ja0hhc2goYmxvY2sgIT09IG51bGwgJiYgYmxvY2sgIT09IHZvaWQgMCA/IGJsb2NrIDogJ2hlYWR+MicpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0UHJvdG9jb2xIYXNoKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0TmV4dFByb3RvY29sKCdoZWFkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRIZWFkQ291bnRlcihwa2gpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0Q291bnRlcihwa2gsICdoZWFkJykpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcwJztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFkanVzdEdhc0ZvckJhdGNoT3BlcmF0aW9uKGdhc0xpbWl0QmxvY2ssIGdhc2xpbWl0T3AsIG51bWJlck9mT3BzKSB7XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIubWluKGdhc2xpbWl0T3AsIGdhc0xpbWl0QmxvY2suZGl2KG51bWJlck9mT3BzICsgMSkpO1xuICAgIH1cbiAgICBnZXRBY2NvdW50TGltaXRzKHBraCwgY29uc3RhbnRzLCBudW1iZXJPZk9wcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0QmFsYW5jZShwa2gsICdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCB7IGhhcmRfZ2FzX2xpbWl0X3Blcl9vcGVyYXRpb24sIGhhcmRfZ2FzX2xpbWl0X3Blcl9ibG9jaywgaGFyZF9zdG9yYWdlX2xpbWl0X3Blcl9vcGVyYXRpb24sIGNvc3RfcGVyX2J5dGUsIH0gPSBjb25zdGFudHM7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZlZTogMCxcbiAgICAgICAgICAgICAgICBnYXNMaW1pdDogbnVtYmVyT2ZPcHNcbiAgICAgICAgICAgICAgICAgICAgPyBNYXRoLmZsb29yKHRoaXMuYWRqdXN0R2FzRm9yQmF0Y2hPcGVyYXRpb24oaGFyZF9nYXNfbGltaXRfcGVyX2Jsb2NrLCBoYXJkX2dhc19saW1pdF9wZXJfb3BlcmF0aW9uLCBudW1iZXJPZk9wcykudG9OdW1iZXIoKSlcbiAgICAgICAgICAgICAgICAgICAgOiBoYXJkX2dhc19saW1pdF9wZXJfb3BlcmF0aW9uLnRvTnVtYmVyKCksXG4gICAgICAgICAgICAgICAgc3RvcmFnZUxpbWl0OiBNYXRoLmZsb29yKEJpZ051bWJlci5taW4oYmFsYW5jZS5kaXZpZGVkQnkoY29zdF9wZXJfYnl0ZSksIGhhcmRfc3RvcmFnZV9saW1pdF9wZXJfb3BlcmF0aW9uKS50b051bWJlcigpKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRGZWUob3AsIHBraCwgaGVhZENvdW50ZXIpIHtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9QcmVwYXJlUHJvdmlkZXJfY291bnRlcnMsIFwiZlwiKVtwa2hdIHx8IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywgXCJmXCIpW3BraF0gPCBoZWFkQ291bnRlcikge1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCBcImZcIilbcGtoXSA9IGhlYWRDb3VudGVyO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wQ291bnRlciA9ICsrX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCBcImZcIilbcGtoXTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNvdW50ZXI6IGAke29wQ291bnRlcn1gLFxuICAgICAgICAgICAgZmVlOiB0eXBlb2Ygb3AuZmVlID09PSAndW5kZWZpbmVkJyA/ICcwJyA6IGAke29wLmZlZX1gLFxuICAgICAgICAgICAgZ2FzX2xpbWl0OiB0eXBlb2Ygb3AuZ2FzX2xpbWl0ID09PSAndW5kZWZpbmVkJyA/ICcwJyA6IGAke29wLmdhc19saW1pdH1gLFxuICAgICAgICAgICAgc3RvcmFnZV9saW1pdDogdHlwZW9mIG9wLnN0b3JhZ2VfbGltaXQgPT09ICd1bmRlZmluZWQnID8gJzAnIDogYCR7b3Auc3RvcmFnZV9saW1pdH1gLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBnZXRTb3VyY2Uob3AsIHBraCwgc291cmNlKSB7XG4gICAgICAgIHJldHVybiB7IHNvdXJjZTogdHlwZW9mIG9wLnNvdXJjZSA9PT0gJ3VuZGVmaW5lZCcgPyBzb3VyY2UgfHwgcGtoIDogb3Auc291cmNlIH07XG4gICAgfVxuICAgIGFkZFJldmVhbE9wZXJhdGlvbklmTmVlZGVkKG9wZXJhdGlvbiwgcHVibGljS2V5SGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGlzT3BSZXF1aXJlUmV2ZWFsKG9wZXJhdGlvbikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcHMgPSBbb3BlcmF0aW9uXTtcbiAgICAgICAgICAgICAgICBjb25zdCB7IHB1YmxpY0tleSwgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgICAgICBpZiAoeWllbGQgdGhpcy5pc0FjY291bnRSZXZlYWxSZXF1aXJlZChwdWJsaWNLZXlIYXNoKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXB1YmxpY0tleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFB1YmxpY0tleU5vdEZvdW5kRXJyb3IocGtoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHMudW5zaGlmdCh5aWVsZCBjcmVhdGVSZXZlYWxPcGVyYXRpb24oe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmVlOiBERUZBVUxUX0ZFRS5SRVZFQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlTGltaXQ6IERFRkFVTFRfU1RPUkFHRV9MSU1JVC5SRVZFQUwsXG4gICAgICAgICAgICAgICAgICAgICAgICBnYXNMaW1pdDogZ2V0UmV2ZWFsR2FzTGltaXQocGtoKSxcbiAgICAgICAgICAgICAgICAgICAgfSwgcHVibGljS2V5SGFzaCwgcHVibGljS2V5KSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvbjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEtleXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBpc1NpZ25lckNvbmZpZ3VyZWQgPSB0aGlzLmNvbnRleHQuaXNBbnlTaWduZXJDb25maWd1cmVkKCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHBraDogaXNTaWduZXJDb25maWd1cmVkXG4gICAgICAgICAgICAgICAgICAgID8geWllbGQgdGhpcy5zaWduZXIucHVibGljS2V5SGFzaCgpXG4gICAgICAgICAgICAgICAgICAgIDogeWllbGQgdGhpcy5jb250ZXh0LndhbGxldFByb3ZpZGVyLmdldFBLSCgpLFxuICAgICAgICAgICAgICAgIHB1YmxpY0tleTogaXNTaWduZXJDb25maWd1cmVkID8geWllbGQgdGhpcy5zaWduZXIucHVibGljS2V5KCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29udmVydEludG9BcnJheShvcCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcCkpIHtcbiAgICAgICAgICAgIHJldHVybiBbLi4ub3BdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFtvcF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gsIHNvdXJjZSwgY3VycmVudFZvdGluZ1BlcmlvZCkge1xuICAgICAgICByZXR1cm4gb3BzLm1hcCgob3ApID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAob3Aua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLkFDVElWQVRJT046XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuRFJBSU5fREVMRUdBVEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcCk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuT1JJR0lOQVRJT046XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcCksIHsgYmFsYW5jZTogdHlwZW9mIG9wLmJhbGFuY2UgIT09ICd1bmRlZmluZWQnID8gYCR7b3AuYmFsYW5jZX1gIDogJzAnIH0pLCB0aGlzLmdldFNvdXJjZShvcCwgcGtoLCBzb3VyY2UpKSwgdGhpcy5nZXRGZWUob3AsIHBraCwgaGVhZENvdW50ZXIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5UUkFOU0FDVElPTjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb3BzID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCB7IGFtb3VudDogdHlwZW9mIG9wLmFtb3VudCAhPT0gJ3VuZGVmaW5lZCcgPyBgJHtvcC5hbW91bnR9YCA6ICcwJyB9KSwgdGhpcy5nZXRTb3VyY2Uob3AsIHBraCwgc291cmNlKSksIHRoaXMuZ2V0RmVlKG9wLCBwa2gsIGhlYWRDb3VudGVyKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb3BzLnNvdXJjZS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ2t0MScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRGVwcmVjYXRpb25FcnJvcihgS1QxIGFkZHJlc3NlcyBhcmUgbm90IHN1cHBvcnRlZCBhcyBzb3VyY2Ugc2luY2UgJHtQcm90b2NvbHMuUHNCYWJ5TTF9YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvcHM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlJFVkVBTDpcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5ERUxFR0FUSU9OOlxuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlJFR0lTVEVSX0dMT0JBTF9DT05TVEFOVDpcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5VUERBVEVfQ09OU0VOU1VTX0tFWTpcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5TTUFSVF9ST0xMVVBfQUREX01FU1NBR0VTOlxuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlNNQVJUX1JPTExVUF9PUklHSU5BVEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCB0aGlzLmdldFNvdXJjZShvcCwgcGtoLCBzb3VyY2UpKSwgdGhpcy5nZXRGZWUob3AsIHBraCwgaGVhZENvdW50ZXIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5UUkFOU0ZFUl9USUNLRVQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcCksIHsgdGlja2V0X2Ftb3VudDogYCR7b3AudGlja2V0X2Ftb3VudH1gIH0pLCB0aGlzLmdldFNvdXJjZShvcCwgcGtoLCBzb3VyY2UpKSwgdGhpcy5nZXRGZWUob3AsIHBraCwgaGVhZENvdW50ZXIpKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5JTkNSRUFTRV9QQUlEX1NUT1JBR0U6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvcCksIHsgYW1vdW50OiBgJHtvcC5hbW91bnR9YCB9KSwgdGhpcy5nZXRTb3VyY2Uob3AsIHBraCwgc291cmNlKSksIHRoaXMuZ2V0RmVlKG9wLCBwa2gsIGhlYWRDb3VudGVyKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuQkFMTE9UOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZvdGluZ1BlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBDUmVzcG9uc2VFcnJvcihgRmFpbGVkIHRvIGdldCB0aGUgY3VycmVudCB2b3RpbmcgcGVyaW9kIGluZGV4YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCB7IHBlcmlvZDogY3VycmVudFZvdGluZ1BlcmlvZCA9PT0gbnVsbCB8fCBjdXJyZW50Vm90aW5nUGVyaW9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Vm90aW5nUGVyaW9kLnZvdGluZ19wZXJpb2QuaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuUFJPUE9TQUxTOlxuICAgICAgICAgICAgICAgICAgICBpZiAoY3VycmVudFZvdGluZ1BlcmlvZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBDUmVzcG9uc2VFcnJvcihgRmFpbGVkIHRvIGdldCB0aGUgY3VycmVudCB2b3RpbmcgcGVyaW9kIGluZGV4YCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCB7IHBlcmlvZDogY3VycmVudFZvdGluZ1BlcmlvZCA9PT0gbnVsbCB8fCBjdXJyZW50Vm90aW5nUGVyaW9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjdXJyZW50Vm90aW5nUGVyaW9kLnZvdGluZ19wZXJpb2QuaW5kZXggfSk7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRPcGVyYXRpb25LaW5kRXJyb3IkMShvcC5raW5kKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBwcmVwYXJlIGFuIGFjdGl2YXRpb24gb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbiBSUENPcGVyYXRpb24gb2JqZWN0IG9yIFJQQ09wZXJhdGlvbiBhcnJheVxuICAgICAqIEBwYXJhbSBzb3VyY2Ugc3RyaW5nIG9yIHVuZGVmaW5lZCBzb3VyY2UgcGtoXG4gICAgICogQHJldHVybnMgYSBQcmVwYXJlZE9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBhY3RpdmF0ZSh7IHBraCwgc2VjcmV0IH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgY3JlYXRlQWN0aXZhdGlvbk9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgcGtoLFxuICAgICAgICAgICAgICAgIHNlY3JldCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5jb252ZXJ0SW50b0FycmF5KG9wKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmdldEJsb2NrSGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLmdldFByb3RvY29sSGFzaCgpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCB7fSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgaGVhZENvdW50ZXIgPSBwYXJzZUludCh5aWVsZCB0aGlzLmdldEhlYWRDb3VudGVyKHBraCksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gcHJlcGFyZSBhIHJldmVhbCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHNvdXJjZSBzdHJpbmcgb3IgdW5kZWZpbmVkIHNvdXJjZSBwa2hcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIHJldmVhbCh7IGZlZSwgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBraCwgcHVibGljS2V5IH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFB1YmxpY0tleU5vdEZvdW5kRXJyb3IocGtoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgREVGQVVMVF9QQVJBTVMgPSB5aWVsZCB0aGlzLmdldEFjY291bnRMaW1pdHMocGtoLCBwcm90b2NvbENvbnN0YW50cyk7XG4gICAgICAgICAgICBjb25zdCBtZXJnZWRFc3RpbWF0ZXMgPSBtZXJnZUxpbWl0cyh7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9LCBERUZBVUxUX1BBUkFNUyk7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIGNyZWF0ZVJldmVhbE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgZmVlOiBtZXJnZWRFc3RpbWF0ZXMuZmVlLFxuICAgICAgICAgICAgICAgIGdhc0xpbWl0OiBtZXJnZWRFc3RpbWF0ZXMuZ2FzTGltaXQsXG4gICAgICAgICAgICAgICAgc3RvcmFnZUxpbWl0OiBtZXJnZWRFc3RpbWF0ZXMuc3RvcmFnZUxpbWl0LFxuICAgICAgICAgICAgfSwgcGtoLCBwdWJsaWNLZXkpO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5jb252ZXJ0SW50b0FycmF5KG9wKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmdldEJsb2NrSGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLmdldFByb3RvY29sSGFzaCgpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCB7fSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgaGVhZENvdW50ZXIgPSBwYXJzZUludCh5aWVsZCB0aGlzLmdldEhlYWRDb3VudGVyKHBraCksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gcHJlcGFyZSBhbiBvcmlnaW5hdGlvbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHNvdXJjZSBzdHJpbmcgb3IgdW5kZWZpbmVkIHNvdXJjZSBwa2hcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIG9yaWdpbmF0ZShfYSwgc291cmNlKSB7XG4gICAgICAgIHZhciB7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZlZVwiLCBcInN0b3JhZ2VMaW1pdFwiLCBcImdhc0xpbWl0XCJdKTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgREVGQVVMVF9QQVJBTVMgPSB5aWVsZCB0aGlzLmdldEFjY291bnRMaW1pdHMocGtoLCBwcm90b2NvbENvbnN0YW50cyk7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIGNyZWF0ZU9yaWdpbmF0aW9uT3BlcmF0aW9uKHlpZWxkIHRoaXMuY29udGV4dC5wYXJzZXIucHJlcGFyZUNvZGVPcmlnaW5hdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCBtZXJnZUxpbWl0cyh7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9LCBERUZBVUxUX1BBUkFNUykpKSk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB5aWVsZCB0aGlzLmFkZFJldmVhbE9wZXJhdGlvbklmTmVlZGVkKG9wLCBwa2gpO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5jb252ZXJ0SW50b0FycmF5KG9wZXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5nZXRCbG9ja0hhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbEhhc2goKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRDb3VudGVyID0gcGFyc2VJbnQoeWllbGQgdGhpcy5nZXRIZWFkQ291bnRlcihwa2gpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gsIHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gcHJlcGFyZSBhIHRyYW5zYWN0aW9uIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcGVyYXRpb24gUlBDT3BlcmF0aW9uIG9iamVjdCBvciBSUENPcGVyYXRpb24gYXJyYXlcbiAgICAgKiBAcGFyYW0gc291cmNlIHN0cmluZyBvciB1bmRlZmluZWQgc291cmNlIHBraFxuICAgICAqIEByZXR1cm5zIGEgUHJlcGFyZWRPcGVyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgdHJhbnNhY3Rpb24oX2EpIHtcbiAgICAgICAgdmFyIHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiZmVlXCIsIFwic3RvcmFnZUxpbWl0XCIsIFwiZ2FzTGltaXRcIl0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwa2ggfSA9IHlpZWxkIHRoaXMuZ2V0S2V5cygpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBERUZBVUxUX1BBUkFNUyA9IHlpZWxkIHRoaXMuZ2V0QWNjb3VudExpbWl0cyhwa2gsIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgY3JlYXRlVHJhbnNmZXJPcGVyYXRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgbWVyZ2VMaW1pdHMoeyBmZWUsIHN0b3JhZ2VMaW1pdCwgZ2FzTGltaXQgfSwgREVGQVVMVF9QQVJBTVMpKSk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB5aWVsZCB0aGlzLmFkZFJldmVhbE9wZXJhdGlvbklmTmVlZGVkKG9wLCBwa2gpO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5jb252ZXJ0SW50b0FycmF5KG9wZXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5nZXRCbG9ja0hhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbEhhc2goKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRDb3VudGVyID0gcGFyc2VJbnQoeWllbGQgdGhpcy5nZXRIZWFkQ291bnRlcihwa2gpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gsIHJlc3Quc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BPYjoge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IGhlYWRDb3VudGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBwcmVwYXJlIGEgZGVsZWdhdGlvbiBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHNvdXJjZSBzdHJpbmcgb3IgdW5kZWZpbmVkIHNvdXJjZSBwa2hcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIGRlbGVnYXRpb24oX2EpIHtcbiAgICAgICAgdmFyIHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiZmVlXCIsIFwic3RvcmFnZUxpbWl0XCIsIFwiZ2FzTGltaXRcIl0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwa2ggfSA9IHlpZWxkIHRoaXMuZ2V0S2V5cygpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBERUZBVUxUX1BBUkFNUyA9IHlpZWxkIHRoaXMuZ2V0QWNjb3VudExpbWl0cyhwa2gsIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgY3JlYXRlU2V0RGVsZWdhdGVPcGVyYXRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgbWVyZ2VMaW1pdHMoeyBmZWUsIHN0b3JhZ2VMaW1pdCwgZ2FzTGltaXQgfSwgREVGQVVMVF9QQVJBTVMpKSk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB5aWVsZCB0aGlzLmFkZFJldmVhbE9wZXJhdGlvbklmTmVlZGVkKG9wLCBwa2gpO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5jb252ZXJ0SW50b0FycmF5KG9wZXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5nZXRCbG9ja0hhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbEhhc2goKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRDb3VudGVyID0gcGFyc2VJbnQoeWllbGQgdGhpcy5nZXRIZWFkQ291bnRlcihwa2gpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gsIHJlc3Quc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BPYjoge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IGhlYWRDb3VudGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBwcmVwYXJlIGEgcmVnaXN0ZXIgZGVsZWdhdGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbiBSUENPcGVyYXRpb24gb2JqZWN0IG9yIFJQQ09wZXJhdGlvbiBhcnJheVxuICAgICAqIEBwYXJhbSBzb3VyY2Ugc3RyaW5nIG9yIHVuZGVmaW5lZCBzb3VyY2UgcGtoXG4gICAgICogQHJldHVybnMgYSBQcmVwYXJlZE9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICByZWdpc3RlckRlbGVnYXRlKHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0sIHNvdXJjZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwa2ggfSA9IHlpZWxkIHRoaXMuZ2V0S2V5cygpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBERUZBVUxUX1BBUkFNUyA9IHlpZWxkIHRoaXMuZ2V0QWNjb3VudExpbWl0cyhwa2gsIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG1lcmdlZEVzdGltYXRlcyA9IG1lcmdlTGltaXRzKHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0sIERFRkFVTFRfUEFSQU1TKTtcbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgY3JlYXRlUmVnaXN0ZXJEZWxlZ2F0ZU9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgZmVlOiBtZXJnZWRFc3RpbWF0ZXMuZmVlLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VMaW1pdDogbWVyZ2VkRXN0aW1hdGVzLnN0b3JhZ2VMaW1pdCxcbiAgICAgICAgICAgICAgICBnYXNMaW1pdDogbWVyZ2VkRXN0aW1hdGVzLmdhc0xpbWl0LFxuICAgICAgICAgICAgfSwgcGtoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHlpZWxkIHRoaXMuYWRkUmV2ZWFsT3BlcmF0aW9uSWZOZWVkZWQob3AsIHBraCk7XG4gICAgICAgICAgICBjb25zdCBvcHMgPSB0aGlzLmNvbnZlcnRJbnRvQXJyYXkob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmdldEJsb2NrSGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLmdldFByb3RvY29sSGFzaCgpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCB7fSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgaGVhZENvdW50ZXIgPSBwYXJzZUludCh5aWVsZCB0aGlzLmdldEhlYWRDb3VudGVyKHBraCksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCwgc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BPYjoge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IGhlYWRDb3VudGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBwcmVwYXJlIGEgcmVnaXN0ZXJfZ2xvYmFsX2NvbnN0YW50IG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcGVyYXRpb24gUlBDT3BlcmF0aW9uIG9iamVjdCBvciBSUENPcGVyYXRpb24gYXJyYXlcbiAgICAgKiBAcGFyYW0gc291cmNlIHN0cmluZyBvciB1bmRlZmluZWQgc291cmNlIHBraFxuICAgICAqIEByZXR1cm5zIGEgUHJlcGFyZWRPcGVyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgcmVnaXN0ZXJHbG9iYWxDb25zdGFudChfYSkge1xuICAgICAgICB2YXIgeyBmZWUsIHN0b3JhZ2VMaW1pdCwgZ2FzTGltaXQgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJmZWVcIiwgXCJzdG9yYWdlTGltaXRcIiwgXCJnYXNMaW1pdFwiXSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBraCB9ID0geWllbGQgdGhpcy5nZXRLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbENvbnN0YW50cyA9IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0UHJvdG9jb2xDb25zdGFudHMoJ2hlYWQnKTtcbiAgICAgICAgICAgIGNvbnN0IERFRkFVTFRfUEFSQU1TID0geWllbGQgdGhpcy5nZXRBY2NvdW50TGltaXRzKHBraCwgcHJvdG9jb2xDb25zdGFudHMpO1xuICAgICAgICAgICAgY29uc3Qgb3AgPSB5aWVsZCBjcmVhdGVSZWdpc3Rlckdsb2JhbENvbnN0YW50T3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIG1lcmdlTGltaXRzKHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0sIERFRkFVTFRfUEFSQU1TKSkpO1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0geWllbGQgdGhpcy5hZGRSZXZlYWxPcGVyYXRpb25JZk5lZWRlZChvcCwgcGtoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wcyA9IHRoaXMuY29udmVydEludG9BcnJheShvcGVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IHlpZWxkIHRoaXMuZ2V0UHJvdG9jb2xIYXNoKCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9QcmVwYXJlUHJvdmlkZXJfY291bnRlcnMsIHt9LCBcImZcIik7XG4gICAgICAgICAgICBjb25zdCBoZWFkQ291bnRlciA9IHBhcnNlSW50KHlpZWxkIHRoaXMuZ2V0SGVhZENvdW50ZXIocGtoKSwgMTApO1xuICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSB0aGlzLmNvbnN0cnVjdE9wQ29udGVudHMob3BzLCBoZWFkQ291bnRlciwgcGtoLCByZXN0LnNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gcHJlcGFyZSBhbiB1cGRhdGVfY29uc2Vuc3VzX2tleSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHNvdXJjZSBzdHJpbmcgb3IgdW5kZWZpbmVkIHNvdXJjZSBwa2hcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIHVwZGF0ZUNvbnNlbnN1c0tleShfYSwgc291cmNlKSB7XG4gICAgICAgIHZhciB7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZlZVwiLCBcInN0b3JhZ2VMaW1pdFwiLCBcImdhc0xpbWl0XCJdKTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgREVGQVVMVF9QQVJBTVMgPSB5aWVsZCB0aGlzLmdldEFjY291bnRMaW1pdHMocGtoLCBwcm90b2NvbENvbnN0YW50cyk7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIGNyZWF0ZVVwZGF0ZUNvbnNlbnN1c0tleU9wZXJhdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCBtZXJnZUxpbWl0cyh7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9LCBERUZBVUxUX1BBUkFNUykpKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHlpZWxkIHRoaXMuYWRkUmV2ZWFsT3BlcmF0aW9uSWZOZWVkZWQob3AsIHBraCk7XG4gICAgICAgICAgICBjb25zdCBvcHMgPSB0aGlzLmNvbnZlcnRJbnRvQXJyYXkob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmdldEJsb2NrSGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLmdldFByb3RvY29sSGFzaCgpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCB7fSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgaGVhZENvdW50ZXIgPSBwYXJzZUludCh5aWVsZCB0aGlzLmdldEhlYWRDb3VudGVyKHBraCksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCwgc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BPYjoge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IGhlYWRDb3VudGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBwcmVwYXJlIGFuIGluY3JlYXNlX3BhaWRfc3RvcmFnZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHNvdXJjZSBzdHJpbmcgb3IgdW5kZWZpbmVkIHNvdXJjZSBwa2hcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIGluY3JlYXNlUGFpZFN0b3JhZ2UoX2EpIHtcbiAgICAgICAgdmFyIHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiZmVlXCIsIFwic3RvcmFnZUxpbWl0XCIsIFwiZ2FzTGltaXRcIl0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwa2ggfSA9IHlpZWxkIHRoaXMuZ2V0S2V5cygpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBERUZBVUxUX1BBUkFNUyA9IHlpZWxkIHRoaXMuZ2V0QWNjb3VudExpbWl0cyhwa2gsIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgY3JlYXRlSW5jcmVhc2VQYWlkU3RvcmFnZU9wZXJhdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlc3QpLCBtZXJnZUxpbWl0cyh7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9LCBERUZBVUxUX1BBUkFNUykpKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHlpZWxkIHRoaXMuYWRkUmV2ZWFsT3BlcmF0aW9uSWZOZWVkZWQob3AsIHBraCk7XG4gICAgICAgICAgICBjb25zdCBvcHMgPSB0aGlzLmNvbnZlcnRJbnRvQXJyYXkob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmdldEJsb2NrSGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLmdldFByb3RvY29sSGFzaCgpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCB7fSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgaGVhZENvdW50ZXIgPSBwYXJzZUludCh5aWVsZCB0aGlzLmdldEhlYWRDb3VudGVyKHBraCksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCwgcmVzdC5zb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcE9iOiB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY291bnRlcjogaGVhZENvdW50ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRvIHByZXBhcmUgYSBiYWxsb3Qgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbiBSUENPcGVyYXRpb24gb2JqZWN0IG9yIFJQQ09wZXJhdGlvbiBhcnJheVxuICAgICAqIEByZXR1cm5zIGEgUHJlcGFyZWRPcGVyYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgYmFsbG90KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBwa2ggfSA9IHlpZWxkIHRoaXMuZ2V0S2V5cygpO1xuICAgICAgICAgICAgY29uc3Qgb3AgPSB5aWVsZCBjcmVhdGVCYWxsb3RPcGVyYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSk7XG4gICAgICAgICAgICBjb25zdCBvcHMgPSB0aGlzLmNvbnZlcnRJbnRvQXJyYXkob3ApO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IHlpZWxkIHRoaXMuZ2V0UHJvdG9jb2xIYXNoKCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9QcmVwYXJlUHJvdmlkZXJfY291bnRlcnMsIHt9LCBcImZcIik7XG4gICAgICAgICAgICBjb25zdCBoZWFkQ291bnRlciA9IHBhcnNlSW50KHlpZWxkIHRoaXMuZ2V0SGVhZENvdW50ZXIocGtoKSwgMTApO1xuICAgICAgICAgICAgbGV0IGN1cnJlbnRWb3RpbmdQZXJpb2Q7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRWb3RpbmdQZXJpb2QgPSB5aWVsZCB0aGlzLnJwYy5nZXRDdXJyZW50UGVyaW9kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBSUENSZXNwb25zZUVycm9yKCdGYWlsZWQgdG8gZ2V0IHRoZSBjdXJyZW50IHZvdGluZyBwZXJpb2QgaW5kZXgnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCwgdW5kZWZpbmVkLCBjdXJyZW50Vm90aW5nUGVyaW9kKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BPYjoge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IGhlYWRDb3VudGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBwcmVwYXJlIGEgcHJvcG9zYWxzIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcGVyYXRpb24gUlBDT3BlcmF0aW9uIG9iamVjdCBvciBSUENPcGVyYXRpb24gYXJyYXlcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIHByb3Bvc2FscyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgY3JlYXRlUHJvcG9zYWxzT3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcykpO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5jb252ZXJ0SW50b0FycmF5KG9wKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmdldEJsb2NrSGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLmdldFByb3RvY29sSGFzaCgpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCB7fSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgaGVhZENvdW50ZXIgPSBwYXJzZUludCh5aWVsZCB0aGlzLmdldEhlYWRDb3VudGVyKHBraCksIDEwKTtcbiAgICAgICAgICAgIGxldCBjdXJyZW50Vm90aW5nUGVyaW9kO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Vm90aW5nUGVyaW9kID0geWllbGQgdGhpcy5ycGMuZ2V0Q3VycmVudFBlcmlvZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUlBDUmVzcG9uc2VFcnJvcignRmFpbGVkIHRvIGdldCB0aGUgY3VycmVudCB2b3RpbmcgcGVyaW9kIGluZGV4Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gsIHVuZGVmaW5lZCwgY3VycmVudFZvdGluZ1BlcmlvZCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gcHJlcGFyZSBhIGRyYWluX2RlbGVnYXRlIG9wZXJhdGlvblxuICAgICAqIEBwYXJhbSBvcGVyYXRpb24gUlBDT3BlcmF0aW9uIG9iamVjdCBvciBSUENPcGVyYXRpb24gYXJyYXlcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIGRyYWluRGVsZWdhdGUocGFyYW1zLCBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgY3JlYXRlRHJhaW5EZWxlZ2F0ZU9wZXJhdGlvbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpKTtcbiAgICAgICAgICAgIGNvbnN0IG9wcyA9IHRoaXMuY29udmVydEludG9BcnJheShvcCk7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5nZXRCbG9ja0hhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbEhhc2goKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRDb3VudGVyID0gcGFyc2VJbnQoeWllbGQgdGhpcy5nZXRIZWFkQ291bnRlcihwa2gpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gsIHNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gcHJlcGFyZSBhIHRyYW5zZmVyX3RpY2tldCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHBhcmFtIHNvdXJjZSBzdHJpbmcgb3IgdW5kZWZpbmVkIHNvdXJjZSBwa2hcbiAgICAgKiBAcmV0dXJucyBhIFByZXBhcmVkT3BlcmF0aW9uIG9iamVjdFxuICAgICAqL1xuICAgIHRyYW5zZmVyVGlja2V0KF9hKSB7XG4gICAgICAgIHZhciB7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZlZVwiLCBcInN0b3JhZ2VMaW1pdFwiLCBcImdhc0xpbWl0XCJdKTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgREVGQVVMVF9QQVJBTVMgPSB5aWVsZCB0aGlzLmdldEFjY291bnRMaW1pdHMocGtoLCBwcm90b2NvbENvbnN0YW50cyk7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIGNyZWF0ZVRyYW5zZmVyVGlja2V0T3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcmVzdCksIG1lcmdlTGltaXRzKHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0sIERFRkFVTFRfUEFSQU1TKSkpO1xuICAgICAgICAgICAgY29uc3Qgb3BlcmF0aW9uID0geWllbGQgdGhpcy5hZGRSZXZlYWxPcGVyYXRpb25JZk5lZWRlZChvcCwgcGtoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wcyA9IHRoaXMuY29udmVydEludG9BcnJheShvcGVyYXRpb24pO1xuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuZ2V0QmxvY2tIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbCA9IHlpZWxkIHRoaXMuZ2V0UHJvdG9jb2xIYXNoKCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9QcmVwYXJlUHJvdmlkZXJfY291bnRlcnMsIHt9LCBcImZcIik7XG4gICAgICAgICAgICBjb25zdCBoZWFkQ291bnRlciA9IHBhcnNlSW50KHlpZWxkIHRoaXMuZ2V0SGVhZENvdW50ZXIocGtoKSwgMTApO1xuICAgICAgICAgICAgY29uc3QgY29udGVudHMgPSB0aGlzLmNvbnN0cnVjdE9wQ29udGVudHMob3BzLCBoZWFkQ291bnRlciwgcGtoLCByZXN0LnNvdXJjZSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gcHJlcGFyZSBhIHNtYXJ0X3JvbGx1cF9hZGRfbWVzc2FnZXMgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIG9wZXJhdGlvbiBSUENPcGVyYXRpb24gb2JqZWN0IG9yIFJQQ09wZXJhdGlvbiBhcnJheVxuICAgICAqIEBwYXJhbSBzb3VyY2Ugc3RyaW5nIG9yIHVuZGVmaW5lZCBzb3VyY2UgcGtoXG4gICAgICogQHJldHVybnMgYSBQcmVwYXJlZE9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBzbWFydFJvbGx1cEFkZE1lc3NhZ2VzKF9hKSB7XG4gICAgICAgIHZhciB7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZlZVwiLCBcInN0b3JhZ2VMaW1pdFwiLCBcImdhc0xpbWl0XCJdKTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgREVGQVVMVF9QQVJBTVMgPSB5aWVsZCB0aGlzLmdldEFjY291bnRMaW1pdHMocGtoLCBwcm90b2NvbENvbnN0YW50cyk7XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIGNyZWF0ZVNtYXJ0Um9sbHVwQWRkTWVzc2FnZXNPcGVyYXRpb24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCByZXN0KSwgbWVyZ2VMaW1pdHMoeyBmZWUsIHN0b3JhZ2VMaW1pdCwgZ2FzTGltaXQgfSwgREVGQVVMVF9QQVJBTVMpKSk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB5aWVsZCB0aGlzLmFkZFJldmVhbE9wZXJhdGlvbklmTmVlZGVkKG9wLCBwa2gpO1xuICAgICAgICAgICAgY29uc3Qgb3BzID0gdGhpcy5jb252ZXJ0SW50b0FycmF5KG9wZXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5nZXRCbG9ja0hhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbEhhc2goKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRDb3VudGVyID0gcGFyc2VJbnQoeWllbGQgdGhpcy5nZXRIZWFkQ291bnRlcihwa2gpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gsIHJlc3Quc291cmNlKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgb3BPYjoge1xuICAgICAgICAgICAgICAgICAgICBicmFuY2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICAgICAgICAgICAgICBwcm90b2NvbCxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNvdW50ZXI6IGhlYWRDb3VudGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIE1ldGhvZCB0byBwcmVwYXJlIGEgc21hcnRfcm9sbHVwX29yaWdpbmF0ZSBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHJldHVybnMgYSBQcmVwYXJlZE9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBzbWFydFJvbGx1cE9yaWdpbmF0ZShfYSkge1xuICAgICAgICB2YXIgeyBmZWUsIHN0b3JhZ2VMaW1pdCwgZ2FzTGltaXQgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJmZWVcIiwgXCJzdG9yYWdlTGltaXRcIiwgXCJnYXNMaW1pdFwiXSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBraCB9ID0geWllbGQgdGhpcy5nZXRLZXlzKCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbENvbnN0YW50cyA9IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0UHJvdG9jb2xDb25zdGFudHMoJ2hlYWQnKTtcbiAgICAgICAgICAgIGNvbnN0IERFRkFVTFRfUEFSQU1TID0geWllbGQgdGhpcy5nZXRBY2NvdW50TGltaXRzKHBraCwgcHJvdG9jb2xDb25zdGFudHMpO1xuICAgICAgICAgICAgY29uc3Qgb3AgPSB5aWVsZCBjcmVhdGVTbWFydFJvbGx1cE9yaWdpbmF0ZU9wZXJhdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG1lcmdlTGltaXRzKHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0sIERFRkFVTFRfUEFSQU1TKSksIHJlc3QpKTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHlpZWxkIHRoaXMuYWRkUmV2ZWFsT3BlcmF0aW9uSWZOZWVkZWQob3AsIHBraCk7XG4gICAgICAgICAgICBjb25zdCBvcHMgPSB0aGlzLmNvbnZlcnRJbnRvQXJyYXkob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmdldEJsb2NrSGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2wgPSB5aWVsZCB0aGlzLmdldFByb3RvY29sSGFzaCgpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzLCB7fSwgXCJmXCIpO1xuICAgICAgICAgICAgY29uc3QgaGVhZENvdW50ZXIgPSBwYXJzZUludCh5aWVsZCB0aGlzLmdldEhlYWRDb3VudGVyKHBraCksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCwgcmVzdC5zb3VyY2UpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcE9iOiB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY291bnRlcjogaGVhZENvdW50ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRvIHByZXBhcmUgYSBiYXRjaCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHJldHVybnMgYSBQcmVwYXJlZE9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBiYXRjaChiYXRjaFBhcmFtcywgZXN0aW1hdGVzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IHBraCwgcHVibGljS2V5IH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgREVGQVVMVF9QQVJBTVMgPSB5aWVsZCB0aGlzLmdldEFjY291bnRMaW1pdHMocGtoLCBwcm90b2NvbENvbnN0YW50cywgYmF0Y2hQYXJhbXMubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IHJldmVhbE5lZWRlZCA9IHlpZWxkIHRoaXMuaXNSZXZlYWxPcE5lZWRlZChiYXRjaFBhcmFtcywgcGtoKTtcbiAgICAgICAgICAgIGNvbnN0IG9wcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCFlc3RpbWF0ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIGJhdGNoUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc09wV2l0aEZlZShvcCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxpbWl0cyA9IG1lcmdlTGltaXRzKG9wLCBERUZBVUxUX1BBUkFNUyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHMucHVzaCh5aWVsZCB0aGlzLmdldFJQQ09wKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCBsaW1pdHMpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHMucHVzaChPYmplY3QuYXNzaWduKHt9LCBvcCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCBvcCBvZiBiYXRjaFBhcmFtcykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNPcFdpdGhGZWUob3ApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlID0gZXN0aW1hdGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBsaW1pdHMgPSBtZXJnZUxpbWl0cyhvcCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZlZTogZS5zdWdnZXN0ZWRGZWVNdXRleixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdG9yYWdlTGltaXQ6IGUuc3RvcmFnZUxpbWl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGdhc0xpbWl0OiBlLmdhc0xpbWl0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHMucHVzaCh5aWVsZCB0aGlzLmdldFJQQ09wKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb3ApLCBsaW1pdHMpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcHMucHVzaChPYmplY3QuYXNzaWduKHt9LCBvcCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJldmVhbE5lZWRlZCkge1xuICAgICAgICAgICAgICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBQdWJsaWNLZXlOb3RGb3VuZEVycm9yKHBraCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9wcy51bnNoaWZ0KHlpZWxkIGNyZWF0ZVJldmVhbE9wZXJhdGlvbih7XG4gICAgICAgICAgICAgICAgICAgIGZlZTogREVGQVVMVF9GRUUuUkVWRUFMLFxuICAgICAgICAgICAgICAgICAgICBzdG9yYWdlTGltaXQ6IERFRkFVTFRfU1RPUkFHRV9MSU1JVC5SRVZFQUwsXG4gICAgICAgICAgICAgICAgICAgIGdhc0xpbWl0OiBnZXRSZXZlYWxHYXNMaW1pdChwa2gpLFxuICAgICAgICAgICAgICAgIH0sIHBraCwgcHVibGljS2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5nZXRCbG9ja0hhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbEhhc2goKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRDb3VudGVyID0gcGFyc2VJbnQoeWllbGQgdGhpcy5nZXRIZWFkQ291bnRlcihwa2gpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50cyA9IHRoaXMuY29uc3RydWN0T3BDb250ZW50cyhvcHMsIGhlYWRDb3VudGVyLCBwa2gpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBvcE9iOiB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHMsXG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY291bnRlcjogaGVhZENvdW50ZXIsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRvIHByZXBhcmUgYSBiYXRjaCBvcGVyYXRpb25cbiAgICAgKiBAcGFyYW0gb3BlcmF0aW9uIFJQQ09wZXJhdGlvbiBvYmplY3Qgb3IgUlBDT3BlcmF0aW9uIGFycmF5XG4gICAgICogQHJldHVybnMgYSBQcmVwYXJlZE9wZXJhdGlvbiBvYmplY3RcbiAgICAgKi9cbiAgICBjb250cmFjdENhbGwoY29udHJhY3RNZXRob2QpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNoID0geWllbGQgdGhpcy5nZXRCbG9ja0hhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sID0geWllbGQgdGhpcy5nZXRQcm90b2NvbEhhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHsgcGtoIH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX1ByZXBhcmVQcm92aWRlcl9jb3VudGVycywge30sIFwiZlwiKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRDb3VudGVyID0gcGFyc2VJbnQoeWllbGQgdGhpcy5nZXRIZWFkQ291bnRlcihwa2gpLCAxMCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSBjb250cmFjdE1ldGhvZC50b1RyYW5zZmVyUGFyYW1zKCk7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbENvbnN0YW50cyA9IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0UHJvdG9jb2xDb25zdGFudHMoJ2hlYWQnKTtcbiAgICAgICAgICAgIGNvbnN0IERFRkFVTFRfUEFSQU1TID0geWllbGQgdGhpcy5nZXRBY2NvdW50TGltaXRzKHBraCwgcHJvdG9jb2xDb25zdGFudHMpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVMaW1pdHMgPSBtZXJnZUxpbWl0cyh7XG4gICAgICAgICAgICAgICAgZmVlOiBwYXJhbXMuZmVlLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VMaW1pdDogcGFyYW1zLnN0b3JhZ2VMaW1pdCxcbiAgICAgICAgICAgICAgICBnYXNMaW1pdDogcGFyYW1zLmdhc0xpbWl0LFxuICAgICAgICAgICAgfSwgREVGQVVMVF9QQVJBTVMpO1xuICAgICAgICAgICAgY29uc3Qgb3AgPSB7XG4gICAgICAgICAgICAgICAga2luZDogT3BLaW5kLlRSQU5TQUNUSU9OLFxuICAgICAgICAgICAgICAgIGZlZTogKF9hID0gcGFyYW1zLmZlZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogZXN0aW1hdGVMaW1pdHMuZmVlLFxuICAgICAgICAgICAgICAgIGdhc19saW1pdDogKF9iID0gcGFyYW1zLmdhc0xpbWl0KSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBlc3RpbWF0ZUxpbWl0cy5nYXNMaW1pdCxcbiAgICAgICAgICAgICAgICBzdG9yYWdlX2xpbWl0OiAoX2MgPSBwYXJhbXMuc3RvcmFnZUxpbWl0KSAhPT0gbnVsbCAmJiBfYyAhPT0gdm9pZCAwID8gX2MgOiBlc3RpbWF0ZUxpbWl0cy5zdG9yYWdlTGltaXQsXG4gICAgICAgICAgICAgICAgYW1vdW50OiBTdHJpbmcocGFyYW1zLmFtb3VudCksXG4gICAgICAgICAgICAgICAgZGVzdGluYXRpb246IHBhcmFtcy50byxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiBwYXJhbXMucGFyYW1ldGVyLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHlpZWxkIHRoaXMuYWRkUmV2ZWFsT3BlcmF0aW9uSWZOZWVkZWQob3AsIHBraCk7XG4gICAgICAgICAgICBjb25zdCBvcHMgPSB0aGlzLmNvbnZlcnRJbnRvQXJyYXkob3BlcmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5jb25zdHJ1Y3RPcENvbnRlbnRzKG9wcywgaGVhZENvdW50ZXIsIHBraCk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG9wT2I6IHtcbiAgICAgICAgICAgICAgICAgICAgYnJhbmNoOiBoYXNoLFxuICAgICAgICAgICAgICAgICAgICBjb250ZW50cyxcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2wsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBjb3VudGVyOiBoZWFkQ291bnRlcixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBNZXRob2QgdG8gY29udmVydCBhIFByZXBhcmVkT3BlcmF0aW9uIHRvIHRoZSBwYXJhbXMgbmVlZGVkIGZvciB0aGUgcHJlYXBwbHlPcGVyYXRpb24gbWV0aG9kXG4gICAgICogQHBhcmFtIHByZXBhcmVkIGEgUHJlcGFyZWQgT3BlcmF0aW9uXG4gICAgICogQHJldHVybnMgYSBQcmVhcHBseVBhcmFtcyBvYmplY3RcbiAgICAgKi9cbiAgICB0b1ByZWFwcGx5KHByZXBhcmVkKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9wT2I6IHsgY29udGVudHMsIGJyYW5jaCwgcHJvdG9jb2wgfSwgfSA9IHByZXBhcmVkO1xuICAgICAgICAgICAgY29uc3QgZm9yZ2VQYXJhbXMgPSB0aGlzLnRvRm9yZ2UocHJlcGFyZWQpO1xuICAgICAgICAgICAgY29uc3QgZm9yZ2VkID0geWllbGQgdGhpcy5jb250ZXh0LmZvcmdlci5mb3JnZShmb3JnZVBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBzaWcgPSB5aWVsZCB0aGlzLmNvbnRleHQuc2lnbmVyLnNpZ24oZm9yZ2VkLCBuZXcgVWludDhBcnJheShbM10pKTtcbiAgICAgICAgICAgIHJldHVybiBbeyBjb250ZW50cywgYnJhbmNoLCBwcm90b2NvbCwgc2lnbmF0dXJlOiBzaWcucHJlZml4U2lnIH1dO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gTWV0aG9kIHRvIGNvbnZlcnQgYSBQcmVwYXJlZE9wZXJhdGlvbiB0byB0aGUgcGFyYW1zIG5lZWRlZCBmb3IgZm9yZ2luZ1xuICAgICAqIEBwYXJhbSBwYXJhbSBhIFByZXBhcmVkIE9wZXJhdGlvblxuICAgICAqIEByZXR1cm5zIGEgRm9yZ2VQYXJhbXMgb2JqZWN0XG4gICAgICovXG4gICAgdG9Gb3JnZSh7IG9wT2I6IHsgY29udGVudHMsIGJyYW5jaCB9IH0pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGJyYW5jaCxcbiAgICAgICAgICAgIGNvbnRlbnRzLFxuICAgICAgICB9O1xuICAgIH1cbn1cbl9QcmVwYXJlUHJvdmlkZXJfY291bnRlcnMgPSBuZXcgV2Vha01hcCgpO1xuXG5jb25zdCBCQVRDSF9LSU5EUyA9IFtcbiAgICBPcEtpbmQuQUNUSVZBVElPTixcbiAgICBPcEtpbmQuT1JJR0lOQVRJT04sXG4gICAgT3BLaW5kLlRSQU5TQUNUSU9OLFxuICAgIE9wS2luZC5ERUxFR0FUSU9OLFxuXTtcbmNsYXNzIE9wZXJhdGlvbkJhdGNoIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGVzdGltYXRvcikge1xuICAgICAgICBzdXBlcihjb250ZXh0KTtcbiAgICAgICAgdGhpcy5lc3RpbWF0b3IgPSBlc3RpbWF0b3I7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucyA9IFtdO1xuICAgICAgICB0aGlzLnByZXBhcmUgPSBuZXcgUHJlcGFyZVByb3ZpZGVyKHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCBhIHRyYW5zYWN0aW9uIG9wZXJhdGlvbiB0byB0aGUgYmF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgVHJhbnNmZXIgb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHdpdGhUcmFuc2ZlcihwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgdG9WYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKHBhcmFtcy50byk7XG4gICAgICAgIGlmIChwYXJhbXMuYW1vdW50IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBbW91bnRFcnJvcihwYXJhbXMuYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b1ZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHBhcmFtcy50bywgaW52YWxpZERldGFpbCh0b1ZhbGlkYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsga2luZDogT3BLaW5kLlRSQU5TQUNUSU9OIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gVHJhbnNmZXIgdGlja2V0cyBmcm9tIGEgVGV6b3MgYWRkcmVzcyAodHoxLHR6MiBvciB0ejMpIHRvIGEgc21hcnQgY29udHJhY3QgYWRkcmVzcyggS1QxKVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBUcmFuc2ZlciBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgd2l0aFRyYW5zZmVyVGlja2V0KHBhcmFtcykge1xuICAgICAgICBjb25zdCBkZXN0aW5hdGlvblZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MocGFyYW1zLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgaWYgKGRlc3RpbmF0aW9uVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IocGFyYW1zLmRlc3RpbmF0aW9uLCBpbnZhbGlkRGV0YWlsKGRlc3RpbmF0aW9uVmFsaWRhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKE9iamVjdC5hc3NpZ24oeyBraW5kOiBPcEtpbmQuVFJBTlNGRVJfVElDS0VUIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGEgY29udHJhY3QgY2FsbCB0byB0aGUgYmF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgQ2FsbCBhIGNvbnRyYWN0IG1ldGhvZFxuICAgICAqIEBwYXJhbSBvcHRpb25zIEdlbmVyaWMgb3BlcmF0aW9uIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICB3aXRoQ29udHJhY3RDYWxsKHBhcmFtcywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLndpdGhUcmFuc2ZlcihwYXJhbXMudG9UcmFuc2ZlclBhcmFtcyhvcHRpb25zKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCBhIGRlbGVnYXRpb24gb3BlcmF0aW9uIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBEZWxlZ2F0aW9uIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICB3aXRoRGVsZWdhdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBjb25zdCBzb3VyY2VWYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKHBhcmFtcy5zb3VyY2UpO1xuICAgICAgICBpZiAocGFyYW1zLnNvdXJjZSAmJiBzb3VyY2VWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuc291cmNlLCBpbnZhbGlkRGV0YWlsKHNvdXJjZVZhbGlkYXRpb24pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkZWxlZ2F0ZVZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MoKF9hID0gcGFyYW1zLmRlbGVnYXRlKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAnJyk7XG4gICAgICAgIGlmIChwYXJhbXMuZGVsZWdhdGUgJiYgZGVsZWdhdGVWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuZGVsZWdhdGUsIGludmFsaWREZXRhaWwoZGVsZWdhdGVWYWxpZGF0aW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vcGVyYXRpb25zLnB1c2goT2JqZWN0LmFzc2lnbih7IGtpbmQ6IE9wS2luZC5ERUxFR0FUSU9OIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGFuIGFjdGl2YXRpb24gb3BlcmF0aW9uIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBBY3RpdmF0aW9uIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkS2V5SGFzaEVycm9yfVxuICAgICAqL1xuICAgIHdpdGhBY3RpdmF0aW9uKHsgcGtoLCBzZWNyZXQgfSkge1xuICAgICAgICBjb25zdCBwa2hWYWxpZGF0aW9uID0gdmFsaWRhdGVLZXlIYXNoKHBraCk7XG4gICAgICAgIGlmIChwa2hWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEtleUhhc2hFcnJvcihwa2gsIGludmFsaWREZXRhaWwocGtoVmFsaWRhdGlvbikpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKHsga2luZDogT3BLaW5kLkFDVElWQVRJT04sIHBraCwgc2VjcmV0IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGFuIG9yaWdpbmF0aW9uIG9wZXJhdGlvbiB0byB0aGUgYmF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgT3JpZ2luYXRpb24gb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHdpdGhPcmlnaW5hdGlvbihwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRpb25zLnB1c2goT2JqZWN0LmFzc2lnbih7IGtpbmQ6IE9wS2luZC5PUklHSU5BVElPTiB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCBhIHJlZ2lzdGVyIGEgZ2xvYmFsIGNvbnN0YW50IG9wZXJhdGlvbiB0byB0aGUgYmF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgUmVnaXN0ZXJHbG9iYWxDb25zdGFudCBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgd2l0aFJlZ2lzdGVyR2xvYmFsQ29uc3RhbnQocGFyYW1zKSB7XG4gICAgICAgIHRoaXMub3BlcmF0aW9ucy5wdXNoKE9iamVjdC5hc3NpZ24oeyBraW5kOiBPcEtpbmQuUkVHSVNURVJfR0xPQkFMX0NPTlNUQU5UIH0sIHBhcmFtcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGFuIGluY3JlYXNlIHBhaWQgc3RvcmFnZSBvcGVyYXRpb24gdG8gdGhlIGJhdGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIEluY3JlYXNlUGFpZFN0b3JhZ2Ugb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHdpdGhJbmNyZWFzZVBhaWRTdG9yYWdlKHBhcmFtcykge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsga2luZDogT3BLaW5kLklOQ1JFQVNFX1BBSURfU1RPUkFHRSB9LCBwYXJhbXMpKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZCBhIHNtYXJ0IHJvbGx1cCBhZGQgbWVzc2FnZXMgb3BlcmF0aW9uIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBSb2xsdXAgb3JpZ2luYXRpb24gb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHdpdGhTbWFydFJvbGx1cEFkZE1lc3NhZ2VzKHBhcmFtcykge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsga2luZDogT3BLaW5kLlNNQVJUX1JPTExVUF9BRERfTUVTU0FHRVMgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBZGQgYSBzbWFydCByb2xsdXAgb3JpZ2luYXRlIG9wZXJhdGlvbiB0byB0aGUgYmF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgU21hcnQgUm9sbHVwIE9yaWdpbmF0ZSBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgd2l0aFNtYXJ0Um9sbHVwT3JpZ2luYXRlKHBhcmFtcykge1xuICAgICAgICB0aGlzLm9wZXJhdGlvbnMucHVzaChPYmplY3QuYXNzaWduKHsga2luZDogT3BLaW5kLlNNQVJUX1JPTExVUF9PUklHSU5BVEUgfSwgcGFyYW1zKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBnZXRSUENPcChwYXJhbSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgc3dpdGNoIChwYXJhbS5raW5kKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuVFJBTlNBQ1RJT046XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVUcmFuc2Zlck9wZXJhdGlvbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLk9SSUdJTkFUSU9OOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlT3JpZ2luYXRpb25PcGVyYXRpb24oeWllbGQgdGhpcy5jb250ZXh0LnBhcnNlci5wcmVwYXJlQ29kZU9yaWdpbmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtKSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLkRFTEVHQVRJT046XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTZXREZWxlZ2F0ZU9wZXJhdGlvbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlJFR0lTVEVSX0dMT0JBTF9DT05TVEFOVDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZ2lzdGVyR2xvYmFsQ29uc3RhbnRPcGVyYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW0pKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5JTkNSRUFTRV9QQUlEX1NUT1JBR0U6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVJbmNyZWFzZVBhaWRTdG9yYWdlT3BlcmF0aW9uKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtKSk7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuVFJBTlNGRVJfVElDS0VUOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlVHJhbnNmZXJUaWNrZXRPcGVyYXRpb24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW0pKTtcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5TTUFSVF9ST0xMVVBfQUREX01FU1NBR0VTOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3JlYXRlU21hcnRSb2xsdXBBZGRNZXNzYWdlc09wZXJhdGlvbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbSkpO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlNNQVJUX1JPTExVUF9PUklHSU5BVEU6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjcmVhdGVTbWFydFJvbGx1cE9yaWdpbmF0ZU9wZXJhdGlvbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbSkpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3BlcmF0aW9uS2luZEVycm9yJDEoSlNPTi5zdHJpbmdpZnkocGFyYW0ua2luZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWRkIGEgZ3JvdXAgb3BlcmF0aW9uIHRvIHRoZSBiYXRjaC4gT3BlcmF0aW9uIHdpbGwgYmUgYXBwbGllZCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgaW4gdGhlIHBhcmFtcyBhcnJheVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBPcGVyYXRpb25zIHBhcmFtZXRlclxuICAgICAqIEB0aHJvd3Mge0BsaW5rIEludmFsaWRPcGVyYXRpb25LaW5kRXJyb3J9XG4gICAgICovXG4gICAgd2l0aChwYXJhbXMpIHtcbiAgICAgICAgZm9yIChjb25zdCBwYXJhbSBvZiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAocGFyYW0ua2luZCkge1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlRSQU5TQUNUSU9OOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhUcmFuc2ZlcihwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLk9SSUdJTkFUSU9OOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhPcmlnaW5hdGlvbihwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLkRFTEVHQVRJT046XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2l0aERlbGVnYXRpb24ocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5BQ1RJVkFUSU9OOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhBY3RpdmF0aW9uKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuUkVHSVNURVJfR0xPQkFMX0NPTlNUQU5UOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhSZWdpc3Rlckdsb2JhbENvbnN0YW50KHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuSU5DUkVBU0VfUEFJRF9TVE9SQUdFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhJbmNyZWFzZVBhaWRTdG9yYWdlKHBhcmFtKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBPcEtpbmQuVFJBTlNGRVJfVElDS0VUOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhUcmFuc2ZlclRpY2tldChwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgT3BLaW5kLlNNQVJUX1JPTExVUF9BRERfTUVTU0FHRVM6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMud2l0aFNtYXJ0Um9sbHVwQWRkTWVzc2FnZXMocGFyYW0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIE9wS2luZC5TTUFSVF9ST0xMVVBfT1JJR0lOQVRFOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLndpdGhTbWFydFJvbGx1cE9yaWdpbmF0ZShwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkT3BlcmF0aW9uS2luZEVycm9yJDEoSlNPTi5zdHJpbmdpZnkocGFyYW0ua2luZCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBGb3JnZSBhbmQgSW5qZWN0IHRoZSBvcGVyYXRpb24gYmF0Y2hcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgT3B0aW9uYWxseSBzcGVjaWZ5IHRoZSBzb3VyY2Ugb2YgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIHNlbmQocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwdWJsaWNLZXlIYXNoID0geWllbGQgdGhpcy5zaWduZXIucHVibGljS2V5SGFzaCgpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gKHBhcmFtcyAmJiBwYXJhbXMuc291cmNlKSB8fCBwdWJsaWNLZXlIYXNoO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVzID0geWllbGQgdGhpcy5lc3RpbWF0b3IuYmF0Y2godGhpcy5vcGVyYXRpb25zKTtcbiAgICAgICAgICAgIGlmIChlc3RpbWF0ZXMubGVuZ3RoICE9PSB0aGlzLm9wZXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZE9wID0geWllbGQgdGhpcy5wcmVwYXJlLmJhdGNoKHRoaXMub3BlcmF0aW9ucywgZXN0aW1hdGVzKTtcbiAgICAgICAgICAgIGNvbnN0IG9wQnl0ZXMgPSB5aWVsZCB0aGlzLmZvcmdlKHByZXBhcmVkT3ApO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoLCBjb250ZXh0LCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSB9ID0geWllbGQgdGhpcy5zaWduQW5kSW5qZWN0KG9wQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBCYXRjaE9wZXJhdGlvbihoYXNoLCBwcmVwYXJlZE9wLm9wT2IuY29udGVudHMsIHNvdXJjZSwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5jbGFzcyBSUENCYXRjaFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0LCBlc3RpbWF0b3IpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5lc3RpbWF0b3IgPSBlc3RpbWF0b3I7XG4gICAgfVxuICAgIC8qKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBCYXRjaCBhIGdyb3VwIG9mIG9wZXJhdGlvbiB0b2dldGhlci4gT3BlcmF0aW9ucyB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBMaXN0IG9mIG9wZXJhdGlvbiB0byBiYXRjaCB0b2dldGhlclxuICAgICAqL1xuICAgIGJhdGNoKHBhcmFtcykge1xuICAgICAgICBjb25zdCBiYXRjaCA9IG5ldyBPcGVyYXRpb25CYXRjaCh0aGlzLmNvbnRleHQsIHRoaXMuZXN0aW1hdG9yKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1zKSkge1xuICAgICAgICAgICAgYmF0Y2gud2l0aChwYXJhbXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXRjaDtcbiAgICB9XG59XG5cbmNsYXNzIEJhdGNoV2FsbGV0T3BlcmF0aW9uIGV4dGVuZHMgV2FsbGV0T3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcEhhc2gsIGNvbnRleHQsIG5ld0hlYWQkKSB7XG4gICAgICAgIHN1cGVyKG9wSGFzaCwgY29udGV4dCwgbmV3SGVhZCQpO1xuICAgICAgICB0aGlzLm9wSGFzaCA9IG9wSGFzaDtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgICAgdGhpcy5nZXRPcmlnaW5hdGVkQ29udHJhY3RBZGRyZXNzZXMgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcFJlc3VsdCA9IHlpZWxkIHRoaXMub3BlcmF0aW9uUmVzdWx0cygpO1xuICAgICAgICAgICAgaWYgKCFvcFJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPYnNlcnZhYmxlRXJyb3IoJ1VuYWJsZSB0byBmZXRjaCBvcGVyYXRpb24gcmVzdWx0cycpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3JpZ2luYXRpb25PcFJlc3VsdHMgPSBvcFJlc3VsdC5maWx0ZXIoKHgpID0+IHgua2luZCA9PT0gJ29yaWdpbmF0aW9uJyk7XG4gICAgICAgICAgICAgICAgbGV0IGFkZHJlc3NlcyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmVzIG9mIG9yaWdpbmF0aW9uT3BSZXN1bHRzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXMubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdC5vcmlnaW5hdGVkX2NvbnRyYWN0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzc2VzID0gWy4uLmFkZHJlc3NlcywgLi4ucmVzLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQub3JpZ2luYXRlZF9jb250cmFjdHNdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBhZGRyZXNzZXM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXZlYWxPcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb25SZXN1bHQgPSB5aWVsZCB0aGlzLm9wZXJhdGlvblJlc3VsdHMoKTtcbiAgICAgICAgICAgIGlmICghb3BlcmF0aW9uUmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9ic2VydmFibGVFcnJvcignVW5hYmxlIHRvIGZldGNoIG9wZXJhdGlvbiByZXN1bHRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gb3BlcmF0aW9uUmVzdWx0LmZpbmQoKHgpID0+IHgua2luZCA9PT0gT3BLaW5kLlJFVkVBTCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0dXMoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2luY2x1ZGVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwZW5kaW5nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9wID0geWllbGQgdGhpcy5vcGVyYXRpb25SZXN1bHRzKCk7XG4gICAgICAgICAgICBpZiAob3ApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gKG9wXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoKHJlc3VsdCkgPT4gQkFUQ0hfS0lORFMuaW5kZXhPZihyZXN1bHQua2luZCkgIT09IC0xKVxuICAgICAgICAgICAgICAgICAgICAubWFwKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhc01ldGFkYXRhV2l0aFJlc3VsdChyZXN1bHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvcFJlc3VsdCA9IHJlc3VsdC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wUmVzdWx0LnN0YXR1cztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVswXSB8fCAndW5rbm93bicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IE9ic2VydmFibGVFcnJvcignVW5hYmxlIHRvIGZldGNoIG9wZXJhdGlvbiByZXN1bHRzJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgSW5jcmVhc2VQYWlkU3RvcmFnZVdhbGxldE9wZXJhdGlvbiBleHRlbmRzIFdhbGxldE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob3BIYXNoLCBjb250ZXh0LCBuZXdIZWFkJCkge1xuICAgICAgICBzdXBlcihvcEhhc2gsIGNvbnRleHQsIG5ld0hlYWQkKTtcbiAgICAgICAgdGhpcy5vcEhhc2ggPSBvcEhhc2g7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIHJldmVhbE9wZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMub3BlcmF0aW9uUmVzdWx0cygpO1xuICAgICAgICAgICAgaWYgKCFvcGVyYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT2JzZXJ2YWJsZUVycm9yKCdVbmFibGUgdG8gZmV0Y2ggb3BlcmF0aW9uIHJlc3VsdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvblJlc3VsdC5maW5kKCh4KSA9PiB4LmtpbmQgPT09IE9wS2luZC5SRVZFQUwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaW5jcmVhc2VQYWlkU3RvcmFnZU9wZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wZXJhdGlvblJlc3VsdCA9IHlpZWxkIHRoaXMub3BlcmF0aW9uUmVzdWx0cygpO1xuICAgICAgICAgICAgaWYgKCFvcGVyYXRpb25SZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgT2JzZXJ2YWJsZUVycm9yKCdVbmFibGUgdG8gZmV0Y2ggb3BlcmF0aW9uIHJlc3VsdCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdGlvblJlc3VsdC5maW5kKCh4KSA9PiB4LmtpbmQgPT09IE9wS2luZC5JTkNSRUFTRV9QQUlEX1NUT1JBR0UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdHVzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbmNsdWRlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAncGVuZGluZyc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBvcCA9IHlpZWxkIHRoaXMuaW5jcmVhc2VQYWlkU3RvcmFnZU9wZXJhdGlvbigpO1xuICAgICAgICAgICAgaWYgKCFvcCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gb3AubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdC5zdGF0dXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gdGltZW91dEFmdGVyKHRpbWVvdXRNaWxsaXNlYykge1xuICAgIHJldHVybiBmdW5jdGlvbiBpbm5lcihzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBCZWhhdmlvclN1YmplY3QobnVsbCkucGlwZSh0aW1lb3V0KHtcbiAgICAgICAgICAgIGVhY2g6IHRpbWVvdXRNaWxsaXNlYyxcbiAgICAgICAgICAgIHdpdGg6ICgpID0+IHRocm93RXJyb3IoKCkgPT4gbmV3IENvbmZpcm1hdGlvblRpbWVvdXRFcnJvcihgQ29uZmlybWF0aW9uIHBvbGxpbmcgdGltZWQgb3V0YCkpLFxuICAgICAgICB9KSwgbWVyZ2VNYXAoKCkgPT4gc291cmNlKSk7XG4gICAgfTtcbn1cbmNvbnN0IGNyZWF0ZU5ld1BvbGxpbmdCYXNlZEhlYWRPYnNlcnZhYmxlID0gKHNoYXJlZEhlYWRPYiwgY29udGV4dCwgX3NjaGVkdWxlcikgPT4ge1xuICAgIHJldHVybiBzaGFyZWRIZWFkT2IucGlwZSh0aW1lb3V0QWZ0ZXIoY29udGV4dC5jb25maWcuY29uZmlybWF0aW9uUG9sbGluZ1RpbWVvdXRTZWNvbmQgKiAxMDAwKSwgc2hhcmUoe1xuICAgICAgICBjb25uZWN0b3I6ICgpID0+IG5ldyBSZXBsYXlTdWJqZWN0KDEpLFxuICAgICAgICByZXNldE9uRXJyb3I6IGZhbHNlLFxuICAgICAgICByZXNldE9uQ29tcGxldGU6IGZhbHNlLFxuICAgICAgICByZXNldE9uUmVmQ291bnRaZXJvOiBmYWxzZSxcbiAgICB9KSk7XG59O1xuY2xhc3MgT3BlcmF0aW9uRmFjdG9yeSB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgICAvLyBDYWNoZSB0aGUgbGFzdCBibG9jayBmb3Igb25lIHNlY29uZCBhY3Jvc3MgYWxsIG9wZXJhdGlvbnNcbiAgICAgICAgdGhpcy5zaGFyZWRIZWFkT2JzID0gZGVmZXIoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGNyZWF0ZU9ic2VydmFibGVGcm9tU3Vic2NyaXB0aW9uKHRoaXMuY29udGV4dC5zdHJlYW0uc3Vic2NyaWJlQmxvY2soJ2hlYWQnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVOZXdIZWFkT2JzZXJ2YWJsZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGVOZXdQb2xsaW5nQmFzZWRIZWFkT2JzZXJ2YWJsZSh0aGlzLnNoYXJlZEhlYWRPYnMsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjcmVhdGVQYXN0QmxvY2tXYWxrZXIoc3RhcnRCbG9jaywgY291bnQgPSAxKSB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0QmxvY2soc3RhcnRCbG9jaykpLnBpcGUoc3dpdGNoTWFwKChibG9jaykgPT4ge1xuICAgICAgICAgICAgaWYgKGNvdW50ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9mKGJsb2NrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZShibG9jay5oZWFkZXIubGV2ZWwsIGNvdW50IC0gMSkucGlwZShzdGFydFdpdGgoYmxvY2spLCBjb25jYXRNYXAoKGxldmVsKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0QmxvY2sodHlwZW9mIGxldmVsID09PSAnbnVtYmVyJyA/IGxldmVsIDogbGV2ZWwuaGVhZGVyLmxldmVsKTtcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgY3JlYXRlSGVhZE9ic2VydmFibGVGcm9tQ29uZmlnKHsgYmxvY2tJZGVudGlmaWVyIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ic2VydmFibGVTZXF1ZW5jZSA9IFtdO1xuICAgICAgICAgICAgaWYgKGJsb2NrSWRlbnRpZmllcikge1xuICAgICAgICAgICAgICAgIG9ic2VydmFibGVTZXF1ZW5jZS5wdXNoKHRoaXMuY3JlYXRlUGFzdEJsb2NrV2Fsa2VyKGJsb2NrSWRlbnRpZmllcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2JzZXJ2YWJsZVNlcXVlbmNlLnB1c2goeWllbGQgdGhpcy5jcmVhdGVOZXdIZWFkT2JzZXJ2YWJsZSgpKTtcbiAgICAgICAgICAgIHJldHVybiBjb25jYXQoLi4ub2JzZXJ2YWJsZVNlcXVlbmNlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZU9wZXJhdGlvbihoYXNoLCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXRPcGVyYXRpb24oaGFzaCwgdGhpcy5jb250ZXh0LmNsb25lKCksIHlpZWxkIHRoaXMuY3JlYXRlSGVhZE9ic2VydmFibGVGcm9tQ29uZmlnKGNvbmZpZykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlQmF0Y2hPcGVyYXRpb24oaGFzaCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgQmF0Y2hXYWxsZXRPcGVyYXRpb24oaGFzaCwgdGhpcy5jb250ZXh0LmNsb25lKCksIHlpZWxkIHRoaXMuY3JlYXRlSGVhZE9ic2VydmFibGVGcm9tQ29uZmlnKGNvbmZpZykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlVHJhbnNhY3Rpb25PcGVyYXRpb24oaGFzaCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25XYWxsZXRPcGVyYXRpb24oaGFzaCwgdGhpcy5jb250ZXh0LmNsb25lKCksIHlpZWxkIHRoaXMuY3JlYXRlSGVhZE9ic2VydmFibGVGcm9tQ29uZmlnKGNvbmZpZykpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlRGVsZWdhdGlvbk9wZXJhdGlvbihoYXNoLCBjb25maWcgPSB7fSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWxlZ2F0aW9uV2FsbGV0T3BlcmF0aW9uKGhhc2gsIHRoaXMuY29udGV4dC5jbG9uZSgpLCB5aWVsZCB0aGlzLmNyZWF0ZUhlYWRPYnNlcnZhYmxlRnJvbUNvbmZpZyhjb25maWcpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZU9yaWdpbmF0aW9uT3BlcmF0aW9uKGhhc2gsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9yaWdpbmF0aW9uV2FsbGV0T3BlcmF0aW9uKGhhc2gsIHRoaXMuY29udGV4dC5jbG9uZSgpLCB5aWVsZCB0aGlzLmNyZWF0ZUhlYWRPYnNlcnZhYmxlRnJvbUNvbmZpZyhjb25maWcpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZUluY3JlYXNlUGFpZFN0b3JhZ2VPcGVyYXRpb24oaGFzaCwgY29uZmlnID0ge30pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW5jcmVhc2VQYWlkU3RvcmFnZVdhbGxldE9wZXJhdGlvbihoYXNoLCB0aGlzLmNvbnRleHQuY2xvbmUoKSwgeWllbGQgdGhpcy5jcmVhdGVIZWFkT2JzZXJ2YWJsZUZyb21Db25maWcoY29uZmlnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgUnBjVHpQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLnByZXBhcmUgPSBuZXcgUHJlcGFyZVByb3ZpZGVyKHRoaXMuY29udGV4dCk7XG4gICAgfVxuICAgIGdldEJhbGFuY2UoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzc1ZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1ZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihhZGRyZXNzLCBpbnZhbGlkRGV0YWlsKGFkZHJlc3NWYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRCYWxhbmNlKGFkZHJlc3MsICdoZWFkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXREZWxlZ2F0ZShhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgICAgIGlmIChhZGRyZXNzVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKGFkZHJlc3MsIGludmFsaWREZXRhaWwoYWRkcmVzc1ZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldERlbGVnYXRlKGFkZHJlc3MsICdoZWFkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhY3RpdmF0ZShwa2gsIHNlY3JldCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcGtoVmFsaWRhdGlvbiA9IHZhbGlkYXRlS2V5SGFzaChwa2gpO1xuICAgICAgICAgICAgaWYgKHBraFZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEtleUhhc2hFcnJvciQxKHBraCwgaW52YWxpZERldGFpbChwa2hWYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZCA9IHlpZWxkIHRoaXMucHJlcGFyZS5hY3RpdmF0ZSh7IHBraCwgc2VjcmV0IH0pO1xuICAgICAgICAgICAgY29uc3QgZm9yZ2VkQnl0ZXMgPSB5aWVsZCB0aGlzLmZvcmdlKHByZXBhcmVkKTtcbiAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYCR7Zm9yZ2VkQnl0ZXMub3BieXRlc30wMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMGA7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9wZXJhdGlvbih5aWVsZCB0aGlzLnJwYy5pbmplY3RPcGVyYXRpb24oYnl0ZXMpLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGZvcmdlZEJ5dGVzKSwgeyBvcGJ5dGVzOiBieXRlcyB9KSwgW10sIHRoaXMuY29udGV4dC5jbG9uZSgpKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG5jb25zdCBNSU5JTUFMX0ZFRV9NVVRFWiA9IDEwMDtcbmNvbnN0IE1JTklNQUxfRkVFX1BFUl9CWVRFX01VVEVaID0gMTtcbmNvbnN0IE1JTklNQUxfRkVFX1BFUl9HQVNfTVVURVogPSAwLjE7XG5jb25zdCBHQVNfQlVGRkVSID0gMTAwO1xuLyoqXG4gKiBFeGFtcGxlcyBvZiB1c2UgOlxuICpcbiAqICBFc3RpbWF0ZSBhIHRyYW5zZmVyIG9wZXJhdGlvbiA6XG4gKiBgYGBcbiAqIC8vIEFzc3VtaW5nIHRoYXQgcHJvdmlkZXIgYW5kIHNpZ25lciBhcmUgYWxyZWFkeSBjb25maWd1cmVkLi4uXG4gKlxuICogY29uc3QgYW1vdW50ID0gMjtcbiAqIGNvbnN0IGFkZHJlc3MgPSAndHoxaDNyUTh3QnhGZDhMOUIzZDdKaGFhd3U2WjU2OFhVM3hZJztcbiAqXG4gKiAvLyBFc3RpbWF0ZSBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciBhIHRyYW5zZmVyIG9wZXJhdGlvblxuICogY29uc3QgZXN0ID0gYXdhaXQgVGV6b3MuZXN0aW1hdGUudHJhbnNmZXIoeyB0bzogYWRkcmVzcywgYW1vdW50OiBhbW91bnQgfSlcbiAqIGNvbnNvbGUubG9nKGVzdC5idXJuRmVlTXV0ZXosIGVzdC5nYXNMaW1pdCwgZXN0Lm1pbmltYWxGZWVNdXRleiwgZXN0LnN0b3JhZ2VMaW1pdCxcbiAqICBlc3Quc3VnZ2VzdGVkRmVlTXV0ZXosIGVzdC50b3RhbENvc3QsIGVzdC51c2luZ0Jhc2VGZWVNdXRleilcbiAqXG4gKiBgYGBcbiAqXG4gKiBFc3RpbWF0ZSBhIGNvbnRyYWN0IG9yaWdpbmF0aW9uIDpcbiAqIGBgYFxuICogLy8gZ2VuZXJpYy5qc29uIGlzIHJlZmVycmluZyB0byBhIE1pY2hlbHNvbiBTbWFydCBDb250cmFjdFxuICpcbiAqIGNvbnN0IGdlbmVyaWNNdWx0aXNpZ0pTT04gPSByZXF1aXJlKCcuL2dlbmVyaWMuanNvbicpXG4gKiBjb25zdCBlc3QgPSBhd2FpdCBUZXpvcy5lc3RpbWF0ZS5vcmlnaW5hdGUoe1xuICogICBjb2RlOiBnZW5lcmljTXVsdGlzaWdKU09OLFxuICogICBzdG9yYWdlOiB7XG4gKiAgICAgc3RvcmVkX2NvdW50ZXI6IDAsXG4gKiAgICAgdGhyZXNob2xkOiAxLFxuICogICAgIGtleXM6IFsnZWRwa3VMeHg5UFFEOGZaNDVlVXpySzNCaGZEWkpIaEJ1SzRaaTQ5RGNFR0FOd2QycnBYODJ0J11cbiAqICAgfVxuICogfSlcbiAqIGNvbnNvbGUubG9nKGVzdC5idXJuRmVlTXV0ZXosIGVzdC5nYXNMaW1pdCwgZXN0Lm1pbmltYWxGZWVNdXRleiwgZXN0LnN0b3JhZ2VMaW1pdCxcbiAqICAgZXN0LnN1Z2dlc3RlZEZlZU11dGV6LCBlc3QudG90YWxDb3N0LCBlc3QudXNpbmdCYXNlRmVlTXV0ZXopXG4gKlxuICogYGBgXG4gKi9cbmNsYXNzIEVzdGltYXRlIHtcbiAgICBjb25zdHJ1Y3RvcihfbWlsbGlnYXNMaW1pdCwgX3N0b3JhZ2VMaW1pdCwgb3BTaXplLCBtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRleiwgXG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEJhc2UgZmVlIGluIG11dGV6ICgxIG11dGV6ID0gMWUxMOKIkjYgdGV6KVxuICAgICAqL1xuICAgIGJhc2VGZWVNdXRleiA9IE1JTklNQUxfRkVFX01VVEVaKSB7XG4gICAgICAgIHRoaXMuX21pbGxpZ2FzTGltaXQgPSBfbWlsbGlnYXNMaW1pdDtcbiAgICAgICAgdGhpcy5fc3RvcmFnZUxpbWl0ID0gX3N0b3JhZ2VMaW1pdDtcbiAgICAgICAgdGhpcy5vcFNpemUgPSBvcFNpemU7XG4gICAgICAgIHRoaXMubWluaW1hbEZlZVBlclN0b3JhZ2VCeXRlTXV0ZXogPSBtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRlejtcbiAgICAgICAgdGhpcy5iYXNlRmVlTXV0ZXogPSBiYXNlRmVlTXV0ZXo7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBUaGUgbnVtYmVyIG9mIE11dGV6IHRoYXQgd2lsbCBiZSBidXJuZWQgZm9yIHRoZSBzdG9yYWdlIG9mIHRoZSBbb3BlcmF0aW9uXShodHRwczovL3Rlem9zLmdpdGxhYi5pby91c2VyL2dsb3NzYXJ5Lmh0bWwjb3BlcmF0aW9ucykuIChTdG9yYWdlICsgQWxsb2NhdGlvbiBmZWVzKVxuICAgICAqL1xuICAgIGdldCBidXJuRmVlTXV0ZXooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kVXAoTnVtYmVyKHRoaXMuc3RvcmFnZUxpbWl0KSAqIE51bWJlcih0aGlzLm1pbmltYWxGZWVQZXJTdG9yYWdlQnl0ZU11dGV6KSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiAgVGhlIGxpbWl0IG9uIHRoZSBhbW91bnQgb2Ygc3RvcmFnZSBhbiBbb3BlcmF0aW9uXShodHRwczovL3Rlem9zLmdpdGxhYi5pby91c2VyL2dsb3NzYXJ5Lmh0bWwjb3BlcmF0aW9ucykgY2FuIHVzZS5cbiAgICAgKi9cbiAgICBnZXQgc3RvcmFnZUxpbWl0KCkge1xuICAgICAgICBjb25zdCBsaW1pdCA9IE1hdGgubWF4KE51bWJlcih0aGlzLl9zdG9yYWdlTGltaXQpLCAwKTtcbiAgICAgICAgcmV0dXJuIGxpbWl0ID4gMCA/IGxpbWl0IDogMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBsaW1pdCBvbiB0aGUgYW1vdW50IG9mIFtnYXNdKGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL3VzZXIvZ2xvc3NhcnkuaHRtbCNnYXMpIGEgZ2l2ZW4gb3BlcmF0aW9uIGNhbiBjb25zdW1lLlxuICAgICAqL1xuICAgIGdldCBnYXNMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmRVcChOdW1iZXIodGhpcy5fbWlsbGlnYXNMaW1pdCkgLyAxMDAwICsgR0FTX0JVRkZFUik7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb25GZWVNdXRleigpIHtcbiAgICAgICAgcmV0dXJuICgoTnVtYmVyKHRoaXMuX21pbGxpZ2FzTGltaXQpIC8gMTAwMCArIEdBU19CVUZGRVIpICogTUlOSU1BTF9GRUVfUEVSX0dBU19NVVRFWiArXG4gICAgICAgICAgICBOdW1iZXIodGhpcy5vcFNpemUpICogTUlOSU1BTF9GRUVfUEVSX0JZVEVfTVVURVopO1xuICAgIH1cbiAgICByb3VuZFVwKG5hbm90ZXopIHtcbiAgICAgICAgcmV0dXJuIE1hdGguY2VpbChOdW1iZXIobmFub3RleikpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gTWluaW11bSBmZWVzIGZvciB0aGUgW29wZXJhdGlvbl0oaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vdXNlci9nbG9zc2FyeS5odG1sI29wZXJhdGlvbnMpIGFjY29yZGluZyB0byBbYmFrZXJdKGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL3VzZXIvZ2xvc3NhcnkuaHRtbCNiYWtlcikgZGVmYXVsdHMuXG4gICAgICovXG4gICAgZ2V0IG1pbmltYWxGZWVNdXRleigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucm91bmRVcChNSU5JTUFMX0ZFRV9NVVRFWiArIHRoaXMub3BlcmF0aW9uRmVlTXV0ZXopO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gVGhlIHN1Z2dlc3RlZCBmZWUgZm9yIHRoZSBvcGVyYXRpb24gd2hpY2ggaW5jbHVkZXMgbWluaW1hbCBmZWVzIGFuZCBhIHNtYWxsIGJ1ZmZlci5cbiAgICAgKi9cbiAgICBnZXQgc3VnZ2VzdGVkRmVlTXV0ZXooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJvdW5kVXAodGhpcy5vcGVyYXRpb25GZWVNdXRleiArIE1JTklNQUxfRkVFX01VVEVaICogMik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBGZWVzIGFjY29yZGluZyB0byB5b3VyIHNwZWNpZmllZCBiYXNlIGZlZSB3aWxsIGVuc3VyZSB0aGF0IGF0IGxlYXN0IG1pbmltdW0gZmVlcyBhcmUgdXNlZC5cbiAgICAgKi9cbiAgICBnZXQgdXNpbmdCYXNlRmVlTXV0ZXooKSB7XG4gICAgICAgIHJldHVybiAoTWF0aC5tYXgoTnVtYmVyKHRoaXMuYmFzZUZlZU11dGV6KSwgTUlOSU1BTF9GRUVfTVVURVopICsgdGhpcy5yb3VuZFVwKHRoaXMub3BlcmF0aW9uRmVlTXV0ZXopKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFRoZSBzdW0gb2YgYG1pbmltYWxGZWVNdXRlemAgKyBgYnVybkZlZU11dGV6YC5cbiAgICAgKi9cbiAgICBnZXQgdG90YWxDb3N0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5taW5pbWFsRmVlTXV0ZXogKyB0aGlzLmJ1cm5GZWVNdXRlejtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFNpbmNlIERlbHBoaW5ldCwgY29uc3VtZWQgZ2FzIGlzIHByb3ZpZGVkIGluIG1pbGxpZ2FzIGZvciBtb3JlIHByZWNpc2lvbi5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYW4gZXN0aW1hdGlvbiBvZiB0aGUgZ2FzIHRoYXQgb3BlcmF0aW9uIHdpbGwgY29uc3VtZSBpbiBtaWxsaWdhcy5cbiAgICAgKi9cbiAgICBnZXQgY29uc3VtZWRNaWxsaWdhcygpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLl9taWxsaWdhc0xpbWl0KTtcbiAgICB9XG4gICAgc3RhdGljIGNyZWF0ZUVzdGltYXRlSW5zdGFuY2VGcm9tUHJvcGVydGllcyhlc3RpbWF0ZVByb3BlcnRpZXMpIHtcbiAgICAgICAgbGV0IG1pbGxpZ2FzTGltaXQgPSAwO1xuICAgICAgICBsZXQgc3RvcmFnZUxpbWl0ID0gMDtcbiAgICAgICAgbGV0IG9wU2l6ZSA9IDA7XG4gICAgICAgIGxldCBtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRleiA9IDA7XG4gICAgICAgIGxldCBiYXNlRmVlTXV0ZXo7XG4gICAgICAgIGVzdGltYXRlUHJvcGVydGllcy5mb3JFYWNoKChlc3RpbWF0ZSkgPT4ge1xuICAgICAgICAgICAgbWlsbGlnYXNMaW1pdCArPSBlc3RpbWF0ZS5taWxsaWdhc0xpbWl0O1xuICAgICAgICAgICAgc3RvcmFnZUxpbWl0ICs9IGVzdGltYXRlLnN0b3JhZ2VMaW1pdDtcbiAgICAgICAgICAgIG9wU2l6ZSArPSBlc3RpbWF0ZS5vcFNpemU7XG4gICAgICAgICAgICBtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRleiA9IE1hdGgubWF4KGVzdGltYXRlLm1pbmltYWxGZWVQZXJTdG9yYWdlQnl0ZU11dGV6LCBtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRleik7XG4gICAgICAgICAgICBpZiAoZXN0aW1hdGUuYmFzZUZlZU11dGV6KSB7XG4gICAgICAgICAgICAgICAgYmFzZUZlZU11dGV6ID0gYmFzZUZlZU11dGV6ID8gYmFzZUZlZU11dGV6ICsgZXN0aW1hdGUuYmFzZUZlZU11dGV6IDogZXN0aW1hdGUuYmFzZUZlZU11dGV6O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBFc3RpbWF0ZShtaWxsaWdhc0xpbWl0LCBzdG9yYWdlTGltaXQsIG9wU2l6ZSwgbWluaW1hbEZlZVBlclN0b3JhZ2VCeXRlTXV0ZXosIGJhc2VGZWVNdXRleik7XG4gICAgfVxuICAgIHN0YXRpYyBjcmVhdGVBcnJheUVzdGltYXRlSW5zdGFuY2VzRnJvbVByb3BlcnRpZXMoZXN0aW1hdGVQcm9wZXJ0aWVzKSB7XG4gICAgICAgIHJldHVybiBlc3RpbWF0ZVByb3BlcnRpZXMubWFwKCh4KSA9PiBuZXcgRXN0aW1hdGUoeC5taWxsaWdhc0xpbWl0LCB4LnN0b3JhZ2VMaW1pdCwgeC5vcFNpemUsIHgubWluaW1hbEZlZVBlclN0b3JhZ2VCeXRlTXV0ZXosIHguYmFzZUZlZU11dGV6KSk7XG4gICAgfVxufVxuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgdW5hYmxlIHRvIGdldCBwdWJsaWMga2V5IHRvIGVzdGltYXRlIHJldmVhbCBvcGVyYXRpb24gaW4gV2FsbGV0IEFQSVxuICovXG5jbGFzcyBSZXZlYWxFc3RpbWF0ZUVycm9yIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1JldmVhbEVzdGltYXRlRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSAnUHVibGljIGtleSBpcyB1bmtub3duLCB1bmFibGUgdG8gZXN0aW1hdGUgdGhlIHJldmVhbCBvcGVyYXRpb24gaW4gV2FsbGV0IEFQSS4nO1xuICAgIH1cbn1cblxuY2xhc3MgUlBDRXN0aW1hdGVQcm92aWRlciBleHRlbmRzIFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5BTExPQ0FUSU9OX1NUT1JBR0UgPSAyNTc7XG4gICAgICAgIHRoaXMuT1JJR0lOQVRJT05fU1RPUkFHRSA9IDI1NztcbiAgICAgICAgdGhpcy5PUF9TSVpFX1JFVkVBTCA9IDEyODtcbiAgICAgICAgdGhpcy5wcmVwYXJlID0gbmV3IFByZXBhcmVQcm92aWRlcih0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgaXNTaWduZXJDb25maWd1cmVkID0gdGhpcy5jb250ZXh0LmlzQW55U2lnbmVyQ29uZmlndXJlZCgpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBwdWJsaWNLZXlIYXNoOiBpc1NpZ25lckNvbmZpZ3VyZWRcbiAgICAgICAgICAgICAgICAgICAgPyB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKClcbiAgICAgICAgICAgICAgICAgICAgOiB5aWVsZCB0aGlzLmNvbnRleHQud2FsbGV0UHJvdmlkZXIuZ2V0UEtIKCksXG4gICAgICAgICAgICAgICAgcHVibGljS2V5OiBpc1NpZ25lckNvbmZpZ3VyZWQgPyB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXkoKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFc3RpbWF0aW9uUHJvcGVydGllc0Zyb21PcGVyYXRpb25Db250ZW50KGNvbnRlbnQsIHNpemUsIGNvc3RQZXJCeXRlKSB7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvblJlc3VsdHMgPSBmbGF0dGVuT3BlcmF0aW9uUmVzdWx0KHsgY29udGVudHM6IFtjb250ZW50XSB9KTtcbiAgICAgICAgbGV0IHRvdGFsTWlsbGlnYXMgPSAwO1xuICAgICAgICBsZXQgdG90YWxTdG9yYWdlID0gMDtcbiAgICAgICAgb3BlcmF0aW9uUmVzdWx0cy5mb3JFYWNoKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRvdGFsU3RvcmFnZSArPVxuICAgICAgICAgICAgICAgICdvcmlnaW5hdGVkX2NvbnRyYWN0cycgaW4gcmVzdWx0ICYmIHR5cGVvZiByZXN1bHQub3JpZ2luYXRlZF9jb250cmFjdHMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgICAgID8gcmVzdWx0Lm9yaWdpbmF0ZWRfY29udHJhY3RzLmxlbmd0aCAqIHRoaXMuT1JJR0lOQVRJT05fU1RPUkFHRVxuICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICB0b3RhbFN0b3JhZ2UgKz0gJ2FsbG9jYXRlZF9kZXN0aW5hdGlvbl9jb250cmFjdCcgaW4gcmVzdWx0ID8gdGhpcy5BTExPQ0FUSU9OX1NUT1JBR0UgOiAwO1xuICAgICAgICAgICAgdG90YWxNaWxsaWdhcyArPSBOdW1iZXIocmVzdWx0LmNvbnN1bWVkX21pbGxpZ2FzKSB8fCAwO1xuICAgICAgICAgICAgdG90YWxTdG9yYWdlICs9XG4gICAgICAgICAgICAgICAgJ3BhaWRfc3RvcmFnZV9zaXplX2RpZmYnIGluIHJlc3VsdCA/IE51bWJlcihyZXN1bHQucGFpZF9zdG9yYWdlX3NpemVfZGlmZikgfHwgMCA6IDA7XG4gICAgICAgICAgICB0b3RhbFN0b3JhZ2UgKz1cbiAgICAgICAgICAgICAgICAnc3RvcmFnZV9zaXplJyBpbiByZXN1bHQgJiYgJ2dsb2JhbF9hZGRyZXNzJyBpbiByZXN1bHRcbiAgICAgICAgICAgICAgICAgICAgPyBOdW1iZXIocmVzdWx0LnN0b3JhZ2Vfc2l6ZSkgfHwgMFxuICAgICAgICAgICAgICAgICAgICA6IDA7XG4gICAgICAgICAgICB0b3RhbFN0b3JhZ2UgKz0gJ2dlbmVzaXNfY29tbWl0bWVudF9oYXNoJyBpbiByZXN1bHQgPyBOdW1iZXIocmVzdWx0LnNpemUpIDogMDtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpc09wV2l0aEZlZShjb250ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBtaWxsaWdhc0xpbWl0OiB0b3RhbE1pbGxpZ2FzIHx8IDAsXG4gICAgICAgICAgICAgICAgc3RvcmFnZUxpbWl0OiBOdW1iZXIodG90YWxTdG9yYWdlIHx8IDApLFxuICAgICAgICAgICAgICAgIG9wU2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICBtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRlejogY29zdFBlckJ5dGUudG9OdW1iZXIoKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1pbGxpZ2FzTGltaXQ6IDAsXG4gICAgICAgICAgICAgICAgc3RvcmFnZUxpbWl0OiAwLFxuICAgICAgICAgICAgICAgIG9wU2l6ZTogc2l6ZSxcbiAgICAgICAgICAgICAgICBtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRlejogY29zdFBlckJ5dGUudG9OdW1iZXIoKSxcbiAgICAgICAgICAgICAgICBiYXNlRmVlTXV0ZXo6IDAsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhbGN1bGF0ZUVzdGltYXRlcyhvcCwgY29uc3RhbnRzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB7IG9wYnl0ZXMsIG9wT2I6IHsgYnJhbmNoLCBjb250ZW50cyB9LCB9ID0geWllbGQgdGhpcy5mb3JnZShvcCk7XG4gICAgICAgICAgICBjb25zdCBvcGVyYXRpb24gPSB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiB7IGJyYW5jaCwgY29udGVudHMgfSxcbiAgICAgICAgICAgICAgICBjaGFpbl9pZDogeWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRDaGFpbklkKCksXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgeyBvcFJlc3BvbnNlIH0gPSB5aWVsZCB0aGlzLnNpbXVsYXRlKG9wZXJhdGlvbik7XG4gICAgICAgICAgICBjb25zdCB7IGNvc3RfcGVyX2J5dGUgfSA9IGNvbnN0YW50cztcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IFsuLi5mbGF0dGVuRXJyb3JzKG9wUmVzcG9uc2UsICdiYWNrdHJhY2tlZCcpLCAuLi5mbGF0dGVuRXJyb3JzKG9wUmVzcG9uc2UpXTtcbiAgICAgICAgICAgIC8vIEZhaWwgZWFybHkgaW4gY2FzZSBvZiBlcnJvcnNcbiAgICAgICAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFRlem9zT3BlcmF0aW9uRXJyb3IoZXJyb3JzLCAnRXJyb3Igb2NjdXJyZWQgZHVyaW5nIGVzdGltYXRpb24nLCBvcFJlc3BvbnNlLmNvbnRlbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBudW1iZXJPZk9wcyA9IDE7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShvcC5vcE9iLmNvbnRlbnRzKSAmJiBvcC5vcE9iLmNvbnRlbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICBudW1iZXJPZk9wcyA9XG4gICAgICAgICAgICAgICAgICAgIG9wUmVzcG9uc2UuY29udGVudHNbMF0ua2luZCA9PT0gJ3JldmVhbCdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gb3Aub3BPYi5jb250ZW50cy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgICAgICA6IG9wLm9wT2IuY29udGVudHMubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG9wUmVzcG9uc2UuY29udGVudHMubWFwKCh4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0RXN0aW1hdGlvblByb3BlcnRpZXNGcm9tT3BlcmF0aW9uQ29udGVudCh4LCBcbiAgICAgICAgICAgICAgICAvLyBUT0RPOiBDYWxjdWxhdGUgYSBzcGVjaWZpYyBvcFNpemUgZm9yIGVhY2ggb3BlcmF0aW9uLlxuICAgICAgICAgICAgICAgIHgua2luZCA9PT0gJ3JldmVhbCcgPyB0aGlzLk9QX1NJWkVfUkVWRUFMIC8gMiA6IG9wYnl0ZXMubGVuZ3RoIC8gMiAvIG51bWJlck9mT3BzLCBjb3N0X3Blcl9ieXRlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gRXN0aW1hdGUgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCBhbmQgZmVlcyBmb3IgYW4gb3JpZ2luYXRpb24gb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlc3RpbWF0aW9uIG9mIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBPcmlnaW5hdGlvbk9wZXJhdGlvbiBPcmlnaW5hdGUgb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIG9yaWdpbmF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkT3BlcmF0aW9uID0geWllbGQgdGhpcy5wcmVwYXJlLm9yaWdpbmF0ZShwYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZVByb3BlcnRpZXMgPSB5aWVsZCB0aGlzLmNhbGN1bGF0ZUVzdGltYXRlcyhwcmVwYXJlZE9wZXJhdGlvbiwgcHJvdG9jb2xDb25zdGFudHMpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkT3BlcmF0aW9uLm9wT2IuY29udGVudHNbMF0ua2luZCA9PT0gJ3JldmVhbCcpIHtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZVByb3BlcnRpZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBFc3RpbWF0ZS5jcmVhdGVFc3RpbWF0ZUluc3RhbmNlRnJvbVByb3BlcnRpZXMoZXN0aW1hdGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEVzdGltYXRlIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIGFuIHRyYW5zZmVyIG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gZXN0aW1hdGlvbiBvZiBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciB0aGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gVHJhbnNmZXJPcGVyYXRpb24gT3JpZ2luYXRlIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICB0cmFuc2ZlcihfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciB7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZlZVwiLCBcInN0b3JhZ2VMaW1pdFwiLCBcImdhc0xpbWl0XCJdKTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHRvVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcyhyZXN0LnRvKTtcbiAgICAgICAgICAgIGlmICh0b1ZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihyZXN0LnRvLCBpbnZhbGlkRGV0YWlsKHRvVmFsaWRhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcygoX2IgPSByZXN0LnNvdXJjZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xuICAgICAgICAgICAgaWYgKHJlc3Quc291cmNlICYmIHNvdXJjZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihyZXN0LnNvdXJjZSwgaW52YWxpZERldGFpbChzb3VyY2VWYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdC5hbW91bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBbW91bnRFcnJvcihyZXN0LmFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkT3BlcmF0aW9uID0geWllbGQgdGhpcy5wcmVwYXJlLnRyYW5zYWN0aW9uKE9iamVjdC5hc3NpZ24oeyBmZWUsXG4gICAgICAgICAgICAgICAgc3RvcmFnZUxpbWl0LFxuICAgICAgICAgICAgICAgIGdhc0xpbWl0IH0sIHJlc3QpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVQcm9wZXJ0aWVzID0geWllbGQgdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZXMocHJlcGFyZWRPcGVyYXRpb24sIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZE9wZXJhdGlvbi5vcE9iLmNvbnRlbnRzWzBdLmtpbmQgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVQcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXN0aW1hdGUuY3JlYXRlRXN0aW1hdGVJbnN0YW5jZUZyb21Qcm9wZXJ0aWVzKGVzdGltYXRlUHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBFc3RpbWF0ZSBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciBhIHRyYW5zZmVyVGlja2V0IG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gZXN0aW1hdGlvbiBvZiBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciB0aGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gVHJhbnNmZXJUaWNrZXRQYXJhbXMgb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHRyYW5zZmVyVGlja2V0KF9hKSB7XG4gICAgICAgIHZhciBfYjtcbiAgICAgICAgdmFyIHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiZmVlXCIsIFwic3RvcmFnZUxpbWl0XCIsIFwiZ2FzTGltaXRcIl0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGVzdGluYXRpb25WYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKHJlc3QuZGVzdGluYXRpb24pO1xuICAgICAgICAgICAgaWYgKGRlc3RpbmF0aW9uVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHJlc3QuZGVzdGluYXRpb24sIGludmFsaWREZXRhaWwoZGVzdGluYXRpb25WYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VWYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKChfYiA9IHJlc3Quc291cmNlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAnJyk7XG4gICAgICAgICAgICBpZiAocmVzdC5zb3VyY2UgJiYgc291cmNlVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHJlc3Quc291cmNlLCBpbnZhbGlkRGV0YWlsKHNvdXJjZVZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRPcGVyYXRpb24gPSB5aWVsZCB0aGlzLnByZXBhcmUudHJhbnNmZXJUaWNrZXQoT2JqZWN0LmFzc2lnbih7IGZlZSxcbiAgICAgICAgICAgICAgICBzdG9yYWdlTGltaXQsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQgfSwgcmVzdCkpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVQcm9wZXJ0aWVzID0geWllbGQgdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZXMocHJlcGFyZWRPcGVyYXRpb24sIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZE9wZXJhdGlvbi5vcE9iLmNvbnRlbnRzWzBdLmtpbmQgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVQcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXN0aW1hdGUuY3JlYXRlRXN0aW1hdGVJbnN0YW5jZUZyb21Qcm9wZXJ0aWVzKGVzdGltYXRlUHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBFc3RpbWF0ZSBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciBhIGRlbGVnYXRlIG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gZXN0aW1hdGlvbiBvZiBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciB0aGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gRXN0aW1hdGVcbiAgICAgKi9cbiAgICBzZXREZWxlZ2F0ZShfYSkge1xuICAgICAgICB2YXIgX2I7XG4gICAgICAgIHZhciB7IGZlZSwgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCB9ID0gX2EsIHJlc3QgPSBfX3Jlc3QoX2EsIFtcImZlZVwiLCBcImdhc0xpbWl0XCIsIFwic3RvcmFnZUxpbWl0XCJdKTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MocmVzdC5zb3VyY2UpO1xuICAgICAgICAgICAgaWYgKHJlc3Quc291cmNlICYmIHNvdXJjZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihyZXN0LnNvdXJjZSwgaW52YWxpZERldGFpbChzb3VyY2VWYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBkZWxlZ2F0ZVZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MoKF9iID0gcmVzdC5kZWxlZ2F0ZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJycpO1xuICAgICAgICAgICAgaWYgKHJlc3QuZGVsZWdhdGUgJiYgZGVsZWdhdGVWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IocmVzdC5kZWxlZ2F0ZSwgaW52YWxpZERldGFpbChkZWxlZ2F0ZVZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkT3BlcmF0aW9uID0geWllbGQgdGhpcy5wcmVwYXJlLmRlbGVnYXRpb24oT2JqZWN0LmFzc2lnbih7IGZlZSxcbiAgICAgICAgICAgICAgICBzdG9yYWdlTGltaXQsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQgfSwgcmVzdCkpO1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZVByb3BlcnRpZXMgPSB5aWVsZCB0aGlzLmNhbGN1bGF0ZUVzdGltYXRlcyhwcmVwYXJlZE9wZXJhdGlvbiwgcHJvdG9jb2xDb25zdGFudHMpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkT3BlcmF0aW9uLm9wT2IuY29udGVudHNbMF0ua2luZCA9PT0gJ3JldmVhbCcpIHtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZVByb3BlcnRpZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBFc3RpbWF0ZS5jcmVhdGVFc3RpbWF0ZUluc3RhbmNlRnJvbVByb3BlcnRpZXMoZXN0aW1hdGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEVzdGltYXRlIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIGEgZWFjaCBvcGVyYXRpb24gaW4gdGhlIGJhdGNoXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBhcnJheSBvZiBFc3RpbWF0ZSBvYmplY3RzLiBJZiBhIHJldmVhbCBvcGVyYXRpb24gaXMgbmVlZGVkLCB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYXJyYXkgaXMgdGhlIEVzdGltYXRlIGZvciB0aGUgcmV2ZWFsIG9wZXJhdGlvbi5cbiAgICAgKi9cbiAgICBiYXRjaChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRPcGVyYXRpb25zID0geWllbGQgdGhpcy5wcmVwYXJlLmJhdGNoKHBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZVByb3BlcnRpZXMgPSB5aWVsZCB0aGlzLmNhbGN1bGF0ZUVzdGltYXRlcyhwcmVwYXJlZE9wZXJhdGlvbnMsIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIHJldHVybiBFc3RpbWF0ZS5jcmVhdGVBcnJheUVzdGltYXRlSW5zdGFuY2VzRnJvbVByb3BlcnRpZXMoZXN0aW1hdGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEVzdGltYXRlIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIGEgZGVsZWdhdGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlc3RpbWF0aW9uIG9mIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBFc3RpbWF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyRGVsZWdhdGUoX2EsIHNvdXJjZSkge1xuICAgICAgICB2YXIgeyBmZWUsIHN0b3JhZ2VMaW1pdCwgZ2FzTGltaXQgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJmZWVcIiwgXCJzdG9yYWdlTGltaXRcIiwgXCJnYXNMaW1pdFwiXSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwa2ggPSAoeWllbGQgdGhpcy5nZXRLZXlzKCkpLnB1YmxpY0tleUhhc2g7XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbENvbnN0YW50cyA9IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0UHJvdG9jb2xDb25zdGFudHMoJ2hlYWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrU291cmNlID0gc291cmNlIHx8IHBraDtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkT3BlcmF0aW9uID0geWllbGQgdGhpcy5wcmVwYXJlLnJlZ2lzdGVyRGVsZWdhdGUoT2JqZWN0LmFzc2lnbih7IGZlZSwgc3RvcmFnZUxpbWl0LCBnYXNMaW1pdCB9LCByZXN0KSwgY2hlY2tTb3VyY2UpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVQcm9wZXJ0aWVzID0geWllbGQgdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZXMocHJlcGFyZWRPcGVyYXRpb24sIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZE9wZXJhdGlvbi5vcE9iLmNvbnRlbnRzWzBdLmtpbmQgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVQcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXN0aW1hdGUuY3JlYXRlRXN0aW1hdGVJbnN0YW5jZUZyb21Qcm9wZXJ0aWVzKGVzdGltYXRlUHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBFc3RpbWF0ZSBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIHRvIHJldmVhbCB0aGUgY3VycmVudCBhY2NvdW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlc3RpbWF0aW9uIG9mIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIHRoZSBvcGVyYXRpb24gb3IgdW5kZWZpbmVkIGlmIHRoZSBhY2NvdW50IGlzIGFscmVhZHkgcmV2ZWFsZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBFc3RpbWF0ZVxuICAgICAqL1xuICAgIHJldmVhbChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgcHVibGljS2V5SGFzaCwgcHVibGljS2V5IH0gPSB5aWVsZCB0aGlzLmdldEtleXMoKTtcbiAgICAgICAgICAgIGlmICghcHVibGljS2V5KSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFJldmVhbEVzdGltYXRlRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh5aWVsZCB0aGlzLmlzQWNjb3VudFJldmVhbFJlcXVpcmVkKHB1YmxpY0tleUhhc2gpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRPcGVyYXRpb24gPSBwYXJhbXNcbiAgICAgICAgICAgICAgICAgICAgPyB5aWVsZCB0aGlzLnByZXBhcmUucmV2ZWFsKHBhcmFtcylcbiAgICAgICAgICAgICAgICAgICAgOiB5aWVsZCB0aGlzLnByZXBhcmUucmV2ZWFsKHt9KTtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZVByb3BlcnRpZXMgPSB5aWVsZCB0aGlzLmNhbGN1bGF0ZUVzdGltYXRlcyhwcmVwYXJlZE9wZXJhdGlvbiwgcHJvdG9jb2xDb25zdGFudHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBFc3RpbWF0ZS5jcmVhdGVFc3RpbWF0ZUluc3RhbmNlRnJvbVByb3BlcnRpZXMoZXN0aW1hdGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEVzdGltYXRlIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIGFuIHJlZ2lzdGVyR2xvYmFsQ29uc3RhbnQgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlc3RpbWF0aW9uIG9mIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgcmVnaXN0ZXJHbG9iYWxDb25zdGFudCBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgcmVnaXN0ZXJHbG9iYWxDb25zdGFudChfYSkge1xuICAgICAgICB2YXIgeyBmZWUsIHN0b3JhZ2VMaW1pdCwgZ2FzTGltaXQgfSA9IF9hLCByZXN0ID0gX19yZXN0KF9hLCBbXCJmZWVcIiwgXCJzdG9yYWdlTGltaXRcIiwgXCJnYXNMaW1pdFwiXSk7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZE9wZXJhdGlvbiA9IHlpZWxkIHRoaXMucHJlcGFyZS5yZWdpc3Rlckdsb2JhbENvbnN0YW50KE9iamVjdC5hc3NpZ24oeyBmZWUsXG4gICAgICAgICAgICAgICAgc3RvcmFnZUxpbWl0LFxuICAgICAgICAgICAgICAgIGdhc0xpbWl0IH0sIHJlc3QpKTtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVQcm9wZXJ0aWVzID0geWllbGQgdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZXMocHJlcGFyZWRPcGVyYXRpb24sIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZE9wZXJhdGlvbi5vcE9iLmNvbnRlbnRzWzBdLmtpbmQgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVQcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXN0aW1hdGUuY3JlYXRlRXN0aW1hdGVJbnN0YW5jZUZyb21Qcm9wZXJ0aWVzKGVzdGltYXRlUHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBFc3RpbWF0ZSBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0LCBhbmQgZmVlcyBmb3IgYW4gaW5jcmVhc2VQYWlkU3RvcmFnZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGVzdGltYXRpb24gb2YgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCwgYW5kIGZlZXMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgaW5jcmVhc2VQYWlkU3RvcmFnZSBvcGVyYXRpb24gcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIGluY3JlYXNlUGFpZFN0b3JhZ2UoX2EpIHtcbiAgICAgICAgdmFyIHsgZmVlLCBzdG9yYWdlTGltaXQsIGdhc0xpbWl0IH0gPSBfYSwgcmVzdCA9IF9fcmVzdChfYSwgW1wiZmVlXCIsIFwic3RvcmFnZUxpbWl0XCIsIFwiZ2FzTGltaXRcIl0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHJlc3QuYW1vdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQW1vdW50RXJyb3IocmVzdC5hbW91bnQudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm90b2NvbENvbnN0YW50cyA9IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0UHJvdG9jb2xDb25zdGFudHMoJ2hlYWQnKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkT3BlcmF0aW9uID0geWllbGQgdGhpcy5wcmVwYXJlLmluY3JlYXNlUGFpZFN0b3JhZ2UoT2JqZWN0LmFzc2lnbih7IGZlZSxcbiAgICAgICAgICAgICAgICBzdG9yYWdlTGltaXQsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQgfSwgcmVzdCkpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVQcm9wZXJ0aWVzID0geWllbGQgdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZXMocHJlcGFyZWRPcGVyYXRpb24sIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZE9wZXJhdGlvbi5vcE9iLmNvbnRlbnRzWzBdLmtpbmQgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVQcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXN0aW1hdGUuY3JlYXRlRXN0aW1hdGVJbnN0YW5jZUZyb21Qcm9wZXJ0aWVzKGVzdGltYXRlUHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBFc3RpbWF0ZSBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciBhbiBVcGRhdGUgQ29uc2Vuc3VzIEtleSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIGVzdGltYXRpb24gb2YgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCBhbmQgZmVlcyBmb3IgdGhlIG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIEVzdGltYXRlXG4gICAgICovXG4gICAgdXBkYXRlQ29uc2Vuc3VzS2V5KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZE9wZXJhdGlvbiA9IHlpZWxkIHRoaXMucHJlcGFyZS51cGRhdGVDb25zZW5zdXNLZXkocGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlUHJvcGVydGllcyA9IHlpZWxkIHRoaXMuY2FsY3VsYXRlRXN0aW1hdGVzKHByZXBhcmVkT3BlcmF0aW9uLCBwcm90b2NvbENvbnN0YW50cyk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWRPcGVyYXRpb24ub3BPYi5jb250ZW50c1swXS5raW5kID09PSAncmV2ZWFsJykge1xuICAgICAgICAgICAgICAgIGVzdGltYXRlUHJvcGVydGllcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEVzdGltYXRlLmNyZWF0ZUVzdGltYXRlSW5zdGFuY2VGcm9tUHJvcGVydGllcyhlc3RpbWF0ZVByb3BlcnRpZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gRXN0aW1hdGUgZ2FzTGltaXQsIHN0b3JhZ2VMaW1pdCBhbmQgZmVlcyBmb3IgYSBzbWFydF9yb2xsdXBfYWRkX21lc3NhZ2VzIG9wZXJhdGlvblxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gZXN0aW1hdGlvbiBvZiBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciB0aGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gRXN0aW1hdGVcbiAgICAgKi9cbiAgICBzbWFydFJvbGx1cEFkZE1lc3NhZ2VzKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZE9wZXJhdGlvbiA9IHlpZWxkIHRoaXMucHJlcGFyZS5zbWFydFJvbGx1cEFkZE1lc3NhZ2VzKHBhcmFtcyk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZVByb3BlcnRpZXMgPSB5aWVsZCB0aGlzLmNhbGN1bGF0ZUVzdGltYXRlcyhwcmVwYXJlZE9wZXJhdGlvbiwgcHJvdG9jb2xDb25zdGFudHMpO1xuICAgICAgICAgICAgaWYgKHByZXBhcmVkT3BlcmF0aW9uLm9wT2IuY29udGVudHNbMF0ua2luZCA9PT0gJ3JldmVhbCcpIHtcbiAgICAgICAgICAgICAgICBlc3RpbWF0ZVByb3BlcnRpZXMuc2hpZnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBFc3RpbWF0ZS5jcmVhdGVFc3RpbWF0ZUluc3RhbmNlRnJvbVByb3BlcnRpZXMoZXN0aW1hdGVQcm9wZXJ0aWVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIEVzdGltYXRlIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIGFuIFNtYXJ0IFJvbGx1cCBPcmlnaW5hdGUgb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlc3RpbWF0aW9uIG9mIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIHRoZSBvcGVyYXRpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBTbWFydFJvbGx1cE9yaWdpbmF0ZVBhcmFtc1xuICAgICAqL1xuICAgIHNtYXJ0Um9sbHVwT3JpZ2luYXRlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdG9jb2xDb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZE9wZXJhdGlvbiA9IHlpZWxkIHRoaXMucHJlcGFyZS5zbWFydFJvbGx1cE9yaWdpbmF0ZShwYXJhbXMpO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGVQcm9wZXJ0aWVzID0geWllbGQgdGhpcy5jYWxjdWxhdGVFc3RpbWF0ZXMocHJlcGFyZWRPcGVyYXRpb24sIHByb3RvY29sQ29uc3RhbnRzKTtcbiAgICAgICAgICAgIGlmIChwcmVwYXJlZE9wZXJhdGlvbi5vcE9iLmNvbnRlbnRzWzBdLmtpbmQgPT09ICdyZXZlYWwnKSB7XG4gICAgICAgICAgICAgICAgZXN0aW1hdGVQcm9wZXJ0aWVzLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gRXN0aW1hdGUuY3JlYXRlRXN0aW1hdGVJbnN0YW5jZUZyb21Qcm9wZXJ0aWVzKGVzdGltYXRlUHJvcGVydGllcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBFc3RpbWF0ZSBnYXNMaW1pdCwgc3RvcmFnZUxpbWl0IGFuZCBmZWVzIGZvciBjb250cmFjdCBjYWxsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBlc3RpbWF0aW9uIG9mIGdhc0xpbWl0LCBzdG9yYWdlTGltaXQgYW5kIGZlZXMgZm9yIHRoZSBjb250cmFjdCBjYWxsXG4gICAgICpcbiAgICAgKiBAcGFyYW0gRXN0aW1hdGVcbiAgICAgKi9cbiAgICBjb250cmFjdENhbGwoY29udHJhY3RNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29sQ29uc3RhbnRzID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRQcm90b2NvbENvbnN0YW50cygnaGVhZCcpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRPcGVyYXRpb24gPSB5aWVsZCB0aGlzLnByZXBhcmUuY29udHJhY3RDYWxsKGNvbnRyYWN0TWV0aG9kKTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlUHJvcGVydGllcyA9IHlpZWxkIHRoaXMuY2FsY3VsYXRlRXN0aW1hdGVzKHByZXBhcmVkT3BlcmF0aW9uLCBwcm90b2NvbENvbnN0YW50cyk7XG4gICAgICAgICAgICBpZiAocHJlcGFyZWRPcGVyYXRpb24ub3BPYi5jb250ZW50c1swXS5raW5kID09PSAncmV2ZWFsJykge1xuICAgICAgICAgICAgICAgIGVzdGltYXRlUHJvcGVydGllcy5zaGlmdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIEVzdGltYXRlLmNyZWF0ZUVzdGltYXRlSW5zdGFuY2VGcm9tUHJvcGVydGllcyhlc3RpbWF0ZVByb3BlcnRpZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIERlbGVnYXRpb24gb3BlcmF0aW9uIHByb3ZpZGUgdXRpbGl0eSBmdW5jdGlvbiB0byBmZXRjaCBuZXdseSBpc3N1ZWQgZGVsZWdhdGlvblxuICpcbiAqIEB3YXJuIEN1cnJlbnRseSBzdXBwb3J0IG9ubHkgb25lIGRlbGVnYXRpb24gcGVyIG9wZXJhdGlvblxuICovXG5jbGFzcyBEZWxlZ2F0ZU9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgcGFyYW1zLCBzb3VyY2UsIHJhdywgcmVzdWx0cywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihoYXNoLCByYXcsIHJlc3VsdHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb25SZXN1bHRzKCkge1xuICAgICAgICBjb25zdCBkZWxlZ2F0aW9uT3AgPSBBcnJheS5pc0FycmF5KHRoaXMucmVzdWx0cykgJiZcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gJ2RlbGVnYXRpb24nKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gZGVsZWdhdGlvbk9wICYmIGRlbGVnYXRpb25PcC5tZXRhZGF0YSAmJiBkZWxlZ2F0aW9uT3AubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5kZWxlZ2F0ZTtcbiAgICB9XG4gICAgZ2V0IGlzUmVnaXN0ZXJPcGVyYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmRlbGVnYXRlID09PSB0aGlzLnNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5mZWUpO1xuICAgIH1cbiAgICBnZXQgZ2FzTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuZ2FzX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5zdG9yYWdlX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnN1bWVkR2FzKCkge1xuICAgICAgICBCaWdOdW1iZXIkMS5jb25maWcoeyBERUNJTUFMX1BMQUNFUzogMCwgUk9VTkRJTkdfTU9ERTogQmlnTnVtYmVyJDEuUk9VTkRfVVAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVkTWlsbGlHYXNcbiAgICAgICAgICAgID8gbmV3IEJpZ051bWJlciQxKHRoaXMuY29uc3VtZWRNaWxsaUdhcykuZGl2aWRlZEJ5KDEwMDApLnRvU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRNaWxsaUdhcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3VtZWRfbWlsbGlnYXM7XG4gICAgfVxuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVycm9ycztcbiAgICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIE9yaWdpbmF0aW9uIG9wZXJhdGlvbiBwcm92aWRlIHV0aWxpdHkgZnVuY3Rpb24gdG8gZmV0Y2ggbmV3bHkgb3JpZ2luYXRlZCBjb250cmFjdFxuICpcbiAqIEB3YXJuIEN1cnJlbnRseSBzdXBwb3J0IG9ubHkgb25lIG9yaWdpbmF0aW9uIHBlciBvcGVyYXRpb25cbiAqL1xuY2xhc3MgT3JpZ2luYXRpb25PcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIHBhcmFtcywgcmF3LCByZXN1bHRzLCBjb250ZXh0LCBjb250cmFjdFByb3ZpZGVyKSB7XG4gICAgICAgIHN1cGVyKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLmNvbnRyYWN0UHJvdmlkZXIgPSBjb250cmFjdFByb3ZpZGVyO1xuICAgICAgICBjb25zdCBvcmlnaW5hdGVkQ29udHJhY3RzID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzICYmIHRoaXMub3BlcmF0aW9uUmVzdWx0cy5vcmlnaW5hdGVkX2NvbnRyYWN0cztcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3JpZ2luYXRlZENvbnRyYWN0cykpIHtcbiAgICAgICAgICAgIHRoaXMuY29udHJhY3RBZGRyZXNzID0gb3JpZ2luYXRlZENvbnRyYWN0c1swXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb25SZXN1bHRzKCkge1xuICAgICAgICBjb25zdCBvcmlnaW5hdGlvbk9wID0gQXJyYXkuaXNBcnJheSh0aGlzLnJlc3VsdHMpICYmXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09ICdvcmlnaW5hdGlvbicpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBvcmlnaW5hdGlvbk9wICYmXG4gICAgICAgICAgICBoYXNNZXRhZGF0YVdpdGhSZXN1bHQob3JpZ2luYXRpb25PcCkgJiZcbiAgICAgICAgICAgIG9yaWdpbmF0aW9uT3AubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5mZWUpO1xuICAgIH1cbiAgICBnZXQgZ2FzTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuZ2FzX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5zdG9yYWdlX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnN1bWVkR2FzKCkge1xuICAgICAgICBCaWdOdW1iZXIkMS5jb25maWcoeyBERUNJTUFMX1BMQUNFUzogMCwgUk9VTkRJTkdfTU9ERTogQmlnTnVtYmVyJDEuUk9VTkRfVVAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVkTWlsbGlHYXNcbiAgICAgICAgICAgID8gbmV3IEJpZ051bWJlciQxKHRoaXMuY29uc3VtZWRNaWxsaUdhcykuZGl2aWRlZEJ5KDEwMDApLnRvU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRNaWxsaUdhcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3VtZWRfbWlsbGlnYXM7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlRGlmZigpIHtcbiAgICAgICAgY29uc3Qgc3RvcmFnZURpZmYgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMgJiYgdGhpcy5vcGVyYXRpb25SZXN1bHRzLnBhaWRfc3RvcmFnZV9zaXplX2RpZmY7XG4gICAgICAgIHJldHVybiBzdG9yYWdlRGlmZiA/IHN0b3JhZ2VEaWZmIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZVNpemUoKSB7XG4gICAgICAgIGNvbnN0IHN0b3JhZ2VTaXplID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzICYmIHRoaXMub3BlcmF0aW9uUmVzdWx0cy5zdG9yYWdlX3NpemU7XG4gICAgICAgIHJldHVybiBzdG9yYWdlU2l6ZSA/IHN0b3JhZ2VTaXplIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcnJvcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBQcm92aWRlIHRoZSBjb250cmFjdCBhYnN0cmFjdCBvZiB0aGUgbmV3bHkgb3JpZ2luYXRlZCBjb250cmFjdFxuICAgICAqIEB0aHJvd3Mge0BsaW5rIE9yaWdpbmF0aW9uT3BlcmF0aW9uRXJyb3J9XG4gICAgICovXG4gICAgY29udHJhY3QoY29uZmlybWF0aW9ucywgdGltZW91dCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBPcmlnaW5hdGlvbk9wZXJhdGlvbkVycm9yKCdObyBjb250cmFjdCB3YXMgb3JpZ2luYXRlZCBpbiB0aGlzIG9wZXJhdGlvbicpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgeWllbGQgdGhpcy5jb25maXJtYXRpb24oY29uZmlybWF0aW9ucywgdGltZW91dCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250cmFjdFByb3ZpZGVyLmF0KHRoaXMuY29udHJhY3RBZGRyZXNzKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBkZXNjcmlwdGlvbiBSZWdpc3Rlckdsb2JhbENvbnN0YW50T3BlcmF0aW9uIHByb3ZpZGVzIHV0aWxpdHkgZnVuY3Rpb25zIHRvIGZldGNoIGEgbmV3bHkgaXNzdWVkIG9wZXJhdGlvbiBvZiBraW5kIHJlZ2lzdGVyX2dsb2JhbF9jb25zdGFudFxuICovXG5jbGFzcyBSZWdpc3Rlckdsb2JhbENvbnN0YW50T3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBwYXJhbXMsIHNvdXJjZSwgcmF3LCByZXN1bHRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgICAgdGhpcy5nbG9iYWxDb25zdGFudEhhc2ggPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMgJiYgdGhpcy5vcGVyYXRpb25SZXN1bHRzLmdsb2JhbF9hZGRyZXNzO1xuICAgIH1cbiAgICBnZXQgb3BlcmF0aW9uUmVzdWx0cygpIHtcbiAgICAgICAgY29uc3QgcmVnaXN0ZXJHbG9iYWxDb25zdGFudE9wID0gQXJyYXkuaXNBcnJheSh0aGlzLnJlc3VsdHMpICYmXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09ICdyZWdpc3Rlcl9nbG9iYWxfY29uc3RhbnQnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gcmVnaXN0ZXJHbG9iYWxDb25zdGFudE9wICYmXG4gICAgICAgICAgICByZWdpc3Rlckdsb2JhbENvbnN0YW50T3AubWV0YWRhdGEgJiZcbiAgICAgICAgICAgIHJlZ2lzdGVyR2xvYmFsQ29uc3RhbnRPcC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIGdldCByZWdpc3RlcmVkRXhwcmVzc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnZhbHVlO1xuICAgIH1cbiAgICBnZXQgZmVlKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMucGFyYW1zLmZlZSk7XG4gICAgfVxuICAgIGdldCBnYXNMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5nYXNfbGltaXQpO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZUxpbWl0KCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMucGFyYW1zLnN0b3JhZ2VfbGltaXQpO1xuICAgIH1cbiAgICBnZXQgZXJyb3JzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5lcnJvcnM7XG4gICAgfVxuICAgIGdldCBjb25zdW1lZEdhcygpIHtcbiAgICAgICAgQmlnTnVtYmVyJDEuY29uZmlnKHsgREVDSU1BTF9QTEFDRVM6IDAsIFJPVU5ESU5HX01PREU6IEJpZ051bWJlciQxLlJPVU5EX1VQIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5jb25zdW1lZE1pbGxpR2FzXG4gICAgICAgICAgICA/IG5ldyBCaWdOdW1iZXIkMSh0aGlzLmNvbnN1bWVkTWlsbGlHYXMpLmRpdmlkZWRCeSgxMDAwKS50b1N0cmluZygpXG4gICAgICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IGNvbnN1bWVkTWlsbGlHYXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN1bWVkX21pbGxpZ2FzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gUmV2ZWFsIG9wZXJhdGlvbiBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyB0byBmZXRjaCBhIG5ld2x5IGlzc3VlZCByZXZlbGF0aW9uXG4gKi9cbmNsYXNzIFJldmVhbE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgcGFyYW1zLCBzb3VyY2UsIHJhdywgcmVzdWx0cywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihoYXNoLCByYXcsIHJlc3VsdHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb25SZXN1bHRzKCkge1xuICAgICAgICBjb25zdCByZXZlYWxPcCA9IEFycmF5LmlzQXJyYXkodGhpcy5yZXN1bHRzKSAmJlxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSAncmV2ZWFsJyk7XG4gICAgICAgIHJldHVybiByZXZlYWxPcCA/IFtyZXZlYWxPcF0gOiBbXTtcbiAgICB9XG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9uUmVzdWx0cyA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cztcbiAgICAgICAgY29uc3QgdHhSZXN1bHQgPSBvcGVyYXRpb25SZXN1bHRzWzBdO1xuICAgICAgICBpZiAodHhSZXN1bHQpIHtcbiAgICAgICAgICAgIHJldHVybiB0eFJlc3VsdC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0LnN0YXR1cztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiAndW5rbm93bic7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5mZWUpO1xuICAgIH1cbiAgICBnZXQgZ2FzTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuZ2FzX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5zdG9yYWdlX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHB1YmxpY0tleSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnB1YmxpY19rZXk7XG4gICAgfVxuICAgIHN1bVByb3AoYXJyLCBwcm9wKSB7XG4gICAgICAgIHJldHVybiBhcnIucmVkdWNlKChwcmV2LCBjdXJyZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gcHJvcCBpbiBjdXJyZW50ID8gTnVtYmVyKGN1cnJlbnRbcHJvcF0pICsgcHJldiA6IHByZXY7XG4gICAgICAgIH0sIDApO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRHYXMoKSB7XG4gICAgICAgIEJpZ051bWJlciQxLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTOiAwLCBST1VORElOR19NT0RFOiBCaWdOdW1iZXIkMS5ST1VORF9VUCB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIkMSh0aGlzLmNvbnN1bWVkTWlsbGlHYXMpLmRpdmlkZWRCeSgxMDAwKS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRNaWxsaUdhcygpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnN1bVByb3AoZmxhdHRlbk9wZXJhdGlvblJlc3VsdCh7IGNvbnRlbnRzOiB0aGlzLm9wZXJhdGlvblJlc3VsdHMgfSksICdjb25zdW1lZF9taWxsaWdhcycpKTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VEaWZmKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3VtUHJvcChmbGF0dGVuT3BlcmF0aW9uUmVzdWx0KHsgY29udGVudHM6IHRoaXMub3BlcmF0aW9uUmVzdWx0cyB9KSwgJ3BhaWRfc3RvcmFnZV9zaXplX2RpZmYnKSk7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlU2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZyh0aGlzLnN1bVByb3AoZmxhdHRlbk9wZXJhdGlvblJlc3VsdCh7IGNvbnRlbnRzOiB0aGlzLm9wZXJhdGlvblJlc3VsdHMgfSksICdzdG9yYWdlX3NpemUnKSk7XG4gICAgfVxuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHJldHVybiBmbGF0dGVuRXJyb3JzKHsgY29udGVudHM6IHRoaXMub3BlcmF0aW9uUmVzdWx0cyB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIFRyYW5zYWN0aW9uIG9wZXJhdGlvbiBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyB0byBmZXRjaCBhIG5ld2x5IGlzc3VlZCB0cmFuc2FjdGlvblxuICpcbiAqIEB3YXJuIEN1cnJlbnRseSBzdXBwb3J0cyBvbmUgdHJhbnNhY3Rpb24gcGVyIG9wZXJhdGlvblxuICovXG5jbGFzcyBUcmFuc2FjdGlvbk9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgcGFyYW1zLCBzb3VyY2UsIHJhdywgcmVzdWx0cywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihoYXNoLCByYXcsIHJlc3VsdHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb25SZXN1bHRzKCkge1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbk9wID0gQXJyYXkuaXNBcnJheSh0aGlzLnJlc3VsdHMpICYmXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09ICd0cmFuc2FjdGlvbicpO1xuICAgICAgICByZXR1cm4gdHJhbnNhY3Rpb25PcCA/IFt0cmFuc2FjdGlvbk9wXSA6IFtdO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICBjb25zdCBvcGVyYXRpb25SZXN1bHRzID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzO1xuICAgICAgICBjb25zdCB0eFJlc3VsdCA9IG9wZXJhdGlvblJlc3VsdHNbMF07XG4gICAgICAgIGlmICh0eFJlc3VsdCkge1xuICAgICAgICAgICAgcmV0dXJuIHR4UmVzdWx0Lm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQuc3RhdHVzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuICd1bmtub3duJztcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gbmV3IEJpZ051bWJlcih0aGlzLnBhcmFtcy5hbW91bnQpO1xuICAgIH1cbiAgICBnZXQgZGVzdGluYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5kZXN0aW5hdGlvbjtcbiAgICB9XG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5mZWUpO1xuICAgIH1cbiAgICBnZXQgZ2FzTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuZ2FzX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5zdG9yYWdlX2xpbWl0KTtcbiAgICB9XG4gICAgc3VtUHJvcChhcnIsIHByb3ApIHtcbiAgICAgICAgcmV0dXJuIGFyci5yZWR1Y2UoKHByZXYsIGN1cnJlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBwcm9wIGluIGN1cnJlbnQgPyBOdW1iZXIoY3VycmVudFtwcm9wXSkgKyBwcmV2IDogcHJldjtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuICAgIGdldCBjb25zdW1lZEdhcygpIHtcbiAgICAgICAgQmlnTnVtYmVyLmNvbmZpZyh7IERFQ0lNQUxfUExBQ0VTOiAwLCBST1VORElOR19NT0RFOiBCaWdOdW1iZXIuUk9VTkRfVVAgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKHRoaXMuY29uc3VtZWRNaWxsaUdhcykuZGl2aWRlZEJ5KDEwMDApLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldCBjb25zdW1lZE1pbGxpR2FzKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3VtUHJvcChmbGF0dGVuT3BlcmF0aW9uUmVzdWx0KHsgY29udGVudHM6IHRoaXMub3BlcmF0aW9uUmVzdWx0cyB9KSwgJ2NvbnN1bWVkX21pbGxpZ2FzJykpO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZURpZmYoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5zdW1Qcm9wKGZsYXR0ZW5PcGVyYXRpb25SZXN1bHQoeyBjb250ZW50czogdGhpcy5vcGVyYXRpb25SZXN1bHRzIH0pLCAncGFpZF9zdG9yYWdlX3NpemVfZGlmZicpKTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VTaXplKCkge1xuICAgICAgICByZXR1cm4gU3RyaW5nKHRoaXMuc3VtUHJvcChmbGF0dGVuT3BlcmF0aW9uUmVzdWx0KHsgY29udGVudHM6IHRoaXMub3BlcmF0aW9uUmVzdWx0cyB9KSwgJ3N0b3JhZ2Vfc2l6ZScpKTtcbiAgICB9XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgcmV0dXJuIGZsYXR0ZW5FcnJvcnMoeyBjb250ZW50czogdGhpcy5vcGVyYXRpb25SZXN1bHRzIH0pO1xuICAgIH1cbn1cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIEJhbGxvdE9wZXJhdGlvbiBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyB0byBmZXRjaCBhIG5ldyBvcGVyYXRpb24gb2Yga2luZCBiYWxsb3RcbiAqXG4gKi9cbmNsYXNzIEJhbGxvdE9wZXJhdGlvbiBleHRlbmRzIE9wZXJhdGlvbiB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgcGFyYW1zLCBzb3VyY2UsIHJhdywgcmVzdWx0cywgY29udGV4dCkge1xuICAgICAgICBzdXBlcihoYXNoLCByYXcsIHJlc3VsdHMsIGNvbnRleHQpO1xuICAgICAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gICAgfVxuICAgIGdldCBvcGVyYXRpb25SZXN1bHRzKCkge1xuICAgICAgICBjb25zdCBiYWxsb3RPcCA9IEFycmF5LmlzQXJyYXkodGhpcy5yZXN1bHRzKSAmJlxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSAnYmFsbG90Jyk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGJhbGxvdE9wO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgcGVyaW9kKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5wZXJpb2Q7XG4gICAgfVxuICAgIGdldCBwcm9wb3NhbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnByb3Bvc2FsO1xuICAgIH1cbiAgICBnZXQgYmFsbG90KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYmFsbG90O1xuICAgIH1cbn1cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIERyYWluRGVsZWdhdGVPcGVyYXRpb24gcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gZmV0Y2ggYSBuZXcgb3BlcmF0aW9uIG9mIGtpbmQgZHJhaW5fZGVsZWdhdGVcbiAqXG4gKi9cbmNsYXNzIERyYWluRGVsZWdhdGVPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIHBhcmFtcywgcmF3LCByZXN1bHRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgIH1cbiAgICBnZXQgb3BlcmF0aW9uUmVzdWx0cygpIHtcbiAgICAgICAgY29uc3QgZHJhaW5EZWxlZ2F0ZU9wID0gQXJyYXkuaXNBcnJheSh0aGlzLnJlc3VsdHMpICYmXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09ICdkcmFpbl9kZWxlZ2F0ZScpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBkcmFpbkRlbGVnYXRlT3AgJiYgZHJhaW5EZWxlZ2F0ZU9wLm1ldGFkYXRhICYmIGRyYWluRGVsZWdhdGVPcC5tZXRhZGF0YS5iYWxhbmNlX3VwZGF0ZXM7XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBjb25zZW5zdXNLZXkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5jb25zZW5zdXNfa2V5O1xuICAgIH1cbiAgICBnZXQgZGVsZWdhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5kZWxlZ2F0ZTtcbiAgICB9XG4gICAgZ2V0IGRlc3RpbmF0aW9uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuZGVzdGluYXRpb247XG4gICAgfVxufVxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gVHJhbnNmZXIgdGlja2V0cyBmcm9tIGEgVGV6b3MgYWRkcmVzcyAodHoxLCB0ejIgb3IgdHozKSB0byBhIHNtYXJ0IGNvbnRyYWN0IGFkZHJlc3MgKEtUMSkgKGV2ZXJ5dGhpbmcgb24gbGF5ZXIgMSBhdCB0aGlzIHN0ZXApXG4gKlxuICogQHdhcm4gQ3VycmVudGx5IG9ubHkgc3VwcG9ydHMgb25lIEwyIHRpY2tldCBob2xkZXIgdHJhbnNmZXIgYXQgb25jZS4gaWUuIG9uZSBjb2xsZWN0aW9uIG9mIHRpY2tldHMgb3duZWQgYnkgdHoxLCB0ejIgb3IgdHozIHRvIGEgc21hcnQgY29udHJhY3QuXG4gKi9cbmNsYXNzIFRyYW5zZmVyVGlja2V0T3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBwYXJhbXMsIHNvdXJjZSwgcmF3LCByZXN1bHRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IG9wZXJhdGlvblJlc3VsdHMoKSB7XG4gICAgICAgIGNvbnN0IHRyYW5zZmVyT3AgPSBBcnJheS5pc0FycmF5KHRoaXMucmVzdWx0cykgJiZcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLlRSQU5TRkVSX1RJQ0tFVCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRyYW5zZmVyT3AgJiYgdHJhbnNmZXJPcC5tZXRhZGF0YSAmJiB0cmFuc2Zlck9wLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5mZWUpO1xuICAgIH1cbiAgICBnZXQgZ2FzTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuZ2FzX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5zdG9yYWdlX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IGNvbnN1bWVkR2FzKCkge1xuICAgICAgICBCaWdOdW1iZXIkMS5jb25maWcoeyBERUNJTUFMX1BMQUNFUzogMCwgUk9VTkRJTkdfTU9ERTogQmlnTnVtYmVyJDEuUk9VTkRfVVAgfSk7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN1bWVkTWlsbGlHYXNcbiAgICAgICAgICAgID8gbmV3IEJpZ051bWJlciQxKHRoaXMuY29uc3VtZWRNaWxsaUdhcykuZGl2aWRlZEJ5KDEwMDApLnRvU3RyaW5nKClcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRNaWxsaUdhcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3VtZWRfbWlsbGlnYXM7XG4gICAgfVxufVxuXG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gSW5jcmVhc2VQYWlkU3RvcmFnZU9wZXJhdGlvbiBwcm92aWRlcyB1dGlsaXR5IGZ1bmN0aW9ucyB0byBmZXRjaCBhIG5ldyBvcGVyYXRpb24gb2Yga2luZCBpbmNyZWFzZV9wYWlkX3N0b3JhZ2VcbiAqXG4gKi9cbmNsYXNzIEluY3JlYXNlUGFpZFN0b3JhZ2VPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIHBhcmFtcywgc291cmNlLCByYXcsIHJlc3VsdHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoaGFzaCwgcmF3LCByZXN1bHRzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBnZXQgb3BlcmF0aW9uUmVzdWx0cygpIHtcbiAgICAgICAgY29uc3QgaW5jcmVhc2VQYWlkU3RvcmFnZU9wID0gQXJyYXkuaXNBcnJheSh0aGlzLnJlc3VsdHMpICYmXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09ICdpbmNyZWFzZV9wYWlkX3N0b3JhZ2UnKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gaW5jcmVhc2VQYWlkU3RvcmFnZU9wICYmXG4gICAgICAgICAgICBpbmNyZWFzZVBhaWRTdG9yYWdlT3AubWV0YWRhdGEgJiZcbiAgICAgICAgICAgIGluY3JlYXNlUGFpZFN0b3JhZ2VPcC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0O1xuICAgICAgICByZXR1cm4gcmVzdWx0ID8gcmVzdWx0IDogdW5kZWZpbmVkO1xuICAgIH1cbiAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiAndW5rbm93bic7XG4gICAgfVxuICAgIGdldCBmZWUoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuZmVlKTtcbiAgICB9XG4gICAgZ2V0IGdhc0xpbWl0KCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMucGFyYW1zLmdhc19saW1pdCk7XG4gICAgfVxuICAgIGdldCBzdG9yYWdlTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuc3RvcmFnZV9saW1pdCk7XG4gICAgfVxuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVycm9ycztcbiAgICB9XG4gICAgZ2V0IGNvbnN1bWVkTWlsbGlHYXMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNvbnN1bWVkX21pbGxpZ2FzO1xuICAgIH1cbiAgICBnZXQgYW1vdW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMuYW1vdW50O1xuICAgIH1cbiAgICBnZXQgZGVzdGluYXRpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5kZXN0aW5hdGlvbjtcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBQcm9wb3NhbHNPcGVyYXRpb24gcHJvdmlkZXMgdXRpbGl0eSBmdW5jdGlvbnMgdG8gZmV0Y2ggYSBuZXcgb3BlcmF0aW9uIG9mIGtpbmQgcHJvcG9zYWxzXG4gKlxuICovXG5jbGFzcyBQcm9wb3NhbHNPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIHBhcmFtcywgc291cmNlLCByYXcsIHJlc3VsdHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoaGFzaCwgcmF3LCByZXN1bHRzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBnZXQgb3BlcmF0aW9uUmVzdWx0cygpIHtcbiAgICAgICAgY29uc3QgcHJvcG9zYWxzT3AgPSBBcnJheS5pc0FycmF5KHRoaXMucmVzdWx0cykgJiZcbiAgICAgICAgICAgIHRoaXMucmVzdWx0cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gJ3Byb3Bvc2FscycpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBwcm9wb3NhbHNPcDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHByb3Bvc2FscygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyYW1zLnByb3Bvc2FscztcbiAgICB9XG4gICAgZ2V0IHBlcmlvZCgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucGVyaW9kO1xuICAgIH1cbn1cblxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIFVwZGF0ZUNvbnNlbnN1c0tleU9wZXJhdGlvbiBwcm92aWRlcyB1dGlsaXR5IHRvIGZldGNoIHByb3BlcnRpZXMgZm9yIE9wZXJhdGlvbiBvZiBraW5kIFVwZGF0ZUNvbnNlbnN1c0tleVxuICpcbiAqL1xuY2xhc3MgVXBkYXRlQ29uc2Vuc3VzS2V5T3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBwYXJhbXMsIHNvdXJjZSwgcmF3LCByZXN1bHRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IG9wZXJhdGlvblJlc3VsdHMoKSB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZUNvbnNlbnN1c0tleU9wID0gQXJyYXkuaXNBcnJheSh0aGlzLnJlc3VsdHMpICYmXG4gICAgICAgICAgICB0aGlzLnJlc3VsdHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09ICd1cGRhdGVfY29uc2Vuc3VzX2tleScpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSB1cGRhdGVDb25zZW5zdXNLZXlPcCAmJlxuICAgICAgICAgICAgdXBkYXRlQ29uc2Vuc3VzS2V5T3AubWV0YWRhdGEgJiZcbiAgICAgICAgICAgIHVwZGF0ZUNvbnNlbnN1c0tleU9wLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgZ2V0IGZlZSgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5mZWUpO1xuICAgIH1cbiAgICBnZXQgZ2FzTGltaXQoKSB7XG4gICAgICAgIHJldHVybiBOdW1iZXIodGhpcy5wYXJhbXMuZ2FzX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHN0b3JhZ2VMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5zdG9yYWdlX2xpbWl0KTtcbiAgICB9XG4gICAgZ2V0IHBrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMucGs7XG4gICAgfVxuICAgIGdldCBjb25zdW1lZE1pbGxpR2FzKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25zdW1lZF9taWxsaWdhcztcbiAgICB9XG4gICAgZ2V0IGVycm9ycygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZXJyb3JzO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gU21hcnRSb2xsdXBBZGRNZXNzYWdlc09wZXJhdGlvbiBwcm92aWRlcyB1dGlsaXR5IHRvIGZldGNoIHByb3BlcnRpZXMgb2YgU21hcnRSb2xsdXBBZGRNZXNzYWdlc1xuICovXG5jbGFzcyBTbWFydFJvbGx1cEFkZE1lc3NhZ2VzT3BlcmF0aW9uIGV4dGVuZHMgT3BlcmF0aW9uIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoLCBwYXJhbXMsIHNvdXJjZSwgcmF3LCByZXN1bHRzLCBjb250ZXh0KSB7XG4gICAgICAgIHN1cGVyKGhhc2gsIHJhdywgcmVzdWx0cywgY29udGV4dCk7XG4gICAgICAgIHRoaXMucGFyYW1zID0gcGFyYW1zO1xuICAgICAgICB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiAgICB9XG4gICAgZ2V0IG9wZXJhdGlvblJlc3VsdHMoKSB7XG4gICAgICAgIGNvbnN0IHNtYXJ0Um9sbHVwQWRkTWVzc2FnZXNPcCA9IEFycmF5LmlzQXJyYXkodGhpcy5yZXN1bHRzKSAmJlxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSAnc21hcnRfcm9sbHVwX2FkZF9tZXNzYWdlcycpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBzbWFydFJvbGx1cEFkZE1lc3NhZ2VzT3AgJiZcbiAgICAgICAgICAgIHNtYXJ0Um9sbHVwQWRkTWVzc2FnZXNPcC5tZXRhZGF0YSAmJlxuICAgICAgICAgICAgc21hcnRSb2xsdXBBZGRNZXNzYWdlc09wLm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQ7XG4gICAgICAgIHJldHVybiByZXN1bHQgPyByZXN1bHQgOiB1bmRlZmluZWQ7XG4gICAgfVxuICAgIGdldCBzdGF0dXMoKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiAoX2IgPSAoX2EgPSB0aGlzLm9wZXJhdGlvblJlc3VsdHMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdGF0dXMpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6ICd1bmtub3duJztcbiAgICB9XG4gICAgZ2V0IG1lc3NhZ2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5tZXNzYWdlO1xuICAgIH1cbiAgICBnZXQgZmVlKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMucGFyYW1zLmZlZSk7XG4gICAgfVxuICAgIGdldCBnYXNMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5nYXNfbGltaXQpO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZUxpbWl0KCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMucGFyYW1zLnN0b3JhZ2VfbGltaXQpO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRNaWxsaUdhcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3VtZWRfbWlsbGlnYXM7XG4gICAgfVxuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVycm9ycztcbiAgICB9XG59XG5cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBTbWFydFJvbGx1cE9yaWdpbmF0ZSBPcGVyYXRpb24gcHJvdmlkZXMgdXRpbGl0eSB0byBmZXRjaCBwcm9wZXJ0aWVzIGZvciBPcGVyYXRpb24gb2Yga2luZCBTbWFydFJvbGx1cE9yaWdpbmF0ZVxuICpcbiAqL1xuY2xhc3MgU21hcnRSb2xsdXBPcmlnaW5hdGVPcGVyYXRpb24gZXh0ZW5kcyBPcGVyYXRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGhhc2gsIHBhcmFtcywgc291cmNlLCByYXcsIHJlc3VsdHMsIGNvbnRleHQpIHtcbiAgICAgICAgc3VwZXIoaGFzaCwgcmF3LCByZXN1bHRzLCBjb250ZXh0KTtcbiAgICAgICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIH1cbiAgICBnZXQgb3BlcmF0aW9uUmVzdWx0cygpIHtcbiAgICAgICAgY29uc3Qgc21hcnRSb2xsdXBPcmlnaW5hdGVPcCA9IEFycmF5LmlzQXJyYXkodGhpcy5yZXN1bHRzKSAmJlxuICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSBPcEtpbmQuU01BUlRfUk9MTFVQX09SSUdJTkFURSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNtYXJ0Um9sbHVwT3JpZ2luYXRlT3AgJiZcbiAgICAgICAgICAgIHNtYXJ0Um9sbHVwT3JpZ2luYXRlT3AubWV0YWRhdGEgJiZcbiAgICAgICAgICAgIHNtYXJ0Um9sbHVwT3JpZ2luYXRlT3AubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCA/IHJlc3VsdCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZ2V0IHN0YXR1cygpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIChfYiA9IChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnN0YXR1cykgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogJ3Vua25vd24nO1xuICAgIH1cbiAgICBnZXQgZmVlKCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMucGFyYW1zLmZlZSk7XG4gICAgfVxuICAgIGdldCBnYXNMaW1pdCgpIHtcbiAgICAgICAgcmV0dXJuIE51bWJlcih0aGlzLnBhcmFtcy5nYXNfbGltaXQpO1xuICAgIH1cbiAgICBnZXQgc3RvcmFnZUxpbWl0KCkge1xuICAgICAgICByZXR1cm4gTnVtYmVyKHRoaXMucGFyYW1zLnN0b3JhZ2VfbGltaXQpO1xuICAgIH1cbiAgICBnZXQgY29uc3VtZWRNaWxsaUdhcygpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gKF9hID0gdGhpcy5vcGVyYXRpb25SZXN1bHRzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29uc3VtZWRfbWlsbGlnYXM7XG4gICAgfVxuICAgIGdldCBwdm1LaW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJhbXMucHZtX2tpbmQ7XG4gICAgfVxuICAgIGdldCBrZXJuZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcmFtcy5rZXJuZWw7XG4gICAgfVxuICAgIGdldCBlcnJvcnMoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgcmV0dXJuIChfYSA9IHRoaXMub3BlcmF0aW9uUmVzdWx0cykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmVycm9ycztcbiAgICB9XG59XG5cbmNsYXNzIFJwY0NvbnRyYWN0UHJvdmlkZXIgZXh0ZW5kcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCwgZXN0aW1hdG9yKSB7XG4gICAgICAgIHN1cGVyKGNvbnRleHQpO1xuICAgICAgICB0aGlzLmVzdGltYXRvciA9IGVzdGltYXRvcjtcbiAgICAgICAgdGhpcy5jb250cmFjdFByb3ZpZGVyVHlwZVN5bWJvbCA9IFN5bWJvbC5mb3IoJ3RhcXVpdG8tY29udHJhY3QtcHJvdmlkZXItdHlwZS1zeW1ib2wnKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlID0gbmV3IFByZXBhcmVQcm92aWRlcih0aGlzLmNvbnRleHQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSB3ZWxsIGZvcm1hdHRlZCBqc29uIG9iamVjdCBvZiB0aGUgY29udHJhY3Qgc3RvcmFnZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbnRyYWN0IGNvbnRyYWN0IGFkZHJlc3MgeW91IHdhbnQgdG8gZ2V0IHRoZSBzdG9yYWdlIGZyb21cbiAgICAgKiBAcGFyYW0gc2NoZW1hIG9wdGlvbmFsIHNjaGVtYSBjYW4gZWl0aGVyIGJlIHRoZSBjb250cmFjdCBzY3JpcHQgcnBjIHJlc3BvbnNlIG9yIGEgbWljaGVsc29uLWVuY29kZXIgc2NoZW1hXG4gICAgICogQHRocm93cyB7QGxpbmsgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yfVxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWNvbnRyYWN0cy1jb250cmFjdC1pZC1zY3JpcHRcbiAgICAgKi9cbiAgICBnZXRTdG9yYWdlKGNvbnRyYWN0LCBzY2hlbWEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0VmFsaWRhdGlvbiA9IHZhbGlkYXRlQ29udHJhY3RBZGRyZXNzKGNvbnRyYWN0KTtcbiAgICAgICAgICAgIGlmIChjb250cmFjdFZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yKGNvbnRyYWN0LCBpbnZhbGlkRGV0YWlsKGNvbnRyYWN0VmFsaWRhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc2NyaXB0ID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRTY3JpcHQoY29udHJhY3QsICdoZWFkJyk7XG4gICAgICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9IHNjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb250cmFjdFNjaGVtYTtcbiAgICAgICAgICAgIGlmIChTY2hlbWEuaXNTY2hlbWEoc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0U2NoZW1hID0gc2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJhY3RTY2hlbWEgPSBTY2hlbWEuZnJvbVJQQ1Jlc3BvbnNlKHsgc2NyaXB0OiBzY2hlbWEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3RTY2hlbWEuRXhlY3V0ZShzY3JpcHQuc3RvcmFnZSwgc21hcnRDb250cmFjdEFic3RyYWN0aW9uU2VtYW50aWModGhpcykpOyAvLyBDYXN0IGludG8gVCBiZWNhdXNlIG9ubHkgdGhlIGNhbGxlciBjYW4ga25vdyB0aGUgdHJ1ZSB0eXBlIG9mIHRoZSBzdG9yYWdlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSB3ZWxsIGZvcm1hdHRlZCBqc29uIG9iamVjdCBvZiB0aGUgY29udHJhY3QgYmlnIG1hcCBzdG9yYWdlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgY29udHJhY3QgYWRkcmVzcyB5b3Ugd2FudCB0byBnZXQgdGhlIHN0b3JhZ2UgZnJvbVxuICAgICAqIEBwYXJhbSBrZXkgY29udHJhY3QgYmlnIG1hcCBrZXkgdG8gZmV0Y2ggdmFsdWUgZnJvbVxuICAgICAqIEBwYXJhbSBzY2hlbWEgb3B0aW9uYWwgc2NoZW1hIGNhbiBlaXRoZXIgYmUgdGhlIGNvbnRyYWN0IHNjcmlwdCBycGMgcmVzcG9uc2Ugb3IgYSBtaWNoZWxzb24tZW5jb2RlciBzY2hlbWFcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3J9XG4gICAgICogQGRlcHJlY2F0ZWQgRGVwcmVjYXRlZCBpbiBmYXZvciBvZiBnZXRCaWdNYXBLZXlCeUlEXG4gICAgICpcbiAgICAgKiBAc2VlIGh0dHBzOi8vdGV6b3MuZ2l0bGFiLmlvL2FwaS9ycGMuaHRtbCNwb3N0LWJsb2NrLWlkLWNvbnRleHQtY29udHJhY3RzLWNvbnRyYWN0LWlkLWJpZy1tYXAtZ2V0XG4gICAgICovXG4gICAgZ2V0QmlnTWFwS2V5KGNvbnRyYWN0LCBrZXksIHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgY29udHJhY3RWYWxpZGF0aW9uID0gdmFsaWRhdGVDb250cmFjdEFkZHJlc3MoY29udHJhY3QpO1xuICAgICAgICAgICAgaWYgKGNvbnRyYWN0VmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IoY29udHJhY3QsIGludmFsaWREZXRhaWwoY29udHJhY3RWYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXNjaGVtYSkge1xuICAgICAgICAgICAgICAgIHNjaGVtYSA9ICh5aWVsZCB0aGlzLnJwYy5nZXRDb250cmFjdChjb250cmFjdCkpLnNjcmlwdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBjb250cmFjdFNjaGVtYTtcbiAgICAgICAgICAgIGlmIChTY2hlbWEuaXNTY2hlbWEoc2NoZW1hKSkge1xuICAgICAgICAgICAgICAgIGNvbnRyYWN0U2NoZW1hID0gc2NoZW1hO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29udHJhY3RTY2hlbWEgPSBTY2hlbWEuZnJvbVJQQ1Jlc3BvbnNlKHsgc2NyaXB0OiBzY2hlbWEgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkS2V5ID0gY29udHJhY3RTY2hlbWEuRW5jb2RlQmlnTWFwS2V5KGtleSk7XG4gICAgICAgICAgICBjb25zdCB2YWwgPSB5aWVsZCB0aGlzLnJwYy5nZXRCaWdNYXBLZXkoY29udHJhY3QsIGVuY29kZWRLZXkpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0U2NoZW1hLkV4ZWN1dGVPbkJpZ01hcFZhbHVlKHZhbCk7IC8vIENhc3QgaW50byBUIGJlY2F1c2Ugb25seSB0aGUgY2FsbGVyIGNhbiBrbm93IHRoZSB0cnVlIHR5cGUgb2YgdGhlIHN0b3JhZ2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFJldHVybiBhIHdlbGwgZm9ybWF0dGVkIGpzb24gb2JqZWN0IG9mIGEgYmlnIG1hcCB2YWx1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGlkIEJpZyBNYXAgSURcbiAgICAgKiBAcGFyYW0ga2V5VG9FbmNvZGUga2V5IHRvIHF1ZXJ5ICh3aWxsIGJlIGVuY29kZWQgcHJvcGVybHkgYWNjb3JkaW5nIHRvIHRoZSBzY2hlbWEpXG4gICAgICogQHBhcmFtIHNjaGVtYSBCaWcgTWFwIHNjaGVtYSAoY2FuIGJlIGRldGVybWluZWQgdXNpbmcgeW91ciBjb250cmFjdCB0eXBlKVxuICAgICAqIEBwYXJhbSBibG9jayBvcHRpb25hbCBibG9jayBsZXZlbCB0byBmZXRjaCB0aGUgdmFsdWVzIGZyb21cbiAgICAgKlxuICAgICAqIEBzZWUgaHR0cHM6Ly90ZXpvcy5naXRsYWIuaW8vYXBpL3JwYy5odG1sI2dldC1ibG9jay1pZC1jb250ZXh0LWJpZy1tYXBzLWJpZy1tYXAtaWQtc2NyaXB0LWV4cHJcbiAgICAgKi9cbiAgICBnZXRCaWdNYXBLZXlCeUlEKGlkLCBrZXlUb0VuY29kZSwgc2NoZW1hLCBibG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBrZXksIHR5cGUgfSA9IHNjaGVtYS5FbmNvZGVCaWdNYXBLZXkoa2V5VG9FbmNvZGUpO1xuICAgICAgICAgICAgY29uc3QgeyBwYWNrZWQgfSA9IHlpZWxkIHRoaXMuY29udGV4dC5wYWNrZXIucGFja0RhdGEoeyBkYXRhOiBrZXksIHR5cGUgfSk7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkRXhwciA9IGVuY29kZUV4cHIocGFja2VkKTtcbiAgICAgICAgICAgIGNvbnN0IGJpZ01hcFZhbHVlID0gYmxvY2tcbiAgICAgICAgICAgICAgICA/IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0QmlnTWFwVmFsdWUoeyBpZDogaWQudG9TdHJpbmcoKSwgZXhwcjogZW5jb2RlZEV4cHIgfSwgYmxvY2spXG4gICAgICAgICAgICAgICAgOiB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldEJpZ01hcFZhbHVlKHsgaWQ6IGlkLnRvU3RyaW5nKCksIGV4cHI6IGVuY29kZWRFeHByIH0sICdoZWFkJyk7XG4gICAgICAgICAgICByZXR1cm4gc2NoZW1hLkV4ZWN1dGVPbkJpZ01hcFZhbHVlKGJpZ01hcFZhbHVlLCBzbWFydENvbnRyYWN0QWJzdHJhY3Rpb25TZW1hbnRpYyh0aGlzKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBGZXRjaCBtdWx0aXBsZSB2YWx1ZXMgaW4gYSBiaWcgbWFwXG4gICAgICogQWxsIHZhbHVlcyB3aWxsIGJlIGZldGNoZWQgb24gdGhlIHNhbWUgYmxvY2sgbGV2ZWwuIElmIGEgYmxvY2sgaXMgc3BlY2lmaWVkIGluIHRoZSByZXF1ZXN0LCB0aGUgdmFsdWVzIHdpbGwgYmUgZmV0Y2hlZCBhdCBpdC5cbiAgICAgKiBPdGhlcndpc2UsIGEgZmlyc3QgcmVxdWVzdCB3aWxsIGJlIGRvbmUgdG8gdGhlIG5vZGUgdG8gZmV0Y2ggdGhlIGxldmVsIG9mIHRoZSBoZWFkIGFuZCBhbGwgdmFsdWVzIHdpbGwgYmUgZmV0Y2hlZCBhdCB0aGlzIGxldmVsLlxuICAgICAqIElmIG9uZSBvZiB0aGUga2V5cyBkb2VzIG5vdCBleGlzdCBpbiB0aGUgYmlnIG1hcCwgaXRzIHZhbHVlIHdpbGwgYmUgc2V0IHRvIHVuZGVmaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBCaWcgTWFwIElEXG4gICAgICogQHBhcmFtIGtleXMgQXJyYXkgb2Yga2V5cyB0byBxdWVyeSAod2lsbCBiZSBlbmNvZGVkIHByb3Blcmx5IGFjY29yZGluZyB0byB0aGUgc2NoZW1hKVxuICAgICAqIEBwYXJhbSBzY2hlbWEgQmlnIE1hcCBzY2hlbWEgKGNhbiBiZSBkZXRlcm1pbmVkIHVzaW5nIHlvdXIgY29udHJhY3QgdHlwZSlcbiAgICAgKiBAcGFyYW0gYmxvY2sgb3B0aW9uYWwgYmxvY2sgbGV2ZWwgdG8gZmV0Y2ggdGhlIHZhbHVlcyBmcm9tXG4gICAgICogQHBhcmFtIGJhdGNoU2l6ZSBvcHRpb25hbCBiYXRjaCBzaXplIHJlcHJlc2VudGluZyB0aGUgbnVtYmVyIG9mIHJlcXVlc3RzIHRvIGV4ZWN1dGUgaW4gcGFyYWxsZWxcbiAgICAgKiBAcmV0dXJucyBBIE1pY2hlbHNvbk1hcCBjb250YWluaW5nIHRoZSBrZXlzIHF1ZXJpZWQgaW4gdGhlIGJpZyBtYXAgYW5kIHRoZWlyIHZhbHVlIGluIGEgd2VsbC1mb3JtYXR0ZWQgSlNPTiBvYmplY3QgZm9ybWF0XG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRCaWdNYXBLZXlzQnlJRChpZCwga2V5cywgc2NoZW1hLCBibG9jaywgYmF0Y2hTaXplID0gNSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgbGV2ZWwgPSB5aWVsZCB0aGlzLmdldEJsb2NrRm9yUmVxdWVzdChrZXlzLCBibG9jayk7XG4gICAgICAgICAgICBjb25zdCBiaWdNYXBWYWx1ZXMgPSBuZXcgTWljaGVsc29uTWFwKCk7XG4gICAgICAgICAgICAvLyBFeGVjdXRlIGJhdGNoIG9mIHByb21pc2VzIGluIHNlcmllc1xuICAgICAgICAgICAgbGV0IHBvc2l0aW9uID0gMDtcbiAgICAgICAgICAgIGxldCByZXN1bHRzID0gW107XG4gICAgICAgICAgICB3aGlsZSAocG9zaXRpb24gPCBrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXNCYXRjaCA9IGtleXMuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgYmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgICBjb25zdCBiYXRjaCA9IGtleXNCYXRjaC5tYXAoKGtleVRvRW5jb2RlKSA9PiB0aGlzLmdldEJpZ01hcFZhbHVlT3JVbmRlZmluZWQoa2V5VG9FbmNvZGUsIGlkLCBzY2hlbWEsIGxldmVsKSk7XG4gICAgICAgICAgICAgICAgcmVzdWx0cyA9IFsuLi5yZXN1bHRzLCAuLi4oeWllbGQgUHJvbWlzZS5hbGwoYmF0Y2gpKV07XG4gICAgICAgICAgICAgICAgcG9zaXRpb24gKz0gYmF0Y2hTaXplO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYmlnTWFwVmFsdWVzLnNldChrZXlzW2ldLCByZXN1bHRzW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBiaWdNYXBWYWx1ZXM7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCbG9ja0ZvclJlcXVlc3Qoa2V5cywgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlzLmxlbmd0aCA9PT0gMSB8fCB0eXBlb2YgYmxvY2sgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICAgICAgICAgPyBibG9ja1xuICAgICAgICAgICAgICAgIDogeWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRCbG9ja0xldmVsKCdoZWFkJyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCaWdNYXBWYWx1ZU9yVW5kZWZpbmVkKGtleVRvRW5jb2RlLCBpZCwgc2NoZW1hLCBsZXZlbCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5nZXRCaWdNYXBLZXlCeUlEKGlkLCBrZXlUb0VuY29kZSwgc2NoZW1hLCBsZXZlbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXggaW5zdGFuY2VvZiBIdHRwUmVzcG9uc2VFcnJvciAmJiBleC5zdGF0dXMgPT09IFNUQVRVU19DT0RFLk5PVF9GT1VORCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBleDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYSB3ZWxsIGZvcm1hdHRlZCBqc29uIG9iamVjdCBvZiBhIHNhcGxpbmcgc3RhdGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBpZCBTYXBsaW5nIHN0YXRlIElEXG4gICAgICogQHBhcmFtIGJsb2NrIG9wdGlvbmFsIGJsb2NrIGxldmVsIHRvIGZldGNoIHRoZSB2YWx1ZSBmcm9tXG4gICAgICpcbiAgICAgKi9cbiAgICBnZXRTYXBsaW5nRGlmZkJ5SUQoaWQsIGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBzYXBsaW5nU3RhdGUgPSBibG9ja1xuICAgICAgICAgICAgICAgID8geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXRTYXBsaW5nRGlmZkJ5SWQoeyBpZDogaWQudG9TdHJpbmcoKSB9LCBibG9jaylcbiAgICAgICAgICAgICAgICA6IHlpZWxkIHRoaXMuY29udGV4dC5yZWFkUHJvdmlkZXIuZ2V0U2FwbGluZ0RpZmZCeUlkKHsgaWQ6IGlkLnRvU3RyaW5nKCkgfSwgJ2hlYWQnKTtcbiAgICAgICAgICAgIHJldHVybiBzYXBsaW5nU3RhdGU7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBPcmlnaW5hdGUgYSBuZXcgY29udHJhY3QgYWNjb3JkaW5nIHRvIHRoZSBzY3JpcHQgaW4gcGFyYW1ldGVycy4gV2lsbCBzaWduIGFuZCBpbmplY3QgYW4gb3BlcmF0aW9uIHVzaW5nIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9wZXJhdGlvbiBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IGZyb20gdGhlIHJwYyBub2RlXG4gICAgICpcbiAgICAgKiBAd2FybiBZb3UgY2Fubm90IHNwZWNpZnkgc3RvcmFnZSBhbmQgaW5pdCBhdCB0aGUgc2FtZSB0aW1lICh1c2UgaW5pdCB0byBwYXNzIHRoZSByYXcgbWljaGVsc29uIHJlcHJlc2VudGF0aW9uIG9mIHN0b3JhZ2UpXG4gICAgICpcbiAgICAgKiBAcGFyYW0gT3JpZ2luYXRpb25PcGVyYXRpb24gT3JpZ2luYXRlIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBvcmlnaW5hdGUocGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHlpZWxkIHRoaXMuZXN0aW1hdGUocGFyYW1zLCB0aGlzLmVzdGltYXRvci5vcmlnaW5hdGUuYmluZCh0aGlzLmVzdGltYXRvcikpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWRPcmlnaW5hdGlvbiA9IHlpZWxkIHRoaXMucHJlcGFyZS5vcmlnaW5hdGUoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCBlc3RpbWF0ZSkpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHByZXBhcmVkT3JpZ2luYXRpb24ub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLk9SSUdJTkFUSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcmdlZE9yaWdpbmF0aW9uID0geWllbGQgdGhpcy5mb3JnZShwcmVwYXJlZE9yaWdpbmF0aW9uKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzaCwgY29udGV4dCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UgfSA9IHlpZWxkIHRoaXMuc2lnbkFuZEluamVjdChmb3JnZWRPcmlnaW5hdGlvbik7XG4gICAgICAgICAgICByZXR1cm4gbmV3IE9yaWdpbmF0aW9uT3BlcmF0aW9uKGhhc2gsIGNvbnRlbnQsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlLCBjb250ZXh0LCB0aGlzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldCB0aGUgZGVsZWdhdGUgZm9yIGEgY29udHJhY3QuIFdpbGwgc2lnbiBhbmQgaW5qZWN0IGFuIG9wZXJhdGlvbiB1c2luZyB0aGUgY3VycmVudCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvcGVyYXRpb24gaGFuZGxlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBycGMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIFNldERlbGVnYXRlIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBzZXREZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3Qgc291cmNlVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcyhwYXJhbXMuc291cmNlKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlICYmIHNvdXJjZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuc291cmNlLCBpbnZhbGlkRGV0YWlsKHNvdXJjZVZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGRlbGVnYXRlVmFsaWRhdGlvbiA9IHZhbGlkYXRlQWRkcmVzcygoX2EgPSBwYXJhbXMuZGVsZWdhdGUpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuZGVsZWdhdGUgJiYgZGVsZWdhdGVWYWxpZGF0aW9uICE9PSBWYWxpZGF0aW9uUmVzdWx0LlZBTElEKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBZGRyZXNzRXJyb3IocGFyYW1zLmRlbGVnYXRlLCBpbnZhbGlkRGV0YWlsKGRlbGVnYXRlVmFsaWRhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU2luY2UgYmFieWxvbiBkZWxlZ2F0aW9uIHNvdXJjZSBjYW5ub3Qgc21hcnQgY29udHJhY3RcbiAgICAgICAgICAgIGlmICgva3QxL2kudGVzdChwYXJhbXMuc291cmNlKSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkRGVsZWdhdGlvblNvdXJjZShwYXJhbXMuc291cmNlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUhhc2ggPSB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VPckRlZmF1bHQgPSBwYXJhbXMuc291cmNlIHx8IHB1YmxpY0tleUhhc2g7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHlpZWxkIHRoaXMuZXN0aW1hdGUocGFyYW1zLCB0aGlzLmVzdGltYXRvci5zZXREZWxlZ2F0ZS5iaW5kKHRoaXMuZXN0aW1hdG9yKSk7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZERlbGVnYXRpb24gPSB5aWVsZCB0aGlzLnByZXBhcmUuZGVsZWdhdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIGVzdGltYXRlKSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWREZWxlZ2F0aW9uLm9wT2IuY29udGVudHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09IE9wS2luZC5ERUxFR0FUSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IG9wQnl0ZXMgPSB5aWVsZCB0aGlzLmZvcmdlKHByZXBhcmVkRGVsZWdhdGlvbik7XG4gICAgICAgICAgICBjb25zdCB7IGhhc2gsIGNvbnRleHQsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlIH0gPSB5aWVsZCB0aGlzLnNpZ25BbmRJbmplY3Qob3BCeXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERlbGVnYXRlT3BlcmF0aW9uKGhhc2gsIGNvbnRlbnQsIHNvdXJjZU9yRGVmYXVsdCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgdGhlIGN1cnJlbnQgYWRkcmVzcyBhcyBkZWxlZ2F0ZS4gV2lsbCBzaWduIGFuZCBpbmplY3QgYW4gb3BlcmF0aW9uIHVzaW5nIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9wZXJhdGlvbiBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IGZyb20gdGhlIHJwYyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUmVnaXN0ZXJEZWxlZ2F0ZSBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgcmVnaXN0ZXJEZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0geWllbGQgdGhpcy5lc3RpbWF0ZShwYXJhbXMsIHRoaXMuZXN0aW1hdG9yLnJlZ2lzdGVyRGVsZWdhdGUuYmluZCh0aGlzLmVzdGltYXRvcikpO1xuICAgICAgICAgICAgY29uc3Qgc291cmNlID0geWllbGQgdGhpcy5zaWduZXIucHVibGljS2V5SGFzaCgpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWQgPSB5aWVsZCB0aGlzLnByZXBhcmUucmVnaXN0ZXJEZWxlZ2F0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIGVzdGltYXRlKSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWQub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLkRFTEVHQVRJT04pO1xuICAgICAgICAgICAgY29uc3Qgb3BCeXRlcyA9IHlpZWxkIHRoaXMuZm9yZ2UocHJlcGFyZWQpO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoLCBjb250ZXh0LCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSB9ID0geWllbGQgdGhpcy5zaWduQW5kSW5qZWN0KG9wQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEZWxlZ2F0ZU9wZXJhdGlvbihoYXNoLCBjb250ZW50LCBzb3VyY2UsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFRyYW5zZmVyIHR6IGZyb20gY3VycmVudCBhZGRyZXNzIHRvIGEgc3BlY2lmaWMgYWRkcmVzcy4gV2lsbCBzaWduIGFuZCBpbmplY3QgYW4gb3BlcmF0aW9uIHVzaW5nIHRoZSBjdXJyZW50IGNvbnRleHRcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9wZXJhdGlvbiBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IGZyb20gdGhlIHJwYyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gVHJhbnNmZXIgb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIHRyYW5zZmVyKHBhcmFtcykge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0b1ZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MocGFyYW1zLnRvKTtcbiAgICAgICAgICAgIGlmICh0b1ZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMudG8sIGludmFsaWREZXRhaWwodG9WYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VWYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKChfYSA9IHBhcmFtcy5zb3VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlICYmIHNvdXJjZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuc291cmNlLCBpbnZhbGlkRGV0YWlsKHNvdXJjZVZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMuYW1vdW50IDwgMCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQW1vdW50RXJyb3IocGFyYW1zLmFtb3VudC50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUhhc2ggPSB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHlpZWxkIHRoaXMuZXN0aW1hdGUocGFyYW1zLCB0aGlzLmVzdGltYXRvci50cmFuc2Zlci5iaW5kKHRoaXMuZXN0aW1hdG9yKSk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSBwYXJhbXMuc291cmNlIHx8IHB1YmxpY0tleUhhc2g7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZCA9IHlpZWxkIHRoaXMucHJlcGFyZS50cmFuc2FjdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIGVzdGltYXRlKSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWQub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLlRSQU5TQUNUSU9OKTtcbiAgICAgICAgICAgIGNvbnN0IG9wQnl0ZXMgPSB5aWVsZCB0aGlzLmZvcmdlKHByZXBhcmVkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzaCwgY29udGV4dCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UgfSA9IHlpZWxkIHRoaXMuc2lnbkFuZEluamVjdChvcEJ5dGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVHJhbnNhY3Rpb25PcGVyYXRpb24oaGFzaCwgY29udGVudCwgc291cmNlLCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBUcmFuc2ZlciBUaWNrZXRzIHRvIGEgc21hcnQgY29udHJhY3QgYWRkcmVzc1xuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gb3BlcmF0aW9uIGhhbmRsZSB3aXRoIHRoZSByZXN1bHQgZnJvbSB0aGUgcnBjIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBUcmFuc2ZlclRpY2tldFBhcmFtcyBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgdHJhbnNmZXJUaWNrZXQocGFyYW1zKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBkZXN0aW5hdGlvblZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MocGFyYW1zLmRlc3RpbmF0aW9uKTtcbiAgICAgICAgICAgIGlmIChkZXN0aW5hdGlvblZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuZGVzdGluYXRpb24sIGludmFsaWREZXRhaWwoZGVzdGluYXRpb25WYWxpZGF0aW9uKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VWYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKChfYSA9IHBhcmFtcy5zb3VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlICYmIHNvdXJjZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuc291cmNlLCBpbnZhbGlkRGV0YWlsKHNvdXJjZVZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUhhc2ggPSB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2UgPSAoX2IgPSBwYXJhbXMuc291cmNlKSAhPT0gbnVsbCAmJiBfYiAhPT0gdm9pZCAwID8gX2IgOiBwdWJsaWNLZXlIYXNoO1xuICAgICAgICAgICAgY29uc3QgZXN0aW1hdGUgPSB5aWVsZCB0aGlzLmVzdGltYXRlKHBhcmFtcywgdGhpcy5lc3RpbWF0b3IudHJhbnNmZXJUaWNrZXQuYmluZCh0aGlzLmVzdGltYXRvcikpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWQgPSB5aWVsZCB0aGlzLnByZXBhcmUudHJhbnNmZXJUaWNrZXQoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCBlc3RpbWF0ZSkpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHByZXBhcmVkLm9wT2IuY29udGVudHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09IE9wS2luZC5UUkFOU0ZFUl9USUNLRVQpO1xuICAgICAgICAgICAgY29uc3Qgb3BCeXRlcyA9IHlpZWxkIHRoaXMuZm9yZ2UocHJlcGFyZWQpO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoLCBjb250ZXh0LCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSB9ID0geWllbGQgdGhpcy5zaWduQW5kSW5qZWN0KG9wQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBUcmFuc2ZlclRpY2tldE9wZXJhdGlvbihoYXNoLCBjb250ZW50LCBzb3VyY2UsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFJldmVhbCB0aGUgY3VycmVudCBhZGRyZXNzLiBXaWxsIHRocm93IGFuIGVycm9yIGlmIHRoZSBhZGRyZXNzIGlzIGFscmVhZHkgcmV2ZWFsZWQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvcGVyYXRpb24gaGFuZGxlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBycGMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIFJldmVhbFBhcmFtcyBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgcmV2ZWFsKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SGFzaCA9IHlpZWxkIHRoaXMuc2lnbmVyLnB1YmxpY0tleUhhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlUmV2ZWFsID0geWllbGQgdGhpcy5lc3RpbWF0b3IucmV2ZWFsKHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoZXN0aW1hdGVSZXZlYWwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBlc3RpbWF0ZWQgPSB5aWVsZCB0aGlzLmVzdGltYXRlKHBhcmFtcywgKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkgeyByZXR1cm4gZXN0aW1hdGVSZXZlYWw7IH0pKTtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmVwYXJlZCA9IHlpZWxkIHRoaXMucHJlcGFyZS5yZXZlYWwoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCBlc3RpbWF0ZWQpKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWQub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLlJFVkVBTCk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb3BCeXRlcyA9IHlpZWxkIHRoaXMuZm9yZ2UocHJlcGFyZWQpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgaGFzaCwgY29udGV4dCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UgfSA9IHlpZWxkIHRoaXMuc2lnbkFuZEluamVjdChvcEJ5dGVzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJldmVhbE9wZXJhdGlvbihoYXNoLCBjb250ZW50LCBwdWJsaWNLZXlIYXNoLCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmV2ZWFsT3BlcmF0aW9uRXJyb3IoYFRoZSBwdWJsaWNLZXlIYXNoICcke3B1YmxpY0tleUhhc2h9JyBoYXMgYWxyZWFkeSBiZWVuIHJldmVhbGVkLmApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmVnaXN0ZXIgYSBNaWNoZWxpbmUgZXhwcmVzc2lvbiBpbiBhIGdsb2JhbCB0YWJsZSBvZiBjb25zdGFudHMuIFdpbGwgc2lnbiBhbmQgaW5qZWN0IGFuIG9wZXJhdGlvbiB1c2luZyB0aGUgY3VycmVudCBjb250ZXh0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvcGVyYXRpb24gaGFuZGxlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBycGMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyByZWdpc3Rlckdsb2JhbENvbnN0YW50IG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICByZWdpc3Rlckdsb2JhbENvbnN0YW50KHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SGFzaCA9IHlpZWxkIHRoaXMuc2lnbmVyLnB1YmxpY0tleUhhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0geWllbGQgdGhpcy5lc3RpbWF0ZShwYXJhbXMsIHRoaXMuZXN0aW1hdG9yLnJlZ2lzdGVyR2xvYmFsQ29uc3RhbnQuYmluZCh0aGlzLmVzdGltYXRvcikpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWQgPSB5aWVsZCB0aGlzLnByZXBhcmUucmVnaXN0ZXJHbG9iYWxDb25zdGFudChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIGVzdGltYXRlKSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWQub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLlJFR0lTVEVSX0dMT0JBTF9DT05TVEFOVCk7XG4gICAgICAgICAgICBjb25zdCBvcEJ5dGVzID0geWllbGQgdGhpcy5mb3JnZShwcmVwYXJlZCk7XG4gICAgICAgICAgICBjb25zdCB7IGhhc2gsIGNvbnRleHQsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlIH0gPSB5aWVsZCB0aGlzLnNpZ25BbmRJbmplY3Qob3BCeXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFJlZ2lzdGVyR2xvYmFsQ29uc3RhbnRPcGVyYXRpb24oaGFzaCwgY29udGVudCwgcHVibGljS2V5SGFzaCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5jcmVhc2UgdGhlIHBhaWQgc3RvcmFnZSBvZiBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvcGVyYXRpb24gaGFuZGxlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBycGMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIHBhcmFtcyBpbmNyZWFzZVBhaWRTdG9yYWdlIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBpbmNyZWFzZVBhaWRTdG9yYWdlKHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5hbW91bnQgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRBbW91bnRFcnJvcihwYXJhbXMuYW1vdW50LnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SGFzaCA9IHlpZWxkIHRoaXMuc2lnbmVyLnB1YmxpY0tleUhhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IGVzdGltYXRlID0geWllbGQgdGhpcy5lc3RpbWF0ZShwYXJhbXMsIHRoaXMuZXN0aW1hdG9yLmluY3JlYXNlUGFpZFN0b3JhZ2UuYmluZCh0aGlzLmVzdGltYXRvcikpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWQgPSB5aWVsZCB0aGlzLnByZXBhcmUuaW5jcmVhc2VQYWlkU3RvcmFnZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIGVzdGltYXRlKSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWQub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLklOQ1JFQVNFX1BBSURfU1RPUkFHRSk7XG4gICAgICAgICAgICBjb25zdCBvcEJ5dGVzID0geWllbGQgdGhpcy5mb3JnZShwcmVwYXJlZCk7XG4gICAgICAgICAgICBjb25zdCB7IGhhc2gsIGNvbnRleHQsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlIH0gPSB5aWVsZCB0aGlzLnNpZ25BbmRJbmplY3Qob3BCeXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEluY3JlYXNlUGFpZFN0b3JhZ2VPcGVyYXRpb24oaGFzaCwgY29udGVudCwgcHVibGljS2V5SGFzaCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gVHJhbnNmZXJzIHRoZSBzcGVuZGFibGUgYmFsYW5jZSBvZiB0aGUgZGVsZWdhdGUgdG8gZGVzdGluYXRpb24gd2hlbiBjb25zZW5zdXNfa2V5IGlzIHRoZSBhY3RpdmUgY29uc2Vuc3VzIGtleSBvZiBkZWxlZ2F0ZVxuICAgICAqXG4gICAgICogQHJldHVybnMgQW4gb3BlcmF0aW9uIGhhbmRsZSB3aXRoIHRoZSByZXN1bHQgZnJvbSB0aGUgcnBjIG5vZGVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJhbXMgZHJhaW5EZWxlZ2F0ZSBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgZHJhaW5EZWxlZ2F0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkID0geWllbGQgdGhpcy5wcmVwYXJlLmRyYWluRGVsZWdhdGUocGFyYW1zKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVwYXJlZC5vcE9iLmNvbnRlbnRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSBPcEtpbmQuRFJBSU5fREVMRUdBVEUpO1xuICAgICAgICAgICAgY29uc3Qgb3BCeXRlcyA9IHlpZWxkIHRoaXMuZm9yZ2UocHJlcGFyZWQpO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoLCBjb250ZXh0LCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSB9ID0geWllbGQgdGhpcy5zaWduQW5kSW5qZWN0KG9wQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEcmFpbkRlbGVnYXRlT3BlcmF0aW9uKGhhc2gsIGNvbnRlbnQsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFN1Ym1pdCBhIGJhbGxvdCB2b3RlIHRvIGEgc3BlY2lmaWVkIHByb3Bvc2FsXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvcGVyYXRpb24gaGFuZGxlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBycGMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIEJhbGxvdFBhcmFtcyBCYWxsb3Qgb3BlcmF0aW9uIHBhcmFtZXRlclxuICAgICAqL1xuICAgIGJhbGxvdChwYXJhbXMpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUhhc2ggPSB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBzb3VyY2VWYWxpZGF0aW9uID0gdmFsaWRhdGVBZGRyZXNzKChfYSA9IHBhcmFtcy5zb3VyY2UpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6ICcnKTtcbiAgICAgICAgICAgIGlmIChwYXJhbXMuc291cmNlICYmIHNvdXJjZVZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFkZHJlc3NFcnJvcihwYXJhbXMuc291cmNlLCBpbnZhbGlkRGV0YWlsKHNvdXJjZVZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZSA9IChfYiA9IHBhcmFtcy5zb3VyY2UpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IHB1YmxpY0tleUhhc2g7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZCA9IHlpZWxkIHRoaXMucHJlcGFyZS5iYWxsb3QoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCB7IHNvdXJjZSB9KSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWQub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLkJBTExPVCk7XG4gICAgICAgICAgICBjb25zdCBvcEJ5dGVzID0geWllbGQgdGhpcy5mb3JnZShwcmVwYXJlZCk7XG4gICAgICAgICAgICBjb25zdCB7IGhhc2gsIGNvbnRleHQsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlIH0gPSB5aWVsZCB0aGlzLnNpZ25BbmRJbmplY3Qob3BCeXRlcyk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEJhbGxvdE9wZXJhdGlvbihoYXNoLCBjb250ZW50LCBwdWJsaWNLZXlIYXNoLCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTdWJtaXQgb3IgdXB2b3RlIGEgcHJvcG9zYWwgZHVyaW5nIHRoZSBQcm9wb3NhbCBwZXJpb2RcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIEFuIG9wZXJhdGlvbiBoYW5kbGUgd2l0aCB0aGUgcmVzdWx0IGZyb20gdGhlIHJwYyBub2RlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gUHJvcG9zYWxzUGFyYW1zIFByb3Bvc2FscyBvcGVyYXRpb24gcGFyYW1ldGVyXG4gICAgICovXG4gICAgcHJvcG9zYWxzKHBhcmFtcykge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHVibGljS2V5SGFzaCA9IHlpZWxkIHRoaXMuc2lnbmVyLnB1YmxpY0tleUhhc2goKTtcbiAgICAgICAgICAgIGNvbnN0IHNvdXJjZVZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MoKF9hID0gcGFyYW1zLnNvdXJjZSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogJycpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5zb3VyY2UgJiYgc291cmNlVmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQWRkcmVzc0Vycm9yKHBhcmFtcy5zb3VyY2UsIGludmFsaWREZXRhaWwoc291cmNlVmFsaWRhdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgc291cmNlID0gKF9iID0gcGFyYW1zLnNvdXJjZSkgIT09IG51bGwgJiYgX2IgIT09IHZvaWQgMCA/IF9iIDogcHVibGljS2V5SGFzaDtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkID0geWllbGQgdGhpcy5wcmVwYXJlLnByb3Bvc2FscyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIHsgc291cmNlIH0pKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVwYXJlZC5vcE9iLmNvbnRlbnRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSBPcEtpbmQuUFJPUE9TQUxTKTtcbiAgICAgICAgICAgIGNvbnN0IG9wQnl0ZXMgPSB5aWVsZCB0aGlzLmZvcmdlKHByZXBhcmVkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzaCwgY29udGV4dCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UgfSA9IHlpZWxkIHRoaXMuc2lnbkFuZEluamVjdChvcEJ5dGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvcG9zYWxzT3BlcmF0aW9uKGhhc2gsIGNvbnRlbnQsIHB1YmxpY0tleUhhc2gsIGZvcmdlZEJ5dGVzLCBvcFJlc3BvbnNlLCBjb250ZXh0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqXG4gICAgICogQGRlc2NyaXB0aW9uIFVwZGF0ZXMgdGhlIGNvbnNlbnN1cyBrZXkgb2YgdGhlIGJha2VyIHRvIHB1YmxpY19rZXkgc3RhcnRpbmcgZnJvbSB0aGUgY3VycmVudCBjeWNsZSBwbHVzIFBSRVNFUlZFRF9DWUNMRVMgKyAxXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBbiBvcGVyYXRpb24gaGFuZGxlIHdpdGggdGhlIHJlc3VsdCBmcm9tIHRoZSBycGMgbm9kZVxuICAgICAqXG4gICAgICogQHBhcmFtIFVwZGF0ZUNvbnNlbnN1c0tleVBhcmFtc1xuICAgICAqL1xuICAgIHVwZGF0ZUNvbnNlbnN1c0tleShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUhhc2ggPSB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHlpZWxkIHRoaXMuZXN0aW1hdGUocGFyYW1zLCB0aGlzLmVzdGltYXRvci51cGRhdGVDb25zZW5zdXNLZXkuYmluZCh0aGlzLmVzdGltYXRvcikpO1xuICAgICAgICAgICAgY29uc3QgcHJlcGFyZWQgPSB5aWVsZCB0aGlzLnByZXBhcmUudXBkYXRlQ29uc2Vuc3VzS2V5KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgcGFyYW1zKSwgZXN0aW1hdGUpKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBwcmVwYXJlZC5vcE9iLmNvbnRlbnRzLmZpbmQoKG9wKSA9PiBvcC5raW5kID09PSBPcEtpbmQuVVBEQVRFX0NPTlNFTlNVU19LRVkpO1xuICAgICAgICAgICAgY29uc3Qgb3BCeXRlcyA9IHlpZWxkIHRoaXMuZm9yZ2UocHJlcGFyZWQpO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoLCBjb250ZXh0LCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSB9ID0geWllbGQgdGhpcy5zaWduQW5kSW5qZWN0KG9wQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVcGRhdGVDb25zZW5zdXNLZXlPcGVyYXRpb24oaGFzaCwgY29udGVudCwgcHVibGljS2V5SGFzaCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UsIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEFkZHMgbWVzc2FnZXMgdG8gdGhlIHJvbGx1cCBpbmJveCB0aGF0IGNhbiBiZSBleGVjdXRlZC9jbGFpbWVkIGFmdGVyIGl0IGdldHMgY2VtZW50ZWRcbiAgICAgKiBAcGFyYW0gU21hcnRSb2xsdXBBZGRNZXNzYWdlc1BhcmFtc1xuICAgICAqIEByZXR1cm5zIEFuIG9wZXJhdGlvbiBoYW5kbGUgd2l0aCByZXN1bHRzIGZyb20gdGhlIFJQQyBub2RlXG4gICAgICovXG4gICAgc21hcnRSb2xsdXBBZGRNZXNzYWdlcyhwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUhhc2ggPSB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHlpZWxkIHRoaXMuZXN0aW1hdGUocGFyYW1zLCB0aGlzLmVzdGltYXRvci5zbWFydFJvbGx1cEFkZE1lc3NhZ2VzLmJpbmQodGhpcy5lc3RpbWF0b3IpKTtcbiAgICAgICAgICAgIGNvbnN0IHByZXBhcmVkID0geWllbGQgdGhpcy5wcmVwYXJlLnNtYXJ0Um9sbHVwQWRkTWVzc2FnZXMoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBwYXJhbXMpLCBlc3RpbWF0ZSkpO1xuICAgICAgICAgICAgY29uc3QgY29udGVudCA9IHByZXBhcmVkLm9wT2IuY29udGVudHMuZmluZCgob3ApID0+IG9wLmtpbmQgPT09IE9wS2luZC5TTUFSVF9ST0xMVVBfQUREX01FU1NBR0VTKTtcbiAgICAgICAgICAgIGNvbnN0IG9wQnl0ZXMgPSB5aWVsZCB0aGlzLmZvcmdlKHByZXBhcmVkKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaGFzaCwgY29udGV4dCwgZm9yZ2VkQnl0ZXMsIG9wUmVzcG9uc2UgfSA9IHlpZWxkIHRoaXMuc2lnbkFuZEluamVjdChvcEJ5dGVzKTtcbiAgICAgICAgICAgIHJldHVybiBuZXcgU21hcnRSb2xsdXBBZGRNZXNzYWdlc09wZXJhdGlvbihoYXNoLCBjb250ZW50LCBwdWJsaWNLZXlIYXNoLCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlcyBhIHNtYXJ0IHJvbGx1cCBvcmlnaW5hdGUgb3BlcmF0aW9uXG4gICAgICogQHBhcmFtIFNtYXJ0Um9sbHVwT3JpZ2luYXRlUGFyYW1zXG4gICAgICogQHJldHVybnMgQW4gb3BlcmF0aW9uIGhhbmRsZSB3aXRoIHJlc3VsdHMgZnJvbSB0aGUgUlBDIG5vZGVcbiAgICAgKi9cbiAgICBzbWFydFJvbGx1cE9yaWdpbmF0ZShwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHB1YmxpY0tleUhhc2ggPSB5aWVsZCB0aGlzLnNpZ25lci5wdWJsaWNLZXlIYXNoKCk7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHlpZWxkIHRoaXMuZXN0aW1hdGUocGFyYW1zLCB0aGlzLmVzdGltYXRvci5zbWFydFJvbGx1cE9yaWdpbmF0ZS5iaW5kKHRoaXMuZXN0aW1hdG9yKSk7XG4gICAgICAgICAgICBjb25zdCBwcmVwYXJlZCA9IHlpZWxkIHRoaXMucHJlcGFyZS5zbWFydFJvbGx1cE9yaWdpbmF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcyksIGVzdGltYXRlKSk7XG4gICAgICAgICAgICBjb25zdCBjb250ZW50ID0gcHJlcGFyZWQub3BPYi5jb250ZW50cy5maW5kKChvcCkgPT4gb3Aua2luZCA9PT0gT3BLaW5kLlNNQVJUX1JPTExVUF9PUklHSU5BVEUpO1xuICAgICAgICAgICAgY29uc3Qgb3BCeXRlcyA9IHlpZWxkIHRoaXMuZm9yZ2UocHJlcGFyZWQpO1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoLCBjb250ZXh0LCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSB9ID0geWllbGQgdGhpcy5zaWduQW5kSW5qZWN0KG9wQnl0ZXMpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBTbWFydFJvbGx1cE9yaWdpbmF0ZU9wZXJhdGlvbihoYXNoLCBjb250ZW50LCBwdWJsaWNLZXlIYXNoLCBmb3JnZWRCeXRlcywgb3BSZXNwb25zZSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBIGZhaWxpbmdfbm9vcCBvcGVyYXRpb24gdGhhdCBpcyBndWFyYW50ZWVkIHRvIGZhaWwuXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyBBIEZhaWxpbmdOb29wT3BlcmF0aW9uIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIHNpZ25lZCBmYWlsaW5nX25vb3Agb3BlcmF0aW9uXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIGZhaWxpbmdOb29wIG9wZXJhdGlvbiBwYXJhbWV0ZXJcbiAgICAgKi9cbiAgICBmYWlsaW5nTm9vcChwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IE9wS2luZC5GQUlMSU5HX05PT1AsXG4gICAgICAgICAgICAgICAgYXJiaXRyYXJ5OiBwYXJhbXMuYXJiaXRyYXJ5LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldEJsb2NrSGFzaChwYXJhbXMuYmFzZWRPbkJsb2NrKTtcbiAgICAgICAgICAgIGNvbnN0IGZvcmdlZCA9IHlpZWxkIHRoaXMuY29udGV4dC5mb3JnZXIuZm9yZ2Uoe1xuICAgICAgICAgICAgICAgIGJyYW5jaDogaGFzaCxcbiAgICAgICAgICAgICAgICBjb250ZW50czogW29wXSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgeyBwcmVmaXhTaWcgfSA9IHlpZWxkIHRoaXMuc2lnbmVyLnNpZ24oZm9yZ2VkLCBuZXcgVWludDhBcnJheShbM10pKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgc2lnbmF0dXJlOiBwcmVmaXhTaWcsXG4gICAgICAgICAgICAgICAgYnl0ZXM6IGZvcmdlZCxcbiAgICAgICAgICAgICAgICBzaWduZWRDb250ZW50OiB7XG4gICAgICAgICAgICAgICAgICAgIGJyYW5jaDogaGFzaCxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudHM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBraW5kOiBPcEtpbmQuRkFJTElOR19OT09QLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyYml0cmFyeTogcGFyYW1zLmFyYml0cmFyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBDcmVhdGUgYW4gc21hcnQgY29udHJhY3QgYWJzdHJhY3Rpb24gZm9yIHRoZSBhZGRyZXNzIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhZGRyZXNzIFNtYXJ0IGNvbnRyYWN0IGFkZHJlc3NcbiAgICAgKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3J9XG4gICAgICovXG4gICAgYXQoYWRkcmVzcywgY29udHJhY3RBYnN0cmFjdGlvbkNvbXBvc2VyID0gKHgpID0+IHgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3NWYWxpZGF0aW9uID0gdmFsaWRhdGVDb250cmFjdEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgICAgICBpZiAoYWRkcmVzc1ZhbGlkYXRpb24gIT09IFZhbGlkYXRpb25SZXN1bHQuVkFMSUQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvbnRyYWN0QWRkcmVzc0Vycm9yKGFkZHJlc3MsIGludmFsaWREZXRhaWwoYWRkcmVzc1ZhbGlkYXRpb24pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJwYyA9IHRoaXMuY29udGV4dC53aXRoRXh0ZW5zaW9ucygpLnJwYztcbiAgICAgICAgICAgIGNvbnN0IHJlYWRQcm92aWRlciA9IHRoaXMuY29udGV4dC53aXRoRXh0ZW5zaW9ucygpLnJlYWRQcm92aWRlcjtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IHlpZWxkIHJlYWRQcm92aWRlci5nZXRTY3JpcHQoYWRkcmVzcywgJ2hlYWQnKTtcbiAgICAgICAgICAgIGNvbnN0IGVudHJ5cG9pbnRzID0geWllbGQgcmVhZFByb3ZpZGVyLmdldEVudHJ5cG9pbnRzKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgYWJzID0gbmV3IENvbnRyYWN0QWJzdHJhY3Rpb24oYWRkcmVzcywgc2NyaXB0LCB0aGlzLCB0aGlzLCBlbnRyeXBvaW50cywgcnBjLCByZWFkUHJvdmlkZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0QWJzdHJhY3Rpb25Db21wb3NlcihhYnMsIHRoaXMuY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBkZXNjcmlwdGlvbiBCYXRjaCBhIGdyb3VwIG9mIG9wZXJhdGlvbiB0b2dldGhlci4gT3BlcmF0aW9ucyB3aWxsIGJlIGFwcGxpZWQgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXJlIGFkZGVkIHRvIHRoZSBiYXRjaFxuICAgICAqXG4gICAgICogQHJldHVybnMgQSBiYXRjaCBvYmplY3QgZnJvbSB3aGljaCB3ZSBjYW4gYWRkIG1vcmUgb3BlcmF0aW9uIG9yIHNlbmQgYSBjb21tYW5kIHRvIGV4ZWN1dGUgdGhlIGJhdGNoXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyYW1zIExpc3Qgb2Ygb3BlcmF0aW9uIHRvIGJhdGNoIHRvZ2V0aGVyXG4gICAgICovXG4gICAgYmF0Y2gocGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGJhdGNoID0gbmV3IE9wZXJhdGlvbkJhdGNoKHRoaXMuY29udGV4dCwgdGhpcy5lc3RpbWF0b3IpO1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJhbXMpKSB7XG4gICAgICAgICAgICBiYXRjaC53aXRoKHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJhdGNoO1xuICAgIH1cbn1cblxuY2xhc3MgTWljaGVsQ29kZWNQYXJzZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICB9XG4gICAgZ2V0TmV4dFByb3RvKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQucHJvdG8pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0UHJvdG8gPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldE5leHRQcm90b2NvbCgnaGVhZCcpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGV4dC5wcm90byA9IG5leHRQcm90bztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbnRleHQucHJvdG87XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZVNjcmlwdChzcmMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoeyBwcm90b2NvbDogeWllbGQgdGhpcy5nZXROZXh0UHJvdG8oKSB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VTY3JpcHQoc3JjKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlTWljaGVsaW5lRXhwcmVzc2lvbihzcmMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBQYXJzZXIoeyBwcm90b2NvbDogeWllbGQgdGhpcy5nZXROZXh0UHJvdG8oKSB9KTtcbiAgICAgICAgICAgIHJldHVybiBwYXJzZXIucGFyc2VNaWNoZWxpbmVFeHByZXNzaW9uKHNyYyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZUpTT04oc3JjKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgUGFyc2VyKHsgcHJvdG9jb2w6IHlpZWxkIHRoaXMuZ2V0TmV4dFByb3RvKCkgfSk7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VyLnBhcnNlSlNPTihzcmMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcHJlcGFyZUNvZGVPcmlnaW5hdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZFBhcmFtcyA9IHBhcmFtcztcbiAgICAgICAgICAgIHBhcnNlZFBhcmFtcy5jb2RlID0geWllbGQgdGhpcy5mb3JtYXRDb2RlUGFyYW0ocGFyYW1zLmNvZGUpO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5pbml0KSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkUGFyYW1zLmluaXQgPSB5aWVsZCB0aGlzLmZvcm1hdEluaXRQYXJhbShwYXJhbXMuaW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuc3RvcmFnZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0b3JhZ2VUeXBlID0gcGFyc2VkUGFyYW1zLmNvZGUuZmluZCgocCkgPT4gJ3ByaW0nIGluIHAgJiYgcC5wcmltID09PSAnc3RvcmFnZScpO1xuICAgICAgICAgICAgICAgIGlmICghKHN0b3JhZ2VUeXBlID09PSBudWxsIHx8IHN0b3JhZ2VUeXBlID09PSB2b2lkIDAgPyB2b2lkIDAgOiBzdG9yYWdlVHlwZS5hcmdzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgSW52YWxpZENvZGVQYXJhbWV0ZXIoJ1RoZSBzdG9yYWdlIHNlY3Rpb24gaXMgbWlzc2luZyBmcm9tIHRoZSBzY3JpcHQnLCBwYXJhbXMuY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNjaGVtYSA9IG5ldyBTY2hlbWEoc3RvcmFnZVR5cGUuYXJnc1swXSk7XG4gICAgICAgICAgICAgICAgY29uc3QgZ2xvYmFsY29uc3RhbnRzSGFzaEFuZFZhbHVlID0geWllbGQgdGhpcy5maW5kR2xvYmFsQ29uc3RhbnRzSGFzaEFuZFZhbHVlKHNjaGVtYSk7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKGdsb2JhbGNvbnN0YW50c0hhc2hBbmRWYWx1ZSkubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBnbG9iYWwgY29uc3RhbnRzIGluIHRoZSBzdG9yYWdlIHBhcnQgb2YgdGhlIGNvbnRyYWN0IGNvZGUsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXkgbmVlZCB0byBiZSBsb2NhbGx5IGV4cGFuZGVkIGluIG9yZGVyIHRvIGVuY29kZSB0aGUgc3RvcmFnZSBhcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5ldyBQYXJzZXIoeyBleHBhbmRHbG9iYWxDb25zdGFudDogZ2xvYmFsY29uc3RhbnRzSGFzaEFuZFZhbHVlIH0pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzdG9yYWdlVHlwZU5vR2xvYmFsQ29uc3QgPSBwLnBhcnNlSlNPTihzdG9yYWdlVHlwZS5hcmdzWzBdKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2NoZW1hTm9HbG9iYWxDb25zdCA9IG5ldyBTY2hlbWEoc3RvcmFnZVR5cGVOb0dsb2JhbENvbnN0KTtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUGFyYW1zLmluaXQgPSBzY2hlbWFOb0dsb2JhbENvbnN0LkVuY29kZShwYXJhbXMuc3RvcmFnZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBwYXJzZWRQYXJhbXMuaW5pdCA9IHNjaGVtYS5FbmNvZGUocGFyYW1zLnN0b3JhZ2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyc2VkUGFyYW1zLnN0b3JhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkUGFyYW1zO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9ybWF0Q29kZVBhcmFtKGNvZGUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBwYXJzZWRDb2RlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSB5aWVsZCB0aGlzLnBhcnNlU2NyaXB0KGNvZGUpO1xuICAgICAgICAgICAgICAgIGlmIChjID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBJbnZhbGlkQ29kZVBhcmFtZXRlcignVW5hYmxlIHRvIHBhcnNlJywgY29kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZENvZGUgPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHlpZWxkIHRoaXMucGFyc2VKU09OKGNvZGUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG9yZGVyID0gWydwYXJhbWV0ZXInLCAnc3RvcmFnZScsICdjb2RlJ107XG4gICAgICAgICAgICAgICAgLy8gRW5zdXJlIGNvcnJlY3Qgb3JkZXJpbmcgZm9yIFJQQ1xuICAgICAgICAgICAgICAgIHBhcnNlZENvZGUgPSBjLnNvcnQoKGEsIGIpID0+IG9yZGVyLmluZGV4T2YoYS5wcmltKSAtIG9yZGVyLmluZGV4T2YoYi5wcmltKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VkQ29kZTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvcm1hdEluaXRQYXJhbShpbml0KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBsZXQgcGFyc2VkSW5pdDtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgaW5pdCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjID0geWllbGQgdGhpcy5wYXJzZU1pY2hlbGluZUV4cHJlc3Npb24oaW5pdCk7XG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEludmFsaWRJbml0UGFyYW1ldGVyKCdJbnZhbGlkIGluaXQgcGFyYW1ldGVyJywgaW5pdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBhcnNlZEluaXQgPSBjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkSW5pdCA9IHlpZWxkIHRoaXMucGFyc2VKU09OKGluaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEluaXQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBmaW5kR2xvYmFsQ29uc3RhbnRzSGFzaEFuZFZhbHVlKHNjaGVtYSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsQ29uc3RhbnRUb2tlbnMgPSBzY2hlbWEuZmluZFRva2VuKCdjb25zdGFudCcpO1xuICAgICAgICAgICAgY29uc3QgZ2xvYmFsQ29uc3RhbnRzSGFzaEFuZFZhbHVlID0ge307XG4gICAgICAgICAgICBpZiAoZ2xvYmFsQ29uc3RhbnRUb2tlbnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgZm9yIChjb25zdCB0b2tlbiBvZiBnbG9iYWxDb25zdGFudFRva2Vucykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0b2tlbkFyZ3MgPSB0b2tlbi50b2tlblZhbC5hcmdzO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW5BcmdzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBleHByZXNzaW9uID0gdG9rZW5BcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4cHJlc3Npb24uc3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaGFzaCA9IGV4cHJlc3Npb24uc3RyaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1pY2hlbGluZVZhbHVlID0geWllbGQgdGhpcy5jb250ZXh0Lmdsb2JhbENvbnN0YW50c1Byb3ZpZGVyLmdldEdsb2JhbENvbnN0YW50QnlIYXNoKGhhc2gpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oZ2xvYmFsQ29uc3RhbnRzSGFzaEFuZFZhbHVlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtoYXNoXTogbWljaGVsaW5lVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZ2xvYmFsQ29uc3RhbnRzSGFzaEFuZFZhbHVlO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFJwY1BhY2tlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBwYWNrRGF0YShkYXRhKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJwYy5wYWNrRGF0YShkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgdGhhdCBhIGdsb2JhbCBjb25zdGFudCBkb2VzIG5vdCBleGlzdFxuICovXG5jbGFzcyBHbG9iYWxDb25zdGFudE5vdEZvdW5kIGV4dGVuZHMgVGFxdWl0b0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihoYXNoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIHRoaXMubmFtZSA9ICdHbG9iYWxDb25zdGFudE5vdEZvdW5kJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYFBsZWFzZSBsb2FkIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggdGhlIGNvbnN0YW50ICR7aGFzaH0gdXNpbmcgdGhlIGxvYWRHbG9iYWxDb25zdGFudCBtZXRob2Qgb2YgdGhlIERlZmF1bHRHbG9iYWxDb25zdGFudHNQcm92aWRlci5gO1xuICAgIH1cbn1cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyB0aGUgZ2xvYmFsIGNvbnN0YW50IHByb3ZpZGVyIG5vdCBiZWluZyBjb25maWd1cmVkIHVuZGVyIFRlem9zVG9vbGtpdFxuICovXG5jbGFzcyBVbmNvbmZpZ3VyZWRHbG9iYWxDb25zdGFudHNQcm92aWRlckVycm9yIGV4dGVuZHMgVGV6b3NUb29sa2l0Q29uZmlnRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnVW5jb25maWd1cmVkR2xvYmFsQ29uc3RhbnRzUHJvdmlkZXJFcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9XG4gICAgICAgICAgICAnTm8gZ2xvYmFsIGNvbnN0YW50cyBwcm92aWRlciBoYXMgYmVlbiBjb25maWd1cmVkLiBQbGVhc2UgY29uZmlndXJlIG9uZSBieSBjYWxsaW5nIHNldEdsb2JhbENvbnN0YW50c1Byb3ZpZGVyKHtnbG9iYWxDb25zdGFudHNQcm92aWRlcn0pIG9uIHlvdXIgVGV6b3NUb29sa2l0IGluc3RhbmNlLic7XG4gICAgfVxufVxuXG5jbGFzcyBOb29wR2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIge1xuICAgIGdldEdsb2JhbENvbnN0YW50QnlIYXNoKF9oYXNoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5jb25maWd1cmVkR2xvYmFsQ29uc3RhbnRzUHJvdmlkZXJFcnJvcigpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbi8qKlxuICogQGRlc2NyaXB0aW9uIENvbnZlcnRzIGNhbGxzIGZyb20gVHpSZWFkUHJvdmlkZXIgaW50byBjYWxscyB0byB0aGUgd3JhcHBlZCBScGNDbGllbnQgaW4gYSBmb3JtYXQgaXQgY2FuIHVuZGVyc3RhbmQuXG4gKi9cbmNsYXNzIFJwY1JlYWRBZGFwdGVyIHtcbiAgICBjb25zdHJ1Y3RvcihycGMpIHtcbiAgICAgICAgdGhpcy5ycGMgPSBycGM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIGJhbGFuY2Ugb2YgYSBjb250cmFjdC5cbiAgICAgKiBAcGFyYW0gYWRkcmVzcyBhZGRyZXNzIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgYmFsYW5jZVxuICAgICAqIEBwYXJhbSBibG9jayBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIGJhbGFuY2VcbiAgICAgKiBAcmV0dXJucyB0aGUgYmFsYW5jZSBpbiBtdXRlelxuICAgICAqL1xuICAgIGdldEJhbGFuY2UoYWRkcmVzcywgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRCYWxhbmNlKGFkZHJlc3MsIHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBkZWxlZ2F0ZSBvZiBhIGNvbnRyYWN0LCBpZiBhbnkuXG4gICAgICogQHBhcmFtIGFkZHJlc3MgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIGRlbGVnYXRlIChiYWtlcilcbiAgICAgKiBAcGFyYW0gYmxvY2sgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBkZWxlZ2F0ZVxuICAgICAqIEByZXR1cm5zIHRoZSBwdWJsaWMga2V5IGhhc2ggb2YgdGhlIGRlbGVnYXRlIG9yIG51bGwgaWYgbm8gZGVsZWdhdGVcbiAgICAgKi9cbiAgICBnZXREZWxlZ2F0ZShhZGRyZXNzLCBibG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldERlbGVnYXRlKGFkZHJlc3MsIHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBuZXh0IHByb3RvY29sIGhhc2hcbiAgICAgKiBAcGFyYW0gYmxvY2sgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBuZXh0IHByb3RvY29sIGhhc2hcbiAgICAgKi9cbiAgICBnZXROZXh0UHJvdG9jb2woYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHByb3RvY29scyA9IHlpZWxkIHRoaXMucnBjLmdldFByb3RvY29scyh7IGJsb2NrOiBTdHJpbmcoYmxvY2spIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHByb3RvY29scy5uZXh0X3Byb3RvY29sO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyBwcm90b2NvbCBjb25zdGFudHMgdXNlZCBpbiBUYXF1aXRvXG4gICAgICogQHBhcmFtIGJsb2NrIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgY29uc3RhbnRzXG4gICAgICovXG4gICAgZ2V0UHJvdG9jb2xDb25zdGFudHMoYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGltZV9iZXR3ZWVuX2Jsb2NrcywgbWluaW1hbF9ibG9ja19kZWxheSwgaGFyZF9nYXNfbGltaXRfcGVyX29wZXJhdGlvbiwgaGFyZF9nYXNfbGltaXRfcGVyX2Jsb2NrLCBoYXJkX3N0b3JhZ2VfbGltaXRfcGVyX29wZXJhdGlvbiwgY29zdF9wZXJfYnl0ZSwgc21hcnRfcm9sbHVwX29yaWdpbmF0aW9uX3NpemUsIH0gPSB5aWVsZCB0aGlzLnJwYy5nZXRDb25zdGFudHMoeyBibG9jazogU3RyaW5nKGJsb2NrKSB9KTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgdGltZV9iZXR3ZWVuX2Jsb2NrcyxcbiAgICAgICAgICAgICAgICBtaW5pbWFsX2Jsb2NrX2RlbGF5LFxuICAgICAgICAgICAgICAgIGhhcmRfZ2FzX2xpbWl0X3Blcl9vcGVyYXRpb24sXG4gICAgICAgICAgICAgICAgaGFyZF9nYXNfbGltaXRfcGVyX2Jsb2NrLFxuICAgICAgICAgICAgICAgIGhhcmRfc3RvcmFnZV9saW1pdF9wZXJfb3BlcmF0aW9uLFxuICAgICAgICAgICAgICAgIGNvc3RfcGVyX2J5dGUsXG4gICAgICAgICAgICAgICAgc21hcnRfcm9sbHVwX29yaWdpbmF0aW9uX3NpemUsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgc2NyaXB0IChjb2RlIGFuZCBzdG9yYWdlKSBvZiBhIHNtYXJ0IGNvbnRyYWN0XG4gICAgICogQHBhcmFtIGNvbnRyYWN0IGNvbnRyYWN0IGFkZHJlc3MgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBzY3JpcHRcbiAgICAgKiBAcGFyYW0gYmxvY2sgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBzdG9yYWdlIHZhbHVlXG4gICAgICogQHJldHVybnMgTm90ZTogVGhlIGNvZGUgbXVzdCBiZSBpbiB0aGUgSlNPTiBmb3JtYXQgYW5kIG5vdCBjb250YWluIGdsb2JhbCBjb25zdGFudFxuICAgICAqL1xuICAgIGdldFNjcmlwdChjb250cmFjdCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgc2NyaXB0IH0gPSB5aWVsZCB0aGlzLnJwYy5nZXRDb250cmFjdChjb250cmFjdCwgeyBibG9jazogU3RyaW5nKGJsb2NrKSB9KTtcbiAgICAgICAgICAgIHJldHVybiBzY3JpcHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBzdG9yYWdlIHZhbHVlIG9mIGEgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gY29udHJhY3QgY29udHJhY3QgYWRkcmVzcyBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIHN0b3JhZ2VcbiAgICAgKiBAcGFyYW0gYmxvY2sgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBzdG9yYWdlIHZhbHVlXG4gICAgICovXG4gICAgZ2V0U3RvcmFnZShjb250cmFjdCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRTdG9yYWdlKGNvbnRyYWN0LCB7IGJsb2NrOiBTdHJpbmcoYmxvY2spIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgYmxvY2sgaGFzaFxuICAgICAqL1xuICAgIGdldEJsb2NrSGFzaChibG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgeyBoYXNoIH0gPSB5aWVsZCB0aGlzLnJwYy5nZXRCbG9ja0hlYWRlcih7IGJsb2NrOiBTdHJpbmcoYmxvY2spIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBibG9jayBsZXZlbFxuICAgICAqL1xuICAgIGdldEJsb2NrTGV2ZWwoYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgbGV2ZWwgfSA9IHlpZWxkIHRoaXMucnBjLmdldEJsb2NrSGVhZGVyKHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgICAgICAgICByZXR1cm4gbGV2ZWw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBjb3VudGVyIG9mIGFuIGFkZHJlc3NcbiAgICAgKiBAcGFyYW0gcGtoIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgY291bnRlclxuICAgICAqIEBwYXJhbSBibG9jayBmcm9tIHdoaWNoIHdlIHdhbnQgdG8gcmV0cmlldmUgdGhlIGNvdW50ZXJcbiAgICAgKi9cbiAgICBnZXRDb3VudGVyKHBraCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgY291bnRlciB9ID0geWllbGQgdGhpcy5ycGMuZ2V0Q29udHJhY3QocGtoLCB7IGJsb2NrOiBTdHJpbmcoYmxvY2spIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGNvdW50ZXIgfHwgJzAnO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIEFjY2VzcyB0aGUgdGltZXN0YW1wIG9mIGEgYmxvY2tcbiAgICAgKiBAcGFyYW0gYmxvY2sgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSB0aW1lc3RhbXBcbiAgICAgKiBAcmV0dXJucyBkYXRlIElTTyBmb3JtYXQgemVybyBVVEMgb2Zmc2V0IChcIjIwMjItMDEtMTlUMjI6Mzc6MDdaXCIpXG4gICAgICovXG4gICAgZ2V0QmxvY2tUaW1lc3RhbXAoYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdGltZXN0YW1wIH0gPSB5aWVsZCB0aGlzLnJwYy5nZXRCbG9ja0hlYWRlcih7IGJsb2NrOiBTdHJpbmcoYmxvY2spIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHRpbWVzdGFtcDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBhIGtleSBpbiBhIGJpZyBtYXAuXG4gICAgICogQHBhcmFtIGJpZ01hcFF1ZXJ5IEJpZyBNYXAgSUQgYW5kIEV4cHJlc3Npb24gaGFzaCB0byBxdWVyeSAoQSBiNThjaGVjayBlbmNvZGVkIEJsYWtlMmIgaGFzaCBvZiB0aGUgZXhwcmVzc2lvbilcbiAgICAgKiBAcGFyYW0gYmxvY2sgZnJvbSB3aGljaCB3ZSB3YW50IHRvIHJldHJpZXZlIHRoZSBiaWcgbWFwIHZhbHVlXG4gICAgICovXG4gICAgZ2V0QmlnTWFwVmFsdWUoYmlnTWFwUXVlcnksIGJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ycGMuZ2V0QmlnTWFwRXhwcihiaWdNYXBRdWVyeS5pZCwgYmlnTWFwUXVlcnkuZXhwciwge1xuICAgICAgICAgICAgICAgIGJsb2NrOiBTdHJpbmcoYmxvY2spLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSB2YWx1ZSBhc3NvY2lhdGVkIHdpdGggYSBzYXBsaW5nIHN0YXRlIElELlxuICAgICAqIEBwYXJhbSBpZCBTYXBsaW5nIHN0YXRlIElEXG4gICAgICogQHBhcmFtIGJsb2NrIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgc2FwbGluZyBzdGF0ZVxuICAgICAqL1xuICAgIGdldFNhcGxpbmdEaWZmQnlJZChzYXBsaW5nU3RhdGVRdWVyeSwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRTYXBsaW5nRGlmZkJ5SWQoc2FwbGluZ1N0YXRlUXVlcnkuaWQsIHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWNjZXNzIHRoZSBzYXBsaW5nIHN0YXRlIG9mIGEgc21hcnQgY29udHJhY3QuXG4gICAgICogQHBhcmFtIGNvbnRyYWN0QWRkcmVzcyBUaGUgYWRkcmVzcyBvZiB0aGUgc21hcnQgY29udHJhY3RcbiAgICAgKiBAcGFyYW0gYmxvY2sgVGhlIGJsb2NrIHlvdSB3YW50IHRvIHJldHJpZXZlIHRoZSBzYXBsaW5nIHN0YXRlIGZyb21cbiAgICAgKi9cbiAgICBnZXRTYXBsaW5nRGlmZkJ5Q29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBibG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldFNhcGxpbmdEaWZmQnlDb250cmFjdChjb250cmFjdEFkZHJlc3MsIHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIHRoZSBsaXN0IG9mIGVudHJ5cG9pbnRzIG9mIHRoZSBjb250cmFjdFxuICAgICAqIEBwYXJhbSBjb250cmFjdCBhZGRyZXNzIG9mIHRoZSBjb250cmFjdCB3ZSB3YW50IHRvIGdldCB0aGUgZW50cnlwb2ludHMgb2ZcbiAgICAgKi9cbiAgICBnZXRFbnRyeXBvaW50cyhjb250cmFjdCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldEVudHJ5cG9pbnRzKGNvbnRyYWN0KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBY2Nlc3MgdGhlIGNoYWluIGlkXG4gICAgICovXG4gICAgZ2V0Q2hhaW5JZCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRDaGFpbklkKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gSW5kaWNhdGUgaWYgYW4gYWNjb3VudCBpcyByZXZlYWxlZFxuICAgICAqIEBwYXJhbSBwdWJsaWNLZXlIYXNoIG9mIHRoZSBhY2NvdW50XG4gICAgICogQHBhcmFtIGJsb2NrIGZyb20gd2hpY2ggd2Ugd2FudCB0byBrbm93IGlmIHRoZSBhY2NvdW50IGlzIHJldmVhbGVkXG4gICAgICovXG4gICAgaXNBY2NvdW50UmV2ZWFsZWQocHVibGljS2V5SGFzaCwgYmxvY2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hbmFnZXIgPSB5aWVsZCB0aGlzLnJwYy5nZXRNYW5hZ2VyS2V5KHB1YmxpY0tleUhhc2gsIHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgICAgICAgICBjb25zdCBoYXZlTWFuYWdlciA9IG1hbmFnZXIgJiYgdHlwZW9mIG1hbmFnZXIgPT09ICdvYmplY3QnID8gISFtYW5hZ2VyLmtleSA6ICEhbWFuYWdlcjtcbiAgICAgICAgICAgIHJldHVybiBoYXZlTWFuYWdlcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBSZXR1cm4gYWxsIHRoZSBpbmZvcm1hdGlvbiBhYm91dCBhIGJsb2NrXG4gICAgICogQHBhcmFtIGJsb2NrIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRCbG9jayhibG9jaykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucnBjLmdldEJsb2NrKHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0dXJuIGEgbGlzdCBvZiB0aGUgYW5jZXN0b3JzIG9mIHRoZSBnaXZlbiBibG9jayB3aGljaCwgaWYgcmVmZXJyZWQgdG8gYXMgdGhlIGJyYW5jaCBpbiBhbiBvcGVyYXRpb24gaGVhZGVyLCBhcmUgcmVjZW50IGVub3VnaCBmb3IgdGhhdCBvcGVyYXRpb24gdG8gYmUgaW5jbHVkZWQgaW4gdGhlIGN1cnJlbnQgYmxvY2suXG4gICAgICogQHBhcmFtIGJsb2NrIGZyb20gd2hpY2ggd2Ugd2FudCB0byByZXRyaWV2ZSB0aGUgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRMaXZlQmxvY2tzKGJsb2NrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnJwYy5nZXRMaXZlQmxvY2tzKHsgYmxvY2s6IFN0cmluZyhibG9jaykgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gdW5zdXBwb3J0ZWQgZXZlbnQgYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgVW5zdXBwb3J0ZWRFdmVudEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdVbnN1cHBvcnRlZEV2ZW50RXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgVW5zdXBwb3J0ZWQgZXZlbnQgdHlwZSBcIiR7dHlwZX1cIiBleHBlY3Rpbmcgb25lIG9mIHRoZSBcImRhdGFcIiwgXCJlcnJvclwiLCBvciBcImNsb3NlXCIuYDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgYW4gaW52YWxpZCBmaWx0ZXIgZXhwcmVzc2lvbiBiZWluZyBwYXNzZWQgb3IgdXNlZFxuICovXG5jbGFzcyBJbnZhbGlkRmlsdGVyRXhwcmVzc2lvbkVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihpbnZhbGlkRXhwcmVzc2lvbikge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmludmFsaWRFeHByZXNzaW9uID0gaW52YWxpZEV4cHJlc3Npb247XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkRmlsdGVyRXhwcmVzc2lvbkVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYEludmFsaWQgZmlsdGVyIGV4cHJlc3Npb24gZXhwZWN0aW5nIHRoZSBvYmplY3QgdG8gY29udGFpbiBlaXRoZXIgYW5kL29yIHByb3BlcnR5YDtcbiAgICB9XG59XG5cbmNvbnN0IG9wSGFzaEZpbHRlciA9IChvcCwgZmlsdGVyKSA9PiBvcC5oYXNoID09PSBmaWx0ZXIub3BIYXNoO1xuY29uc3Qgc291cmNlRmlsdGVyID0gKHgsIGZpbHRlcikgPT4ge1xuICAgIHN3aXRjaCAoeC5raW5kKSB7XG4gICAgICAgIGNhc2UgJ2F0dGVzdGF0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiAnbWV0YWRhdGEnIGluIHggJiYgeC5tZXRhZGF0YS5kZWxlZ2F0ZSA9PT0gZmlsdGVyLnNvdXJjZTtcbiAgICAgICAgY2FzZSAnZW5kb3JzZW1lbnQnOlxuICAgICAgICAgICAgcmV0dXJuICdtZXRhZGF0YScgaW4geCAmJiB4Lm1ldGFkYXRhLmRlbGVnYXRlID09PSBmaWx0ZXIuc291cmNlO1xuICAgICAgICBjYXNlICdhY3RpdmF0ZV9hY2NvdW50JzpcbiAgICAgICAgICAgIHJldHVybiAnbWV0YWRhdGEnIGluIHggJiYgeC5wa2ggPT09IGZpbHRlci5zb3VyY2U7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3NvdXJjZScgaW4geCAmJiB4LnNvdXJjZSA9PT0gZmlsdGVyLnNvdXJjZTtcbiAgICB9XG59O1xuY29uc3Qga2luZEZpbHRlciA9ICh4LCBmaWx0ZXIpID0+ICdraW5kJyBpbiB4ICYmIHgua2luZCA9PT0gZmlsdGVyLmtpbmQ7XG5jb25zdCBkZXN0aW5hdGlvbkZpbHRlciA9ICh4LCBmaWx0ZXIpID0+IHtcbiAgICBzd2l0Y2ggKHgua2luZCkge1xuICAgICAgICBjYXNlICdkZWxlZ2F0aW9uJzpcbiAgICAgICAgICAgIHJldHVybiB4LmRlbGVnYXRlID09PSBmaWx0ZXIuZGVzdGluYXRpb247XG4gICAgICAgIGNhc2UgJ29yaWdpbmF0aW9uJzpcbiAgICAgICAgICAgIGlmICgnbWV0YWRhdGEnIGluIHggJiZcbiAgICAgICAgICAgICAgICAnb3BlcmF0aW9uX3Jlc3VsdCcgaW4geC5tZXRhZGF0YSAmJlxuICAgICAgICAgICAgICAgICdvcmlnaW5hdGVkX2NvbnRyYWN0cycgaW4geC5tZXRhZGF0YS5vcGVyYXRpb25fcmVzdWx0ICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheSh4Lm1ldGFkYXRhLm9wZXJhdGlvbl9yZXN1bHQub3JpZ2luYXRlZF9jb250cmFjdHMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHgubWV0YWRhdGEub3BlcmF0aW9uX3Jlc3VsdC5vcmlnaW5hdGVkX2NvbnRyYWN0cy5zb21lKChjb250cmFjdCkgPT4gY29udHJhY3QgPT09IGZpbHRlci5kZXN0aW5hdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndHJhbnNhY3Rpb24nOlxuICAgICAgICAgICAgcmV0dXJuIHguZGVzdGluYXRpb24gPT09IGZpbHRlci5kZXN0aW5hdGlvbjtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59O1xuY29uc3QgZXZlbnRGaWx0ZXIgPSAocmVzdWx0LCBhZGRyZXNzLCB0YWcsIGV4Y2x1ZGVGYWlsZWRPcGVyYXRpb25zKSA9PiB7XG4gICAgaWYgKHJlc3VsdC5raW5kICE9PSAnZXZlbnQnKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHRhZyAmJiByZXN1bHQudGFnICE9PSB0YWcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYWRkcmVzcyAmJiByZXN1bHQuc291cmNlICE9PSBhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGV4Y2x1ZGVGYWlsZWRPcGVyYXRpb25zICYmIHJlc3VsdC5yZXN1bHQuc3RhdHVzICE9PSAnYXBwbGllZCcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5jb25zdCBldmFsdWF0ZU9wRmlsdGVyID0gKG9wLCBmaWx0ZXIpID0+IHtcbiAgICBpZiAoJ29wSGFzaCcgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBvcEhhc2hGaWx0ZXIob3AsIGZpbHRlcik7XG4gICAgfVxuICAgIGVsc2UgaWYgKCdzb3VyY2UnIGluIGZpbHRlcikge1xuICAgICAgICByZXR1cm4gc291cmNlRmlsdGVyKG9wLCBmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgna2luZCcgaW4gZmlsdGVyKSB7XG4gICAgICAgIHJldHVybiBraW5kRmlsdGVyKG9wLCBmaWx0ZXIpO1xuICAgIH1cbiAgICBlbHNlIGlmICgnZGVzdGluYXRpb24nIGluIGZpbHRlcikge1xuICAgICAgICByZXR1cm4gZGVzdGluYXRpb25GaWx0ZXIob3AsIGZpbHRlcik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG5jb25zdCBldmFsdWF0ZUV4cHJlc3Npb24gPSAob3AsIGV4cCkgPT4ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV4cC5hbmQpKSB7XG4gICAgICAgIHJldHVybiBleHAuYW5kLmV2ZXJ5KCh4KSA9PiBldmFsdWF0ZUZpbHRlcihvcCwgeCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGV4cC5vcikpIHtcbiAgICAgICAgcmV0dXJuIGV4cC5vci5zb21lKCh4KSA9PiBldmFsdWF0ZUZpbHRlcihvcCwgeCkpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRGaWx0ZXJFeHByZXNzaW9uRXJyb3IoZXhwKTtcbiAgICB9XG59O1xuY29uc3QgZXZhbHVhdGVGaWx0ZXIgPSAob3AsIGZpbHRlcikgPT4ge1xuICAgIGNvbnN0IGZpbHRlcnMgPSBbXTtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xuICAgICAgICBmaWx0ZXJzLnB1c2goZmlsdGVyKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGZpbHRlcnMucHVzaCguLi5maWx0ZXIpO1xuICAgIH1cbiAgICByZXR1cm4gZmlsdGVycy5ldmVyeSgoZmlsdGVyT3JFeHApID0+IHtcbiAgICAgICAgaWYgKCdhbmQnIGluIGZpbHRlck9yRXhwIHx8ICdvcicgaW4gZmlsdGVyT3JFeHApIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZUV4cHJlc3Npb24ob3AsIGZpbHRlck9yRXhwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBldmFsdWF0ZU9wRmlsdGVyKG9wLCBmaWx0ZXJPckV4cCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn07XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLWR1cGUtY2xhc3MtbWVtYmVycyAqL1xuY2xhc3MgT2JzZXJ2YWJsZVN1YnNjcmlwdGlvbiB7XG4gICAgY29uc3RydWN0b3Iob2JzLCBzaG91bGRSZXRyeSA9IGZhbHNlLCBvcGVyYXRvckZ1bmN0aW9uID0gcmV0cnkoKSkge1xuICAgICAgICB0aGlzLnNob3VsZFJldHJ5ID0gc2hvdWxkUmV0cnk7XG4gICAgICAgIHRoaXMub3BlcmF0b3JGdW5jdGlvbiA9IG9wZXJhdG9yRnVuY3Rpb247XG4gICAgICAgIHRoaXMuZXJyb3JMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5tZXNzYWdlTGlzdGVuZXJzID0gW107XG4gICAgICAgIHRoaXMuY2xvc2VMaXN0ZW5lcnMgPSBbXTtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQkID0gbmV3IFN1YmplY3QoKTtcbiAgICAgICAgb2JzXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5jb21wbGV0ZWQkKSwgdGFwKChkYXRhKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwodGhpcy5tZXNzYWdlTGlzdGVuZXJzLCBkYXRhKTtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwodGhpcy5lcnJvckxpc3RlbmVycywgZXJyb3IpO1xuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmNhbGwodGhpcy5jbG9zZUxpc3RlbmVycyk7XG4gICAgICAgIH0pLCB0aGlzLnNob3VsZFJldHJ5ID8gb3BlcmF0b3JGdW5jdGlvbiA6IHRhcCgpLCBjYXRjaEVycm9yKCgpID0+IE5FVkVSKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgY2FsbChsaXN0ZW5lcnMsIHZhbHVlKSB7XG4gICAgICAgIGZvciAoY29uc3QgbCBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgICAgICBsKHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJlbW92ZShsaXN0ZW5lcnMsIHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IGxpc3RlbmVycy5pbmRleE9mKHZhbHVlKTtcbiAgICAgICAgaWYgKGlkeCAhPT0gLTEpIHtcbiAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaWR4LCAxKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbih0eXBlLCBjYikge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2RhdGEnOlxuICAgICAgICAgICAgICAgIHRoaXMubWVzc2FnZUxpc3RlbmVycy5wdXNoKGNiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICB0aGlzLmVycm9yTGlzdGVuZXJzLnB1c2goY2IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VMaXN0ZW5lcnMucHVzaChjYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEV2ZW50RXJyb3IodHlwZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb2ZmKHR5cGUsIGNiKSB7XG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnZGF0YSc6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5tZXNzYWdlTGlzdGVuZXJzLCBjYik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmUodGhpcy5lcnJvckxpc3RlbmVycywgY2IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2xvc2UnOlxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlKHRoaXMuY2xvc2VMaXN0ZW5lcnMsIGNiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFVuc3VwcG9ydGVkRXZlbnRFcnJvcih0eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5jb21wbGV0ZWQkLm5leHQoKTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRDb25maWdTdHJlYW1lciA9IHtcbiAgICBzaG91bGRPYnNlcnZhYmxlU3Vic2NyaXB0aW9uUmV0cnk6IGZhbHNlLFxuICAgIG9ic2VydmFibGVTdWJzY3JpcHRpb25SZXRyeUZ1bmN0aW9uOiByZXRyeSgpLFxufTtcbmNvbnN0IGdldExhc3RCbG9jayA9IChjb250ZXh0KSA9PiB7XG4gICAgcmV0dXJuIGZyb20oY29udGV4dC5ycGMuZ2V0QmxvY2soKSkucGlwZShmaXJzdCgpKTtcbn07XG5jb25zdCBhcHBseUZpbHRlciA9IChmaWx0ZXIpID0+IGNvbmNhdE1hcCgoYmxvY2spID0+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG9wcyBvZiBibG9jay5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBvcC5jb250ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXZhbHVhdGVGaWx0ZXIoT2JqZWN0LmFzc2lnbih7IGhhc2g6IG9wLmhhc2ggfSwgY29udGVudCksIGZpbHRlcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN1Yi5uZXh0KE9iamVjdC5hc3NpZ24oeyBoYXNoOiBvcC5oYXNoIH0sIGNvbnRlbnQpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBzdWIuY29tcGxldGUoKTtcbiAgICB9KTtcbn0pO1xuY29uc3QgYXBwbHlFdmVudEZpbHRlciA9IChmaWx0ZXIpID0+IGNvbmNhdE1hcCgoYmxvY2spID0+IHtcbiAgICByZXR1cm4gbmV3IE9ic2VydmFibGUoKHN1YikgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG9wcyBvZiBibG9jay5vcGVyYXRpb25zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wIG9mIG9wcykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29udGVudCBvZiBvcC5jb250ZW50cykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGNvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGludGVybmFsT3BSZXN1bHRzID0gdHgubWV0YWRhdGEuaW50ZXJuYWxfb3BlcmF0aW9uX3Jlc3VsdHM7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnRlcm5hbE9wUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBldmVudCBvZiBpbnRlcm5hbE9wUmVzdWx0cykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChldmVudEZpbHRlcihldmVudCwgZmlsdGVyID09PSBudWxsIHx8IGZpbHRlciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZmlsdGVyLmFkZHJlc3MsIGZpbHRlciA9PT0gbnVsbCB8fCBmaWx0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlci50YWcsIGZpbHRlciA9PT0gbnVsbCB8fCBmaWx0ZXIgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGZpbHRlci5leGNsdWRlRmFpbGVkT3BlcmF0aW9ucykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViLm5leHQoT2JqZWN0LmFzc2lnbih7IG9wSGFzaDogb3AuaGFzaCwgYmxvY2tIYXNoOiBibG9jay5oYXNoLCBsZXZlbDogYmxvY2suaGVhZGVyLmxldmVsIH0sIGV2ZW50KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1Yi5jb21wbGV0ZSgpO1xuICAgIH0pO1xufSk7XG5jbGFzcyBQb2xsaW5nU3Vic2NyaWJlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRleHQsIGNvbmZpZyA9IHt9KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgICAgIHRoaXMuX2NvbmZpZyQgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdENvbmZpZ1N0cmVhbWVyKSwgY29uZmlnKSk7XG4gICAgICAgIHRoaXMudGltZXIkID0gdGhpcy5fY29uZmlnJC5waXBlKHBsdWNrKCdwb2xsaW5nSW50ZXJ2YWxNaWxsaXNlY29uZHMnKSwgc3dpdGNoTWFwKChwb2xsaW5nSW50ZXJ2YWxNaWxsaXNlY29uZHMpID0+IHtcbiAgICAgICAgICAgIGlmICghcG9sbGluZ0ludGVydmFsTWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZyb20odGhpcy5nZXRDb25maXJtYXRpb25Qb2xsaW5nSW50ZXJ2YWwoKSkucGlwZShzd2l0Y2hNYXAoKGludGVydmFsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aW1lcigwLCBpbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDAsIHBvbGxpbmdJbnRlcnZhbE1pbGxpc2Vjb25kcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICAgICAgdGhpcy5uZXdCbG9jayQgPSB0aGlzLnRpbWVyJC5waXBlKHN3aXRjaE1hcCgoKSA9PiBnZXRMYXN0QmxvY2sodGhpcy5jb250ZXh0KSksIGRpc3RpbmN0VW50aWxLZXlDaGFuZ2VkKCdoYXNoJyksIHB1Ymxpc2goKSwgcmVmQ291bnQoKSk7XG4gICAgfVxuICAgIGdldCBjb25maWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25maWckLmdldFZhbHVlKCk7XG4gICAgfVxuICAgIGdldENvbmZpcm1hdGlvblBvbGxpbmdJbnRlcnZhbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb25maWcucG9sbGluZ0ludGVydmFsTWlsbGlzZWNvbmRzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZGVmYXVsdEludGVydmFsVGVzdG5ldHNNYWlubmV0ID0gNTAwMDtcbiAgICAgICAgICAgICAgICBjb25zdCBkZWZhdWx0SW50ZXJ2YWxTYW5kYm94ID0gMTAwMDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb25zdGFudHMgPSB5aWVsZCB0aGlzLmNvbnRleHQucmVhZFByb3ZpZGVyLmdldFByb3RvY29sQ29uc3RhbnRzKCdoZWFkJyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrVGltZSA9IGNvbnN0YW50cy5taW5pbWFsX2Jsb2NrX2RlbGF5XG4gICAgICAgICAgICAgICAgICAgICAgICA/IGNvbnN0YW50cy5taW5pbWFsX2Jsb2NrX2RlbGF5Lm11bHRpcGxpZWRCeSgxMDAwKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBjb25zdGFudHMudGltZV9iZXR3ZWVuX2Jsb2Nrc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gY29uc3RhbnRzLnRpbWVfYmV0d2Vlbl9ibG9ja3NbMF0ubXVsdGlwbGllZEJ5KDEwMDApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBuZXcgQmlnTnVtYmVyKGRlZmF1bHRJbnRlcnZhbFRlc3RuZXRzTWFpbm5ldCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpcm1hdGlvblBvbGxpbmdJbnRlcnZhbCA9IGJsb2NrVGltZS5kaXZpZGVkQnkoMyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29uZmlnLnBvbGxpbmdJbnRlcnZhbE1pbGxpc2Vjb25kcyA9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25Qb2xsaW5nSW50ZXJ2YWwudG9OdW1iZXIoKSA9PT0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZGVmYXVsdEludGVydmFsU2FuZGJveFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogY29uZmlybWF0aW9uUG9sbGluZ0ludGVydmFsLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChleGNlcHRpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlZmF1bHRJbnRlcnZhbFRlc3RuZXRzTWFpbm5ldDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25maWcucG9sbGluZ0ludGVydmFsTWlsbGlzZWNvbmRzO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3Vic2NyaWJlQmxvY2soX2ZpbHRlcikge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdWJzY3JpcHRpb24odGhpcy5uZXdCbG9jayQsIHRoaXMuY29uZmlnLnNob3VsZE9ic2VydmFibGVTdWJzY3JpcHRpb25SZXRyeSwgdGhpcy5jb25maWcub2JzZXJ2YWJsZVN1YnNjcmlwdGlvblJldHJ5RnVuY3Rpb24pO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoX2ZpbHRlcikge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdWJzY3JpcHRpb24odGhpcy5uZXdCbG9jayQucGlwZShwbHVjaygnaGFzaCcpKSwgdGhpcy5jb25maWcuc2hvdWxkT2JzZXJ2YWJsZVN1YnNjcmlwdGlvblJldHJ5LCB0aGlzLmNvbmZpZy5vYnNlcnZhYmxlU3Vic2NyaXB0aW9uUmV0cnlGdW5jdGlvbik7XG4gICAgfVxuICAgIHN1YnNjcmliZU9wZXJhdGlvbihmaWx0ZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBPYnNlcnZhYmxlU3Vic2NyaXB0aW9uKHRoaXMubmV3QmxvY2skLnBpcGUoYXBwbHlGaWx0ZXIoZmlsdGVyKSksIHRoaXMuY29uZmlnLnNob3VsZE9ic2VydmFibGVTdWJzY3JpcHRpb25SZXRyeSwgdGhpcy5jb25maWcub2JzZXJ2YWJsZVN1YnNjcmlwdGlvblJldHJ5RnVuY3Rpb24pO1xuICAgIH1cbiAgICBzdWJzY3JpYmVFdmVudChldmVudEZpbHRlcikge1xuICAgICAgICByZXR1cm4gbmV3IE9ic2VydmFibGVTdWJzY3JpcHRpb24odGhpcy5uZXdCbG9jayQucGlwZShhcHBseUV2ZW50RmlsdGVyKGV2ZW50RmlsdGVyKSksIHRoaXMuY29uZmlnLnNob3VsZE9ic2VydmFibGVTdWJzY3JpcHRpb25SZXRyeSwgdGhpcy5jb25maWcub2JzZXJ2YWJsZVN1YnNjcmlwdGlvblJldHJ5RnVuY3Rpb24pO1xuICAgIH1cbn1cblxuY2xhc3MgVGFxdWl0b0xvY2FsRm9yZ2VyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb250ZXh0KSB7XG4gICAgICAgIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuICAgIGdldE5leHRQcm90bygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jb250ZXh0LnByb3RvKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmV4dFByb3RvID0geWllbGQgdGhpcy5jb250ZXh0LnJlYWRQcm92aWRlci5nZXROZXh0UHJvdG9jb2woJ2hlYWQnKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbnRleHQucHJvdG8gPSBuZXh0UHJvdG87XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnByb3RvO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yZ2UoeyBicmFuY2gsIGNvbnRlbnRzIH0pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGZvcmdlciA9IG5ldyBMb2NhbEZvcmdlcih5aWVsZCB0aGlzLmdldE5leHRQcm90bygpKTtcbiAgICAgICAgICAgIHJldHVybiBmb3JnZXIuZm9yZ2UoeyBicmFuY2gsIGNvbnRlbnRzIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNvbnN0IGRlZmF1bHRDb25maWdDb25maXJtYXRpb24gPSB7XG4gICAgZGVmYXVsdENvbmZpcm1hdGlvbkNvdW50OiAxLFxuICAgIGNvbmZpcm1hdGlvblBvbGxpbmdUaW1lb3V0U2Vjb25kOiAxODAsXG59O1xuLyoqXG4gKiBAZGVzY3JpcHRpb24gRW5jYXBzdWxhdGUgY29tbW9uIHNlcnZpY2UgdXNlZCB0aHJvdWdob3V0IGRpZmZlcmVudCBwYXJ0IG9mIHRoZSBsaWJyYXJ5XG4gKi9cbmNsYXNzIENvbnRleHQge1xuICAgIGNvbnN0cnVjdG9yKF9ycGMsIF9zaWduZXIgPSBuZXcgTm9vcFNpZ25lcigpLCBfcHJvdG8sIF9jb25maWcgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KE9iamVjdC5hc3NpZ24oe30sIGRlZmF1bHRDb25maWdDb25maXJtYXRpb24pKSwgZm9yZ2VyLCBpbmplY3RvciwgcGFja2VyLCB3YWxsZXQsIHBhcnNlciwgZ2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIsIHJlYWRQcm92aWRlciwgc3RyZWFtKSB7XG4gICAgICAgIHRoaXMuX3JwYyA9IF9ycGM7XG4gICAgICAgIHRoaXMuX3NpZ25lciA9IF9zaWduZXI7XG4gICAgICAgIHRoaXMuX3Byb3RvID0gX3Byb3RvO1xuICAgICAgICB0aGlzLl9jb25maWcgPSBfY29uZmlnO1xuICAgICAgICB0aGlzLnByb3ZpZGVyRGVjb3JhdG9yID0gW107XG4gICAgICAgIHRoaXMudHogPSBuZXcgUnBjVHpQcm92aWRlcih0aGlzKTtcbiAgICAgICAgdGhpcy5lc3RpbWF0ZSA9IG5ldyBSUENFc3RpbWF0ZVByb3ZpZGVyKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbnRyYWN0ID0gbmV3IFJwY0NvbnRyYWN0UHJvdmlkZXIodGhpcywgdGhpcy5lc3RpbWF0ZSk7XG4gICAgICAgIHRoaXMucHJlcGFyZSA9IG5ldyBQcmVwYXJlUHJvdmlkZXIodGhpcyk7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSBuZXcgUlBDQmF0Y2hQcm92aWRlcih0aGlzLCB0aGlzLmVzdGltYXRlKTtcbiAgICAgICAgdGhpcy53YWxsZXQgPSBuZXcgV2FsbGV0KHRoaXMpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQGRlc2NyaXB0aW9uIEFwcGxpZXMgdGhlIGRlY29yYXRvcnMgb24gYSBjbG9uZWQgaW5zdGFuY2Ugb2YgdGhlIGNvbnRleHQgYW5kIHJldHVybmVkIHRoaXMgY2xvbmVkIGluc3RhbmNlLlxuICAgICAgICAgKiBUaGUgZGVjb3JhdG9ycyBhcmUgZnVuY3Rpb25zIHRoYXQgaW5qZWN0IGxvZ2ljIGludG8gdGhlIGNvbnRleHQuXG4gICAgICAgICAqIFRoZXkgYXJlIHByb3ZpZGVkIGJ5IHRoZSBleHRlbnNpb25zIHNldCBvbiB0aGUgVGV6b3NUb29sa2l0IGJ5IGNhbGxpbmcgdGhlIHJlZ2lzdGVyUHJvdmlkZXJEZWNvcmF0b3IgbWV0aG9kLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy53aXRoRXh0ZW5zaW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgIGxldCBjbG9uZWRDb250ZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICAgICAgdGhpcy5wcm92aWRlckRlY29yYXRvci5mb3JFYWNoKChkZWNvcmF0b3IpID0+IHtcbiAgICAgICAgICAgICAgICBjbG9uZWRDb250ZXh0ID0gZGVjb3JhdG9yKGNsb25lZENvbnRleHQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gY2xvbmVkQ29udGV4dDtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ycGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNDbGllbnQgPSBuZXcgUnBjQ2xpZW50KHRoaXMuX3JwYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNDbGllbnQgPSB0aGlzLl9ycGM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yZ2VyID0gZm9yZ2VyID8gZm9yZ2VyIDogbmV3IFRhcXVpdG9Mb2NhbEZvcmdlcih0aGlzKTtcbiAgICAgICAgdGhpcy5faW5qZWN0b3IgPSBpbmplY3RvciA/IGluamVjdG9yIDogbmV3IFJwY0luamVjdG9yKHRoaXMpO1xuICAgICAgICB0aGlzLm9wZXJhdGlvbkZhY3RvcnkgPSBuZXcgT3BlcmF0aW9uRmFjdG9yeSh0aGlzKTtcbiAgICAgICAgdGhpcy5fd2FsbGV0UHJvdmlkZXIgPSB3YWxsZXQgPyB3YWxsZXQgOiBuZXcgTGVnYWN5V2FsbGV0UHJvdmlkZXIodGhpcyk7XG4gICAgICAgIHRoaXMuX3BhcnNlciA9IHBhcnNlciA/IHBhcnNlciA6IG5ldyBNaWNoZWxDb2RlY1BhcnNlcih0aGlzKTtcbiAgICAgICAgdGhpcy5fcGFja2VyID0gcGFja2VyID8gcGFja2VyIDogbmV3IFJwY1BhY2tlcih0aGlzKTtcbiAgICAgICAgdGhpcy5fZ2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIgPSBnbG9iYWxDb25zdGFudHNQcm92aWRlclxuICAgICAgICAgICAgPyBnbG9iYWxDb25zdGFudHNQcm92aWRlclxuICAgICAgICAgICAgOiBuZXcgTm9vcEdsb2JhbENvbnN0YW50c1Byb3ZpZGVyKCk7XG4gICAgICAgIHRoaXMuX3JlYWRQcm92aWRlciA9IHJlYWRQcm92aWRlciA/IHJlYWRQcm92aWRlciA6IG5ldyBScGNSZWFkQWRhcHRlcih0aGlzLl9ycGNDbGllbnQpO1xuICAgICAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW0gPyBzdHJlYW0gOiBuZXcgUG9sbGluZ1N1YnNjcmliZVByb3ZpZGVyKHRoaXMpO1xuICAgIH1cbiAgICBnZXQgY29uZmlnKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29uZmlnLmdldFZhbHVlKCk7XG4gICAgfVxuICAgIHNldCBjb25maWcodmFsdWUpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLm5leHQoT2JqZWN0LmFzc2lnbih7fSwgdmFsdWUpKTtcbiAgICB9XG4gICAgc2V0UGFydGlhbENvbmZpZyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9jb25maWcubmV4dChPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuX2NvbmZpZy5nZXRWYWx1ZSgpKSwgdmFsdWUpKTtcbiAgICB9XG4gICAgZ2V0IHJwYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JwY0NsaWVudDtcbiAgICB9XG4gICAgc2V0IHJwYyh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9ycGNDbGllbnQgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGluamVjdG9yKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faW5qZWN0b3I7XG4gICAgfVxuICAgIHNldCBpbmplY3Rvcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9pbmplY3RvciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgZm9yZ2VyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZm9yZ2VyO1xuICAgIH1cbiAgICBzZXQgZm9yZ2VyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX2ZvcmdlciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgc2lnbmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2lnbmVyO1xuICAgIH1cbiAgICBzZXQgc2lnbmVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3NpZ25lciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgd2FsbGV0UHJvdmlkZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YWxsZXRQcm92aWRlcjtcbiAgICB9XG4gICAgc2V0IHdhbGxldFByb3ZpZGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3dhbGxldFByb3ZpZGVyID0gdmFsdWU7XG4gICAgfVxuICAgIHNldCBwcm90byh2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wcm90byA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcHJvdG8oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wcm90bztcbiAgICB9XG4gICAgZ2V0IHBhcnNlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhcnNlcjtcbiAgICB9XG4gICAgc2V0IHBhcnNlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IHBhY2tlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhY2tlcjtcbiAgICB9XG4gICAgc2V0IHBhY2tlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9wYWNrZXIgPSB2YWx1ZTtcbiAgICB9XG4gICAgZ2V0IGdsb2JhbENvbnN0YW50c1Byb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2xvYmFsQ29uc3RhbnRzUHJvdmlkZXI7XG4gICAgfVxuICAgIHNldCBnbG9iYWxDb25zdGFudHNQcm92aWRlcih2YWx1ZSkge1xuICAgICAgICB0aGlzLl9nbG9iYWxDb25zdGFudHNQcm92aWRlciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgcmVhZFByb3ZpZGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVhZFByb3ZpZGVyO1xuICAgIH1cbiAgICBzZXQgcmVhZFByb3ZpZGVyKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3JlYWRQcm92aWRlciA9IHZhbHVlO1xuICAgIH1cbiAgICBnZXQgc3RyZWFtKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc3RyZWFtO1xuICAgIH1cbiAgICBzZXQgc3RyZWFtKHZhbHVlKSB7XG4gICAgICAgIHRoaXMuX3N0cmVhbSA9IHZhbHVlO1xuICAgIH1cbiAgICBpc0FueVByb3RvY29sQWN0aXZlKHByb3RvY29sID0gW10pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9wcm90bykge1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm90b2NvbC5pbmNsdWRlcyh0aGlzLl9wcm90byk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0X3Byb3RvY29sID0geWllbGQgdGhpcy5yZWFkUHJvdmlkZXIuZ2V0TmV4dFByb3RvY29sKCdoZWFkJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3RvY29sLmluY2x1ZGVzKG5leHRfcHJvdG9jb2wpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNBbnlTaWduZXJDb25maWd1cmVkKCkge1xuICAgICAgICByZXR1cm4gISh0aGlzLnNpZ25lciBpbnN0YW5jZW9mIE5vb3BTaWduZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQ3JlYXRlIGEgY29weSBvZiB0aGUgY3VycmVudCBjb250ZXh0LiBVc2VmdWwgd2hlbiB5b3UgaGF2ZSBsb25nIHJ1bm5pbmcgb3BlcmF0aW9uIGFuZCB5b3UgZG8gbm90IHdhbnQgYSBjb250ZXh0IGNoYW5nZSB0byBhZmZlY3QgdGhlIG9wZXJhdGlvblxuICAgICAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRleHQodGhpcy5ycGMsIHRoaXMuc2lnbmVyLCB0aGlzLnByb3RvLCB0aGlzLl9jb25maWcsIHRoaXMuZm9yZ2VyLCB0aGlzLl9pbmplY3RvciwgdGhpcy5wYWNrZXIsIHRoaXMuX3dhbGxldFByb3ZpZGVyLCB0aGlzLl9wYXJzZXIsIHRoaXMuX2dsb2JhbENvbnN0YW50c1Byb3ZpZGVyLCB0aGlzLl9yZWFkUHJvdmlkZXIsIHRoaXMuX3N0cmVhbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBBbGxvd3MgZXh0ZW5zaW9ucyBzZXQgb24gdGhlIFRlem9zVG9vbGtpdCB0byBpbmplY3QgbG9naWMgaW50byB0aGUgY29udGV4dFxuICAgICAqL1xuICAgIHJlZ2lzdGVyUHJvdmlkZXJEZWNvcmF0b3IoZngpIHtcbiAgICAgICAgdGhpcy5wcm92aWRlckRlY29yYXRvci5wdXNoKGZ4KTtcbiAgICB9XG59XG5cbi8vIElNUE9SVEFOVDogVEhJUyBGSUxFIElTIEFVVE8gR0VORVJBVEVEISBETyBOT1QgTUFOVUFMTFkgRURJVCBPUiBDSEVDS0lOIVxuY29uc3QgVkVSU0lPTiA9IHtcbiAgICBcImNvbW1pdEhhc2hcIjogXCIxM2ExMmFiN2NmNDQyMDQzNTI2NzQ1ZGIyYmJmNGVmM2IwODljMzRhXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiMTkuMC4yXCJcbn07XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBDb21wb3NpdGVGb3JnZXIuZm9yZ2UoKSByZXN1bHRzIGRvZXNuJ3QgbWF0Y2ggZWFjaCBvdGhlclxuICovXG5jbGFzcyBGb3JnaW5nTWlzbWF0Y2hFcnJvciBleHRlbmRzIFRhcXVpdG9FcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzdWx0cykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgICB0aGlzLm5hbWUgPSAnRm9yZ2luZ01pc21hdGNoRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBgRm9yZ2luZyBtaXNtYXRjaCBlcnJvcmA7XG4gICAgfVxufVxuLyoqXG4gKiAgQGNhdGVnb3J5IEVycm9yXG4gKiAgQGRlc2NyaXB0aW9uIEVycm9yIHRoYXQgaW5kaWNhdGVzIG5vIGZvcmdlciBoYXMgYmVlbiBjb25maWd1cmVkIGZvciBDb21wb3NpdGVGb3JnZXJcbiAqL1xuY2xhc3MgVW5zcGVjaWZpZWRGb3JnZXJFcnJvciBleHRlbmRzIFRlem9zVG9vbGtpdENvbmZpZ0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ1Vuc3BlY2lmaWVkRm9yZ2VyRXJyb3InO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPVxuICAgICAgICAgICAgJ05vIGZvcmdlciBoYXMgYmVlbiBjb25maWd1cmVkLiBQbGVhc2UgY29uZmlndXJlIG5ldyBDb21wb3NpdGVGb3JnZXIoW3JwY0ZvcmdlciwgbG9jYWxGb3JnZXJdKSB3aXRoIHlvdXIgVGV6b3NUb29sa2l0IGluc3RhbmNlLic7XG4gICAgfVxufVxuXG5jbGFzcyBDb21wb3NpdGVGb3JnZXIge1xuICAgIGNvbnN0cnVjdG9yKGZvcmdlcnMpIHtcbiAgICAgICAgdGhpcy5mb3JnZXJzID0gZm9yZ2VycztcbiAgICAgICAgaWYgKGZvcmdlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVW5zcGVjaWZpZWRGb3JnZXJFcnJvcigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcmdlKHsgYnJhbmNoLCBjb250ZW50cyB9KSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwodGhpcy5mb3JnZXJzLm1hcCgoZm9yZ2VyKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcmdlci5mb3JnZSh7IGJyYW5jaCwgY29udGVudHMgfSk7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVW5zcGVjaWZpZWRGb3JnZXJFcnJvcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1ub24tbnVsbC1hc3NlcnRpb25cbiAgICAgICAgICAgIGxldCBsYXN0UmVzdWx0ID0gcmVzdWx0cy5wb3AoKTsgLy8gQXNzdW1lZCB0byBiZSBtb3JlIHRoYW4gb25lIHNpbmNlIHdlXG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRSZXN1bHQgPSByZXN1bHRzLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50UmVzdWx0ICE9PSBsYXN0UmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBGb3JnaW5nTWlzbWF0Y2hFcnJvcihbbGFzdFJlc3VsdCwgY3VycmVudFJlc3VsdF0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsYXN0UmVzdWx0ID0gY3VycmVudFJlc3VsdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIFJwY0ZvcmdlciB7XG4gICAgY29uc3RydWN0b3IoY29udGV4dCkge1xuICAgICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cbiAgICBmb3JnZSh7IGJyYW5jaCwgY29udGVudHMgfSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZXh0LnJwYy5mb3JnZU9wZXJhdGlvbnMoeyBicmFuY2gsIGNvbnRlbnRzIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgTm9vcFBhcnNlciB7XG4gICAgcHJlcGFyZUNvZGVPcmlnaW5hdGlvbihwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBwYXJhbXM7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxuY2xhc3MgTWljaGVsQ29kZWNQYWNrZXIge1xuICAgIHBhY2tEYXRhKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYnl0ZXMgfSA9IHBhY2tEYXRhQnl0ZXMoZGF0YS5kYXRhLCBkYXRhLnR5cGUpO1xuICAgICAgICAgICAgcmV0dXJuIHsgcGFja2VkOiBieXRlcyB9O1xuICAgICAgICB9KTtcbiAgICB9XG59XG5cbmNsYXNzIERlZmF1bHRHbG9iYWxDb25zdGFudHNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX2dsb2JhbENvbnN0YW50c0xpYnJhcnkgPSB7fTtcbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gQWxsb3dzIHRvIGxvYWQgZ2xvYmFsIGNvbnN0YW50IGhhc2hlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBNaWNoZWxzb24gSlNPTiB2YWx1ZXNcbiAgICAgKi9cbiAgICBsb2FkR2xvYmFsQ29uc3RhbnQoZ2xvYmFsQ29uc3RhbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBoYXNoIGluIGdsb2JhbENvbnN0YW50KSB7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKHRoaXMuX2dsb2JhbENvbnN0YW50c0xpYnJhcnksIHtcbiAgICAgICAgICAgICAgICBbaGFzaF06IGdsb2JhbENvbnN0YW50W2hhc2hdLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAZGVzY3JpcHRpb24gUmV0cmlldmUgdGhlIE1pY2hlbHNvbiB2YWx1ZSBvZiBhIGdsb2JhbCBjb25zdGFudCBiYXNlZCBvbiBpdHMgaGFzaFxuICAgICAqXG4gICAgICogQHBhcmFtIGhhc2ggYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnbG9iYWwgY29uc3RhbnQgaGFzaFxuICAgICAqIEByZXR1cm5zIEV4cHIsIHRoZSBKU09OIE1pY2hlbHNvbiB2YWx1ZVxuICAgICAqL1xuICAgIGdldEdsb2JhbENvbnN0YW50QnlIYXNoKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdGhpcy5fZ2xvYmFsQ29uc3RhbnRzTGlicmFyeVtoYXNoXTtcbiAgICAgICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgR2xvYmFsQ29uc3RhbnROb3RGb3VuZChoYXNoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBwYWNrYWdlRG9jdW1lbnRhdGlvblxuICogQG1vZHVsZSBAdGFxdWl0by90YXF1aXRvXG4gKi9cbi8qKlxuICogQGRlc2NyaXB0aW9uIEZhY2FkZSBjbGFzcyB0aGF0IHN1cmZhY2VzIGFsbCBvZiB0aGUgbGlicmFyaWVzIGNhcGFiaWxpdHkgYW5kIGFsbG93IGl0J3MgY29uZmlndXJhdGlvblxuICpcbiAqIEBwYXJhbSBfcnBjIFRoZSBSUEMgc2VydmVyIHRvIHVzZVxuICovXG5jbGFzcyBUZXpvc1Rvb2xraXQge1xuICAgIGNvbnN0cnVjdG9yKF9ycGMpIHtcbiAgICAgICAgdGhpcy5fcnBjID0gX3JwYztcbiAgICAgICAgdGhpcy5fb3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLl9ycGMgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNDbGllbnQgPSBuZXcgUnBjQ2xpZW50KHRoaXMuX3JwYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9ycGNDbGllbnQgPSB0aGlzLl9ycGM7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29udGV4dCA9IG5ldyBDb250ZXh0KF9ycGMpO1xuICAgICAgICB0aGlzLl93YWxsZXQgPSBuZXcgV2FsbGV0KHRoaXMuX2NvbnRleHQpO1xuICAgICAgICB0aGlzLnNldFByb3ZpZGVyKHsgcnBjOiB0aGlzLl9ycGNDbGllbnQgfSk7XG4gICAgICAgIHRoaXMuYmF0Y2ggPSB0aGlzLl9jb250ZXh0LmJhdGNoLmJhdGNoLmJpbmQodGhpcy5fY29udGV4dC5iYXRjaCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIGNvbmZpZ3VyYXRpb24gb24gdGhlIFRlem9zIFRhcXVpdG8gaW5zdGFuY2UuIEFsbG93cyB1c2VyIHRvIGNob29zZSB3aGljaCBzaWduZXIsIHJwYyBjbGllbnQsIHJwYyB1cmwsIGZvcmdlciBhbmQgc28gZm9ydGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHJwYyB1cmwgb3IgcnBjQ2xpZW50IHRvIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBUZXpvcyBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBUZXpvcy5zZXRQcm92aWRlcih7cnBjOiAnaHR0cHM6Ly9tYWlubmV0LmVjYWRpbmZyYS5jb20vJywgc2lnbmVyOiBuZXcgSW5NZW1vcnlTaWduZXIuZnJvbVNlY3JldEtleSjigJxlZHNrLi4u4oCdKX0pXG4gICAgICogQGV4YW1wbGUgVGV6b3Muc2V0UHJvdmlkZXIoeyBjb25maWc6IHsgY29uZmlybWF0aW9uUG9sbGluZ1RpbWVvdXRTZWNvbmQ6IDMwMCB9fSlcbiAgICAgKlxuICAgICAqL1xuICAgIHNldFByb3ZpZGVyKHsgcnBjLCBzdHJlYW0sIHNpZ25lciwgcHJvdG9jb2wsIGNvbmZpZywgZm9yZ2VyLCB3YWxsZXQsIHBhY2tlciwgZ2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIsIHJlYWRQcm92aWRlciwgcGFyc2VyUHJvdmlkZXIsIGluamVjdG9yUHJvdmlkZXIsIH0pIHtcbiAgICAgICAgdGhpcy5zZXRScGNQcm92aWRlcihycGMpO1xuICAgICAgICB0aGlzLnNldFN0cmVhbVByb3ZpZGVyKHN0cmVhbSk7XG4gICAgICAgIHRoaXMuc2V0U2lnbmVyUHJvdmlkZXIoc2lnbmVyKTtcbiAgICAgICAgdGhpcy5zZXRGb3JnZXJQcm92aWRlcihmb3JnZXIpO1xuICAgICAgICB0aGlzLnNldFdhbGxldFByb3ZpZGVyKHdhbGxldCk7XG4gICAgICAgIHRoaXMuc2V0UGFja2VyUHJvdmlkZXIocGFja2VyKTtcbiAgICAgICAgdGhpcy5zZXRHbG9iYWxDb25zdGFudHNQcm92aWRlcihnbG9iYWxDb25zdGFudHNQcm92aWRlcik7XG4gICAgICAgIHRoaXMuc2V0UmVhZFByb3ZpZGVyKHJlYWRQcm92aWRlcik7XG4gICAgICAgIHRoaXMuc2V0UGFyc2VyUHJvdmlkZXIocGFyc2VyUHJvdmlkZXIpO1xuICAgICAgICB0aGlzLnNldEluamVjdG9yUHJvdmlkZXIoaW5qZWN0b3JQcm92aWRlcik7XG4gICAgICAgIHRoaXMuX2NvbnRleHQucHJvdG8gPSBwcm90b2NvbDtcbiAgICAgICAgaWYgKGNvbmZpZykge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5zZXRQYXJ0aWFsQ29uZmlnKGNvbmZpZyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldHMgc2lnbmVyIHByb3ZpZGVyIG9uIHRoZSBUZXpvcyBUYXF1aXRvIGluc3RhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgc2lnbmVyIHRvIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBUZXpvcyBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBUZXpvcy5zZXRTaWduZXJQcm92aWRlcihuZXcgSW5NZW1vcnlTaWduZXIuZnJvbVNlY3JldEtleSgnZWRzay4uLicpKVxuICAgICAqXG4gICAgICovXG4gICAgc2V0U2lnbmVyUHJvdmlkZXIoc2lnbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy5zaWduZXIgJiYgdHlwZW9mIHNpZ25lciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc2lnbmVyID0gbmV3IE5vb3BTaWduZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzaWduZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnNpZ25lciA9IHNpZ25lcjtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc2lnbmVyID0gc2lnbmVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIHJwYyBwcm92aWRlciBvbiB0aGUgVGV6b3MgVGFxdWl0byBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgcnBjIHVybCBvciBycGNDbGllbnQgdG8gdXNlIHRvIGludGVyYWN0IHdpdGggdGhlIFRlem9zIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIFRlem9zLnNldFJwY1Byb3ZpZGVyKCdodHRwczovL21haW5uZXQuZWNhZGluZnJhLmNvbS8nKVxuICAgICAqXG4gICAgICovXG4gICAgc2V0UnBjUHJvdmlkZXIocnBjKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcnBjID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhpcy5fcnBjQ2xpZW50ID0gbmV3IFJwY0NsaWVudChycGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJwYyA9PT0gdW5kZWZpbmVkKSA7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcnBjQ2xpZW50ID0gcnBjO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX29wdGlvbnMucnBjID0gdGhpcy5fcnBjQ2xpZW50O1xuICAgICAgICB0aGlzLl9jb250ZXh0LnJwYyA9IHRoaXMuX3JwY0NsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldHMgZm9yZ2VyIHByb3ZpZGVyIG9uIHRoZSBUZXpvcyBUYXF1aXRvIGluc3RhbmNlXG4gICAgICogVGhlIGBMb2NhbEZvcmdlcmAgZnJvbSBgQHRhcXVpdG8vbG9jYWwtZm9yZ2luZ2AgaXMgc2V0IGJ5IGRlZmF1bHQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBmb3JnZXIgdG8gdXNlIHRvIGludGVyYWN0IHdpdGggdGhlIFRlem9zIG5ldHdvcmtcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIFRlem9zLnNldEZvcmdlclByb3ZpZGVyKHRoaXMuZ2V0RmFjdG9yeShScGNGb3JnZXIpKCkpXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRGb3JnZXJQcm92aWRlcihmb3JnZXIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBmb3JnZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmZvcmdlciA9IGZvcmdlcjtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZm9yZ2VyID0gZm9yZ2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuZm9yZ2VyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IGYgPSB0aGlzLmdldEZhY3RvcnkoVGFxdWl0b0xvY2FsRm9yZ2VyKSgpO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5mb3JnZXIgPSBmO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5mb3JnZXIgPSBmO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIHN0cmVhbSBwcm92aWRlciBvbiB0aGUgVGV6b3MgVGFxdWl0byBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgc3RyZWFtIHRvIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBUZXpvcyBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBUZXpvcy5zZXRTdHJlYW1Qcm92aWRlciguLi4pXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRTdHJlYW1Qcm92aWRlcihzdHJlYW0pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzdHJlYW0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gbmV3IFBvbGxpbmdTdWJzY3JpYmVQcm92aWRlcihuZXcgQ29udGV4dChuZXcgUnBjQ2xpZW50KHN0cmVhbSkpKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtID0gcztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3RyZWFtID0gcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygc3RyZWFtICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5zdHJlYW0gPSBzdHJlYW07XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLl9vcHRpb25zLnN0cmVhbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBjb25zdCBzID0gdGhpcy5nZXRGYWN0b3J5KFBvbGxpbmdTdWJzY3JpYmVQcm92aWRlcikoKTtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMuc3RyZWFtID0gcztcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuc3RyZWFtID0gcztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0cyB3YWxsZXQgcHJvdmlkZXIgb24gdGhlIFRlem9zIFRhcXVpdG8gaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIHdhbGxldCB0byB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVGV6b3MgbmV0d29ya1xuICAgICAqXG4gICAgICogQGV4YW1wbGUgVGV6b3Muc2V0V2FsbGV0UHJvdmlkZXIoLi4uKVxuICAgICAqXG4gICAgICovXG4gICAgc2V0V2FsbGV0UHJvdmlkZXIod2FsbGV0KSB7XG4gICAgICAgIGlmICghdGhpcy5fb3B0aW9ucy53YWxsZXQgJiYgdHlwZW9mIHdhbGxldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHcgPSB0aGlzLmdldEZhY3RvcnkoTGVnYWN5V2FsbGV0UHJvdmlkZXIpKCk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLndhbGxldCA9IHc7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LndhbGxldFByb3ZpZGVyID0gdztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygd2FsbGV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy53YWxsZXQgPSB3YWxsZXQ7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LndhbGxldFByb3ZpZGVyID0gd2FsbGV0O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIFBhY2tlciBwcm92aWRlciBvbiB0aGUgVGV6b3MgVGFxdWl0byBpbnN0YW5jZVxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdGlvbnMgcGFja2VyIHRvIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBUZXpvcyBuZXR3b3JrXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZSBUZXpvcy5zZXRQYWNrZXJQcm92aWRlcihuZXcgTWljaGVsQ29kZWNQYWNrZXIoKSlcbiAgICAgKlxuICAgICAqL1xuICAgIHNldFBhY2tlclByb3ZpZGVyKHBhY2tlcikge1xuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMucGFja2VyICYmIHR5cGVvZiBwYWNrZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gdGhpcy5nZXRGYWN0b3J5KFJwY1BhY2tlcikoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQucGFja2VyID0gcDtcbiAgICAgICAgICAgIHRoaXMuX29wdGlvbnMucGFja2VyID0gcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFja2VyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5wYWNrZXIgPSBwYWNrZXI7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLnBhY2tlciA9IHBhY2tlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gU2V0cyBnbG9iYWwgY29uc3RhbnRzIHByb3ZpZGVyIG9uIHRoZSBUZXpvcyBUYXF1aXRvIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBnbG9iYWxDb25zdGFudHNQcm92aWRlciB0byB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVGV6b3MgbmV0d29ya1xuICAgICAqXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBcbiAgICAgKiBjb25zdCBnbG9iYWxDb25zdCA9IG5ldyBEZWZhdWx0R2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIoKTtcbiAgICAgKiBnbG9iYWxDb25zdC5sb2FkR2xvYmFsQ29uc3RhbnQoe1xuICAgICAqICBcImV4cHJ1dTVCVGRXN2FqcUo5WFBURjNrZ2NWNzhwUmlhQlczR3EzMW1ncDNXU1lqalVCWXhyZVwiOiB7IHByaW06IFwiaW50XCIgfSxcbiAgICAgKiAgLy8gLi4uXG4gICAgICogfSlcbiAgICAgKiBUZXpvcy5zZXRHbG9iYWxDb25zdGFudHNQcm92aWRlcihnbG9iYWxDb25zdCk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRHbG9iYWxDb25zdGFudHNQcm92aWRlcihnbG9iYWxDb25zdGFudHNQcm92aWRlcikge1xuICAgICAgICBpZiAoIXRoaXMuX29wdGlvbnMuZ2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIgJiYgdHlwZW9mIGdsb2JhbENvbnN0YW50c1Byb3ZpZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgY29uc3QgZyA9IG5ldyBOb29wR2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIoKTtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRleHQuZ2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIgPSBnO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5nbG9iYWxDb25zdGFudHNQcm92aWRlciA9IGc7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbENvbnN0YW50c1Byb3ZpZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5nbG9iYWxDb25zdGFudHNQcm92aWRlciA9IGdsb2JhbENvbnN0YW50c1Byb3ZpZGVyO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5nbG9iYWxDb25zdGFudHNQcm92aWRlciA9IGdsb2JhbENvbnN0YW50c1Byb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIHJlYWQgcHJvdmlkZXIgb24gdGhlIFRlem9zIFRhcXVpdG8gaW5zdGFuY2VcbiAgICAgKiBCeSBkZWZhdWx0IHJlYWRzIGFyZSBkb25lIGZyb20gdGhlIFJQQyB1c2lnbiB0aGUgUnBjUmVhZEFkYXB0ZXIgY2xhc3MsIHRoaXMgY2FuIGJlIG92ZXJyaWRkZW4gdG8gcmVhZCBmcm9tIGFuIGluZGV4ZXIgdGhhdCBpbXBsZW1lbnRzIHRoZSBUelJlYWRQcm92aWRlciBpbnRlcmZhY2VcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zIFR6UmVhZFByb3ZpZGVyIHRvIHVzZSB0byBpbnRlcmFjdCB3aXRoIHRoZSBUZXpvcyBuZXR3b3JrXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRSZWFkUHJvdmlkZXIocmVhZFByb3ZpZGVyKSB7XG4gICAgICAgIGNvbnN0IHJlYWRQID0gcmVhZFByb3ZpZGVyID8gcmVhZFByb3ZpZGVyIDogbmV3IFJwY1JlYWRBZGFwdGVyKHRoaXMuX2NvbnRleHQucnBjKTtcbiAgICAgICAgdGhpcy5fb3B0aW9ucy5yZWFkUHJvdmlkZXIgPSByZWFkUDtcbiAgICAgICAgdGhpcy5fY29udGV4dC5yZWFkUHJvdmlkZXIgPSByZWFkUDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFNldHMgcGFyc2VyIHByb3ZpZGVyIG9uIHRoZSBUZXpvcyBUYXF1aXRvIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBwYXJzZXJQcm92aWRlciB0byB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVGV6b3MgbmV0d29ya1xuICAgICAqXG4gICAgICovXG4gICAgc2V0UGFyc2VyUHJvdmlkZXIocGFyc2VyUHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLnBhcnNlclByb3ZpZGVyICYmIHR5cGVvZiBwYXJzZXJQcm92aWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IHAgPSBuZXcgTWljaGVsQ29kZWNQYXJzZXIodGhpcy5fY29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnBhcnNlciA9IHA7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLnBhcnNlclByb3ZpZGVyID0gcDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgcGFyc2VyUHJvdmlkZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9jb250ZXh0LnBhcnNlciA9IHBhcnNlclByb3ZpZGVyO1xuICAgICAgICAgICAgdGhpcy5fb3B0aW9ucy5wYXJzZXJQcm92aWRlciA9IHBhcnNlclByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBTZXRzIGluamVjdG9yIHByb3ZpZGVyIG9uIHRoZSBUZXpvcyBUYXF1aXRvIGluc3RhbmNlXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyBJbmplY3RvciB0byB1c2UgdG8gaW50ZXJhY3Qgd2l0aCB0aGUgVGV6b3MgbmV0d29yayBieSBkZWZhdWx0IFJwY0luamVjdG9yXG4gICAgICpcbiAgICAgKi9cbiAgICBzZXRJbmplY3RvclByb3ZpZGVyKGluamVjdG9yUHJvdmlkZXIpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9vcHRpb25zLmluamVjdG9yUHJvdmlkZXIgJiYgdHlwZW9mIGluamVjdG9yUHJvdmlkZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBpID0gbmV3IFJwY0luamVjdG9yKHRoaXMuX2NvbnRleHQpO1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5pbmplY3RvciA9IGk7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmluamVjdG9yUHJvdmlkZXIgPSBpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpbmplY3RvclByb3ZpZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhpcy5fY29udGV4dC5pbmplY3RvciA9IGluamVjdG9yUHJvdmlkZXI7XG4gICAgICAgICAgICB0aGlzLl9vcHRpb25zLmluamVjdG9yUHJvdmlkZXIgPSBpbmplY3RvclByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBQcm92aWRlIGFjY2VzcyB0byB0ZXpvcyBhY2NvdW50IG1hbmFnZW1lbnRcbiAgICAgKi9cbiAgICBnZXQgdHooKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LnR6O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUHJvdmlkZSBhY2Nlc3MgdG8gc21hcnQgY29udHJhY3QgdXRpbGl0aWVzXG4gICAgICovXG4gICAgZ2V0IGNvbnRyYWN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGV4dC5jb250cmFjdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFByb3ZpZGUgYWNjZXNzIHRvIHRlem9zIG9wZXJhdGlvbiBwcmVwYXJhdGlvbiB1dGlsaXRpZXNcbiAgICAgKi9cbiAgICBnZXQgcHJlcGFyZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQucHJlcGFyZTtcbiAgICB9XG4gICAgZ2V0IHdhbGxldCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dhbGxldDtcbiAgICB9XG4gICAgZ2V0IG9wZXJhdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQub3BlcmF0aW9uRmFjdG9yeTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFByb3ZpZGUgYWNjZXNzIHRvIG9wZXJhdGlvbiBlc3RpbWF0aW9uIHV0aWxpdGllc1xuICAgICAqL1xuICAgIGdldCBlc3RpbWF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQuZXN0aW1hdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBkZXNjcmlwdGlvbiBQcm92aWRlIGFjY2VzcyB0byBzdHJlYW1pbmcgdXRpbGl0aWVzIGJhY2tlZCBieSBhbiBzdHJlYW1lciBpbXBsZW1lbnRhdGlvblxuICAgICAqL1xuICAgIGdldCBzdHJlYW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LnN0cmVhbTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFByb3ZpZGUgYWNjZXNzIHRvIHRoZSBjdXJyZW50bHkgdXNlZCBycGMgY2xpZW50XG4gICAgICovXG4gICAgZ2V0IHJwYygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbnRleHQucnBjO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gUHJvdmlkZSBhY2Nlc3MgdG8gdGhlIGN1cnJlbnRseSB1c2VkIHNpZ25lclxuICAgICAqL1xuICAgIGdldCBzaWduZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0LnNpZ25lcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGRlc2NyaXB0aW9uIFByb3ZpZGUgYWNjZXNzIHRvIHRoZSBjdXJyZW50bHkgdXNlZCBnbG9iYWxDb25zdGFudHNQcm92aWRlclxuICAgICAqL1xuICAgIGdldCBnbG9iYWxDb25zdGFudHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb250ZXh0Lmdsb2JhbENvbnN0YW50c1Byb3ZpZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gQWxsb3cgdG8gYWRkIGEgbW9kdWxlIHRvIHRoZSBUZXpvc1Rvb2xraXQgaW5zdGFuY2UuIFRoaXMgbWV0aG9kIGFkZHMgdGhlIGFwcHJvcHJpYXRlIFByb3ZpZGVycyhzKSByZXF1aXJlZCBieSB0aGUgbW9kdWxlIHRvIHRoZSBpbnRlcm5hbCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIG1vZHVsZSBleHRlbnNpb24gdG8gYWRkIHRvIHRoZSBUZXpvc1Rvb2xraXQgaW5zdGFuY2VcbiAgICAgKlxuICAgICAqIEBleGFtcGxlIFRlem9zLmFkZEV4dGVuc2lvbihuZXcgVHppcDE2TW9kdWxlKCkpO1xuICAgICAqL1xuICAgIGFkZEV4dGVuc2lvbihtb2R1bGUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkobW9kdWxlKSkge1xuICAgICAgICAgICAgbW9kdWxlLmZvckVhY2goKGV4dGVuc2lvbikgPT4gZXh0ZW5zaW9uLmNvbmZpZ3VyZUNvbnRleHQodGhpcy5fY29udGV4dCkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbW9kdWxlLmNvbmZpZ3VyZUNvbnRleHQodGhpcy5fY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RmFjdG9yeShjdG9yKSB7XG4gICAgICAgIHJldHVybiAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHRoaXMuX2NvbnRleHQsIC4uLmFyZ3MpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAZGVzY3JpcHRpb24gR2V0cyBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgdmVyc2lvbiBvZiBUYXF1aXRvIGxpYnJhcnkgYW5kIGdpdCBzaGEgb2YgdGhlIGNvbW1pdCB0aGlzIGxpYnJhcnkgaXMgY29tcGlsZWQgZnJvbVxuICAgICAqL1xuICAgIGdldFZlcnNpb25JbmZvKCkge1xuICAgICAgICByZXR1cm4gVkVSU0lPTjtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJhbGxvdE9wZXJhdGlvbiwgQmF0Y2hPcGVyYXRpb24sIEJpZ01hcEFic3RyYWN0aW9uLCBDT1NUX1BFUl9CWVRFLCBDaGFpbklkcywgQ29tcG9zaXRlRm9yZ2VyLCBDb250ZXh0LCBDb250cmFjdEFic3RyYWN0aW9uLCBDb250cmFjdE1ldGhvZCwgQ29udHJhY3RNZXRob2RPYmplY3QsIENvbnRyYWN0VmlldywgREVGQVVMVF9GRUUsIERFRkFVTFRfR0FTX0xJTUlULCBERUZBVUxUX1NNQVJUX0NPTlRSQUNUX01FVEhPRF9OQU1FLCBERUZBVUxUX1NUT1JBR0VfTElNSVQsIERlZmF1bHRHbG9iYWxDb25zdGFudHNQcm92aWRlciwgRGVsZWdhdGVPcGVyYXRpb24sIERlbGVnYXRpb25XYWxsZXRPcGVyYXRpb24sIERyYWluRGVsZWdhdGVPcGVyYXRpb24sIEVzdGltYXRlLCBHbG9iYWxDb25zdGFudE5vdEZvdW5kLCBJbnZhbGlkQmFsYW5jZUVycm9yLCBJbnZhbGlkQ29kZVBhcmFtZXRlciwgSW52YWxpZERlbGVnYXRpb25Tb3VyY2UsIEludmFsaWRFc3RpbWF0ZVZhbHVlRXJyb3IsIEludmFsaWRJbml0UGFyYW1ldGVyLCBJbnZhbGlkUGFyYW1ldGVyRXJyb3IsIEludmFsaWRWaWV3U2ltdWxhdGlvbkNvbnRleHQsIExlZ2FjeVdhbGxldFByb3ZpZGVyLCBNQU5BR0VSX0xBTUJEQSwgTWljaGVsQ29kZWNQYWNrZXIsIE1pY2hlbENvZGVjUGFyc2VyLCBOb29wUGFyc2VyLCBPYnNlcnZhYmxlU3Vic2NyaXB0aW9uLCBPcGVyYXRpb24sIE9wZXJhdGlvbkJhdGNoLCBPcmlnaW5hdGlvbk9wZXJhdGlvbiwgT3JpZ2luYXRpb25QYXJhbWV0ZXJFcnJvciwgT3JpZ2luYXRpb25XYWxsZXRPcGVyYXRpb24sIFBvbGxpbmdTdWJzY3JpYmVQcm92aWRlciwgUHJlcGFyZVByb3ZpZGVyLCBQcm90b2NvbHMsIFJQQ0VzdGltYXRlUHJvdmlkZXIsIFJldmVhbEVzdGltYXRlRXJyb3IsIFJldmVhbE9wZXJhdGlvbkVycm9yLCBScGNGb3JnZXIsIFJwY0luamVjdG9yLCBScGNQYWNrZXIsIFJwY1JlYWRBZGFwdGVyLCBTYXBsaW5nU3RhdGVBYnN0cmFjdGlvbiwgVGFxdWl0b0xvY2FsRm9yZ2VyLCBUZXpvc09wZXJhdGlvbkVycm9yLCBUZXpvc1ByZWFwcGx5RmFpbHVyZUVycm9yLCBUZXpvc1Rvb2xraXQsIFRyYW5zYWN0aW9uT3BlcmF0aW9uLCBUcmFuc2FjdGlvbldhbGxldE9wZXJhdGlvbiwgVW5jb25maWd1cmVkR2xvYmFsQ29uc3RhbnRzUHJvdmlkZXJFcnJvciwgVklFV19MQU1CREEsIFZpZXdTaW11bGF0aW9uRXJyb3IsIFdhbGxldCwgV2FsbGV0T3BlcmF0aW9uLCBXYWxsZXRPcGVyYXRpb25CYXRjaCwgY29tcG9zZSwgY3JlYXRlQWN0aXZhdGlvbk9wZXJhdGlvbiwgY3JlYXRlQmFsbG90T3BlcmF0aW9uLCBjcmVhdGVEcmFpbkRlbGVnYXRlT3BlcmF0aW9uLCBjcmVhdGVJbmNyZWFzZVBhaWRTdG9yYWdlT3BlcmF0aW9uLCBjcmVhdGVPcmlnaW5hdGlvbk9wZXJhdGlvbiwgY3JlYXRlUHJvcG9zYWxzT3BlcmF0aW9uLCBjcmVhdGVSZWdpc3RlckRlbGVnYXRlT3BlcmF0aW9uLCBjcmVhdGVSZWdpc3Rlckdsb2JhbENvbnN0YW50T3BlcmF0aW9uLCBjcmVhdGVSZXZlYWxPcGVyYXRpb24sIGNyZWF0ZVNldERlbGVnYXRlT3BlcmF0aW9uLCBjcmVhdGVTbWFydFJvbGx1cEFkZE1lc3NhZ2VzT3BlcmF0aW9uLCBjcmVhdGVTbWFydFJvbGx1cE9yaWdpbmF0ZU9wZXJhdGlvbiwgY3JlYXRlVHJhbnNmZXJPcGVyYXRpb24sIGNyZWF0ZVRyYW5zZmVyVGlja2V0T3BlcmF0aW9uLCBjcmVhdGVVcGRhdGVDb25zZW5zdXNLZXlPcGVyYXRpb24sIGRlZmF1bHRDb25maWdDb25maXJtYXRpb24sIGdldFJldmVhbEdhc0xpbWl0LCBwcm90b2NvbHMsIHNtYXJ0Q29udHJhY3RBYnN0cmFjdGlvblNlbWFudGljLCB2YWxpZGF0ZUFuZEV4dHJhY3RGYWlsd2l0aCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFxdWl0by5lczYuanMubWFwXG4iXSwibmFtZXMiOlsiT3BLaW5kIiwiUnBjQ2xpZW50IiwiSHR0cFJlc3BvbnNlRXJyb3IiLCJTVEFUVVNfQ09ERSIsIlRlem9zVG9vbGtpdENvbmZpZ0Vycm9yIiwiUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIiwiUnBjRXJyb3IiLCJUYXF1aXRvRXJyb3IiLCJOZXR3b3JrRXJyb3IiLCJJbnZhbGlkT3BlcmF0aW9uSGFzaEVycm9yIiwiSW52YWxpZEFkZHJlc3NFcnJvciIsIkludmFsaWRPcGVyYXRpb25LaW5kRXJyb3IiLCJJbnZhbGlkT3BlcmF0aW9uS2luZEVycm9yJDEiLCJJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IiLCJJbnZhbGlkVmlld1BhcmFtZXRlckVycm9yIiwiRGVwcmVjYXRpb25FcnJvciIsIkludmFsaWRDaGFpbklkRXJyb3IiLCJQdWJsaWNLZXlOb3RGb3VuZEVycm9yIiwiSW52YWxpZEFtb3VudEVycm9yIiwiSW52YWxpZEtleUhhc2hFcnJvciIsIk9ic2VydmFibGUiLCJSZXBsYXlTdWJqZWN0IiwiQmVoYXZpb3JTdWJqZWN0IiwidGhyb3dFcnJvciIsImRlZmVyIiwicmFuZ2UiLCJvZiIsIkVNUFRZIiwiY29tYmluZUxhdGVzdCIsImZyb20iLCJjb25jYXQiLCJTdWJqZWN0IiwiTkVWRVIiLCJ0aW1lciIsInN3aXRjaE1hcCIsInRpbWVvdXQiLCJjb25jYXRNYXAiLCJlbmRXaXRoIiwidGFwIiwic2hhcmVSZXBsYXkiLCJtYXAiLCJmaWx0ZXIiLCJmaXJzdCIsImNhdGNoRXJyb3IiLCJzaGFyZSIsImRpc3RpbmN0VW50aWxDaGFuZ2VkIiwidGFrZVdoaWxlIiwic3RhcnRXaXRoIiwibWVyZ2VNYXAiLCJ0YWtlVW50aWwiLCJyZXRyeSIsInBsdWNrIiwiZGlzdGluY3RVbnRpbEtleUNoYW5nZWQiLCJwdWJsaXNoIiwicmVmQ291bnQiLCJTY2hlbWEiLCJQYXJhbWV0ZXJTY2hlbWEiLCJWaWV3U2NoZW1hIiwiRXZlbnRTY2hlbWEiLCJNaWNoZWxzb25NYXAiLCJVbml0VmFsdWUiLCJmb3JtYXQiLCJ2YWxpZGF0ZU9wZXJhdGlvbiIsIlZhbGlkYXRpb25SZXN1bHQiLCJ2YWxpZGF0ZUFkZHJlc3MiLCJpbnZhbGlkRGV0YWlsIiwidmFsaWRhdGVDb250cmFjdEFkZHJlc3MiLCJ2YWxpZGF0ZUNoYWluIiwidmFsaWRhdGVLZXlIYXNoIiwiSW52YWxpZEtleUhhc2hFcnJvciQxIiwiZW5jb2RlRXhwciIsIkJpZ051bWJlciIsIkJpZ051bWJlciQxIiwiUGFyc2VyIiwicGFja0RhdGFCeXRlcyIsIkxvY2FsRm9yZ2VyIiwiX19yZXN0IiwicyIsImUiLCJ0IiwicCIsIk9iamVjdCIsInByb3RvdHlwZSIsImhhc093blByb3BlcnR5IiwiY2FsbCIsImluZGV4T2YiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJpIiwibGVuZ3RoIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfX2F3YWl0ZXIiLCJ0aGlzQXJnIiwiX2FyZ3VtZW50cyIsIlAiLCJnZW5lcmF0b3IiLCJhZG9wdCIsInZhbHVlIiwicmVzb2x2ZSIsIlByb21pc2UiLCJyZWplY3QiLCJmdWxmaWxsZWQiLCJzdGVwIiwibmV4dCIsInJlamVjdGVkIiwicmVzdWx0IiwiZG9uZSIsInRoZW4iLCJhcHBseSIsIl9fY2xhc3NQcml2YXRlRmllbGRHZXQiLCJyZWNlaXZlciIsInN0YXRlIiwia2luZCIsImYiLCJUeXBlRXJyb3IiLCJoYXMiLCJnZXQiLCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0Iiwic2V0IiwiU3VwcHJlc3NlZEVycm9yIiwiZXJyb3IiLCJzdXBwcmVzc2VkIiwibWVzc2FnZSIsIkVycm9yIiwibmFtZSIsImZvcm1hdEVycm9yTWVzc2FnZSIsInN0cmluZ1RvUmVwbGFjZSIsImJvZHkiLCJKU09OIiwicGFyc2UiLCJtc2ciLCJuZXdCb2R5Iiwic3RyaW5naWZ5IiwiaWQiLCJyZXBsYWNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsInVybCIsIlJwY0luamVjdG9yIiwiY29uc3RydWN0b3IiLCJjb250ZXh0IiwiaW5qZWN0Iiwic2lnbmVkT3BlcmF0aW9uQnl0ZXMiLCJoYXNoIiwicnBjIiwiaW5qZWN0T3BlcmF0aW9uIiwic3RyaW5nVG9TdHJpcCIsImluY2x1ZGVzIiwiVW5jb25maWd1cmVkU2lnbmVyRXJyb3IiLCJOb29wU2lnbmVyIiwicHVibGljS2V5IiwicHVibGljS2V5SGFzaCIsInNlY3JldEtleSIsInNpZ24iLCJfYnl0ZXMiLCJfd2F0ZXJtYXJrIiwiY3JlYXRlT2JzZXJ2YWJsZUZyb21TdWJzY3JpcHRpb24iLCJzdWIiLCJzdWJzY3JpYmVyIiwib24iLCJkYXRhIiwiY29tcGxldGUiLCJjbG9zZSIsIkRFRkFVTFRfR0FTX0xJTUlUIiwiREVMRUdBVElPTiIsIk9SSUdJTkFUSU9OIiwiVFJBTlNGRVIiLCJSRVZFQUxfVFoxIiwiUkVWRUFMX1RaMiIsIlJFVkVBTF9UWjMiLCJSRVZFQUxfVFo0IiwiREVGQVVMVF9GRUUiLCJSRVZFQUwiLCJERUZBVUxUX1NUT1JBR0VfTElNSVQiLCJDT1NUX1BFUl9CWVRFIiwiUHJvdG9jb2xzIiwicHJvdG9jb2xzIiwiUHQyNG00eGkiLCJQc0JBQlk1SCIsIlBzQmFieU0xIiwiUHNDQVJUSEEiLCJQc0RFTFBIMSIsIlB0RWRvMlprIiwiUHNGTG9yZW5hIiwiUHRHUkFOQURzIiwiUHRIYW5nejIiLCJQc2lUaGFDYSIsIlBzaXRoYWNhMiIsIlB0SmFrYXJ0MiIsIlB0S2F0aG1hbiIsIlB0TGltYVB0TCIsIlB0TXVtYmFpMiIsIlB0TmFpcm9iaSIsIlByb3hmb3JkWSIsIlByb3RvQUxwaGEiLCJDaGFpbklkcyIsImdldFJldmVhbEdhc0xpbWl0IiwiYWRkcmVzcyIsIk1hdGgiLCJyb3VuZCIsImdldFJldmVhbEdhc0xpbWl0SW50ZXJuYWwiLCJzdWJzdHJpbmciLCJJbnZhbGlkUGFyYW1ldGVyRXJyb3IiLCJzbWFydENvbnRyYWN0TWV0aG9kTmFtZSIsInNpZ3MiLCJpbnZhbGlkUGFyYW1zIiwiSW52YWxpZERlbGVnYXRpb25Tb3VyY2UiLCJzb3VyY2UiLCJJbnZhbGlkQ29kZVBhcmFtZXRlciIsIkludmFsaWRJbml0UGFyYW1ldGVyIiwiVmlld1NpbXVsYXRpb25FcnJvciIsInZpZXdOYW1lIiwiZmFpbFdpdGgiLCJjYXVzZSIsInZhbGlkYXRlQW5kRXh0cmFjdEZhaWx3aXRoIiwiaXNKc29uU3RyaW5nIiwicGFyc2VkRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJ3aXRoIiwic3RyIiwiSW52YWxpZFZpZXdTaW11bGF0aW9uQ29udGV4dCIsImluZm8iLCJSZXZlYWxPcGVyYXRpb25FcnJvciIsIk9yaWdpbmF0aW9uUGFyYW1ldGVyRXJyb3IiLCJJbnZhbGlkQmFsYW5jZUVycm9yIiwiY3JlYXRlQWN0aXZhdGlvbk9wZXJhdGlvbiIsInBraCIsInNlY3JldCIsIkFDVElWQVRJT04iLCJjcmVhdGVPcmlnaW5hdGlvbk9wZXJhdGlvbiIsImNvZGUiLCJpbml0IiwiYmFsYW5jZSIsImRlbGVnYXRlIiwic3RvcmFnZSIsImZlZSIsImdhc0xpbWl0Iiwic3RvcmFnZUxpbWl0IiwibXV0ZXoiLCJ1bmRlZmluZWQiLCJjb250cmFjdFN0b3JhZ2UiLCJzdG9yYWdlVHlwZSIsImZpbmQiLCJwcmltIiwiYXJncyIsInNjaGVtYSIsIkVuY29kZSIsInNjcmlwdCIsImlzTmFOIiwiTnVtYmVyIiwib3BlcmF0aW9uIiwiZ2FzX2xpbWl0Iiwic3RvcmFnZV9saW1pdCIsInRvU3RyaW5nIiwiY3JlYXRlVHJhbnNmZXJPcGVyYXRpb24iLCJ0byIsImFtb3VudCIsInBhcmFtZXRlciIsIlRSQU5TQUNUSU9OIiwiZGVzdGluYXRpb24iLCJwYXJhbWV0ZXJzIiwiY3JlYXRlU2V0RGVsZWdhdGVPcGVyYXRpb24iLCJjcmVhdGVSZWdpc3RlckRlbGVnYXRlT3BlcmF0aW9uIiwiY3JlYXRlUmV2ZWFsT3BlcmF0aW9uIiwicHVibGljX2tleSIsImNyZWF0ZVJlZ2lzdGVyR2xvYmFsQ29uc3RhbnRPcGVyYXRpb24iLCJSRUdJU1RFUl9HTE9CQUxfQ09OU1RBTlQiLCJjcmVhdGVUcmFuc2ZlclRpY2tldE9wZXJhdGlvbiIsInRpY2tldENvbnRlbnRzIiwidGlja2V0VHkiLCJ0aWNrZXRUaWNrZXRlciIsInRpY2tldEFtb3VudCIsImVudHJ5cG9pbnQiLCJUUkFOU0ZFUl9USUNLRVQiLCJ0aWNrZXRfY29udGVudHMiLCJ0aWNrZXRfdHkiLCJ0aWNrZXRfdGlja2V0ZXIiLCJ0aWNrZXRfYW1vdW50IiwiY3JlYXRlSW5jcmVhc2VQYWlkU3RvcmFnZU9wZXJhdGlvbiIsIklOQ1JFQVNFX1BBSURfU1RPUkFHRSIsImNyZWF0ZURyYWluRGVsZWdhdGVPcGVyYXRpb24iLCJjb25zZW5zdXNfa2V5IiwiRFJBSU5fREVMRUdBVEUiLCJjcmVhdGVCYWxsb3RPcGVyYXRpb24iLCJwcm9wb3NhbCIsImJhbGxvdCIsIkJBTExPVCIsImNyZWF0ZVByb3Bvc2Fsc09wZXJhdGlvbiIsInByb3Bvc2FscyIsIlBST1BPU0FMUyIsImNyZWF0ZVVwZGF0ZUNvbnNlbnN1c0tleU9wZXJhdGlvbiIsInBrIiwiVVBEQVRFX0NPTlNFTlNVU19LRVkiLCJjcmVhdGVTbWFydFJvbGx1cEFkZE1lc3NhZ2VzT3BlcmF0aW9uIiwiU01BUlRfUk9MTFVQX0FERF9NRVNTQUdFUyIsImNyZWF0ZVNtYXJ0Um9sbHVwT3JpZ2luYXRlT3BlcmF0aW9uIiwicHZtS2luZCIsImtlcm5lbCIsInBhcmFtZXRlcnNUeXBlIiwiU01BUlRfUk9MTFVQX09SSUdJTkFURSIsInB2bV9raW5kIiwicGFyYW1ldGVyc190eSIsImF0dGFjaEtpbmQiLCJvcCIsImFzc2lnbiIsImZpbmRXaXRoS2luZCIsImFyciIsImZvdW5kIiwiaXNLaW5kIiwiaXNPcFdpdGhGZWUiLCJpc09wUmVxdWlyZVJldmVhbCIsImhhc01ldGFkYXRhIiwiaGFzTWV0YWRhdGFXaXRoUmVzdWx0IiwibWV0YWRhdGEiLCJoYXNNZXRhZGF0YVdpdGhJbnRlcm5hbE9wZXJhdGlvblJlc3VsdCIsImlzRXJyb3JXaXRoTWVzc2FnZSIsIlRlem9zT3BlcmF0aW9uRXJyb3IiLCJlcnJvcnMiLCJlcnJvckRldGFpbHMiLCJvcGVyYXRpb25zV2l0aFJlc3VsdHMiLCJsYXN0RXJyb3IiLCJzdHJpbmciLCJpbnQiLCJUZXpvc1ByZWFwcGx5RmFpbHVyZUVycm9yIiwiZmxhdHRlbk9wZXJhdGlvblJlc3VsdCIsInJlc3BvbnNlIiwicmVzdWx0cyIsInJldHVybmVkUmVzdWx0cyIsImoiLCJjb250ZW50cyIsImNvbnRlbnQiLCJwdXNoIiwib3BlcmF0aW9uX3Jlc3VsdCIsImludGVybmFsX29wZXJhdGlvbl9yZXN1bHRzIiwiZm9yRWFjaCIsIngiLCJmbGF0dGVuRXJyb3JzIiwiaW50ZXJuYWxSZXN1bHQiLCJPcmlnaW5hdGlvbk9wZXJhdGlvbkVycm9yIiwiSW52YWxpZEVzdGltYXRlVmFsdWVFcnJvciIsIkludmFsaWRDb25maXJtYXRpb25Db3VudEVycm9yIiwiaW52YWxpZENvbmZpcm1hdGlvbnMiLCJDb25maXJtYXRpb25UaW1lb3V0RXJyb3IiLCJSUENSZXNwb25zZUVycm9yIiwiT3BlcmF0aW9uIiwiaW5jbHVkZWRJbkJsb2NrIiwiX2ZvdW5kQXQiLCJyYXciLCJfcG9sbGluZ0NvbmZpZyQiLCJjdXJyZW50SGVhZCQiLCJwaXBlIiwiY29uZmlnIiwiZWFjaCIsInN0cmVhbSIsInN1YnNjcmliZUJsb2NrIiwibmV3SGVhZCIsIl9hIiwiX2IiLCJwcmV2SGVhZCIsImxhc3RIZWFkIiwiaGVhZGVyIiwibGV2ZWwiLCJyZWFkUHJvdmlkZXIiLCJnZXRCbG9jayIsImNvbmZpcm1lZCQiLCJoZWFkIiwib3BlcmF0aW9ucyIsIlBPU0lUSVZFX0lORklOSVRZIiwiVkFMSUQiLCJzdWJzY3JpYmUiLCJyZXZlYWxPcGVyYXRpb24iLCJyZXZlYWxTdGF0dXMiLCJjb25maXJtYXRpb24iLCJjb25maXJtYXRpb25zIiwiZGVmYXVsdENvbmZpcm1hdGlvbkNvdW50IiwiY29uZmlybWF0aW9uUG9sbGluZ1RpbWVvdXRTZWNvbmQiLCJjb25mIiwiXyIsIkJhdGNoT3BlcmF0aW9uIiwicGFyYW1zIiwic3VtUHJvcCIsInByb3AiLCJyZWR1Y2UiLCJwcmV2IiwiY3VycmVudCIsImdldE9yaWdpbmF0ZWRDb250cmFjdEFkZHJlc3NlcyIsIm9yaWdpbmF0aW9uT3BSZXN1bHRzIiwiYWRkcmVzc2VzIiwicmVzIiwib3JpZ2luYXRlZF9jb250cmFjdHMiLCJCQVRDSF9LSU5EUyIsIm9wUmVzdWx0IiwiY29uc3VtZWRHYXMiLCJERUNJTUFMX1BMQUNFUyIsIlJPVU5ESU5HX01PREUiLCJST1VORF9VUCIsImNvbnN1bWVkTWlsbGlHYXMiLCJkaXZpZGVkQnkiLCJTdHJpbmciLCJzdG9yYWdlRGlmZiIsIlByb3ZpZGVyIiwic2lnbmVyIiwiZm9yZ2UiLCJvcE9iIiwiYnJhbmNoIiwicHJvdG9jb2wiLCJjb3VudGVyIiwiZm9yZ2VkQnl0ZXMiLCJmb3JnZXIiLCJvcGJ5dGVzIiwiZXN0aW1hdGUiLCJlc3RpbWF0b3IiLCJyZXN0IiwiY2FsY3VsYXRlZEZlZSIsImNhbGN1bGF0ZWRHYXMiLCJjYWxjdWxhdGVkU3RvcmFnZSIsImVzdGltYXRpb24iLCJzdWdnZXN0ZWRGZWVNdXRleiIsImdldFJQQ09wIiwicGFyYW0iLCJwYXJzZXIiLCJwcmVwYXJlQ29kZU9yaWdpbmF0aW9uIiwicnVuT3BlcmF0aW9uIiwib3BSZXNwb25zZSIsImNsb25lIiwic2ltdWxhdGUiLCJzaW11bGF0ZU9wZXJhdGlvbiIsImlzUmV2ZWFsT3BOZWVkZWQiLCJpc0FjY291bnRSZXZlYWxSZXF1aXJlZCIsImlzUmV2ZWFsUmVxdWlyZWRGb3JPcFR5cGUiLCJpc0FjY291bnRSZXZlYWxlZCIsIm9wUmVxdWlyZVJldmVhbCIsInNpZ25BbmRJbmplY3QiLCJzaWduZWQiLCJVaW50OEFycmF5Iiwic2J5dGVzIiwic2lnbmF0dXJlIiwicHJlZml4U2lnIiwicHJlYXBwbHlPcGVyYXRpb25zIiwiaW5qZWN0b3IiLCJXYWxsZXRPcGVyYXRpb25CYXRjaCIsIndhbGxldFByb3ZpZGVyIiwid2l0aFRyYW5zZmVyIiwidG9WYWxpZGF0aW9uIiwid2l0aENvbnRyYWN0Q2FsbCIsIm9wdGlvbnMiLCJ0b1RyYW5zZmVyUGFyYW1zIiwid2l0aERlbGVnYXRpb24iLCJkZWxlZ2F0ZVZhbGlkYXRpb24iLCJ3aXRoT3JpZ2luYXRpb24iLCJ3aXRoSW5jcmVhc2VQYWlkU3RvcmFnZSIsImRlc3RpbmF0aW9uVmFsaWRhdGlvbiIsIm1hcE9wZXJhdGlvbiIsIm1hcFRyYW5zZmVyUGFyYW1zVG9XYWxsZXRQYXJhbXMiLCJtYXBPcmlnaW5hdGVQYXJhbXNUb1dhbGxldFBhcmFtcyIsIm1hcERlbGVnYXRlUGFyYW1zVG9XYWxsZXRQYXJhbXMiLCJtYXBJbmNyZWFzZVBhaWRTdG9yYWdlV2FsbGV0UGFyYW1zIiwic2VuZCIsIm9wcyIsIm9wSGFzaCIsInNlbmRPcGVyYXRpb25zIiwib3BlcmF0aW9uRmFjdG9yeSIsImNyZWF0ZUJhdGNoT3BlcmF0aW9uIiwiV2FsbGV0Iiwid2FsbGV0Q29tbWFuZCIsImZvcmNlUmVmZXRjaCIsIl9wa2giLCJnZXRQS0giLCJfcGsiLCJnZXRQSyIsIm9yaWdpbmF0ZSIsIm1hcHBlZFBhcmFtcyIsInNldERlbGVnYXRlIiwiY3JlYXRlRGVsZWdhdGlvbk9wZXJhdGlvbiIsInNpZ25GYWlsaW5nTm9vcCIsIkZBSUxJTkdfTk9PUCIsImFyYml0cmFyeSIsImdldEJsb2NrSGFzaCIsImJhc2VkT25CbG9jayIsImJ5dGVzIiwic2lnbmVkQ29udGVudCIsInJlZ2lzdGVyRGVsZWdhdGUiLCJ0cmFuc2ZlciIsImNyZWF0ZVRyYW5zYWN0aW9uT3BlcmF0aW9uIiwiaW5jcmVhc2VQYWlkU3RvcmFnZSIsImJhdGNoIiwiYXQiLCJjb250cmFjdEFic3RyYWN0aW9uQ29tcG9zZXIiLCJhZGRyZXNzVmFsaWRhdGlvbiIsIndpdGhFeHRlbnNpb25zIiwiZ2V0U2NyaXB0IiwiZW50cnlwb2ludHMiLCJnZXRFbnRyeXBvaW50cyIsImFicyIsIkNvbnRyYWN0QWJzdHJhY3Rpb24iLCJjb250cmFjdCIsInJlY2VpcHRGcm9tT3BlcmF0aW9uIiwiQUxMT0NBVElPTl9CVVJOIiwiT1JJR0lOQVRJT05fQlVSTiIsIm9wZXJhdGlvblJlc3VsdHMiLCJ0b3RhbE1pbGxpR2FzIiwidG90YWxTdG9yYWdlIiwidG90YWxGZWUiLCJ0b3RhbE9yaWdpbmF0aW9uQnVybiIsInRvdGFsQWxsb2NhdGlvbkJ1cm4iLCJ0b3RhbFBhaWRTdG9yYWdlRGlmZiIsInBsdXMiLCJjb25zdW1lZF9taWxsaWdhcyIsInBhaWRfc3RvcmFnZV9zaXplX2RpZmYiLCJ0b3RhbEdhcyIsInRvdGFsU3RvcmFnZUJ1cm4iLCJtdWx0aXBsaWVkQnkiLCJDb25maXJtYXRpb25VbmRlZmluZWRFcnJvciIsIk9ic2VydmFibGVFcnJvciIsIk1BWF9CUkFOQ0hfQU5DRVNUT1JTIiwiV2FsbGV0T3BlcmF0aW9uIiwiX29wZXJhdGlvblJlc3VsdCIsInRvUHJvbWlzZSIsInJlY2VpcHQiLCJfbmV3SGVhZCQiLCJfaW5jbHVkZWRJbkJsb2NrIiwiX2luY2x1ZGVkIiwibmV3SGVhZCQiLCJjb25uZWN0b3IiLCJyZXNldE9uRXJyb3IiLCJyZXNldE9uQ29tcGxldGUiLCJyZXNldE9uUmVmQ291bnRaZXJvIiwib3BHcm91cCIsImdldEN1cnJlbnRDb25maXJtYXRpb24iLCJmb3VuZEF0QmxvY2siLCJpc0luQ3VycmVudEJyYW5jaCIsInRpcEJsb2NrSWRlbnRpZmllciIsInRpcEJsb2NrSGVhZGVyTGV2ZWwiLCJnZXRCbG9ja0xldmVsIiwiaW5jbHVzaW9uQmxvY2siLCJsZXZlbERpZmYiLCJ0aXBCbG9ja0xldmVsIiwibWluIiwiYmxvY2tzIiwiU2V0IiwiZ2V0TGl2ZUJsb2NrcyIsImNvbmZpcm1hdGlvbk9ic2VydmFibGUiLCJwcmV2aW91c0hlYWQiLCJibG9jayIsImV4cGVjdGVkQ29uZmlybWF0aW9uIiwiY3VycmVudENvbmZpcm1hdGlvbiIsImNvbXBsZXRlZCIsIlRyYW5zYWN0aW9uV2FsbGV0T3BlcmF0aW9uIiwib3BlcmF0aW9uUmVzdWx0IiwidHJhbnNhY3Rpb25PcGVyYXRpb24iLCJPcmlnaW5hdGlvbldhbGxldE9wZXJhdGlvbiIsIm9yaWdpbmF0aW9uT3BlcmF0aW9uIiwid2FsbGV0IiwiRGVsZWdhdGlvbldhbGxldE9wZXJhdGlvbiIsImRlbGVnYXRpb25PcGVyYXRpb24iLCJMZWdhY3lXYWxsZXRQcm92aWRlciIsIndhdGVybWFyayIsIkNvbnRyYWN0TWV0aG9kT2JqZWN0IiwicHJvdmlkZXIiLCJwYXJhbWV0ZXJTY2hlbWEiLCJpc011bHRpcGxlRW50cnlwb2ludCIsImlzQW5vbnltb3VzIiwiZ2V0U2lnbmF0dXJlIiwiRXh0cmFjdFNjaGVtYSIsImZ1bGxUcmFuc2ZlclBhcmFtcyIsIkRFRkFVTFRfU01BUlRfQ09OVFJBQ1RfTUVUSE9EX05BTUUiLCJFbmNvZGVPYmplY3QiLCJDb250cmFjdE1ldGhvZCIsInZhbGlkYXRlQXJncyIsIkV4dHJhY3RTaWduYXR1cmVzIiwic2lnIiwic2hpZnQiLCJPbkNoYWluVmlldyIsIl9ycGMiLCJfcmVhZFByb3ZpZGVyIiwiX2NvbnRyYWN0QWRkcmVzcyIsIl9zbWFydENvbnRyYWN0Vmlld1NjaGVtYSIsIl9jb250cmFjdFN0b3JhZ2VUeXBlIiwiX2FyZ3MiLCJleHRyYWN0QXJnc1NjaGVtYSIsImV4dHJhY3RSZXN1bHRTY2hlbWEiLCJleGVjdXRlVmlldyIsImV4ZWN1dGlvbkNvbnRleHQiLCJ2ZXJpZnlDb250ZXh0RXhlY3V0aW9uIiwiY2hhaW5JZCIsImdldENoYWluSWQiLCJ2aWV3QXJncyIsInRyYW5zZm9ybUFyZ3NUb01pY2hlbHNvbiIsInNjcmlwdFZpZXciLCJ2aWV3IiwiaW5wdXQiLCJjaGFpbl9pZCIsInZpZXdDYWxsZXIiLCJwYXllciIsImV4ZWN1dGVWaWV3QW5kRGVjb2RlUmVzdWx0IiwiZW5jb2RlVmlld0FyZ3MiLCJhZGFwdFZpZXdDb2RlVG9Db250ZXh0IiwiaW5zdHJ1Y3Rpb25zIiwiY29udHJhY3RCYWxhbmNlIiwiaW5zdHJ1Y3Rpb25zVG9SZXBsYWNlIiwiQkFMQU5DRSIsIlNFTkRFUiIsIlNFTEZfQUREUkVTUyIsIkFNT1VOVCIsImluc3QiLCJ2aWV3U2NyaXB0IiwicnVuU2NyaXB0VmlldyIsImRlY29kZVZpZXdSZXN1bHQiLCJDb250cmFjdE1ldGhvZEZhY3RvcnkiLCJjb250cmFjdEFkZHJlc3MiLCJjcmVhdGVDb250cmFjdE1ldGhvZEZsYXRQYXJhbXMiLCJzbWFydENvbnRyYWN0TWV0aG9kU2NoZW1hIiwiY3JlYXRlQ29udHJhY3RNZXRob2RPYmplY3RQYXJhbSIsImNyZWF0ZUNvbnRyYWN0Vmlld09iamVjdFBhcmFtIiwic21hcnRDb250cmFjdFZpZXdTY2hlbWEiLCJjb250cmFjdFN0b3JhZ2VUeXBlIiwiQ29udHJhY3RWaWV3IiwiY3VycmVudENvbnRyYWN0IiwiY2FsbGJhY2tQYXJhbWV0ZXJzU2NoZW1hIiwicmVhZCIsImNoYWluSWRWYWxpZGF0aW9uIiwiYXJnIiwicnVuVmlldyIsIkV4ZWN1dGUiLCJpc1ZpZXciLCJsYXN0RWxlbWVudCIsInN0b3JhZ2VQcm92aWRlciIsIm1ldGhvZHMiLCJtZXRob2RzT2JqZWN0Iiwidmlld3MiLCJjb250cmFjdFZpZXdzIiwiY29udHJhY3RNZXRob2RGYWN0b3J5IiwiZnJvbVJQQ1Jlc3BvbnNlIiwidmlld1NjaGVtYSIsIl9pbml0aWFsaXplT25DaGFpblZpZXdzIiwiZXZlbnRTY2hlbWEiLCJfaW5pdGlhbGl6ZU1ldGhvZHMiLCJrZXlzIiwiaXNNdWx0aXBsZUVudHJ5UG9pbnQiLCJlbnRyeXBvaW50UGFyYW1XaXRob3V0Q2FsbGJhY2siLCJzbWFydENvbnRyYWN0TWV0aG9kU2NoZW1hV2l0aG91dENhbGxiYWNrIiwicGFyYW1ldGVyc0NhbGxiYWNrIiwic21hcnRDb250cmFjdE1ldGhvZENhbGxiYWNrU2NoZW1hIiwiYW5vbnltb3VzTWV0aG9kcyIsImtleSIsImFsbENvbnRyYWN0Vmlld3MiLCJ2YWwiLCJnZXRTdG9yYWdlIiwiYmlnTWFwIiwiZ2V0QmlnTWFwS2V5IiwidHJhbnNmZXJJbXBsaWNpdCIsInJlbW92ZURlbGVnYXRlIiwidHJhbnNmZXJUb0NvbnRyYWN0IiwiTUFOQUdFUl9MQU1CREEiLCJWSUVXX0xBTUJEQSIsImNvbXBvc2UiLCJmdW5jdGlvbmNvbXBvc2VyMSIsImZ1bmN0aW9uY29tcG9zZXIyIiwiY29udHJhY3RBYnN0cmFjdGlvbiIsIlNhcGxpbmdTdGF0ZUFic3RyYWN0aW9uIiwiZ2V0U2FwbGluZ0RpZmYiLCJnZXRTYXBsaW5nRGlmZkJ5SUQiLCJnZXRJZCIsIkJpZ01hcEFic3RyYWN0aW9uIiwia2V5VG9FbmNvZGUiLCJnZXRCaWdNYXBLZXlCeUlEIiwiTk9UX0ZPVU5EIiwiZ2V0TXVsdGlwbGVWYWx1ZXMiLCJrZXlzVG9FbmNvZGUiLCJiYXRjaFNpemUiLCJnZXRCaWdNYXBLZXlzQnlJRCIsInRvSlNPTiIsInNtYXJ0Q29udHJhY3RBYnN0cmFjdGlvblNlbWFudGljIiwiYmlnX21hcCIsInNhcGxpbmdfc3RhdGUiLCJfUHJlcGFyZVByb3ZpZGVyX2NvdW50ZXJzIiwibWVyZ2VMaW1pdHMiLCJ1c2VyRGVmaW5lZExpbWl0IiwiZGVmYXVsdExpbWl0cyIsIl9jIiwiUHJlcGFyZVByb3ZpZGVyIiwiZ2V0UHJvdG9jb2xIYXNoIiwiZ2V0TmV4dFByb3RvY29sIiwiZ2V0SGVhZENvdW50ZXIiLCJnZXRDb3VudGVyIiwiYWRqdXN0R2FzRm9yQmF0Y2hPcGVyYXRpb24iLCJnYXNMaW1pdEJsb2NrIiwiZ2FzbGltaXRPcCIsIm51bWJlck9mT3BzIiwiZGl2IiwiZ2V0QWNjb3VudExpbWl0cyIsImNvbnN0YW50cyIsImdldEJhbGFuY2UiLCJoYXJkX2dhc19saW1pdF9wZXJfb3BlcmF0aW9uIiwiaGFyZF9nYXNfbGltaXRfcGVyX2Jsb2NrIiwiaGFyZF9zdG9yYWdlX2xpbWl0X3Blcl9vcGVyYXRpb24iLCJjb3N0X3Blcl9ieXRlIiwiZmxvb3IiLCJ0b051bWJlciIsImdldEZlZSIsImhlYWRDb3VudGVyIiwib3BDb3VudGVyIiwiZ2V0U291cmNlIiwiYWRkUmV2ZWFsT3BlcmF0aW9uSWZOZWVkZWQiLCJnZXRLZXlzIiwidW5zaGlmdCIsImlzU2lnbmVyQ29uZmlndXJlZCIsImlzQW55U2lnbmVyQ29uZmlndXJlZCIsImNvbnZlcnRJbnRvQXJyYXkiLCJjb25zdHJ1Y3RPcENvbnRlbnRzIiwiY3VycmVudFZvdGluZ1BlcmlvZCIsImNvcHMiLCJ0b0xvd2VyQ2FzZSIsInN0YXJ0c1dpdGgiLCJwZXJpb2QiLCJ2b3RpbmdfcGVyaW9kIiwiaW5kZXgiLCJhY3RpdmF0ZSIsInBhcnNlSW50IiwicmV2ZWFsIiwicHJvdG9jb2xDb25zdGFudHMiLCJnZXRQcm90b2NvbENvbnN0YW50cyIsIkRFRkFVTFRfUEFSQU1TIiwibWVyZ2VkRXN0aW1hdGVzIiwidHJhbnNhY3Rpb24iLCJkZWxlZ2F0aW9uIiwicmVnaXN0ZXJHbG9iYWxDb25zdGFudCIsInVwZGF0ZUNvbnNlbnN1c0tleSIsImdldEN1cnJlbnRQZXJpb2QiLCJkcmFpbkRlbGVnYXRlIiwidHJhbnNmZXJUaWNrZXQiLCJzbWFydFJvbGx1cEFkZE1lc3NhZ2VzIiwic21hcnRSb2xsdXBPcmlnaW5hdGUiLCJiYXRjaFBhcmFtcyIsImVzdGltYXRlcyIsInJldmVhbE5lZWRlZCIsImxpbWl0cyIsImNvbnRyYWN0Q2FsbCIsImNvbnRyYWN0TWV0aG9kIiwiZXN0aW1hdGVMaW1pdHMiLCJ0b1ByZWFwcGx5IiwicHJlcGFyZWQiLCJmb3JnZVBhcmFtcyIsInRvRm9yZ2UiLCJmb3JnZWQiLCJXZWFrTWFwIiwiT3BlcmF0aW9uQmF0Y2giLCJwcmVwYXJlIiwid2l0aFRyYW5zZmVyVGlja2V0Iiwic291cmNlVmFsaWRhdGlvbiIsIndpdGhBY3RpdmF0aW9uIiwicGtoVmFsaWRhdGlvbiIsIndpdGhSZWdpc3Rlckdsb2JhbENvbnN0YW50Iiwid2l0aFNtYXJ0Um9sbHVwQWRkTWVzc2FnZXMiLCJ3aXRoU21hcnRSb2xsdXBPcmlnaW5hdGUiLCJwcmVwYXJlZE9wIiwib3BCeXRlcyIsIlJQQ0JhdGNoUHJvdmlkZXIiLCJCYXRjaFdhbGxldE9wZXJhdGlvbiIsIkluY3JlYXNlUGFpZFN0b3JhZ2VXYWxsZXRPcGVyYXRpb24iLCJpbmNyZWFzZVBhaWRTdG9yYWdlT3BlcmF0aW9uIiwidGltZW91dEFmdGVyIiwidGltZW91dE1pbGxpc2VjIiwiaW5uZXIiLCJjcmVhdGVOZXdQb2xsaW5nQmFzZWRIZWFkT2JzZXJ2YWJsZSIsInNoYXJlZEhlYWRPYiIsIl9zY2hlZHVsZXIiLCJPcGVyYXRpb25GYWN0b3J5Iiwic2hhcmVkSGVhZE9icyIsImNyZWF0ZU5ld0hlYWRPYnNlcnZhYmxlIiwiY3JlYXRlUGFzdEJsb2NrV2Fsa2VyIiwic3RhcnRCbG9jayIsImNvdW50IiwiY3JlYXRlSGVhZE9ic2VydmFibGVGcm9tQ29uZmlnIiwiYmxvY2tJZGVudGlmaWVyIiwib2JzZXJ2YWJsZVNlcXVlbmNlIiwiY3JlYXRlT3BlcmF0aW9uIiwiUnBjVHpQcm92aWRlciIsImdldERlbGVnYXRlIiwiTUlOSU1BTF9GRUVfTVVURVoiLCJNSU5JTUFMX0ZFRV9QRVJfQllURV9NVVRFWiIsIk1JTklNQUxfRkVFX1BFUl9HQVNfTVVURVoiLCJHQVNfQlVGRkVSIiwiRXN0aW1hdGUiLCJfbWlsbGlnYXNMaW1pdCIsIl9zdG9yYWdlTGltaXQiLCJvcFNpemUiLCJtaW5pbWFsRmVlUGVyU3RvcmFnZUJ5dGVNdXRleiIsImJhc2VGZWVNdXRleiIsImJ1cm5GZWVNdXRleiIsInJvdW5kVXAiLCJsaW1pdCIsIm1heCIsIm9wZXJhdGlvbkZlZU11dGV6IiwibmFub3RleiIsImNlaWwiLCJtaW5pbWFsRmVlTXV0ZXoiLCJ1c2luZ0Jhc2VGZWVNdXRleiIsInRvdGFsQ29zdCIsImNvbnN1bWVkTWlsbGlnYXMiLCJjcmVhdGVFc3RpbWF0ZUluc3RhbmNlRnJvbVByb3BlcnRpZXMiLCJlc3RpbWF0ZVByb3BlcnRpZXMiLCJtaWxsaWdhc0xpbWl0IiwiY3JlYXRlQXJyYXlFc3RpbWF0ZUluc3RhbmNlc0Zyb21Qcm9wZXJ0aWVzIiwiUmV2ZWFsRXN0aW1hdGVFcnJvciIsIlJQQ0VzdGltYXRlUHJvdmlkZXIiLCJhcmd1bWVudHMiLCJBTExPQ0FUSU9OX1NUT1JBR0UiLCJPUklHSU5BVElPTl9TVE9SQUdFIiwiT1BfU0laRV9SRVZFQUwiLCJnZXRFc3RpbWF0aW9uUHJvcGVydGllc0Zyb21PcGVyYXRpb25Db250ZW50Iiwic2l6ZSIsImNvc3RQZXJCeXRlIiwidG90YWxNaWxsaWdhcyIsInN0b3JhZ2Vfc2l6ZSIsImNhbGN1bGF0ZUVzdGltYXRlcyIsInByZXBhcmVkT3BlcmF0aW9uIiwicHJlcGFyZWRPcGVyYXRpb25zIiwiY2hlY2tTb3VyY2UiLCJEZWxlZ2F0ZU9wZXJhdGlvbiIsImRlbGVnYXRpb25PcCIsImlzUmVnaXN0ZXJPcGVyYXRpb24iLCJPcmlnaW5hdGlvbk9wZXJhdGlvbiIsImNvbnRyYWN0UHJvdmlkZXIiLCJvcmlnaW5hdGVkQ29udHJhY3RzIiwib3JpZ2luYXRpb25PcCIsInN0b3JhZ2VTaXplIiwiUmVnaXN0ZXJHbG9iYWxDb25zdGFudE9wZXJhdGlvbiIsImdsb2JhbENvbnN0YW50SGFzaCIsImdsb2JhbF9hZGRyZXNzIiwicmVnaXN0ZXJHbG9iYWxDb25zdGFudE9wIiwicmVnaXN0ZXJlZEV4cHJlc3Npb24iLCJSZXZlYWxPcGVyYXRpb24iLCJyZXZlYWxPcCIsInR4UmVzdWx0IiwiVHJhbnNhY3Rpb25PcGVyYXRpb24iLCJ0cmFuc2FjdGlvbk9wIiwiQmFsbG90T3BlcmF0aW9uIiwiYmFsbG90T3AiLCJEcmFpbkRlbGVnYXRlT3BlcmF0aW9uIiwiZHJhaW5EZWxlZ2F0ZU9wIiwiYmFsYW5jZV91cGRhdGVzIiwiY29uc2Vuc3VzS2V5IiwiVHJhbnNmZXJUaWNrZXRPcGVyYXRpb24iLCJ0cmFuc2Zlck9wIiwiSW5jcmVhc2VQYWlkU3RvcmFnZU9wZXJhdGlvbiIsImluY3JlYXNlUGFpZFN0b3JhZ2VPcCIsIlByb3Bvc2Fsc09wZXJhdGlvbiIsInByb3Bvc2Fsc09wIiwiVXBkYXRlQ29uc2Vuc3VzS2V5T3BlcmF0aW9uIiwidXBkYXRlQ29uc2Vuc3VzS2V5T3AiLCJTbWFydFJvbGx1cEFkZE1lc3NhZ2VzT3BlcmF0aW9uIiwic21hcnRSb2xsdXBBZGRNZXNzYWdlc09wIiwiU21hcnRSb2xsdXBPcmlnaW5hdGVPcGVyYXRpb24iLCJzbWFydFJvbGx1cE9yaWdpbmF0ZU9wIiwiUnBjQ29udHJhY3RQcm92aWRlciIsImNvbnRyYWN0UHJvdmlkZXJUeXBlU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiY29udHJhY3RWYWxpZGF0aW9uIiwiY29udHJhY3RTY2hlbWEiLCJpc1NjaGVtYSIsImdldENvbnRyYWN0IiwiZW5jb2RlZEtleSIsIkVuY29kZUJpZ01hcEtleSIsIkV4ZWN1dGVPbkJpZ01hcFZhbHVlIiwidHlwZSIsInBhY2tlZCIsInBhY2tlciIsInBhY2tEYXRhIiwiZW5jb2RlZEV4cHIiLCJiaWdNYXBWYWx1ZSIsImdldEJpZ01hcFZhbHVlIiwiZXhwciIsImdldEJsb2NrRm9yUmVxdWVzdCIsImJpZ01hcFZhbHVlcyIsInBvc2l0aW9uIiwia2V5c0JhdGNoIiwic2xpY2UiLCJnZXRCaWdNYXBWYWx1ZU9yVW5kZWZpbmVkIiwiYWxsIiwiZXgiLCJzYXBsaW5nU3RhdGUiLCJnZXRTYXBsaW5nRGlmZkJ5SWQiLCJiaW5kIiwicHJlcGFyZWRPcmlnaW5hdGlvbiIsImZvcmdlZE9yaWdpbmF0aW9uIiwidGVzdCIsInNvdXJjZU9yRGVmYXVsdCIsInByZXBhcmVkRGVsZWdhdGlvbiIsImVzdGltYXRlUmV2ZWFsIiwiZXN0aW1hdGVkIiwiZmFpbGluZ05vb3AiLCJNaWNoZWxDb2RlY1BhcnNlciIsImdldE5leHRQcm90byIsInByb3RvIiwibmV4dFByb3RvIiwicGFyc2VTY3JpcHQiLCJzcmMiLCJwYXJzZU1pY2hlbGluZUV4cHJlc3Npb24iLCJwYXJzZUpTT04iLCJwYXJzZWRQYXJhbXMiLCJmb3JtYXRDb2RlUGFyYW0iLCJmb3JtYXRJbml0UGFyYW0iLCJnbG9iYWxjb25zdGFudHNIYXNoQW5kVmFsdWUiLCJmaW5kR2xvYmFsQ29uc3RhbnRzSGFzaEFuZFZhbHVlIiwiZXhwYW5kR2xvYmFsQ29uc3RhbnQiLCJzdG9yYWdlVHlwZU5vR2xvYmFsQ29uc3QiLCJzY2hlbWFOb0dsb2JhbENvbnN0IiwicGFyc2VkQ29kZSIsImMiLCJvcmRlciIsInNvcnQiLCJhIiwiYiIsInBhcnNlZEluaXQiLCJnbG9iYWxDb25zdGFudFRva2VucyIsImZpbmRUb2tlbiIsImdsb2JhbENvbnN0YW50c0hhc2hBbmRWYWx1ZSIsInRva2VuIiwidG9rZW5BcmdzIiwidG9rZW5WYWwiLCJleHByZXNzaW9uIiwibWljaGVsaW5lVmFsdWUiLCJnbG9iYWxDb25zdGFudHNQcm92aWRlciIsImdldEdsb2JhbENvbnN0YW50QnlIYXNoIiwiUnBjUGFja2VyIiwiR2xvYmFsQ29uc3RhbnROb3RGb3VuZCIsIlVuY29uZmlndXJlZEdsb2JhbENvbnN0YW50c1Byb3ZpZGVyRXJyb3IiLCJOb29wR2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIiLCJfaGFzaCIsIlJwY1JlYWRBZGFwdGVyIiwiZ2V0UHJvdG9jb2xzIiwibmV4dF9wcm90b2NvbCIsInRpbWVfYmV0d2Vlbl9ibG9ja3MiLCJtaW5pbWFsX2Jsb2NrX2RlbGF5Iiwic21hcnRfcm9sbHVwX29yaWdpbmF0aW9uX3NpemUiLCJnZXRDb25zdGFudHMiLCJnZXRCbG9ja0hlYWRlciIsImdldEJsb2NrVGltZXN0YW1wIiwidGltZXN0YW1wIiwiYmlnTWFwUXVlcnkiLCJnZXRCaWdNYXBFeHByIiwic2FwbGluZ1N0YXRlUXVlcnkiLCJnZXRTYXBsaW5nRGlmZkJ5Q29udHJhY3QiLCJtYW5hZ2VyIiwiZ2V0TWFuYWdlcktleSIsImhhdmVNYW5hZ2VyIiwiVW5zdXBwb3J0ZWRFdmVudEVycm9yIiwiSW52YWxpZEZpbHRlckV4cHJlc3Npb25FcnJvciIsImludmFsaWRFeHByZXNzaW9uIiwib3BIYXNoRmlsdGVyIiwic291cmNlRmlsdGVyIiwia2luZEZpbHRlciIsImRlc3RpbmF0aW9uRmlsdGVyIiwic29tZSIsImV2ZW50RmlsdGVyIiwidGFnIiwiZXhjbHVkZUZhaWxlZE9wZXJhdGlvbnMiLCJldmFsdWF0ZU9wRmlsdGVyIiwiZXZhbHVhdGVFeHByZXNzaW9uIiwiZXhwIiwiYW5kIiwiZXZlcnkiLCJldmFsdWF0ZUZpbHRlciIsIm9yIiwiZmlsdGVycyIsImZpbHRlck9yRXhwIiwiT2JzZXJ2YWJsZVN1YnNjcmlwdGlvbiIsIm9icyIsInNob3VsZFJldHJ5Iiwib3BlcmF0b3JGdW5jdGlvbiIsImVycm9yTGlzdGVuZXJzIiwibWVzc2FnZUxpc3RlbmVycyIsImNsb3NlTGlzdGVuZXJzIiwiY29tcGxldGVkJCIsImxpc3RlbmVycyIsImwiLCJjb25zb2xlIiwicmVtb3ZlIiwiaWR4Iiwic3BsaWNlIiwiY2IiLCJvZmYiLCJkZWZhdWx0Q29uZmlnU3RyZWFtZXIiLCJzaG91bGRPYnNlcnZhYmxlU3Vic2NyaXB0aW9uUmV0cnkiLCJvYnNlcnZhYmxlU3Vic2NyaXB0aW9uUmV0cnlGdW5jdGlvbiIsImdldExhc3RCbG9jayIsImFwcGx5RmlsdGVyIiwiYXBwbHlFdmVudEZpbHRlciIsInR4IiwiaW50ZXJuYWxPcFJlc3VsdHMiLCJldmVudCIsImJsb2NrSGFzaCIsIlBvbGxpbmdTdWJzY3JpYmVQcm92aWRlciIsIl9jb25maWckIiwidGltZXIkIiwicG9sbGluZ0ludGVydmFsTWlsbGlzZWNvbmRzIiwiZ2V0Q29uZmlybWF0aW9uUG9sbGluZ0ludGVydmFsIiwiaW50ZXJ2YWwiLCJuZXdCbG9jayQiLCJnZXRWYWx1ZSIsImRlZmF1bHRJbnRlcnZhbFRlc3RuZXRzTWFpbm5ldCIsImRlZmF1bHRJbnRlcnZhbFNhbmRib3giLCJibG9ja1RpbWUiLCJjb25maXJtYXRpb25Qb2xsaW5nSW50ZXJ2YWwiLCJleGNlcHRpb24iLCJfZmlsdGVyIiwic3Vic2NyaWJlT3BlcmF0aW9uIiwic3Vic2NyaWJlRXZlbnQiLCJUYXF1aXRvTG9jYWxGb3JnZXIiLCJkZWZhdWx0Q29uZmlnQ29uZmlybWF0aW9uIiwiQ29udGV4dCIsIl9zaWduZXIiLCJfcHJvdG8iLCJfY29uZmlnIiwicHJvdmlkZXJEZWNvcmF0b3IiLCJ0eiIsImNsb25lZENvbnRleHQiLCJkZWNvcmF0b3IiLCJfcnBjQ2xpZW50IiwiX2ZvcmdlciIsIl9pbmplY3RvciIsIl93YWxsZXRQcm92aWRlciIsIl9wYXJzZXIiLCJfcGFja2VyIiwiX2dsb2JhbENvbnN0YW50c1Byb3ZpZGVyIiwiX3N0cmVhbSIsInNldFBhcnRpYWxDb25maWciLCJpc0FueVByb3RvY29sQWN0aXZlIiwicmVnaXN0ZXJQcm92aWRlckRlY29yYXRvciIsImZ4IiwiVkVSU0lPTiIsIkZvcmdpbmdNaXNtYXRjaEVycm9yIiwiVW5zcGVjaWZpZWRGb3JnZXJFcnJvciIsIkNvbXBvc2l0ZUZvcmdlciIsImZvcmdlcnMiLCJsYXN0UmVzdWx0IiwicG9wIiwiY3VycmVudFJlc3VsdCIsIlJwY0ZvcmdlciIsImZvcmdlT3BlcmF0aW9ucyIsIk5vb3BQYXJzZXIiLCJNaWNoZWxDb2RlY1BhY2tlciIsIkRlZmF1bHRHbG9iYWxDb25zdGFudHNQcm92aWRlciIsIl9nbG9iYWxDb25zdGFudHNMaWJyYXJ5IiwibG9hZEdsb2JhbENvbnN0YW50IiwiZ2xvYmFsQ29uc3RhbnQiLCJUZXpvc1Rvb2xraXQiLCJfb3B0aW9ucyIsIl9jb250ZXh0IiwiX3dhbGxldCIsInNldFByb3ZpZGVyIiwicGFyc2VyUHJvdmlkZXIiLCJpbmplY3RvclByb3ZpZGVyIiwic2V0UnBjUHJvdmlkZXIiLCJzZXRTdHJlYW1Qcm92aWRlciIsInNldFNpZ25lclByb3ZpZGVyIiwic2V0Rm9yZ2VyUHJvdmlkZXIiLCJzZXRXYWxsZXRQcm92aWRlciIsInNldFBhY2tlclByb3ZpZGVyIiwic2V0R2xvYmFsQ29uc3RhbnRzUHJvdmlkZXIiLCJzZXRSZWFkUHJvdmlkZXIiLCJzZXRQYXJzZXJQcm92aWRlciIsInNldEluamVjdG9yUHJvdmlkZXIiLCJnZXRGYWN0b3J5IiwidyIsImciLCJyZWFkUCIsImdsb2JhbENvbnN0YW50cyIsImFkZEV4dGVuc2lvbiIsIm1vZHVsZSIsImV4dGVuc2lvbiIsImNvbmZpZ3VyZUNvbnRleHQiLCJjdG9yIiwiZ2V0VmVyc2lvbkluZm8iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/taquito/dist/taquito.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/utils/dist/taquito-utils.es6.js":
/*!***************************************************************!*\
  !*** ./node_modules/@taquito/utils/dist/taquito-utils.es6.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DeprecationError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.DeprecationError),\n/* harmony export */   InvalidAddressError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidAddressError),\n/* harmony export */   InvalidBlockHashError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidBlockHashError),\n/* harmony export */   InvalidChainIdError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidChainIdError),\n/* harmony export */   InvalidContractAddressError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidContractAddressError),\n/* harmony export */   InvalidHexStringError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidHexStringError),\n/* harmony export */   InvalidKeyError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidKeyError),\n/* harmony export */   InvalidKeyHashError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidKeyHashError),\n/* harmony export */   InvalidMessageError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidMessageError),\n/* harmony export */   InvalidOperationHashError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidOperationHashError),\n/* harmony export */   InvalidOperationKindError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidOperationKindError),\n/* harmony export */   InvalidProtocolHashError: () => (/* binding */ InvalidProtocolHashError),\n/* harmony export */   InvalidPublicKeyError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidPublicKeyError),\n/* harmony export */   InvalidSignatureError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidSignatureError),\n/* harmony export */   Prefix: () => (/* binding */ Prefix),\n/* harmony export */   ProhibitedActionError: () => (/* reexport safe */ _taquito_core__WEBPACK_IMPORTED_MODULE_5__.ProhibitedActionError),\n/* harmony export */   VERSION: () => (/* binding */ VERSION),\n/* harmony export */   ValidationResult: () => (/* binding */ ValidationResult),\n/* harmony export */   ValueConversionError: () => (/* binding */ ValueConversionError),\n/* harmony export */   b58cdecode: () => (/* binding */ b58cdecode),\n/* harmony export */   b58cencode: () => (/* binding */ b58cencode),\n/* harmony export */   b58decode: () => (/* binding */ b58decode),\n/* harmony export */   b58decodeL2Address: () => (/* binding */ b58decodeL2Address),\n/* harmony export */   buf2hex: () => (/* binding */ buf2hex),\n/* harmony export */   bytes2Char: () => (/* binding */ bytes2Char),\n/* harmony export */   char2Bytes: () => (/* binding */ char2Bytes),\n/* harmony export */   encodeExpr: () => (/* binding */ encodeExpr),\n/* harmony export */   encodeKey: () => (/* binding */ encodeKey),\n/* harmony export */   encodeKeyHash: () => (/* binding */ encodeKeyHash),\n/* harmony export */   encodeL2Address: () => (/* binding */ encodeL2Address),\n/* harmony export */   encodeOpHash: () => (/* binding */ encodeOpHash),\n/* harmony export */   encodePubKey: () => (/* binding */ encodePubKey),\n/* harmony export */   format: () => (/* binding */ format),\n/* harmony export */   getPkhfromPk: () => (/* binding */ getPkhfromPk),\n/* harmony export */   hex2Bytes: () => (/* binding */ hex2Bytes),\n/* harmony export */   hex2buf: () => (/* binding */ hex2buf),\n/* harmony export */   invalidDetail: () => (/* binding */ invalidDetail),\n/* harmony export */   isValidPrefix: () => (/* binding */ isValidPrefix),\n/* harmony export */   mergebuf: () => (/* binding */ mergebuf),\n/* harmony export */   mic2arr: () => (/* binding */ mic2arr),\n/* harmony export */   num2PaddedHex: () => (/* binding */ num2PaddedHex),\n/* harmony export */   prefix: () => (/* binding */ prefix),\n/* harmony export */   prefixLength: () => (/* binding */ prefixLength),\n/* harmony export */   stripHexPrefix: () => (/* binding */ stripHexPrefix),\n/* harmony export */   toHexBuf: () => (/* binding */ toHexBuf),\n/* harmony export */   validateAddress: () => (/* binding */ validateAddress),\n/* harmony export */   validateBlock: () => (/* binding */ validateBlock),\n/* harmony export */   validateChain: () => (/* binding */ validateChain),\n/* harmony export */   validateContractAddress: () => (/* binding */ validateContractAddress),\n/* harmony export */   validateKeyHash: () => (/* binding */ validateKeyHash),\n/* harmony export */   validateOperation: () => (/* binding */ validateOperation),\n/* harmony export */   validatePkAndExtractPrefix: () => (/* binding */ validatePkAndExtractPrefix),\n/* harmony export */   validateProtocol: () => (/* binding */ validateProtocol),\n/* harmony export */   validatePublicKey: () => (/* binding */ validatePublicKey),\n/* harmony export */   validateSignature: () => (/* binding */ validateSignature),\n/* harmony export */   validateSmartRollupAddress: () => (/* binding */ validateSmartRollupAddress),\n/* harmony export */   validateSpendingKey: () => (/* binding */ validateSpendingKey),\n/* harmony export */   verifySignature: () => (/* binding */ verifySignature)\n/* harmony export */ });\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! buffer */ \"buffer\");\n/* harmony import */ var buffer__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(buffer__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _stablelib_ed25519__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @stablelib/ed25519 */ \"(ssr)/./node_modules/@stablelib/ed25519/lib/ed25519.js\");\n/* harmony import */ var _stablelib_blake2b__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @stablelib/blake2b */ \"(ssr)/./node_modules/@stablelib/blake2b/lib/blake2b.js\");\n/* harmony import */ var blakejs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! blakejs */ \"(ssr)/./node_modules/blakejs/index.js\");\n/* harmony import */ var blakejs__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(blakejs__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var bs58check__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! bs58check */ \"(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/index.js\");\n/* harmony import */ var bs58check__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(bs58check__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var _taquito_core__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @taquito/core */ \"(ssr)/./node_modules/@taquito/core/dist/taquito-core.es6.js\");\n/* harmony import */ var bignumber_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! bignumber.js */ \"(ssr)/./node_modules/bignumber.js/bignumber.mjs\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! elliptic */ \"(ssr)/./node_modules/elliptic/lib/elliptic.js\");\n/* harmony import */ var elliptic__WEBPACK_IMPORTED_MODULE_7___default = /*#__PURE__*/__webpack_require__.n(elliptic__WEBPACK_IMPORTED_MODULE_7__);\n/* harmony import */ var typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! typedarray-to-buffer */ \"(ssr)/./node_modules/typedarray-to-buffer/index.js\");\n/* harmony import */ var typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_8___default = /*#__PURE__*/__webpack_require__.n(typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_8__);\n\n\n\n\n\n\n\n\n\n\nvar Prefix;\n(function(Prefix) {\n    Prefix[\"TZ1\"] = \"tz1\";\n    Prefix[\"TZ2\"] = \"tz2\";\n    Prefix[\"TZ3\"] = \"tz3\";\n    Prefix[\"TZ4\"] = \"tz4\";\n    Prefix[\"KT\"] = \"KT\";\n    Prefix[\"KT1\"] = \"KT1\";\n    Prefix[\"EDSK2\"] = \"edsk2\";\n    Prefix[\"SPSK\"] = \"spsk\";\n    Prefix[\"P2SK\"] = \"p2sk\";\n    Prefix[\"EDPK\"] = \"edpk\";\n    Prefix[\"SPPK\"] = \"sppk\";\n    Prefix[\"P2PK\"] = \"p2pk\";\n    Prefix[\"BLPK\"] = \"BLpk\";\n    Prefix[\"EDESK\"] = \"edesk\";\n    Prefix[\"SPESK\"] = \"spesk\";\n    Prefix[\"P2ESK\"] = \"p2esk\";\n    Prefix[\"EDSK\"] = \"edsk\";\n    Prefix[\"EDSIG\"] = \"edsig\";\n    Prefix[\"SPSIG\"] = \"spsig\";\n    Prefix[\"P2SIG\"] = \"p2sig\";\n    Prefix[\"SIG\"] = \"sig\";\n    Prefix[\"NET\"] = \"Net\";\n    Prefix[\"NCE\"] = \"nce\";\n    Prefix[\"B\"] = \"B\";\n    Prefix[\"O\"] = \"o\";\n    Prefix[\"LO\"] = \"Lo\";\n    Prefix[\"LLO\"] = \"LLo\";\n    Prefix[\"P\"] = \"P\";\n    Prefix[\"CO\"] = \"Co\";\n    Prefix[\"ID\"] = \"id\";\n    Prefix[\"EXPR\"] = \"expr\";\n    Prefix[\"TZ\"] = \"TZ\";\n    Prefix[\"VH\"] = \"vh\";\n    Prefix[\"SASK\"] = \"sask\";\n    Prefix[\"ZET1\"] = \"zet1\";\n    Prefix[\"SR1\"] = \"sr1\";\n    Prefix[\"SRC1\"] = \"src1\";\n})(Prefix || (Prefix = {}));\nconst prefix = {\n    [Prefix.TZ1]: new Uint8Array([\n        6,\n        161,\n        159\n    ]),\n    [Prefix.TZ2]: new Uint8Array([\n        6,\n        161,\n        161\n    ]),\n    [Prefix.TZ3]: new Uint8Array([\n        6,\n        161,\n        164\n    ]),\n    [Prefix.TZ4]: new Uint8Array([\n        6,\n        161,\n        166\n    ]),\n    [Prefix.KT]: new Uint8Array([\n        2,\n        90,\n        121\n    ]),\n    [Prefix.KT1]: new Uint8Array([\n        2,\n        90,\n        121\n    ]),\n    [Prefix.EDSK]: new Uint8Array([\n        43,\n        246,\n        78,\n        7\n    ]),\n    [Prefix.EDSK2]: new Uint8Array([\n        13,\n        15,\n        58,\n        7\n    ]),\n    [Prefix.SPSK]: new Uint8Array([\n        17,\n        162,\n        224,\n        201\n    ]),\n    [Prefix.P2SK]: new Uint8Array([\n        16,\n        81,\n        238,\n        189\n    ]),\n    [Prefix.EDPK]: new Uint8Array([\n        13,\n        15,\n        37,\n        217\n    ]),\n    [Prefix.SPPK]: new Uint8Array([\n        3,\n        254,\n        226,\n        86\n    ]),\n    [Prefix.P2PK]: new Uint8Array([\n        3,\n        178,\n        139,\n        127\n    ]),\n    [Prefix.BLPK]: new Uint8Array([\n        6,\n        149,\n        135,\n        204\n    ]),\n    [Prefix.EDESK]: new Uint8Array([\n        7,\n        90,\n        60,\n        179,\n        41\n    ]),\n    [Prefix.SPESK]: new Uint8Array([\n        0x09,\n        0xed,\n        0xf1,\n        0xae,\n        0x96\n    ]),\n    [Prefix.P2ESK]: new Uint8Array([\n        0x09,\n        0x30,\n        0x39,\n        0x73,\n        0xab\n    ]),\n    [Prefix.EDSIG]: new Uint8Array([\n        9,\n        245,\n        205,\n        134,\n        18\n    ]),\n    [Prefix.SPSIG]: new Uint8Array([\n        13,\n        115,\n        101,\n        19,\n        63\n    ]),\n    [Prefix.P2SIG]: new Uint8Array([\n        54,\n        240,\n        44,\n        52\n    ]),\n    [Prefix.SIG]: new Uint8Array([\n        4,\n        130,\n        43\n    ]),\n    [Prefix.NET]: new Uint8Array([\n        87,\n        82,\n        0\n    ]),\n    [Prefix.NCE]: new Uint8Array([\n        69,\n        220,\n        169\n    ]),\n    [Prefix.B]: new Uint8Array([\n        1,\n        52\n    ]),\n    [Prefix.O]: new Uint8Array([\n        5,\n        116\n    ]),\n    [Prefix.LO]: new Uint8Array([\n        133,\n        233\n    ]),\n    [Prefix.LLO]: new Uint8Array([\n        29,\n        159,\n        109\n    ]),\n    [Prefix.P]: new Uint8Array([\n        2,\n        170\n    ]),\n    [Prefix.CO]: new Uint8Array([\n        79,\n        179\n    ]),\n    [Prefix.ID]: new Uint8Array([\n        153,\n        103\n    ]),\n    [Prefix.EXPR]: new Uint8Array([\n        13,\n        44,\n        64,\n        27\n    ]),\n    // Legacy prefix\n    [Prefix.TZ]: new Uint8Array([\n        2,\n        90,\n        121\n    ]),\n    [Prefix.VH]: new Uint8Array([\n        1,\n        106,\n        242\n    ]),\n    [Prefix.SASK]: new Uint8Array([\n        11,\n        237,\n        20,\n        92\n    ]),\n    [Prefix.ZET1]: new Uint8Array([\n        18,\n        71,\n        40,\n        223\n    ]),\n    [Prefix.SR1]: new Uint8Array([\n        6,\n        124,\n        117\n    ]),\n    [Prefix.SRC1]: new Uint8Array([\n        17,\n        165,\n        134,\n        138\n    ])\n};\nconst prefixLength = {\n    [Prefix.TZ1]: 20,\n    [Prefix.TZ2]: 20,\n    [Prefix.TZ3]: 20,\n    [Prefix.TZ4]: 20,\n    [Prefix.KT]: 20,\n    [Prefix.KT1]: 20,\n    [Prefix.EDPK]: 32,\n    [Prefix.SPPK]: 33,\n    [Prefix.P2PK]: 33,\n    //working with value in comment for base58.ml line 445 but not consistent with the three above\n    [Prefix.BLPK]: 48,\n    [Prefix.EDSIG]: 64,\n    [Prefix.SPSIG]: 64,\n    [Prefix.P2SIG]: 64,\n    [Prefix.SIG]: 64,\n    [Prefix.NET]: 4,\n    [Prefix.B]: 32,\n    [Prefix.P]: 32,\n    [Prefix.O]: 32,\n    [Prefix.VH]: 32,\n    [Prefix.SASK]: 169,\n    [Prefix.ZET1]: 43,\n    [Prefix.SR1]: 20,\n    [Prefix.SRC1]: 32\n};\n/**\n * @description Verify signature of a payload\n *\n * @param messageBytes The forged message including the magic byte (11 for block,\n *        12 for preattestation/preendorsement, 13 for attestation/endorsement, 3 for generic, 5 for the PACK format of michelson)\n * @param publicKey The public key to verify the signature against\n * @param signature The signature to verify\n * @returns A boolean indicating if the signature matches\n * @throws {@link InvalidPublicKeyError} | {@link InvalidSignatureError} | {@link InvalidMessageError}\n * @example\n * ```\n * const message = '03d0c10e3ed11d7c6e3357f6ef335bab9e8f2bd54d0ce20c482e241191a6e4b8ce6c01be917311d9ac46959750e405d57e268e2ed9e174a80794fbd504e12a4a000141eb3781afed2f69679ff2bbe1c5375950b0e40d00ff000000005e05050505050507070100000024747a32526773486e74516b72794670707352466261313652546656503539684b72654a4d07070100000024747a315a6672455263414c42776d4171776f6e525859565142445439426a4e6a42484a750001';\n * const pk = 'sppk7c7hkPj47yjYFEHX85q46sFJGw6RBrqoVSHwAJAT4e14KJwzoey';\n * const sig = 'spsig1cdLkp1RLgUHAp13aRFkZ6MQDPp7xCnjAExGL3MBSdMDmT6JgQSX8cufyDgJRM3sinFtiCzLbsyP6d365EHoNevxhT47nx'\n *\n * const response = verifySignature(message, pk, sig);\n * ```\n *\n */ function verifySignature(messageBytes, publicKey, signature, watermark) {\n    const pkPrefix = validatePkAndExtractPrefix(publicKey);\n    const sigPrefix = validateSigAndExtractPrefix(signature);\n    const decodedPublicKey = b58cdecode(publicKey, prefix[pkPrefix]);\n    const decodedSig = b58cdecode(signature, prefix[sigPrefix]);\n    let messageBuf = hex2buf(validateMessageNotEmpty(messageBytes));\n    if (typeof watermark !== \"undefined\") {\n        messageBuf = mergebuf(watermark, messageBuf);\n    }\n    const bytesHash = (0,_stablelib_blake2b__WEBPACK_IMPORTED_MODULE_2__.hash)(messageBuf, 32);\n    if (pkPrefix === Prefix.EDPK) {\n        return verifyEdSignature(decodedSig, bytesHash, decodedPublicKey);\n    } else if (pkPrefix === Prefix.SPPK) {\n        return verifySpSignature(decodedSig, bytesHash, decodedPublicKey);\n    } else if (pkPrefix === Prefix.P2PK) {\n        return verifyP2Signature(decodedSig, bytesHash, decodedPublicKey);\n    } else {\n        return false;\n    }\n}\nfunction validateMessageNotEmpty(message) {\n    if (message === \"\") {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidMessageError(message, `can't be empty`);\n    }\n    return message;\n}\nfunction validatePkAndExtractPrefix(publicKey) {\n    if (publicKey === \"\") {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidPublicKeyError(publicKey, `can't be empty`);\n    }\n    const pkPrefix = publicKey.substring(0, 4);\n    const publicKeyValidation = validatePublicKey(publicKey);\n    if (publicKeyValidation !== ValidationResult.VALID) {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidPublicKeyError(publicKey, invalidDetail(publicKeyValidation));\n    }\n    return pkPrefix;\n}\nfunction validateSigAndExtractPrefix(signature) {\n    const signaturePrefix = signature.startsWith(\"sig\") ? signature.substring(0, 3) : signature.substring(0, 5);\n    const validation = validateSignature(signature);\n    if (validation !== ValidationResult.VALID) {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidSignatureError(signature, invalidDetail(validation));\n    }\n    return signaturePrefix;\n}\nfunction verifyEdSignature(decodedSig, bytesHash, decodedPublicKey) {\n    try {\n        return (0,_stablelib_ed25519__WEBPACK_IMPORTED_MODULE_1__.verify)(decodedPublicKey, bytesHash, decodedSig);\n    } catch (e) {\n        return false;\n    }\n}\nfunction verifySpSignature(decodedSig, bytesHash, decodedPublicKey) {\n    const key = new (elliptic__WEBPACK_IMPORTED_MODULE_7___default().ec)(\"secp256k1\").keyFromPublic(decodedPublicKey);\n    return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\nfunction verifyP2Signature(decodedSig, bytesHash, decodedPublicKey) {\n    const key = new (elliptic__WEBPACK_IMPORTED_MODULE_7___default().ec)(\"p256\").keyFromPublic(decodedPublicKey);\n    return verifySpOrP2Sig(decodedSig, bytesHash, key);\n}\nfunction verifySpOrP2Sig(decodedSig, bytesHash, key) {\n    const hexSig = buf2hex(typedarray_to_buffer__WEBPACK_IMPORTED_MODULE_8___default()(decodedSig));\n    const match = hexSig.match(/([a-f\\d]{64})/gi);\n    if (match) {\n        try {\n            const [r, s] = match;\n            return key.verify(bytesHash, {\n                r,\n                s\n            });\n        } catch (e) {\n            return false;\n        }\n    }\n    return false;\n}\n/**\n *  @category Error\n *  @description Error that indicates invalid protocol hash being passed or used\n */ class InvalidProtocolHashError extends _taquito_core__WEBPACK_IMPORTED_MODULE_5__.ParameterValidationError {\n    constructor(protocolHash, errorDetails){\n        super();\n        this.protocolHash = protocolHash;\n        this.errorDetails = errorDetails;\n        this.name = \"InvalidProtocolHashError\";\n        this.name = \"InvalidProtocolHashError\";\n        this.message = `The protocol hash '${protocolHash}' is invalid`;\n        errorDetails ? this.message += `: ${errorDetails}` : null;\n    }\n}\n/**\n *  @category Error\n *  @description Error that indicates unable to convert data type from one to another\n */ class ValueConversionError extends _taquito_core__WEBPACK_IMPORTED_MODULE_5__.UnsupportedActionError {\n    constructor(value, desiredType){\n        super();\n        this.value = value;\n        this.desiredType = desiredType;\n        this.name = \"ValueConversionError\";\n        this.message = `Unable to convert ${value} to a ${desiredType}`;\n    }\n}\nvar ValidationResult;\n(function(ValidationResult) {\n    ValidationResult[ValidationResult[\"NO_PREFIX_MATCHED\"] = 0] = \"NO_PREFIX_MATCHED\";\n    ValidationResult[ValidationResult[\"INVALID_CHECKSUM\"] = 1] = \"INVALID_CHECKSUM\";\n    ValidationResult[ValidationResult[\"INVALID_LENGTH\"] = 2] = \"INVALID_LENGTH\";\n    ValidationResult[ValidationResult[\"VALID\"] = 3] = \"VALID\";\n})(ValidationResult || (ValidationResult = {}));\nfunction isValidPrefix(value) {\n    if (typeof value !== \"string\") {\n        return false;\n    }\n    return value in prefix;\n}\n/**\n * @description This function is called by the validation functions ([[validateAddress]], [[validateChain]], [[validateContractAddress]], [[validateKeyHash]], [[validateSignature]], [[validatePublicKey]]).\n * Verify if the value has the right prefix or return `NO_PREFIX_MATCHED`,\n * decode the value using base58 and return `INVALID_CHECKSUM` if it fails,\n * check if the length of the value matches the prefix type or return `INVALID_LENGTH`.\n * If all checks pass, return `VALID`.\n *\n * @param value Value to validate\n * @param prefixes prefix the value should have\n */ function validatePrefixedValue(value, prefixes) {\n    const match = new RegExp(`^(${prefixes.join(\"|\")})`).exec(value);\n    if (!match || match.length === 0) {\n        return ValidationResult.NO_PREFIX_MATCHED;\n    }\n    const prefixKey = match[0];\n    if (!isValidPrefix(prefixKey)) {\n        return ValidationResult.NO_PREFIX_MATCHED;\n    }\n    // Check whether annotation exist before starting validation\n    if (value.includes(\"%\")) {\n        value = value.split(\"%\")[0];\n    }\n    const kt1Regex = /^(KT1\\w{33})$/;\n    if (!kt1Regex.test(value) && prefixKey === \"KT1\") {\n        return ValidationResult.INVALID_CHECKSUM;\n    }\n    // decodeUnsafe return undefined if decoding fail\n    let decoded = bs58check__WEBPACK_IMPORTED_MODULE_4___default().decodeUnsafe(value);\n    if (!decoded) {\n        return ValidationResult.INVALID_CHECKSUM;\n    }\n    decoded = decoded.slice(prefix[prefixKey].length);\n    if (decoded.length !== prefixLength[prefixKey]) {\n        return ValidationResult.INVALID_LENGTH;\n    }\n    return ValidationResult.VALID;\n}\nconst implicitPrefix = [\n    Prefix.TZ1,\n    Prefix.TZ2,\n    Prefix.TZ3,\n    Prefix.TZ4\n];\nconst contractPrefix = [\n    Prefix.KT1\n];\nconst signaturePrefix = [\n    Prefix.EDSIG,\n    Prefix.P2SIG,\n    Prefix.SPSIG,\n    Prefix.SIG\n];\nconst pkPrefix = [\n    Prefix.EDPK,\n    Prefix.SPPK,\n    Prefix.P2PK,\n    Prefix.BLPK\n];\nconst operationPrefix = [\n    Prefix.O\n];\nconst protocolPrefix = [\n    Prefix.P\n];\nconst blockPrefix = [\n    Prefix.B\n];\nconst smartRollupPrefix = [\n    Prefix.SR1\n];\n/**\n * @description Used to check if an address or a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateAddress } from '@taquito/utils';\n * const pkh = 'tz1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateAddress(pkh)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validateAddress(value) {\n    return validatePrefixedValue(value, [\n        ...implicitPrefix,\n        ...contractPrefix,\n        ...smartRollupPrefix\n    ]);\n}\n/**\n * @description Used to check if a chain id is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateChain } from '@taquito/utils';\n * const chainId = 'NetXdQprcVkpaWU'\n * const validation = validateChain(chainId)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validateChain(value) {\n    return validatePrefixedValue(value, [\n        Prefix.NET\n    ]);\n}\n/**\n * @description Used to check if a contract address is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateContractAddress } from '@taquito/utils';\n * const contractAddress = 'KT1JVErLYTgtY8uGGZ4mso2npTSxqVLDRVbC'\n * const validation = validateContractAddress(contractAddress)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validateContractAddress(value) {\n    return validatePrefixedValue(value, contractPrefix);\n}\n/**\n * @description Used to check if a key hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateKeyHash } from '@taquito/utils';\n * const keyHashWithoutPrefix = '1L9r8mWmRPndRhuvMCWESLGSVeFzQ9NAWx'\n * const validation = validateKeyHash(keyHashWithoutPrefix)\n * console.log(validation)\n * // This example return 0 which correspond to NO_PREFIX_MATCHED\n * ```\n */ function validateKeyHash(value) {\n    return validatePrefixedValue(value, implicitPrefix);\n}\n/**\n * @description Used to check if a signature is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateSignature } from '@taquito/utils';\n * const signature = 'edsigtkpiSSschcaCt9pUVrpNPf7TTcgvgDEDD6NCEHMy8NNQJCGnMfLZzYoQj74yLjo9wx6MPVV29CvVzgi7qEcEUok3k7AuMg'\n * const validation = validateSignature(signature)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validateSignature(value) {\n    return validatePrefixedValue(value, signaturePrefix);\n}\n/**\n * @description Used to check if a public key is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validatePublicKey } from '@taquito/utils';\n * const publicKey = 'edpkvS5QFv7KRGfa3b87gg9DBpxSm3NpSwnjhUjNBQrRUUR66F7C9g'\n * const validation = validatePublicKey(publicKey)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validatePublicKey(value) {\n    return validatePrefixedValue(value, pkPrefix);\n}\n/**\n * @description Used to check if an operation hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateOperation } from '@taquito/utils';\n * const operationHash = 'oo6JPEAy8VuMRGaFuMmLNFFGdJgiaKfnmT1CpHJfKP3Ye5ZahiP'\n * const validation = validateOperation(operationHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validateOperation(value) {\n    return validatePrefixedValue(value, operationPrefix);\n}\n/**\n * @description Used to check if a protocol hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateProtocol } from '@taquito/utils';\n * const protocolHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateProtocol(protocolHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validateProtocol(value) {\n    return validatePrefixedValue(value, protocolPrefix);\n}\n/**\n * @description Used to check if a block hash is valid.\n *\n * @returns\n * 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n * @example\n * ```\n * import { validateBlock } from '@taquito/utils';\n * const blockHash = 'PtHangz2aRngywmSRGGvrcTyMbbdpWdpFKuS4uMWxg2RaH9i1qx'\n * const validation = validateBlock(blockHash)\n * console.log(validation)\n * // This example return 3 which correspond to VALID\n * ```\n */ function validateBlock(value) {\n    return validatePrefixedValue(value, blockPrefix);\n}\n/**\n * @description Used to check if a spending key is valid.\n * @returns 0 (NO_PREFIX_MATCHED), 1 (INVALID_CHECKSUM), 2 (INVALID_LENGTH) or 3 (VALID).\n *\n */ function validateSpendingKey(value) {\n    return validatePrefixedValue(value, [\n        Prefix.SASK\n    ]);\n}\nfunction invalidDetail(validation) {\n    switch(validation){\n        case ValidationResult.NO_PREFIX_MATCHED:\n            return \"with unsupported prefix\";\n        case ValidationResult.INVALID_CHECKSUM:\n            return \"failed checksum\";\n        case ValidationResult.INVALID_LENGTH:\n            return \"with incorrect length\";\n        default:\n            return \"\";\n    }\n}\nfunction validateSmartRollupAddress(value) {\n    return validatePrefixedValue(value, [\n        ...smartRollupPrefix\n    ]);\n}\n// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!\nconst VERSION = {\n    \"commitHash\": \"13a12ab7cf442043526745db2bbf4ef3b089c34a\",\n    \"version\": \"19.0.2\"\n};\nconst TZ_DECIMALS = 6;\nconst MTZ_DECIMALS = 3;\nfunction getDecimal(format) {\n    switch(format){\n        case \"tz\":\n            return TZ_DECIMALS;\n        case \"mtz\":\n            return MTZ_DECIMALS;\n        case \"mutez\":\n        default:\n            return 0;\n    }\n}\nfunction format(from = \"mutez\", to = \"mutez\", amount) {\n    const bigNum = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](amount);\n    if (bigNum.isNaN()) {\n        return amount;\n    }\n    return bigNum.multipliedBy(Math.pow(10, getDecimal(from))).dividedBy(Math.pow(10, getDecimal(to)));\n}\n/**\n * @packageDocumentation\n * @module @taquito/utils\n */ /*\n * Some code in this file is originally from sotez and eztz\n * Copyright (c) 2018 Andrew Kishino\n * Copyright (c) 2017 Stephen Andrews\n */ /**\n *\n * @description Hash a string using the BLAKE2b algorithm, base58 encode the hash obtained and appends the prefix 'expr' to it\n *\n * @param value Value in hex\n */ function encodeExpr(value) {\n    const blakeHash = blakejs__WEBPACK_IMPORTED_MODULE_3___default().blake2b(hex2buf(value), undefined, 32);\n    return b58cencode(blakeHash, prefix[\"expr\"]);\n}\n/**\n *\n * @description Return the operation hash of a signed operation\n * @param value Value in hex of a signed operation\n */ function encodeOpHash(value) {\n    const blakeHash = blakejs__WEBPACK_IMPORTED_MODULE_3___default().blake2b(hex2buf(value), undefined, 32);\n    return b58cencode(blakeHash, prefix.o);\n}\n/**\n *\n * @description Base58 encode a string or a Uint8Array and append a prefix to it\n *\n * @param value Value to base58 encode\n * @param prefix prefix to append to the encoded string\n */ function b58cencode(value, prefix) {\n    const payloadAr = typeof value === \"string\" ? Uint8Array.from(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(value, \"hex\")) : value;\n    const n = new Uint8Array(prefix.length + payloadAr.length);\n    n.set(prefix);\n    n.set(payloadAr, prefix.length);\n    return bs58check__WEBPACK_IMPORTED_MODULE_4___default().encode(buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(n.buffer));\n}\n/**\n *\n * @description Base58 decode a string and remove the prefix from it\n *\n * @param value Value to base58 decode\n * @param prefix prefix to remove from the decoded string\n */ const b58cdecode = (enc, prefixArg)=>bs58check__WEBPACK_IMPORTED_MODULE_4___default().decode(enc).slice(prefixArg.length);\n/**\n *\n * @description Base58 decode a string with predefined prefix\n *\n * @param value Value to base58 decode\n */ function b58decode(payload) {\n    const buf = bs58check__WEBPACK_IMPORTED_MODULE_4___default().decode(payload);\n    const prefixMap = {\n        [prefix.tz1.toString()]: \"0000\",\n        [prefix.tz2.toString()]: \"0001\",\n        [prefix.tz3.toString()]: \"0002\"\n    };\n    const pref = prefixMap[new Uint8Array(buf.slice(0, 3)).toString()];\n    if (pref) {\n        // tz addresses\n        const hex = buf2hex(buf.slice(3));\n        return pref + hex;\n    } else {\n        // other (kt addresses)\n        return \"01\" + buf2hex(buf.slice(3, 42)) + \"00\";\n    }\n}\n/**\n *\n * @description b58 decode a string without predefined prefix\n * @param value\n * @returns string of bytes\n */ function b58decodeL2Address(payload) {\n    const buf = bs58check__WEBPACK_IMPORTED_MODULE_4___default().decode(payload);\n    // tz4 address currently\n    return buf2hex(buf.slice(3, 42));\n}\n/**\n *\n * @description Base58 encode an address using predefined prefix\n *\n * @param value Address to base58 encode (tz1, tz2, tz3 or KT1)\n */ function encodePubKey(value) {\n    if (value.substring(0, 2) === \"00\") {\n        const pref = {\n            \"0000\": prefix.tz1,\n            \"0001\": prefix.tz2,\n            \"0002\": prefix.tz3\n        };\n        return b58cencode(value.substring(4), pref[value.substring(0, 4)]);\n    }\n    return b58cencode(value.substring(2, 42), prefix.KT);\n}\n/**\n *\n * @description Base58 encode an address without predefined prefix\n * @param value Address to base58 encode (tz4) hex dec\n * @returns return address\n */ function encodeL2Address(value) {\n    return b58cencode(value, prefix.tz4);\n}\n/**\n *\n * @description Base58 encode a key according to its prefix\n *\n * @param value Key to base58 encode\n */ function encodeKey(value) {\n    if (value[0] === \"0\") {\n        const pref = {\n            \"00\": new Uint8Array([\n                13,\n                15,\n                37,\n                217\n            ]),\n            \"01\": new Uint8Array([\n                3,\n                254,\n                226,\n                86\n            ]),\n            \"02\": new Uint8Array([\n                3,\n                178,\n                139,\n                127\n            ])\n        };\n        return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n    }\n}\n/**\n *\n * @description Base58 encode a key hash according to its prefix\n *\n * @param value Key hash to base58 encode\n */ function encodeKeyHash(value) {\n    if (value[0] === \"0\") {\n        const pref = {\n            \"00\": new Uint8Array([\n                6,\n                161,\n                159\n            ]),\n            \"01\": new Uint8Array([\n                6,\n                161,\n                161\n            ]),\n            \"02\": new Uint8Array([\n                6,\n                161,\n                164\n            ])\n        };\n        return b58cencode(value.substring(2), pref[value.substring(0, 2)]);\n    }\n}\n/**\n *\n * @description Convert an hex string to a Uint8Array\n *\n * @param hex Hex string to convert\n * @throws {@link ValueConversionError}\n */ const hex2buf = (hex)=>{\n    if (hex.length % 2 !== 0) {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidHexStringError(hex, `: Expecting even number of characters`);\n    }\n    const hexDigits = stripHexPrefix(hex);\n    if (!hexDigits.match(/^([\\da-f]{2})*$/gi)) {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidHexStringError(hex, `: Only characters 0-9, a-f and A-F are expected. Optionally, it can be prefixed with '0x'`);\n    }\n    const out = new Uint8Array(hexDigits.length / 2);\n    let j = 0;\n    for(let i = 0; i < hexDigits.length; i += 2){\n        const v = parseInt(hexDigits.slice(i, i + 2), 16);\n        if (Number.isNaN(v)) {\n            throw new ValueConversionError(hex, \"Uint8Array\");\n        }\n        out[j++] = v;\n    }\n    return out;\n};\n/**\n *\n * @description Merge 2 buffers together\n *\n * @param b1 First buffer\n * @param b2 Second buffer\n */ const mergebuf = (b1, b2)=>{\n    const r = new Uint8Array(b1.length + b2.length);\n    r.set(b1);\n    r.set(b2, b1.length);\n    return r;\n};\n/**\n *\n * @description Flatten a michelson json representation to an array\n *\n * @param s michelson json\n */ const mic2arr = function me2(s) {\n    let ret = [];\n    if (Object.prototype.hasOwnProperty.call(s, \"prim\")) {\n        if (s.prim === \"Pair\") {\n            ret.push(me2(s.args[0]));\n            ret = ret.concat(me2(s.args[1]));\n        } else if (s.prim === \"Elt\") {\n            ret = {\n                key: me2(s.args[0]),\n                val: me2(s.args[1])\n            };\n        } else if (s.prim === \"True\") {\n            ret = true;\n        } else if (s.prim === \"False\") {\n            ret = false;\n        }\n    } else if (Array.isArray(s)) {\n        const sc = s.length;\n        for(let i = 0; i < sc; i++){\n            const n = me2(s[i]);\n            if (typeof n.key !== \"undefined\") {\n                if (Array.isArray(ret)) {\n                    ret = {\n                        keys: [],\n                        vals: []\n                    };\n                }\n                ret.keys.push(n.key);\n                ret.vals.push(n.val);\n            } else {\n                ret.push(n);\n            }\n        }\n    } else if (Object.prototype.hasOwnProperty.call(s, \"string\")) {\n        ret = s.string;\n    } else if (Object.prototype.hasOwnProperty.call(s, \"int\")) {\n        ret = parseInt(s.int, 10);\n    } else {\n        ret = s;\n    }\n    return ret;\n};\n/**\n *\n * @description Convert a Uint8Array to an hex string\n *\n * @param buffer Uint8Array to convert\n */ const buf2hex = (buffer)=>{\n    const hexParts = [];\n    buffer.forEach((byte)=>{\n        const hex = byte.toString(16);\n        const paddedHex = `00${hex}`.slice(-2);\n        hexParts.push(paddedHex);\n    });\n    return hexParts.join(\"\");\n};\n/**\n *\n *  @description Gets Tezos address (PKH) from Public Key\n *\n *  @param publicKey Public Key\n *  @returns A string of the Tezos address (PKH) that was derived from the given Public Key\n */ const getPkhfromPk = (publicKey)=>{\n    let encodingPrefix;\n    let prefixLen;\n    const keyPrefix = validatePkAndExtractPrefix(publicKey);\n    const decoded = b58cdecode(publicKey, prefix[keyPrefix]);\n    switch(keyPrefix){\n        case Prefix.EDPK:\n            encodingPrefix = prefix[Prefix.TZ1];\n            prefixLen = prefixLength[Prefix.TZ1];\n            break;\n        case Prefix.SPPK:\n            encodingPrefix = prefix[Prefix.TZ2];\n            prefixLen = prefixLength[Prefix.TZ2];\n            break;\n        case Prefix.P2PK:\n            encodingPrefix = prefix[Prefix.TZ3];\n            prefixLen = prefixLength[Prefix.TZ3];\n            break;\n        case Prefix.BLPK:\n            encodingPrefix = prefix[Prefix.TZ4];\n            prefixLen = prefixLength[Prefix.TZ4];\n    }\n    const hashed = (0,_stablelib_blake2b__WEBPACK_IMPORTED_MODULE_2__.hash)(decoded, prefixLen);\n    const result = b58cencode(hashed, encodingPrefix);\n    return result;\n};\n/**\n *\n * @description Convert a string to bytes\n *\n * @param str String to convert\n */ function char2Bytes(str) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(str, \"utf8\").toString(\"hex\");\n}\n/**\n *\n * @description Convert bytes to a string\n *\n * @param str Bytes to convert\n */ function bytes2Char(hex) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hex2buf(hex)).toString(\"utf8\");\n}\n/**\n *\n * @description Convert hex string/UintArray/Buffer to bytes\n *\n * @param hex String value to convert to bytes\n */ function hex2Bytes(hex) {\n    const hexDigits = stripHexPrefix(hex);\n    if (!hexDigits.match(/^(0x)?([\\da-f]{2})*$/gi)) {\n        throw new _taquito_core__WEBPACK_IMPORTED_MODULE_5__.InvalidHexStringError(hex, `: Expecting even number of characters: 0-9, a-z, A-Z, optionally prefixed with 0x`);\n    }\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(hexDigits, \"hex\");\n}\n/**\n *\n * @description Converts a number or Bignumber to hexadecimal  string\n *\n * @param val The value  that will be converted to a hexadecimal string value\n */ function toHexBuf(val, bitLength = 8) {\n    return buffer__WEBPACK_IMPORTED_MODULE_0__.Buffer.from(num2PaddedHex(val, bitLength), \"hex\");\n}\n/**\n *\n * @description Converts a number or BigNumber to a padded hexadecimal string\n * @param val The value that will be converted into a padded hexadecimal string value\n * @param bitLength The length of bits\n *\n */ function num2PaddedHex(val, bitLength = 8) {\n    if (new bignumber_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](val).isPositive()) {\n        const nibbleLength = Math.ceil(bitLength / 4);\n        const hex = val.toString(16);\n        // check whether nibble (4 bits) length is higher or lower than the current hex string length\n        let targetLength = hex.length >= nibbleLength ? hex.length : nibbleLength;\n        // make sure the hex string target length is even\n        targetLength = targetLength % 2 == 0 ? targetLength : targetLength + 1;\n        return padHexWithZero(hex, targetLength);\n    } else {\n        const twosCompliment = new bignumber_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](2).pow(bitLength).minus(new bignumber_js__WEBPACK_IMPORTED_MODULE_6__[\"default\"](val).abs());\n        return twosCompliment.toString(16);\n    }\n}\nfunction padHexWithZero(hex, targetLength) {\n    const padString = \"0\";\n    if (hex.length >= targetLength) {\n        return hex;\n    } else {\n        const padLength = targetLength - hex.length;\n        return padString.repeat(padLength) + hex;\n    }\n}\n/**\n *\n * @description Strips the first 2 characters of a hex string (0x)\n *\n * @param hex string to strip prefix from\n */ function stripHexPrefix(hex) {\n    return hex.startsWith(\"0x\") ? hex.slice(2) : hex;\n}\n //# sourceMappingURL=taquito-utils.es6.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vdXRpbHMvZGlzdC90YXF1aXRvLXV0aWxzLmVzNi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBZ0M7QUFDWTtBQUNGO0FBQ2Q7QUFDTTtBQUN5STtBQUNpTDtBQUN2VDtBQUNMO0FBQ1k7QUFFNUMsSUFBSXdCO0FBQ0gsVUFBVUEsTUFBTTtJQUNiQSxNQUFNLENBQUMsTUFBTSxHQUFHO0lBQ2hCQSxNQUFNLENBQUMsTUFBTSxHQUFHO0lBQ2hCQSxNQUFNLENBQUMsTUFBTSxHQUFHO0lBQ2hCQSxNQUFNLENBQUMsTUFBTSxHQUFHO0lBQ2hCQSxNQUFNLENBQUMsS0FBSyxHQUFHO0lBQ2ZBLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDaEJBLE1BQU0sQ0FBQyxRQUFRLEdBQUc7SUFDbEJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakJBLE1BQU0sQ0FBQyxRQUFRLEdBQUc7SUFDbEJBLE1BQU0sQ0FBQyxRQUFRLEdBQUc7SUFDbEJBLE1BQU0sQ0FBQyxRQUFRLEdBQUc7SUFDbEJBLE1BQU0sQ0FBQyxPQUFPLEdBQUc7SUFDakJBLE1BQU0sQ0FBQyxRQUFRLEdBQUc7SUFDbEJBLE1BQU0sQ0FBQyxRQUFRLEdBQUc7SUFDbEJBLE1BQU0sQ0FBQyxRQUFRLEdBQUc7SUFDbEJBLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDaEJBLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDaEJBLE1BQU0sQ0FBQyxNQUFNLEdBQUc7SUFDaEJBLE1BQU0sQ0FBQyxJQUFJLEdBQUc7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NEYsSUFBSXZELEtBQUssQ0FBQyxLQUFLdUQ7QUFDakQ7QUFFb3FCLENBQ3BxQiw2Q0FBNkMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd3JwZXJrcy8uL25vZGVfbW9kdWxlcy9AdGFxdWl0by91dGlscy9kaXN0L3RhcXVpdG8tdXRpbHMuZXM2LmpzPzNlNjgiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyIH0gZnJvbSAnYnVmZmVyJztcbmltcG9ydCB7IHZlcmlmeSB9IGZyb20gJ0BzdGFibGVsaWIvZWQyNTUxOSc7XG5pbXBvcnQgeyBoYXNoIH0gZnJvbSAnQHN0YWJsZWxpYi9ibGFrZTJiJztcbmltcG9ydCBibGFrZSBmcm9tICdibGFrZWpzJztcbmltcG9ydCBiczU4Y2hlY2sgZnJvbSAnYnM1OGNoZWNrJztcbmltcG9ydCB7IEludmFsaWRNZXNzYWdlRXJyb3IsIEludmFsaWRQdWJsaWNLZXlFcnJvciwgSW52YWxpZFNpZ25hdHVyZUVycm9yLCBQYXJhbWV0ZXJWYWxpZGF0aW9uRXJyb3IsIFVuc3VwcG9ydGVkQWN0aW9uRXJyb3IsIEludmFsaWRIZXhTdHJpbmdFcnJvciB9IGZyb20gJ0B0YXF1aXRvL2NvcmUnO1xuZXhwb3J0IHsgRGVwcmVjYXRpb25FcnJvciwgSW52YWxpZEFkZHJlc3NFcnJvciwgSW52YWxpZEJsb2NrSGFzaEVycm9yLCBJbnZhbGlkQ2hhaW5JZEVycm9yLCBJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IsIEludmFsaWRIZXhTdHJpbmdFcnJvciwgSW52YWxpZEtleUVycm9yLCBJbnZhbGlkS2V5SGFzaEVycm9yLCBJbnZhbGlkTWVzc2FnZUVycm9yLCBJbnZhbGlkT3BlcmF0aW9uSGFzaEVycm9yLCBJbnZhbGlkT3BlcmF0aW9uS2luZEVycm9yLCBJbnZhbGlkUHVibGljS2V5RXJyb3IsIEludmFsaWRTaWduYXR1cmVFcnJvciwgUHJvaGliaXRlZEFjdGlvbkVycm9yIH0gZnJvbSAnQHRhcXVpdG8vY29yZSc7XG5pbXBvcnQgQmlnTnVtYmVyIGZyb20gJ2JpZ251bWJlci5qcyc7XG5pbXBvcnQgZWxsaXB0aWMgZnJvbSAnZWxsaXB0aWMnO1xuaW1wb3J0IHRvQnVmZmVyIGZyb20gJ3R5cGVkYXJyYXktdG8tYnVmZmVyJztcblxudmFyIFByZWZpeDtcbihmdW5jdGlvbiAoUHJlZml4KSB7XG4gICAgUHJlZml4W1wiVFoxXCJdID0gXCJ0ejFcIjtcbiAgICBQcmVmaXhbXCJUWjJcIl0gPSBcInR6MlwiO1xuICAgIFByZWZpeFtcIlRaM1wiXSA9IFwidHozXCI7XG4gICAgUHJlZml4W1wiVFo0XCJdID0gXCJ0ejRcIjtcbiAgICBQcmVmaXhbXCJLVFwiXSA9IFwiS1RcIjtcbiAgICBQcmVmaXhbXCJLVDFcIl0gPSBcIktUMVwiO1xuICAgIFByZWZpeFtcIkVEU0syXCJdID0gXCJlZHNrMlwiO1xuICAgIFByZWZpeFtcIlNQU0tcIl0gPSBcInNwc2tcIjtcbiAgICBQcmVmaXhbXCJQMlNLXCJdID0gXCJwMnNrXCI7XG4gICAgUHJlZml4W1wiRURQS1wiXSA9IFwiZWRwa1wiO1xuICAgIFByZWZpeFtcIlNQUEtcIl0gPSBcInNwcGtcIjtcbiAgICBQcmVmaXhbXCJQMlBLXCJdID0gXCJwMnBrXCI7XG4gICAgUHJlZml4W1wiQkxQS1wiXSA9IFwiQkxwa1wiO1xuICAgIFByZWZpeFtcIkVERVNLXCJdID0gXCJlZGVza1wiO1xuICAgIFByZWZpeFtcIlNQRVNLXCJdID0gXCJzcGVza1wiO1xuICAgIFByZWZpeFtcIlAyRVNLXCJdID0gXCJwMmVza1wiO1xuICAgIFByZWZpeFtcIkVEU0tcIl0gPSBcImVkc2tcIjtcbiAgICBQcmVmaXhbXCJFRFNJR1wiXSA9IFwiZWRzaWdcIjtcbiAgICBQcmVmaXhbXCJTUFNJR1wiXSA9IFwic3BzaWdcIjtcbiAgICBQcmVmaXhbXCJQMlNJR1wiXSA9IFwicDJzaWdcIjtcbiAgICBQcmVmaXhbXCJTSUdcIl0gPSBcInNpZ1wiO1xuICAgIFByZWZpeFtcIk5FVFwiXSA9IFwiTmV0XCI7XG4gICAgUHJlZml4W1wiTkNFXCJdID0gXCJuY2VcIjtcbiAgICBQcmVmaXhbXCJCXCJdID0gXCJCXCI7XG4gICAgUHJlZml4W1wiT1wiXSA9IFwib1wiO1xuICAgIFByZWZpeFtcIkxPXCJdID0gXCJMb1wiO1xuICAgIFByZWZpeFtcIkxMT1wiXSA9IFwiTExvXCI7XG4gICAgUHJlZml4W1wiUFwiXSA9IFwiUFwiO1xuICAgIFByZWZpeFtcIkNPXCJdID0gXCJDb1wiO1xuICAgIFByZWZpeFtcIklEXCJdID0gXCJpZFwiO1xuICAgIFByZWZpeFtcIkVYUFJcIl0gPSBcImV4cHJcIjtcbiAgICBQcmVmaXhbXCJUWlwiXSA9IFwiVFpcIjtcbiAgICBQcmVmaXhbXCJWSFwiXSA9IFwidmhcIjtcbiAgICBQcmVmaXhbXCJTQVNLXCJdID0gXCJzYXNrXCI7XG4gICAgUHJlZml4W1wiWkVUMVwiXSA9IFwiemV0MVwiO1xuICAgIFByZWZpeFtcIlNSMVwiXSA9IFwic3IxXCI7XG4gICAgUHJlZml4W1wiU1JDMVwiXSA9IFwic3JjMVwiO1xufSkoUHJlZml4IHx8IChQcmVmaXggPSB7fSkpO1xuY29uc3QgcHJlZml4ID0ge1xuICAgIFtQcmVmaXguVFoxXTogbmV3IFVpbnQ4QXJyYXkoWzYsIDE2MSwgMTU5XSksXG4gICAgW1ByZWZpeC5UWjJdOiBuZXcgVWludDhBcnJheShbNiwgMTYxLCAxNjFdKSxcbiAgICBbUHJlZml4LlRaM106IG5ldyBVaW50OEFycmF5KFs2LCAxNjEsIDE2NF0pLFxuICAgIFtQcmVmaXguVFo0XTogbmV3IFVpbnQ4QXJyYXkoWzYsIDE2MSwgMTY2XSksXG4gICAgW1ByZWZpeC5LVF06IG5ldyBVaW50OEFycmF5KFsyLCA5MCwgMTIxXSksXG4gICAgW1ByZWZpeC5LVDFdOiBuZXcgVWludDhBcnJheShbMiwgOTAsIDEyMV0pLFxuICAgIFtQcmVmaXguRURTS106IG5ldyBVaW50OEFycmF5KFs0MywgMjQ2LCA3OCwgN10pLFxuICAgIFtQcmVmaXguRURTSzJdOiBuZXcgVWludDhBcnJheShbMTMsIDE1LCA1OCwgN10pLFxuICAgIFtQcmVmaXguU1BTS106IG5ldyBVaW50OEFycmF5KFsxNywgMTYyLCAyMjQsIDIwMV0pLFxuICAgIFtQcmVmaXguUDJTS106IG5ldyBVaW50OEFycmF5KFsxNiwgODEsIDIzOCwgMTg5XSksXG4gICAgW1ByZWZpeC5FRFBLXTogbmV3IFVpbnQ4QXJyYXkoWzEzLCAxNSwgMzcsIDIxN10pLFxuICAgIFtQcmVmaXguU1BQS106IG5ldyBVaW50OEFycmF5KFszLCAyNTQsIDIyNiwgODZdKSxcbiAgICBbUHJlZml4LlAyUEtdOiBuZXcgVWludDhBcnJheShbMywgMTc4LCAxMzksIDEyN10pLFxuICAgIFtQcmVmaXguQkxQS106IG5ldyBVaW50OEFycmF5KFs2LCAxNDksIDEzNSwgMjA0XSksXG4gICAgW1ByZWZpeC5FREVTS106IG5ldyBVaW50OEFycmF5KFs3LCA5MCwgNjAsIDE3OSwgNDFdKSxcbiAgICBbUHJlZml4LlNQRVNLXTogbmV3IFVpbnQ4QXJyYXkoWzB4MDksIDB4ZWQsIDB4ZjEsIDB4YWUsIDB4OTZdKSxcbiAgICBbUHJlZml4LlAyRVNLXTogbmV3IFVpbnQ4QXJyYXkoWzB4MDksIDB4MzAsIDB4MzksIDB4NzMsIDB4YWJdKSxcbiAgICBbUHJlZml4LkVEU0lHXTogbmV3IFVpbnQ4QXJyYXkoWzksIDI0NSwgMjA1LCAxMzQsIDE4XSksXG4gICAgW1ByZWZpeC5TUFNJR106IG5ldyBVaW50OEFycmF5KFsxMywgMTE1LCAxMDEsIDE5LCA2M10pLFxuICAgIFtQcmVmaXguUDJTSUddOiBuZXcgVWludDhBcnJheShbNTQsIDI0MCwgNDQsIDUyXSksXG4gICAgW1ByZWZpeC5TSUddOiBuZXcgVWludDhBcnJheShbNCwgMTMwLCA0M10pLFxuICAgIFtQcmVmaXguTkVUXTogbmV3IFVpbnQ4QXJyYXkoWzg3LCA4MiwgMF0pLFxuICAgIFtQcmVmaXguTkNFXTogbmV3IFVpbnQ4QXJyYXkoWzY5LCAyMjAsIDE2OV0pLFxuICAgIFtQcmVmaXguQl06IG5ldyBVaW50OEFycmF5KFsxLCA1Ml0pLFxuICAgIFtQcmVmaXguT106IG5ldyBVaW50OEFycmF5KFs1LCAxMTZdKSxcbiAgICBbUHJlZml4LkxPXTogbmV3IFVpbnQ4QXJyYXkoWzEzMywgMjMzXSksXG4gICAgW1ByZWZpeC5MTE9dOiBuZXcgVWludDhBcnJheShbMjksIDE1OSwgMTA5XSksXG4gICAgW1ByZWZpeC5QXTogbmV3IFVpbnQ4QXJyYXkoWzIsIDE3MF0pLFxuICAgIFtQcmVmaXguQ09dOiBuZXcgVWludDhBcnJheShbNzksIDE3OV0pLFxuICAgIFtQcmVmaXguSURdOiBuZXcgVWludDhBcnJheShbMTUzLCAxMDNdKSxcbiAgICBbUHJlZml4LkVYUFJdOiBuZXcgVWludDhBcnJheShbMTMsIDQ0LCA2NCwgMjddKSxcbiAgICAvLyBMZWdhY3kgcHJlZml4XG4gICAgW1ByZWZpeC5UWl06IG5ldyBVaW50OEFycmF5KFsyLCA5MCwgMTIxXSksXG4gICAgW1ByZWZpeC5WSF06IG5ldyBVaW50OEFycmF5KFsxLCAxMDYsIDI0Ml0pLFxuICAgIFtQcmVmaXguU0FTS106IG5ldyBVaW50OEFycmF5KFsxMSwgMjM3LCAyMCwgOTJdKSxcbiAgICBbUHJlZml4LlpFVDFdOiBuZXcgVWludDhBcnJheShbMTgsIDcxLCA0MCwgMjIzXSksXG4gICAgW1ByZWZpeC5TUjFdOiBuZXcgVWludDhBcnJheShbNiwgMTI0LCAxMTddKSxcbiAgICBbUHJlZml4LlNSQzFdOiBuZXcgVWludDhBcnJheShbMTcsIDE2NSwgMTM0LCAxMzhdKSxcbn07XG5jb25zdCBwcmVmaXhMZW5ndGggPSB7XG4gICAgW1ByZWZpeC5UWjFdOiAyMCxcbiAgICBbUHJlZml4LlRaMl06IDIwLFxuICAgIFtQcmVmaXguVFozXTogMjAsXG4gICAgW1ByZWZpeC5UWjRdOiAyMCxcbiAgICBbUHJlZml4LktUXTogMjAsXG4gICAgW1ByZWZpeC5LVDFdOiAyMCxcbiAgICBbUHJlZml4LkVEUEtdOiAzMixcbiAgICBbUHJlZml4LlNQUEtdOiAzMyxcbiAgICBbUHJlZml4LlAyUEtdOiAzMyxcbiAgICAvL3dvcmtpbmcgd2l0aCB2YWx1ZSBpbiBjb21tZW50IGZvciBiYXNlNTgubWwgbGluZSA0NDUgYnV0IG5vdCBjb25zaXN0ZW50IHdpdGggdGhlIHRocmVlIGFib3ZlXG4gICAgW1ByZWZpeC5CTFBLXTogNDgsXG4gICAgW1ByZWZpeC5FRFNJR106IDY0LFxuICAgIFtQcmVmaXguU1BTSUddOiA2NCxcbiAgICBbUHJlZml4LlAyU0lHXTogNjQsXG4gICAgW1ByZWZpeC5TSUddOiA2NCxcbiAgICBbUHJlZml4Lk5FVF06IDQsXG4gICAgW1ByZWZpeC5CXTogMzIsXG4gICAgW1ByZWZpeC5QXTogMzIsXG4gICAgW1ByZWZpeC5PXTogMzIsXG4gICAgW1ByZWZpeC5WSF06IDMyLFxuICAgIFtQcmVmaXguU0FTS106IDE2OSxcbiAgICBbUHJlZml4LlpFVDFdOiA0MyxcbiAgICBbUHJlZml4LlNSMV06IDIwLFxuICAgIFtQcmVmaXguU1JDMV06IDMyLFxufTtcblxuLyoqXG4gKiBAZGVzY3JpcHRpb24gVmVyaWZ5IHNpZ25hdHVyZSBvZiBhIHBheWxvYWRcbiAqXG4gKiBAcGFyYW0gbWVzc2FnZUJ5dGVzIFRoZSBmb3JnZWQgbWVzc2FnZSBpbmNsdWRpbmcgdGhlIG1hZ2ljIGJ5dGUgKDExIGZvciBibG9jayxcbiAqICAgICAgICAxMiBmb3IgcHJlYXR0ZXN0YXRpb24vcHJlZW5kb3JzZW1lbnQsIDEzIGZvciBhdHRlc3RhdGlvbi9lbmRvcnNlbWVudCwgMyBmb3IgZ2VuZXJpYywgNSBmb3IgdGhlIFBBQ0sgZm9ybWF0IG9mIG1pY2hlbHNvbilcbiAqIEBwYXJhbSBwdWJsaWNLZXkgVGhlIHB1YmxpYyBrZXkgdG8gdmVyaWZ5IHRoZSBzaWduYXR1cmUgYWdhaW5zdFxuICogQHBhcmFtIHNpZ25hdHVyZSBUaGUgc2lnbmF0dXJlIHRvIHZlcmlmeVxuICogQHJldHVybnMgQSBib29sZWFuIGluZGljYXRpbmcgaWYgdGhlIHNpZ25hdHVyZSBtYXRjaGVzXG4gKiBAdGhyb3dzIHtAbGluayBJbnZhbGlkUHVibGljS2V5RXJyb3J9IHwge0BsaW5rIEludmFsaWRTaWduYXR1cmVFcnJvcn0gfCB7QGxpbmsgSW52YWxpZE1lc3NhZ2VFcnJvcn1cbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGNvbnN0IG1lc3NhZ2UgPSAnMDNkMGMxMGUzZWQxMWQ3YzZlMzM1N2Y2ZWYzMzViYWI5ZThmMmJkNTRkMGNlMjBjNDgyZTI0MTE5MWE2ZTRiOGNlNmMwMWJlOTE3MzExZDlhYzQ2OTU5NzUwZTQwNWQ1N2UyNjhlMmVkOWUxNzRhODA3OTRmYmQ1MDRlMTJhNGEwMDAxNDFlYjM3ODFhZmVkMmY2OTY3OWZmMmJiZTFjNTM3NTk1MGIwZTQwZDAwZmYwMDAwMDAwMDVlMDUwNTA1MDUwNTA1MDcwNzAxMDAwMDAwMjQ3NDdhMzI1MjY3NzM0ODZlNzQ1MTZiNzI3OTQ2NzA3MDczNTI0NjYyNjEzMTM2NTI1NDY2NTY1MDM1Mzk2ODRiNzI2NTRhNGQwNzA3MDEwMDAwMDAyNDc0N2EzMTVhNjY3MjQ1NTI2MzQxNGM0Mjc3NmQ0MTcxNzc2ZjZlNTI1ODU5NTY1MTQyNDQ1NDM5NDI2YTRlNmE0MjQ4NGE3NTAwMDEnO1xuICogY29uc3QgcGsgPSAnc3BwazdjN2hrUGo0N3lqWUZFSFg4NXE0NnNGSkd3NlJCcnFvVlNId0FKQVQ0ZTE0S0p3em9leSc7XG4gKiBjb25zdCBzaWcgPSAnc3BzaWcxY2RMa3AxUkxnVUhBcDEzYVJGa1o2TVFEUHA3eENuakFFeEdMM01CU2RNRG1UNkpnUVNYOGN1ZnlEZ0pSTTNzaW5GdGlDekxic3lQNmQzNjVFSG9OZXZ4aFQ0N254J1xuICpcbiAqIGNvbnN0IHJlc3BvbnNlID0gdmVyaWZ5U2lnbmF0dXJlKG1lc3NhZ2UsIHBrLCBzaWcpO1xuICogYGBgXG4gKlxuICovXG5mdW5jdGlvbiB2ZXJpZnlTaWduYXR1cmUobWVzc2FnZUJ5dGVzLCBwdWJsaWNLZXksIHNpZ25hdHVyZSwgd2F0ZXJtYXJrKSB7XG4gICAgY29uc3QgcGtQcmVmaXggPSB2YWxpZGF0ZVBrQW5kRXh0cmFjdFByZWZpeChwdWJsaWNLZXkpO1xuICAgIGNvbnN0IHNpZ1ByZWZpeCA9IHZhbGlkYXRlU2lnQW5kRXh0cmFjdFByZWZpeChzaWduYXR1cmUpO1xuICAgIGNvbnN0IGRlY29kZWRQdWJsaWNLZXkgPSBiNThjZGVjb2RlKHB1YmxpY0tleSwgcHJlZml4W3BrUHJlZml4XSk7XG4gICAgY29uc3QgZGVjb2RlZFNpZyA9IGI1OGNkZWNvZGUoc2lnbmF0dXJlLCBwcmVmaXhbc2lnUHJlZml4XSk7XG4gICAgbGV0IG1lc3NhZ2VCdWYgPSBoZXgyYnVmKHZhbGlkYXRlTWVzc2FnZU5vdEVtcHR5KG1lc3NhZ2VCeXRlcykpO1xuICAgIGlmICh0eXBlb2Ygd2F0ZXJtYXJrICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtZXNzYWdlQnVmID0gbWVyZ2VidWYod2F0ZXJtYXJrLCBtZXNzYWdlQnVmKTtcbiAgICB9XG4gICAgY29uc3QgYnl0ZXNIYXNoID0gaGFzaChtZXNzYWdlQnVmLCAzMik7XG4gICAgaWYgKHBrUHJlZml4ID09PSBQcmVmaXguRURQSykge1xuICAgICAgICByZXR1cm4gdmVyaWZ5RWRTaWduYXR1cmUoZGVjb2RlZFNpZywgYnl0ZXNIYXNoLCBkZWNvZGVkUHVibGljS2V5KTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGtQcmVmaXggPT09IFByZWZpeC5TUFBLKSB7XG4gICAgICAgIHJldHVybiB2ZXJpZnlTcFNpZ25hdHVyZShkZWNvZGVkU2lnLCBieXRlc0hhc2gsIGRlY29kZWRQdWJsaWNLZXkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwa1ByZWZpeCA9PT0gUHJlZml4LlAyUEspIHtcbiAgICAgICAgcmV0dXJuIHZlcmlmeVAyU2lnbmF0dXJlKGRlY29kZWRTaWcsIGJ5dGVzSGFzaCwgZGVjb2RlZFB1YmxpY0tleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVNZXNzYWdlTm90RW1wdHkobWVzc2FnZSkge1xuICAgIGlmIChtZXNzYWdlID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZE1lc3NhZ2VFcnJvcihtZXNzYWdlLCBgY2FuJ3QgYmUgZW1wdHlgKTtcbiAgICB9XG4gICAgcmV0dXJuIG1lc3NhZ2U7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZVBrQW5kRXh0cmFjdFByZWZpeChwdWJsaWNLZXkpIHtcbiAgICBpZiAocHVibGljS2V5ID09PSAnJykge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFB1YmxpY0tleUVycm9yKHB1YmxpY0tleSwgYGNhbid0IGJlIGVtcHR5YCk7XG4gICAgfVxuICAgIGNvbnN0IHBrUHJlZml4ID0gcHVibGljS2V5LnN1YnN0cmluZygwLCA0KTtcbiAgICBjb25zdCBwdWJsaWNLZXlWYWxpZGF0aW9uID0gdmFsaWRhdGVQdWJsaWNLZXkocHVibGljS2V5KTtcbiAgICBpZiAocHVibGljS2V5VmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFB1YmxpY0tleUVycm9yKHB1YmxpY0tleSwgaW52YWxpZERldGFpbChwdWJsaWNLZXlWYWxpZGF0aW9uKSk7XG4gICAgfVxuICAgIHJldHVybiBwa1ByZWZpeDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU2lnQW5kRXh0cmFjdFByZWZpeChzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWduYXR1cmVQcmVmaXggPSBzaWduYXR1cmUuc3RhcnRzV2l0aCgnc2lnJylcbiAgICAgICAgPyBzaWduYXR1cmUuc3Vic3RyaW5nKDAsIDMpXG4gICAgICAgIDogc2lnbmF0dXJlLnN1YnN0cmluZygwLCA1KTtcbiAgICBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVTaWduYXR1cmUoc2lnbmF0dXJlKTtcbiAgICBpZiAodmFsaWRhdGlvbiAhPT0gVmFsaWRhdGlvblJlc3VsdC5WQUxJRCkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZFNpZ25hdHVyZUVycm9yKHNpZ25hdHVyZSwgaW52YWxpZERldGFpbCh2YWxpZGF0aW9uKSk7XG4gICAgfVxuICAgIHJldHVybiBzaWduYXR1cmVQcmVmaXg7XG59XG5mdW5jdGlvbiB2ZXJpZnlFZFNpZ25hdHVyZShkZWNvZGVkU2lnLCBieXRlc0hhc2gsIGRlY29kZWRQdWJsaWNLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gdmVyaWZ5KGRlY29kZWRQdWJsaWNLZXksIGJ5dGVzSGFzaCwgZGVjb2RlZFNpZyk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlTcFNpZ25hdHVyZShkZWNvZGVkU2lnLCBieXRlc0hhc2gsIGRlY29kZWRQdWJsaWNLZXkpIHtcbiAgICBjb25zdCBrZXkgPSBuZXcgZWxsaXB0aWMuZWMoJ3NlY3AyNTZrMScpLmtleUZyb21QdWJsaWMoZGVjb2RlZFB1YmxpY0tleSk7XG4gICAgcmV0dXJuIHZlcmlmeVNwT3JQMlNpZyhkZWNvZGVkU2lnLCBieXRlc0hhc2gsIGtleSk7XG59XG5mdW5jdGlvbiB2ZXJpZnlQMlNpZ25hdHVyZShkZWNvZGVkU2lnLCBieXRlc0hhc2gsIGRlY29kZWRQdWJsaWNLZXkpIHtcbiAgICBjb25zdCBrZXkgPSBuZXcgZWxsaXB0aWMuZWMoJ3AyNTYnKS5rZXlGcm9tUHVibGljKGRlY29kZWRQdWJsaWNLZXkpO1xuICAgIHJldHVybiB2ZXJpZnlTcE9yUDJTaWcoZGVjb2RlZFNpZywgYnl0ZXNIYXNoLCBrZXkpO1xufVxuZnVuY3Rpb24gdmVyaWZ5U3BPclAyU2lnKGRlY29kZWRTaWcsIGJ5dGVzSGFzaCwga2V5KSB7XG4gICAgY29uc3QgaGV4U2lnID0gYnVmMmhleCh0b0J1ZmZlcihkZWNvZGVkU2lnKSk7XG4gICAgY29uc3QgbWF0Y2ggPSBoZXhTaWcubWF0Y2goLyhbYS1mXFxkXXs2NH0pL2dpKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IFtyLCBzXSA9IG1hdGNoO1xuICAgICAgICAgICAgcmV0dXJuIGtleS52ZXJpZnkoYnl0ZXNIYXNoLCB7IHIsIHMgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogIEBjYXRlZ29yeSBFcnJvclxuICogIEBkZXNjcmlwdGlvbiBFcnJvciB0aGF0IGluZGljYXRlcyBpbnZhbGlkIHByb3RvY29sIGhhc2ggYmVpbmcgcGFzc2VkIG9yIHVzZWRcbiAqL1xuY2xhc3MgSW52YWxpZFByb3RvY29sSGFzaEVycm9yIGV4dGVuZHMgUGFyYW1ldGVyVmFsaWRhdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm90b2NvbEhhc2gsIGVycm9yRGV0YWlscykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnByb3RvY29sSGFzaCA9IHByb3RvY29sSGFzaDtcbiAgICAgICAgdGhpcy5lcnJvckRldGFpbHMgPSBlcnJvckRldGFpbHM7XG4gICAgICAgIHRoaXMubmFtZSA9ICdJbnZhbGlkUHJvdG9jb2xIYXNoRXJyb3InO1xuICAgICAgICB0aGlzLm5hbWUgPSAnSW52YWxpZFByb3RvY29sSGFzaEVycm9yJztcbiAgICAgICAgdGhpcy5tZXNzYWdlID0gYFRoZSBwcm90b2NvbCBoYXNoICcke3Byb3RvY29sSGFzaH0nIGlzIGludmFsaWRgO1xuICAgICAgICBlcnJvckRldGFpbHMgPyAodGhpcy5tZXNzYWdlICs9IGA6ICR7ZXJyb3JEZXRhaWxzfWApIDogbnVsbDtcbiAgICB9XG59XG4vKipcbiAqICBAY2F0ZWdvcnkgRXJyb3JcbiAqICBAZGVzY3JpcHRpb24gRXJyb3IgdGhhdCBpbmRpY2F0ZXMgdW5hYmxlIHRvIGNvbnZlcnQgZGF0YSB0eXBlIGZyb20gb25lIHRvIGFub3RoZXJcbiAqL1xuY2xhc3MgVmFsdWVDb252ZXJzaW9uRXJyb3IgZXh0ZW5kcyBVbnN1cHBvcnRlZEFjdGlvbkVycm9yIHtcbiAgICBjb25zdHJ1Y3Rvcih2YWx1ZSwgZGVzaXJlZFR5cGUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmRlc2lyZWRUeXBlID0gZGVzaXJlZFR5cGU7XG4gICAgICAgIHRoaXMubmFtZSA9ICdWYWx1ZUNvbnZlcnNpb25FcnJvcic7XG4gICAgICAgIHRoaXMubWVzc2FnZSA9IGBVbmFibGUgdG8gY29udmVydCAke3ZhbHVlfSB0byBhICR7ZGVzaXJlZFR5cGV9YDtcbiAgICB9XG59XG5cbnZhciBWYWxpZGF0aW9uUmVzdWx0O1xuKGZ1bmN0aW9uIChWYWxpZGF0aW9uUmVzdWx0KSB7XG4gICAgVmFsaWRhdGlvblJlc3VsdFtWYWxpZGF0aW9uUmVzdWx0W1wiTk9fUFJFRklYX01BVENIRURcIl0gPSAwXSA9IFwiTk9fUFJFRklYX01BVENIRURcIjtcbiAgICBWYWxpZGF0aW9uUmVzdWx0W1ZhbGlkYXRpb25SZXN1bHRbXCJJTlZBTElEX0NIRUNLU1VNXCJdID0gMV0gPSBcIklOVkFMSURfQ0hFQ0tTVU1cIjtcbiAgICBWYWxpZGF0aW9uUmVzdWx0W1ZhbGlkYXRpb25SZXN1bHRbXCJJTlZBTElEX0xFTkdUSFwiXSA9IDJdID0gXCJJTlZBTElEX0xFTkdUSFwiO1xuICAgIFZhbGlkYXRpb25SZXN1bHRbVmFsaWRhdGlvblJlc3VsdFtcIlZBTElEXCJdID0gM10gPSBcIlZBTElEXCI7XG59KShWYWxpZGF0aW9uUmVzdWx0IHx8IChWYWxpZGF0aW9uUmVzdWx0ID0ge30pKTtcbmZ1bmN0aW9uIGlzVmFsaWRQcmVmaXgodmFsdWUpIHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZSBpbiBwcmVmaXg7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBUaGlzIGZ1bmN0aW9uIGlzIGNhbGxlZCBieSB0aGUgdmFsaWRhdGlvbiBmdW5jdGlvbnMgKFtbdmFsaWRhdGVBZGRyZXNzXV0sIFtbdmFsaWRhdGVDaGFpbl1dLCBbW3ZhbGlkYXRlQ29udHJhY3RBZGRyZXNzXV0sIFtbdmFsaWRhdGVLZXlIYXNoXV0sIFtbdmFsaWRhdGVTaWduYXR1cmVdXSwgW1t2YWxpZGF0ZVB1YmxpY0tleV1dKS5cbiAqIFZlcmlmeSBpZiB0aGUgdmFsdWUgaGFzIHRoZSByaWdodCBwcmVmaXggb3IgcmV0dXJuIGBOT19QUkVGSVhfTUFUQ0hFRGAsXG4gKiBkZWNvZGUgdGhlIHZhbHVlIHVzaW5nIGJhc2U1OCBhbmQgcmV0dXJuIGBJTlZBTElEX0NIRUNLU1VNYCBpZiBpdCBmYWlscyxcbiAqIGNoZWNrIGlmIHRoZSBsZW5ndGggb2YgdGhlIHZhbHVlIG1hdGNoZXMgdGhlIHByZWZpeCB0eXBlIG9yIHJldHVybiBgSU5WQUxJRF9MRU5HVEhgLlxuICogSWYgYWxsIGNoZWNrcyBwYXNzLCByZXR1cm4gYFZBTElEYC5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgdG8gdmFsaWRhdGVcbiAqIEBwYXJhbSBwcmVmaXhlcyBwcmVmaXggdGhlIHZhbHVlIHNob3VsZCBoYXZlXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUHJlZml4ZWRWYWx1ZSh2YWx1ZSwgcHJlZml4ZXMpIHtcbiAgICBjb25zdCBtYXRjaCA9IG5ldyBSZWdFeHAoYF4oJHtwcmVmaXhlcy5qb2luKCd8Jyl9KWApLmV4ZWModmFsdWUpO1xuICAgIGlmICghbWF0Y2ggfHwgbWF0Y2gubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBWYWxpZGF0aW9uUmVzdWx0Lk5PX1BSRUZJWF9NQVRDSEVEO1xuICAgIH1cbiAgICBjb25zdCBwcmVmaXhLZXkgPSBtYXRjaFswXTtcbiAgICBpZiAoIWlzVmFsaWRQcmVmaXgocHJlZml4S2V5KSkge1xuICAgICAgICByZXR1cm4gVmFsaWRhdGlvblJlc3VsdC5OT19QUkVGSVhfTUFUQ0hFRDtcbiAgICB9XG4gICAgLy8gQ2hlY2sgd2hldGhlciBhbm5vdGF0aW9uIGV4aXN0IGJlZm9yZSBzdGFydGluZyB2YWxpZGF0aW9uXG4gICAgaWYgKHZhbHVlLmluY2x1ZGVzKCclJykpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnJScpWzBdO1xuICAgIH1cbiAgICBjb25zdCBrdDFSZWdleCA9IC9eKEtUMVxcd3szM30pJC87XG4gICAgaWYgKCFrdDFSZWdleC50ZXN0KHZhbHVlKSAmJiBwcmVmaXhLZXkgPT09ICdLVDEnKSB7XG4gICAgICAgIHJldHVybiBWYWxpZGF0aW9uUmVzdWx0LklOVkFMSURfQ0hFQ0tTVU07XG4gICAgfVxuICAgIC8vIGRlY29kZVVuc2FmZSByZXR1cm4gdW5kZWZpbmVkIGlmIGRlY29kaW5nIGZhaWxcbiAgICBsZXQgZGVjb2RlZCA9IGJzNThjaGVjay5kZWNvZGVVbnNhZmUodmFsdWUpO1xuICAgIGlmICghZGVjb2RlZCkge1xuICAgICAgICByZXR1cm4gVmFsaWRhdGlvblJlc3VsdC5JTlZBTElEX0NIRUNLU1VNO1xuICAgIH1cbiAgICBkZWNvZGVkID0gZGVjb2RlZC5zbGljZShwcmVmaXhbcHJlZml4S2V5XS5sZW5ndGgpO1xuICAgIGlmIChkZWNvZGVkLmxlbmd0aCAhPT0gcHJlZml4TGVuZ3RoW3ByZWZpeEtleV0pIHtcbiAgICAgICAgcmV0dXJuIFZhbGlkYXRpb25SZXN1bHQuSU5WQUxJRF9MRU5HVEg7XG4gICAgfVxuICAgIHJldHVybiBWYWxpZGF0aW9uUmVzdWx0LlZBTElEO1xufVxuY29uc3QgaW1wbGljaXRQcmVmaXggPSBbUHJlZml4LlRaMSwgUHJlZml4LlRaMiwgUHJlZml4LlRaMywgUHJlZml4LlRaNF07XG5jb25zdCBjb250cmFjdFByZWZpeCA9IFtQcmVmaXguS1QxXTtcbmNvbnN0IHNpZ25hdHVyZVByZWZpeCA9IFtQcmVmaXguRURTSUcsIFByZWZpeC5QMlNJRywgUHJlZml4LlNQU0lHLCBQcmVmaXguU0lHXTtcbmNvbnN0IHBrUHJlZml4ID0gW1ByZWZpeC5FRFBLLCBQcmVmaXguU1BQSywgUHJlZml4LlAyUEssIFByZWZpeC5CTFBLXTtcbmNvbnN0IG9wZXJhdGlvblByZWZpeCA9IFtQcmVmaXguT107XG5jb25zdCBwcm90b2NvbFByZWZpeCA9IFtQcmVmaXguUF07XG5jb25zdCBibG9ja1ByZWZpeCA9IFtQcmVmaXguQl07XG5jb25zdCBzbWFydFJvbGx1cFByZWZpeCA9IFtQcmVmaXguU1IxXTtcbi8qKlxuICogQGRlc2NyaXB0aW9uIFVzZWQgdG8gY2hlY2sgaWYgYW4gYWRkcmVzcyBvciBhIGNvbnRyYWN0IGFkZHJlc3MgaXMgdmFsaWQuXG4gKlxuICogQHJldHVybnNcbiAqIDAgKE5PX1BSRUZJWF9NQVRDSEVEKSwgMSAoSU5WQUxJRF9DSEVDS1NVTSksIDIgKElOVkFMSURfTEVOR1RIKSBvciAzIChWQUxJRCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogaW1wb3J0IHsgdmFsaWRhdGVBZGRyZXNzIH0gZnJvbSAnQHRhcXVpdG8vdXRpbHMnO1xuICogY29uc3QgcGtoID0gJ3R6MUw5cjhtV21SUG5kUmh1dk1DV0VTTEdTVmVGelE5TkFXeCdcbiAqIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZUFkZHJlc3MocGtoKVxuICogY29uc29sZS5sb2codmFsaWRhdGlvbilcbiAqIC8vIFRoaXMgZXhhbXBsZSByZXR1cm4gMyB3aGljaCBjb3JyZXNwb25kIHRvIFZBTElEXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlUHJlZml4ZWRWYWx1ZSh2YWx1ZSwgWy4uLmltcGxpY2l0UHJlZml4LCAuLi5jb250cmFjdFByZWZpeCwgLi4uc21hcnRSb2xsdXBQcmVmaXhdKTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFVzZWQgdG8gY2hlY2sgaWYgYSBjaGFpbiBpZCBpcyB2YWxpZC5cbiAqXG4gKiBAcmV0dXJuc1xuICogMCAoTk9fUFJFRklYX01BVENIRUQpLCAxIChJTlZBTElEX0NIRUNLU1VNKSwgMiAoSU5WQUxJRF9MRU5HVEgpIG9yIDMgKFZBTElEKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBpbXBvcnQgeyB2YWxpZGF0ZUNoYWluIH0gZnJvbSAnQHRhcXVpdG8vdXRpbHMnO1xuICogY29uc3QgY2hhaW5JZCA9ICdOZXRYZFFwcmNWa3BhV1UnXG4gKiBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVDaGFpbihjaGFpbklkKVxuICogY29uc29sZS5sb2codmFsaWRhdGlvbilcbiAqIC8vIFRoaXMgZXhhbXBsZSByZXR1cm4gMyB3aGljaCBjb3JyZXNwb25kIHRvIFZBTElEXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDaGFpbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZVByZWZpeGVkVmFsdWUodmFsdWUsIFtQcmVmaXguTkVUXSk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVc2VkIHRvIGNoZWNrIGlmIGEgY29udHJhY3QgYWRkcmVzcyBpcyB2YWxpZC5cbiAqXG4gKiBAcmV0dXJuc1xuICogMCAoTk9fUFJFRklYX01BVENIRUQpLCAxIChJTlZBTElEX0NIRUNLU1VNKSwgMiAoSU5WQUxJRF9MRU5HVEgpIG9yIDMgKFZBTElEKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBpbXBvcnQgeyB2YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcyB9IGZyb20gJ0B0YXF1aXRvL3V0aWxzJztcbiAqIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9ICdLVDFKVkVyTFlUZ3RZOHVHR1o0bXNvMm5wVFN4cVZMRFJWYkMnXG4gKiBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVDb250cmFjdEFkZHJlc3MoY29udHJhY3RBZGRyZXNzKVxuICogY29uc29sZS5sb2codmFsaWRhdGlvbilcbiAqIC8vIFRoaXMgZXhhbXBsZSByZXR1cm4gMyB3aGljaCBjb3JyZXNwb25kIHRvIFZBTElEXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVDb250cmFjdEFkZHJlc3ModmFsdWUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVQcmVmaXhlZFZhbHVlKHZhbHVlLCBjb250cmFjdFByZWZpeCk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVc2VkIHRvIGNoZWNrIGlmIGEga2V5IGhhc2ggaXMgdmFsaWQuXG4gKlxuICogQHJldHVybnNcbiAqIDAgKE5PX1BSRUZJWF9NQVRDSEVEKSwgMSAoSU5WQUxJRF9DSEVDS1NVTSksIDIgKElOVkFMSURfTEVOR1RIKSBvciAzIChWQUxJRCkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYFxuICogaW1wb3J0IHsgdmFsaWRhdGVLZXlIYXNoIH0gZnJvbSAnQHRhcXVpdG8vdXRpbHMnO1xuICogY29uc3Qga2V5SGFzaFdpdGhvdXRQcmVmaXggPSAnMUw5cjhtV21SUG5kUmh1dk1DV0VTTEdTVmVGelE5TkFXeCdcbiAqIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZUtleUhhc2goa2V5SGFzaFdpdGhvdXRQcmVmaXgpXG4gKiBjb25zb2xlLmxvZyh2YWxpZGF0aW9uKVxuICogLy8gVGhpcyBleGFtcGxlIHJldHVybiAwIHdoaWNoIGNvcnJlc3BvbmQgdG8gTk9fUFJFRklYX01BVENIRURcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZUtleUhhc2godmFsdWUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVQcmVmaXhlZFZhbHVlKHZhbHVlLCBpbXBsaWNpdFByZWZpeCk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVc2VkIHRvIGNoZWNrIGlmIGEgc2lnbmF0dXJlIGlzIHZhbGlkLlxuICpcbiAqIEByZXR1cm5zXG4gKiAwIChOT19QUkVGSVhfTUFUQ0hFRCksIDEgKElOVkFMSURfQ0hFQ0tTVU0pLCAyIChJTlZBTElEX0xFTkdUSCkgb3IgMyAoVkFMSUQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGltcG9ydCB7IHZhbGlkYXRlU2lnbmF0dXJlIH0gZnJvbSAnQHRhcXVpdG8vdXRpbHMnO1xuICogY29uc3Qgc2lnbmF0dXJlID0gJ2Vkc2lndGtwaVNTc2NoY2FDdDlwVVZycE5QZjdUVGNndmdERURENk5DRUhNeThOTlFKQ0duTWZMWnpZb1FqNzR5TGpvOXd4Nk1QVlYyOUN2VnpnaTdxRWNFVW9rM2s3QXVNZydcbiAqIGNvbnN0IHZhbGlkYXRpb24gPSB2YWxpZGF0ZVNpZ25hdHVyZShzaWduYXR1cmUpXG4gKiBjb25zb2xlLmxvZyh2YWxpZGF0aW9uKVxuICogLy8gVGhpcyBleGFtcGxlIHJldHVybiAzIHdoaWNoIGNvcnJlc3BvbmQgdG8gVkFMSURcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVNpZ25hdHVyZSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZVByZWZpeGVkVmFsdWUodmFsdWUsIHNpZ25hdHVyZVByZWZpeCk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVc2VkIHRvIGNoZWNrIGlmIGEgcHVibGljIGtleSBpcyB2YWxpZC5cbiAqXG4gKiBAcmV0dXJuc1xuICogMCAoTk9fUFJFRklYX01BVENIRUQpLCAxIChJTlZBTElEX0NIRUNLU1VNKSwgMiAoSU5WQUxJRF9MRU5HVEgpIG9yIDMgKFZBTElEKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgXG4gKiBpbXBvcnQgeyB2YWxpZGF0ZVB1YmxpY0tleSB9IGZyb20gJ0B0YXF1aXRvL3V0aWxzJztcbiAqIGNvbnN0IHB1YmxpY0tleSA9ICdlZHBrdlM1UUZ2N0tSR2ZhM2I4N2dnOURCcHhTbTNOcFN3bmpoVWpOQlFyUlVVUjY2RjdDOWcnXG4gKiBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVQdWJsaWNLZXkocHVibGljS2V5KVxuICogY29uc29sZS5sb2codmFsaWRhdGlvbilcbiAqIC8vIFRoaXMgZXhhbXBsZSByZXR1cm4gMyB3aGljaCBjb3JyZXNwb25kIHRvIFZBTElEXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQdWJsaWNLZXkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsaWRhdGVQcmVmaXhlZFZhbHVlKHZhbHVlLCBwa1ByZWZpeCk7XG59XG4vKipcbiAqIEBkZXNjcmlwdGlvbiBVc2VkIHRvIGNoZWNrIGlmIGFuIG9wZXJhdGlvbiBoYXNoIGlzIHZhbGlkLlxuICpcbiAqIEByZXR1cm5zXG4gKiAwIChOT19QUkVGSVhfTUFUQ0hFRCksIDEgKElOVkFMSURfQ0hFQ0tTVU0pLCAyIChJTlZBTElEX0xFTkdUSCkgb3IgMyAoVkFMSUQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGltcG9ydCB7IHZhbGlkYXRlT3BlcmF0aW9uIH0gZnJvbSAnQHRhcXVpdG8vdXRpbHMnO1xuICogY29uc3Qgb3BlcmF0aW9uSGFzaCA9ICdvbzZKUEVBeThWdU1SR2FGdU1tTE5GRkdkSmdpYUtmbm1UMUNwSEpmS1AzWWU1WmFoaVAnXG4gKiBjb25zdCB2YWxpZGF0aW9uID0gdmFsaWRhdGVPcGVyYXRpb24ob3BlcmF0aW9uSGFzaClcbiAqIGNvbnNvbGUubG9nKHZhbGlkYXRpb24pXG4gKiAvLyBUaGlzIGV4YW1wbGUgcmV0dXJuIDMgd2hpY2ggY29ycmVzcG9uZCB0byBWQUxJRFxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlT3BlcmF0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlUHJlZml4ZWRWYWx1ZSh2YWx1ZSwgb3BlcmF0aW9uUHJlZml4KTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFVzZWQgdG8gY2hlY2sgaWYgYSBwcm90b2NvbCBoYXNoIGlzIHZhbGlkLlxuICpcbiAqIEByZXR1cm5zXG4gKiAwIChOT19QUkVGSVhfTUFUQ0hFRCksIDEgKElOVkFMSURfQ0hFQ0tTVU0pLCAyIChJTlZBTElEX0xFTkdUSCkgb3IgMyAoVkFMSUQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGltcG9ydCB7IHZhbGlkYXRlUHJvdG9jb2wgfSBmcm9tICdAdGFxdWl0by91dGlscyc7XG4gKiBjb25zdCBwcm90b2NvbEhhc2ggPSAnUHRIYW5nejJhUm5neXdtU1JHR3ZyY1R5TWJiZHBXZHBGS3VTNHVNV3hnMlJhSDlpMXF4J1xuICogY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlUHJvdG9jb2wocHJvdG9jb2xIYXNoKVxuICogY29uc29sZS5sb2codmFsaWRhdGlvbilcbiAqIC8vIFRoaXMgZXhhbXBsZSByZXR1cm4gMyB3aGljaCBjb3JyZXNwb25kIHRvIFZBTElEXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVQcm90b2NvbCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZVByZWZpeGVkVmFsdWUodmFsdWUsIHByb3RvY29sUHJlZml4KTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFVzZWQgdG8gY2hlY2sgaWYgYSBibG9jayBoYXNoIGlzIHZhbGlkLlxuICpcbiAqIEByZXR1cm5zXG4gKiAwIChOT19QUkVGSVhfTUFUQ0hFRCksIDEgKElOVkFMSURfQ0hFQ0tTVU0pLCAyIChJTlZBTElEX0xFTkdUSCkgb3IgMyAoVkFMSUQpLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBcbiAqIGltcG9ydCB7IHZhbGlkYXRlQmxvY2sgfSBmcm9tICdAdGFxdWl0by91dGlscyc7XG4gKiBjb25zdCBibG9ja0hhc2ggPSAnUHRIYW5nejJhUm5neXdtU1JHR3ZyY1R5TWJiZHBXZHBGS3VTNHVNV3hnMlJhSDlpMXF4J1xuICogY29uc3QgdmFsaWRhdGlvbiA9IHZhbGlkYXRlQmxvY2soYmxvY2tIYXNoKVxuICogY29uc29sZS5sb2codmFsaWRhdGlvbilcbiAqIC8vIFRoaXMgZXhhbXBsZSByZXR1cm4gMyB3aGljaCBjb3JyZXNwb25kIHRvIFZBTElEXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCbG9jayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZVByZWZpeGVkVmFsdWUodmFsdWUsIGJsb2NrUHJlZml4KTtcbn1cbi8qKlxuICogQGRlc2NyaXB0aW9uIFVzZWQgdG8gY2hlY2sgaWYgYSBzcGVuZGluZyBrZXkgaXMgdmFsaWQuXG4gKiBAcmV0dXJucyAwIChOT19QUkVGSVhfTUFUQ0hFRCksIDEgKElOVkFMSURfQ0hFQ0tTVU0pLCAyIChJTlZBTElEX0xFTkdUSCkgb3IgMyAoVkFMSUQpLlxuICpcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTcGVuZGluZ0tleSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWxpZGF0ZVByZWZpeGVkVmFsdWUodmFsdWUsIFtQcmVmaXguU0FTS10pO1xufVxuZnVuY3Rpb24gaW52YWxpZERldGFpbCh2YWxpZGF0aW9uKSB7XG4gICAgc3dpdGNoICh2YWxpZGF0aW9uKSB7XG4gICAgICAgIGNhc2UgVmFsaWRhdGlvblJlc3VsdC5OT19QUkVGSVhfTUFUQ0hFRDpcbiAgICAgICAgICAgIHJldHVybiAnd2l0aCB1bnN1cHBvcnRlZCBwcmVmaXgnO1xuICAgICAgICBjYXNlIFZhbGlkYXRpb25SZXN1bHQuSU5WQUxJRF9DSEVDS1NVTTpcbiAgICAgICAgICAgIHJldHVybiAnZmFpbGVkIGNoZWNrc3VtJztcbiAgICAgICAgY2FzZSBWYWxpZGF0aW9uUmVzdWx0LklOVkFMSURfTEVOR1RIOlxuICAgICAgICAgICAgcmV0dXJuICd3aXRoIGluY29ycmVjdCBsZW5ndGgnO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuICcnO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlU21hcnRSb2xsdXBBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbGlkYXRlUHJlZml4ZWRWYWx1ZSh2YWx1ZSwgWy4uLnNtYXJ0Um9sbHVwUHJlZml4XSk7XG59XG5cbi8vIElNUE9SVEFOVDogVEhJUyBGSUxFIElTIEFVVE8gR0VORVJBVEVEISBETyBOT1QgTUFOVUFMTFkgRURJVCBPUiBDSEVDS0lOIVxuY29uc3QgVkVSU0lPTiA9IHtcbiAgICBcImNvbW1pdEhhc2hcIjogXCIxM2ExMmFiN2NmNDQyMDQzNTI2NzQ1ZGIyYmJmNGVmM2IwODljMzRhXCIsXG4gICAgXCJ2ZXJzaW9uXCI6IFwiMTkuMC4yXCJcbn07XG5cbmNvbnN0IFRaX0RFQ0lNQUxTID0gNjtcbmNvbnN0IE1UWl9ERUNJTUFMUyA9IDM7XG5mdW5jdGlvbiBnZXREZWNpbWFsKGZvcm1hdCkge1xuICAgIHN3aXRjaCAoZm9ybWF0KSB7XG4gICAgICAgIGNhc2UgJ3R6JzpcbiAgICAgICAgICAgIHJldHVybiBUWl9ERUNJTUFMUztcbiAgICAgICAgY2FzZSAnbXR6JzpcbiAgICAgICAgICAgIHJldHVybiBNVFpfREVDSU1BTFM7XG4gICAgICAgIGNhc2UgJ211dGV6JzpcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZvcm1hdChmcm9tID0gJ211dGV6JywgdG8gPSAnbXV0ZXonLCBhbW91bnQpIHtcbiAgICBjb25zdCBiaWdOdW0gPSBuZXcgQmlnTnVtYmVyKGFtb3VudCk7XG4gICAgaWYgKGJpZ051bS5pc05hTigpKSB7XG4gICAgICAgIHJldHVybiBhbW91bnQ7XG4gICAgfVxuICAgIHJldHVybiBiaWdOdW1cbiAgICAgICAgLm11bHRpcGxpZWRCeShNYXRoLnBvdygxMCwgZ2V0RGVjaW1hbChmcm9tKSkpXG4gICAgICAgIC5kaXZpZGVkQnkoTWF0aC5wb3coMTAsIGdldERlY2ltYWwodG8pKSk7XG59XG5cbi8qKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKiBAbW9kdWxlIEB0YXF1aXRvL3V0aWxzXG4gKi9cbi8qXG4gKiBTb21lIGNvZGUgaW4gdGhpcyBmaWxlIGlzIG9yaWdpbmFsbHkgZnJvbSBzb3RleiBhbmQgZXp0elxuICogQ29weXJpZ2h0IChjKSAyMDE4IEFuZHJldyBLaXNoaW5vXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTcgU3RlcGhlbiBBbmRyZXdzXG4gKi9cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBIYXNoIGEgc3RyaW5nIHVzaW5nIHRoZSBCTEFLRTJiIGFsZ29yaXRobSwgYmFzZTU4IGVuY29kZSB0aGUgaGFzaCBvYnRhaW5lZCBhbmQgYXBwZW5kcyB0aGUgcHJlZml4ICdleHByJyB0byBpdFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSBpbiBoZXhcbiAqL1xuZnVuY3Rpb24gZW5jb2RlRXhwcih2YWx1ZSkge1xuICAgIGNvbnN0IGJsYWtlSGFzaCA9IGJsYWtlLmJsYWtlMmIoaGV4MmJ1Zih2YWx1ZSksIHVuZGVmaW5lZCwgMzIpO1xuICAgIHJldHVybiBiNThjZW5jb2RlKGJsYWtlSGFzaCwgcHJlZml4WydleHByJ10pO1xufVxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIFJldHVybiB0aGUgb3BlcmF0aW9uIGhhc2ggb2YgYSBzaWduZWQgb3BlcmF0aW9uXG4gKiBAcGFyYW0gdmFsdWUgVmFsdWUgaW4gaGV4IG9mIGEgc2lnbmVkIG9wZXJhdGlvblxuICovXG5mdW5jdGlvbiBlbmNvZGVPcEhhc2godmFsdWUpIHtcbiAgICBjb25zdCBibGFrZUhhc2ggPSBibGFrZS5ibGFrZTJiKGhleDJidWYodmFsdWUpLCB1bmRlZmluZWQsIDMyKTtcbiAgICByZXR1cm4gYjU4Y2VuY29kZShibGFrZUhhc2gsIHByZWZpeC5vKTtcbn1cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBCYXNlNTggZW5jb2RlIGEgc3RyaW5nIG9yIGEgVWludDhBcnJheSBhbmQgYXBwZW5kIGEgcHJlZml4IHRvIGl0XG4gKlxuICogQHBhcmFtIHZhbHVlIFZhbHVlIHRvIGJhc2U1OCBlbmNvZGVcbiAqIEBwYXJhbSBwcmVmaXggcHJlZml4IHRvIGFwcGVuZCB0byB0aGUgZW5jb2RlZCBzdHJpbmdcbiAqL1xuZnVuY3Rpb24gYjU4Y2VuY29kZSh2YWx1ZSwgcHJlZml4KSB7XG4gICAgY29uc3QgcGF5bG9hZEFyID0gdHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJyA/IFVpbnQ4QXJyYXkuZnJvbShCdWZmZXIuZnJvbSh2YWx1ZSwgJ2hleCcpKSA6IHZhbHVlO1xuICAgIGNvbnN0IG4gPSBuZXcgVWludDhBcnJheShwcmVmaXgubGVuZ3RoICsgcGF5bG9hZEFyLmxlbmd0aCk7XG4gICAgbi5zZXQocHJlZml4KTtcbiAgICBuLnNldChwYXlsb2FkQXIsIHByZWZpeC5sZW5ndGgpO1xuICAgIHJldHVybiBiczU4Y2hlY2suZW5jb2RlKEJ1ZmZlci5mcm9tKG4uYnVmZmVyKSk7XG59XG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQmFzZTU4IGRlY29kZSBhIHN0cmluZyBhbmQgcmVtb3ZlIHRoZSBwcmVmaXggZnJvbSBpdFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiYXNlNTggZGVjb2RlXG4gKiBAcGFyYW0gcHJlZml4IHByZWZpeCB0byByZW1vdmUgZnJvbSB0aGUgZGVjb2RlZCBzdHJpbmdcbiAqL1xuY29uc3QgYjU4Y2RlY29kZSA9IChlbmMsIHByZWZpeEFyZykgPT4gYnM1OGNoZWNrLmRlY29kZShlbmMpLnNsaWNlKHByZWZpeEFyZy5sZW5ndGgpO1xuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIEJhc2U1OCBkZWNvZGUgYSBzdHJpbmcgd2l0aCBwcmVkZWZpbmVkIHByZWZpeFxuICpcbiAqIEBwYXJhbSB2YWx1ZSBWYWx1ZSB0byBiYXNlNTggZGVjb2RlXG4gKi9cbmZ1bmN0aW9uIGI1OGRlY29kZShwYXlsb2FkKSB7XG4gICAgY29uc3QgYnVmID0gYnM1OGNoZWNrLmRlY29kZShwYXlsb2FkKTtcbiAgICBjb25zdCBwcmVmaXhNYXAgPSB7XG4gICAgICAgIFtwcmVmaXgudHoxLnRvU3RyaW5nKCldOiAnMDAwMCcsXG4gICAgICAgIFtwcmVmaXgudHoyLnRvU3RyaW5nKCldOiAnMDAwMScsXG4gICAgICAgIFtwcmVmaXgudHozLnRvU3RyaW5nKCldOiAnMDAwMicsXG4gICAgfTtcbiAgICBjb25zdCBwcmVmID0gcHJlZml4TWFwW25ldyBVaW50OEFycmF5KGJ1Zi5zbGljZSgwLCAzKSkudG9TdHJpbmcoKV07XG4gICAgaWYgKHByZWYpIHtcbiAgICAgICAgLy8gdHogYWRkcmVzc2VzXG4gICAgICAgIGNvbnN0IGhleCA9IGJ1ZjJoZXgoYnVmLnNsaWNlKDMpKTtcbiAgICAgICAgcmV0dXJuIHByZWYgKyBoZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBvdGhlciAoa3QgYWRkcmVzc2VzKVxuICAgICAgICByZXR1cm4gJzAxJyArIGJ1ZjJoZXgoYnVmLnNsaWNlKDMsIDQyKSkgKyAnMDAnO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBiNTggZGVjb2RlIGEgc3RyaW5nIHdpdGhvdXQgcHJlZGVmaW5lZCBwcmVmaXhcbiAqIEBwYXJhbSB2YWx1ZVxuICogQHJldHVybnMgc3RyaW5nIG9mIGJ5dGVzXG4gKi9cbmZ1bmN0aW9uIGI1OGRlY29kZUwyQWRkcmVzcyhwYXlsb2FkKSB7XG4gICAgY29uc3QgYnVmID0gYnM1OGNoZWNrLmRlY29kZShwYXlsb2FkKTtcbiAgICAvLyB0ejQgYWRkcmVzcyBjdXJyZW50bHlcbiAgICByZXR1cm4gYnVmMmhleChidWYuc2xpY2UoMywgNDIpKTtcbn1cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBCYXNlNTggZW5jb2RlIGFuIGFkZHJlc3MgdXNpbmcgcHJlZGVmaW5lZCBwcmVmaXhcbiAqXG4gKiBAcGFyYW0gdmFsdWUgQWRkcmVzcyB0byBiYXNlNTggZW5jb2RlICh0ejEsIHR6MiwgdHozIG9yIEtUMSlcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUHViS2V5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlLnN1YnN0cmluZygwLCAyKSA9PT0gJzAwJykge1xuICAgICAgICBjb25zdCBwcmVmID0ge1xuICAgICAgICAgICAgJzAwMDAnOiBwcmVmaXgudHoxLFxuICAgICAgICAgICAgJzAwMDEnOiBwcmVmaXgudHoyLFxuICAgICAgICAgICAgJzAwMDInOiBwcmVmaXgudHozLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gYjU4Y2VuY29kZSh2YWx1ZS5zdWJzdHJpbmcoNCksIHByZWZbdmFsdWUuc3Vic3RyaW5nKDAsIDQpXSk7XG4gICAgfVxuICAgIHJldHVybiBiNThjZW5jb2RlKHZhbHVlLnN1YnN0cmluZygyLCA0MiksIHByZWZpeC5LVCk7XG59XG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQmFzZTU4IGVuY29kZSBhbiBhZGRyZXNzIHdpdGhvdXQgcHJlZGVmaW5lZCBwcmVmaXhcbiAqIEBwYXJhbSB2YWx1ZSBBZGRyZXNzIHRvIGJhc2U1OCBlbmNvZGUgKHR6NCkgaGV4IGRlY1xuICogQHJldHVybnMgcmV0dXJuIGFkZHJlc3NcbiAqL1xuZnVuY3Rpb24gZW5jb2RlTDJBZGRyZXNzKHZhbHVlKSB7XG4gICAgcmV0dXJuIGI1OGNlbmNvZGUodmFsdWUsIHByZWZpeC50ejQpO1xufVxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIEJhc2U1OCBlbmNvZGUgYSBrZXkgYWNjb3JkaW5nIHRvIGl0cyBwcmVmaXhcbiAqXG4gKiBAcGFyYW0gdmFsdWUgS2V5IHRvIGJhc2U1OCBlbmNvZGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlS2V5KHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlWzBdID09PSAnMCcpIHtcbiAgICAgICAgY29uc3QgcHJlZiA9IHtcbiAgICAgICAgICAgICcwMCc6IG5ldyBVaW50OEFycmF5KFsxMywgMTUsIDM3LCAyMTddKSxcbiAgICAgICAgICAgICcwMSc6IG5ldyBVaW50OEFycmF5KFszLCAyNTQsIDIyNiwgODZdKSxcbiAgICAgICAgICAgICcwMic6IG5ldyBVaW50OEFycmF5KFszLCAxNzgsIDEzOSwgMTI3XSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBiNThjZW5jb2RlKHZhbHVlLnN1YnN0cmluZygyKSwgcHJlZlt2YWx1ZS5zdWJzdHJpbmcoMCwgMildKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQmFzZTU4IGVuY29kZSBhIGtleSBoYXNoIGFjY29yZGluZyB0byBpdHMgcHJlZml4XG4gKlxuICogQHBhcmFtIHZhbHVlIEtleSBoYXNoIHRvIGJhc2U1OCBlbmNvZGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlS2V5SGFzaCh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVswXSA9PT0gJzAnKSB7XG4gICAgICAgIGNvbnN0IHByZWYgPSB7XG4gICAgICAgICAgICAnMDAnOiBuZXcgVWludDhBcnJheShbNiwgMTYxLCAxNTldKSxcbiAgICAgICAgICAgICcwMSc6IG5ldyBVaW50OEFycmF5KFs2LCAxNjEsIDE2MV0pLFxuICAgICAgICAgICAgJzAyJzogbmV3IFVpbnQ4QXJyYXkoWzYsIDE2MSwgMTY0XSksXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBiNThjZW5jb2RlKHZhbHVlLnN1YnN0cmluZygyKSwgcHJlZlt2YWx1ZS5zdWJzdHJpbmcoMCwgMildKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydCBhbiBoZXggc3RyaW5nIHRvIGEgVWludDhBcnJheVxuICpcbiAqIEBwYXJhbSBoZXggSGV4IHN0cmluZyB0byBjb252ZXJ0XG4gKiBAdGhyb3dzIHtAbGluayBWYWx1ZUNvbnZlcnNpb25FcnJvcn1cbiAqL1xuY29uc3QgaGV4MmJ1ZiA9IChoZXgpID0+IHtcbiAgICBpZiAoaGV4Lmxlbmd0aCAlIDIgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEludmFsaWRIZXhTdHJpbmdFcnJvcihoZXgsIGA6IEV4cGVjdGluZyBldmVuIG51bWJlciBvZiBjaGFyYWN0ZXJzYCk7XG4gICAgfVxuICAgIGNvbnN0IGhleERpZ2l0cyA9IHN0cmlwSGV4UHJlZml4KGhleCk7XG4gICAgaWYgKCFoZXhEaWdpdHMubWF0Y2goL14oW1xcZGEtZl17Mn0pKiQvZ2kpKSB7XG4gICAgICAgIHRocm93IG5ldyBJbnZhbGlkSGV4U3RyaW5nRXJyb3IoaGV4LCBgOiBPbmx5IGNoYXJhY3RlcnMgMC05LCBhLWYgYW5kIEEtRiBhcmUgZXhwZWN0ZWQuIE9wdGlvbmFsbHksIGl0IGNhbiBiZSBwcmVmaXhlZCB3aXRoICcweCdgKTtcbiAgICB9XG4gICAgY29uc3Qgb3V0ID0gbmV3IFVpbnQ4QXJyYXkoaGV4RGlnaXRzLmxlbmd0aCAvIDIpO1xuICAgIGxldCBqID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleERpZ2l0cy5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICBjb25zdCB2ID0gcGFyc2VJbnQoaGV4RGlnaXRzLnNsaWNlKGksIGkgKyAyKSwgMTYpO1xuICAgICAgICBpZiAoTnVtYmVyLmlzTmFOKHYpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVDb252ZXJzaW9uRXJyb3IoaGV4LCAnVWludDhBcnJheScpO1xuICAgICAgICB9XG4gICAgICAgIG91dFtqKytdID0gdjtcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbn07XG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gTWVyZ2UgMiBidWZmZXJzIHRvZ2V0aGVyXG4gKlxuICogQHBhcmFtIGIxIEZpcnN0IGJ1ZmZlclxuICogQHBhcmFtIGIyIFNlY29uZCBidWZmZXJcbiAqL1xuY29uc3QgbWVyZ2VidWYgPSAoYjEsIGIyKSA9PiB7XG4gICAgY29uc3QgciA9IG5ldyBVaW50OEFycmF5KGIxLmxlbmd0aCArIGIyLmxlbmd0aCk7XG4gICAgci5zZXQoYjEpO1xuICAgIHIuc2V0KGIyLCBiMS5sZW5ndGgpO1xuICAgIHJldHVybiByO1xufTtcbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBGbGF0dGVuIGEgbWljaGVsc29uIGpzb24gcmVwcmVzZW50YXRpb24gdG8gYW4gYXJyYXlcbiAqXG4gKiBAcGFyYW0gcyBtaWNoZWxzb24ganNvblxuICovXG5jb25zdCBtaWMyYXJyID0gZnVuY3Rpb24gbWUyKHMpIHtcbiAgICBsZXQgcmV0ID0gW107XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCAncHJpbScpKSB7XG4gICAgICAgIGlmIChzLnByaW0gPT09ICdQYWlyJykge1xuICAgICAgICAgICAgcmV0LnB1c2gobWUyKHMuYXJnc1swXSkpO1xuICAgICAgICAgICAgcmV0ID0gcmV0LmNvbmNhdChtZTIocy5hcmdzWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocy5wcmltID09PSAnRWx0Jykge1xuICAgICAgICAgICAgcmV0ID0ge1xuICAgICAgICAgICAgICAgIGtleTogbWUyKHMuYXJnc1swXSksXG4gICAgICAgICAgICAgICAgdmFsOiBtZTIocy5hcmdzWzFdKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocy5wcmltID09PSAnVHJ1ZScpIHtcbiAgICAgICAgICAgIHJldCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocy5wcmltID09PSAnRmFsc2UnKSB7XG4gICAgICAgICAgICByZXQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHMpKSB7XG4gICAgICAgIGNvbnN0IHNjID0gcy5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2M7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgbiA9IG1lMihzW2ldKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygbi5rZXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmV0KSkge1xuICAgICAgICAgICAgICAgICAgICByZXQgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlzOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXQua2V5cy5wdXNoKG4ua2V5KTtcbiAgICAgICAgICAgICAgICByZXQudmFscy5wdXNoKG4udmFsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldC5wdXNoKG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCAnc3RyaW5nJykpIHtcbiAgICAgICAgcmV0ID0gcy5zdHJpbmc7XG4gICAgfVxuICAgIGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCAnaW50JykpIHtcbiAgICAgICAgcmV0ID0gcGFyc2VJbnQocy5pbnQsIDEwKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldCA9IHM7XG4gICAgfVxuICAgIHJldHVybiByZXQ7XG59O1xuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIENvbnZlcnQgYSBVaW50OEFycmF5IHRvIGFuIGhleCBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gYnVmZmVyIFVpbnQ4QXJyYXkgdG8gY29udmVydFxuICovXG5jb25zdCBidWYyaGV4ID0gKGJ1ZmZlcikgPT4ge1xuICAgIGNvbnN0IGhleFBhcnRzID0gW107XG4gICAgYnVmZmVyLmZvckVhY2goKGJ5dGUpID0+IHtcbiAgICAgICAgY29uc3QgaGV4ID0gYnl0ZS50b1N0cmluZygxNik7XG4gICAgICAgIGNvbnN0IHBhZGRlZEhleCA9IGAwMCR7aGV4fWAuc2xpY2UoLTIpO1xuICAgICAgICBoZXhQYXJ0cy5wdXNoKHBhZGRlZEhleCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhleFBhcnRzLmpvaW4oJycpO1xufTtcbi8qKlxuICpcbiAqICBAZGVzY3JpcHRpb24gR2V0cyBUZXpvcyBhZGRyZXNzIChQS0gpIGZyb20gUHVibGljIEtleVxuICpcbiAqICBAcGFyYW0gcHVibGljS2V5IFB1YmxpYyBLZXlcbiAqICBAcmV0dXJucyBBIHN0cmluZyBvZiB0aGUgVGV6b3MgYWRkcmVzcyAoUEtIKSB0aGF0IHdhcyBkZXJpdmVkIGZyb20gdGhlIGdpdmVuIFB1YmxpYyBLZXlcbiAqL1xuY29uc3QgZ2V0UGtoZnJvbVBrID0gKHB1YmxpY0tleSkgPT4ge1xuICAgIGxldCBlbmNvZGluZ1ByZWZpeDtcbiAgICBsZXQgcHJlZml4TGVuO1xuICAgIGNvbnN0IGtleVByZWZpeCA9IHZhbGlkYXRlUGtBbmRFeHRyYWN0UHJlZml4KHB1YmxpY0tleSk7XG4gICAgY29uc3QgZGVjb2RlZCA9IGI1OGNkZWNvZGUocHVibGljS2V5LCBwcmVmaXhba2V5UHJlZml4XSk7XG4gICAgc3dpdGNoIChrZXlQcmVmaXgpIHtcbiAgICAgICAgY2FzZSBQcmVmaXguRURQSzpcbiAgICAgICAgICAgIGVuY29kaW5nUHJlZml4ID0gcHJlZml4W1ByZWZpeC5UWjFdO1xuICAgICAgICAgICAgcHJlZml4TGVuID0gcHJlZml4TGVuZ3RoW1ByZWZpeC5UWjFdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUHJlZml4LlNQUEs6XG4gICAgICAgICAgICBlbmNvZGluZ1ByZWZpeCA9IHByZWZpeFtQcmVmaXguVFoyXTtcbiAgICAgICAgICAgIHByZWZpeExlbiA9IHByZWZpeExlbmd0aFtQcmVmaXguVFoyXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFByZWZpeC5QMlBLOlxuICAgICAgICAgICAgZW5jb2RpbmdQcmVmaXggPSBwcmVmaXhbUHJlZml4LlRaM107XG4gICAgICAgICAgICBwcmVmaXhMZW4gPSBwcmVmaXhMZW5ndGhbUHJlZml4LlRaM107XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQcmVmaXguQkxQSzpcbiAgICAgICAgICAgIGVuY29kaW5nUHJlZml4ID0gcHJlZml4W1ByZWZpeC5UWjRdO1xuICAgICAgICAgICAgcHJlZml4TGVuID0gcHJlZml4TGVuZ3RoW1ByZWZpeC5UWjRdO1xuICAgIH1cbiAgICBjb25zdCBoYXNoZWQgPSBoYXNoKGRlY29kZWQsIHByZWZpeExlbik7XG4gICAgY29uc3QgcmVzdWx0ID0gYjU4Y2VuY29kZShoYXNoZWQsIGVuY29kaW5nUHJlZml4KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0IGEgc3RyaW5nIHRvIGJ5dGVzXG4gKlxuICogQHBhcmFtIHN0ciBTdHJpbmcgdG8gY29udmVydFxuICovXG5mdW5jdGlvbiBjaGFyMkJ5dGVzKHN0cikge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIsICd1dGY4JykudG9TdHJpbmcoJ2hleCcpO1xufVxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIENvbnZlcnQgYnl0ZXMgdG8gYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gc3RyIEJ5dGVzIHRvIGNvbnZlcnRcbiAqL1xuZnVuY3Rpb24gYnl0ZXMyQ2hhcihoZXgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4MmJ1ZihoZXgpKS50b1N0cmluZygndXRmOCcpO1xufVxuLyoqXG4gKlxuICogQGRlc2NyaXB0aW9uIENvbnZlcnQgaGV4IHN0cmluZy9VaW50QXJyYXkvQnVmZmVyIHRvIGJ5dGVzXG4gKlxuICogQHBhcmFtIGhleCBTdHJpbmcgdmFsdWUgdG8gY29udmVydCB0byBieXRlc1xuICovXG5mdW5jdGlvbiBoZXgyQnl0ZXMoaGV4KSB7XG4gICAgY29uc3QgaGV4RGlnaXRzID0gc3RyaXBIZXhQcmVmaXgoaGV4KTtcbiAgICBpZiAoIWhleERpZ2l0cy5tYXRjaCgvXigweCk/KFtcXGRhLWZdezJ9KSokL2dpKSkge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEhleFN0cmluZ0Vycm9yKGhleCwgYDogRXhwZWN0aW5nIGV2ZW4gbnVtYmVyIG9mIGNoYXJhY3RlcnM6IDAtOSwgYS16LCBBLVosIG9wdGlvbmFsbHkgcHJlZml4ZWQgd2l0aCAweGApO1xuICAgIH1cbiAgICByZXR1cm4gQnVmZmVyLmZyb20oaGV4RGlnaXRzLCAnaGV4Jyk7XG59XG4vKipcbiAqXG4gKiBAZGVzY3JpcHRpb24gQ29udmVydHMgYSBudW1iZXIgb3IgQmlnbnVtYmVyIHRvIGhleGFkZWNpbWFsICBzdHJpbmdcbiAqXG4gKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSAgdGhhdCB3aWxsIGJlIGNvbnZlcnRlZCB0byBhIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZVxuICovXG5mdW5jdGlvbiB0b0hleEJ1Zih2YWwsIGJpdExlbmd0aCA9IDgpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20obnVtMlBhZGRlZEhleCh2YWwsIGJpdExlbmd0aCksICdoZXgnKTtcbn1cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBDb252ZXJ0cyBhIG51bWJlciBvciBCaWdOdW1iZXIgdG8gYSBwYWRkZWQgaGV4YWRlY2ltYWwgc3RyaW5nXG4gKiBAcGFyYW0gdmFsIFRoZSB2YWx1ZSB0aGF0IHdpbGwgYmUgY29udmVydGVkIGludG8gYSBwYWRkZWQgaGV4YWRlY2ltYWwgc3RyaW5nIHZhbHVlXG4gKiBAcGFyYW0gYml0TGVuZ3RoIFRoZSBsZW5ndGggb2YgYml0c1xuICpcbiAqL1xuZnVuY3Rpb24gbnVtMlBhZGRlZEhleCh2YWwsIGJpdExlbmd0aCA9IDgpIHtcbiAgICBpZiAobmV3IEJpZ051bWJlcih2YWwpLmlzUG9zaXRpdmUoKSkge1xuICAgICAgICBjb25zdCBuaWJibGVMZW5ndGggPSBNYXRoLmNlaWwoYml0TGVuZ3RoIC8gNCk7XG4gICAgICAgIGNvbnN0IGhleCA9IHZhbC50b1N0cmluZygxNik7XG4gICAgICAgIC8vIGNoZWNrIHdoZXRoZXIgbmliYmxlICg0IGJpdHMpIGxlbmd0aCBpcyBoaWdoZXIgb3IgbG93ZXIgdGhhbiB0aGUgY3VycmVudCBoZXggc3RyaW5nIGxlbmd0aFxuICAgICAgICBsZXQgdGFyZ2V0TGVuZ3RoID0gaGV4Lmxlbmd0aCA+PSBuaWJibGVMZW5ndGggPyBoZXgubGVuZ3RoIDogbmliYmxlTGVuZ3RoO1xuICAgICAgICAvLyBtYWtlIHN1cmUgdGhlIGhleCBzdHJpbmcgdGFyZ2V0IGxlbmd0aCBpcyBldmVuXG4gICAgICAgIHRhcmdldExlbmd0aCA9IHRhcmdldExlbmd0aCAlIDIgPT0gMCA/IHRhcmdldExlbmd0aCA6IHRhcmdldExlbmd0aCArIDE7XG4gICAgICAgIHJldHVybiBwYWRIZXhXaXRoWmVybyhoZXgsIHRhcmdldExlbmd0aCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCB0d29zQ29tcGxpbWVudCA9IG5ldyBCaWdOdW1iZXIoMilcbiAgICAgICAgICAgIC5wb3coYml0TGVuZ3RoKVxuICAgICAgICAgICAgLm1pbnVzKG5ldyBCaWdOdW1iZXIodmFsKS5hYnMoKSk7XG4gICAgICAgIHJldHVybiB0d29zQ29tcGxpbWVudC50b1N0cmluZygxNik7XG4gICAgfVxufVxuZnVuY3Rpb24gcGFkSGV4V2l0aFplcm8oaGV4LCB0YXJnZXRMZW5ndGgpIHtcbiAgICBjb25zdCBwYWRTdHJpbmcgPSAnMCc7XG4gICAgaWYgKGhleC5sZW5ndGggPj0gdGFyZ2V0TGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBoZXg7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBwYWRMZW5ndGggPSB0YXJnZXRMZW5ndGggLSBoZXgubGVuZ3RoO1xuICAgICAgICByZXR1cm4gcGFkU3RyaW5nLnJlcGVhdChwYWRMZW5ndGgpICsgaGV4O1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBkZXNjcmlwdGlvbiBTdHJpcHMgdGhlIGZpcnN0IDIgY2hhcmFjdGVycyBvZiBhIGhleCBzdHJpbmcgKDB4KVxuICpcbiAqIEBwYXJhbSBoZXggc3RyaW5nIHRvIHN0cmlwIHByZWZpeCBmcm9tXG4gKi9cbmZ1bmN0aW9uIHN0cmlwSGV4UHJlZml4KGhleCkge1xuICAgIHJldHVybiBoZXguc3RhcnRzV2l0aCgnMHgnKSA/IGhleC5zbGljZSgyKSA6IGhleDtcbn1cblxuZXhwb3J0IHsgSW52YWxpZFByb3RvY29sSGFzaEVycm9yLCBQcmVmaXgsIFZFUlNJT04sIFZhbGlkYXRpb25SZXN1bHQsIFZhbHVlQ29udmVyc2lvbkVycm9yLCBiNThjZGVjb2RlLCBiNThjZW5jb2RlLCBiNThkZWNvZGUsIGI1OGRlY29kZUwyQWRkcmVzcywgYnVmMmhleCwgYnl0ZXMyQ2hhciwgY2hhcjJCeXRlcywgZW5jb2RlRXhwciwgZW5jb2RlS2V5LCBlbmNvZGVLZXlIYXNoLCBlbmNvZGVMMkFkZHJlc3MsIGVuY29kZU9wSGFzaCwgZW5jb2RlUHViS2V5LCBmb3JtYXQsIGdldFBraGZyb21QaywgaGV4MkJ5dGVzLCBoZXgyYnVmLCBpbnZhbGlkRGV0YWlsLCBpc1ZhbGlkUHJlZml4LCBtZXJnZWJ1ZiwgbWljMmFyciwgbnVtMlBhZGRlZEhleCwgcHJlZml4LCBwcmVmaXhMZW5ndGgsIHN0cmlwSGV4UHJlZml4LCB0b0hleEJ1ZiwgdmFsaWRhdGVBZGRyZXNzLCB2YWxpZGF0ZUJsb2NrLCB2YWxpZGF0ZUNoYWluLCB2YWxpZGF0ZUNvbnRyYWN0QWRkcmVzcywgdmFsaWRhdGVLZXlIYXNoLCB2YWxpZGF0ZU9wZXJhdGlvbiwgdmFsaWRhdGVQa0FuZEV4dHJhY3RQcmVmaXgsIHZhbGlkYXRlUHJvdG9jb2wsIHZhbGlkYXRlUHVibGljS2V5LCB2YWxpZGF0ZVNpZ25hdHVyZSwgdmFsaWRhdGVTbWFydFJvbGx1cEFkZHJlc3MsIHZhbGlkYXRlU3BlbmRpbmdLZXksIHZlcmlmeVNpZ25hdHVyZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dGFxdWl0by11dGlscy5lczYuanMubWFwXG4iXSwibmFtZXMiOlsiQnVmZmVyIiwidmVyaWZ5IiwiaGFzaCIsImJsYWtlIiwiYnM1OGNoZWNrIiwiSW52YWxpZE1lc3NhZ2VFcnJvciIsIkludmFsaWRQdWJsaWNLZXlFcnJvciIsIkludmFsaWRTaWduYXR1cmVFcnJvciIsIlBhcmFtZXRlclZhbGlkYXRpb25FcnJvciIsIlVuc3VwcG9ydGVkQWN0aW9uRXJyb3IiLCJJbnZhbGlkSGV4U3RyaW5nRXJyb3IiLCJEZXByZWNhdGlvbkVycm9yIiwiSW52YWxpZEFkZHJlc3NFcnJvciIsIkludmFsaWRCbG9ja0hhc2hFcnJvciIsIkludmFsaWRDaGFpbklkRXJyb3IiLCJJbnZhbGlkQ29udHJhY3RBZGRyZXNzRXJyb3IiLCJJbnZhbGlkS2V5RXJyb3IiLCJJbnZhbGlkS2V5SGFzaEVycm9yIiwiSW52YWxpZE9wZXJhdGlvbkhhc2hFcnJvciIsIkludmFsaWRPcGVyYXRpb25LaW5kRXJyb3IiLCJQcm9oaWJpdGVkQWN0aW9uRXJyb3IiLCJCaWdOdW1iZXIiLCJlbGxpcHRpYyIsInRvQnVmZmVyIiwiUHJlZml4IiwicHJlZml4IiwiVFoxIiwiVWludDhBcnJheSIsIlRaMiIsIlRaMyIsIlRaNCIsIktUIiwiS1QxIiwiRURTSyIsIkVEU0syIiwiU1BTSyIsIlAyU0siLCJFRFBLIiwiU1BQSyIsIlAyUEsiLCJCTFBLIiwiRURFU0siLCJTUEVTSyIsIlAyRVNLIiwiRURTSUciLCJTUFNJRyIsIlAyU0lHIiwiU0lHIiwiTkVUIiwiTkNFIiwiQiIsIk8iLCJMTyIsIkxMTyIsIlAiLCJDTyIsIklEIiwiRVhQUiIsIlRaIiwiVkgiLCJTQVNLIiwiWkVUMSIsIlNSMSIsIlNSQzEiLCJwcmVmaXhMZW5ndGgiLCJ2ZXJpZnlTaWduYXR1cmUiLCJtZXNzYWdlQnl0ZXMiLCJwdWJsaWNLZXkiLCJzaWduYXR1cmUiLCJ3YXRlcm1hcmsiLCJwa1ByZWZpeCIsInZhbGlkYXRlUGtBbmRFeHRyYWN0UHJlZml4Iiwic2lnUHJlZml4IiwidmFsaWRhdGVTaWdBbmRFeHRyYWN0UHJlZml4IiwiZGVjb2RlZFB1YmxpY0tleSIsImI1OGNkZWNvZGUiLCJkZWNvZGVkU2lnIiwibWVzc2FnZUJ1ZiIsImhleDJidWYiLCJ2YWxpZGF0ZU1lc3NhZ2VOb3RFbXB0eSIsIm1lcmdlYnVmIiwiYnl0ZXNIYXNoIiwidmVyaWZ5RWRTaWduYXR1cmUiLCJ2ZXJpZnlTcFNpZ25hdHVyZSIsInZlcmlmeVAyU2lnbmF0dXJlIiwibWVzc2FnZSIsInN1YnN0cmluZyIsInB1YmxpY0tleVZhbGlkYXRpb24iLCJ2YWxpZGF0ZVB1YmxpY0tleSIsIlZhbGlkYXRpb25SZXN1bHQiLCJWQUxJRCIsImludmFsaWREZXRhaWwiLCJzaWduYXR1cmVQcmVmaXgiLCJzdGFydHNXaXRoIiwidmFsaWRhdGlvbiIsInZhbGlkYXRlU2lnbmF0dXJlIiwiZSIsImtleSIsImVjIiwia2V5RnJvbVB1YmxpYyIsInZlcmlmeVNwT3JQMlNpZyIsImhleFNpZyIsImJ1ZjJoZXgiLCJtYXRjaCIsInIiLCJzIiwiSW52YWxpZFByb3RvY29sSGFzaEVycm9yIiwiY29uc3RydWN0b3IiLCJwcm90b2NvbEhhc2giLCJlcnJvckRldGFpbHMiLCJuYW1lIiwiVmFsdWVDb252ZXJzaW9uRXJyb3IiLCJ2YWx1ZSIsImRlc2lyZWRUeXBlIiwiaXNWYWxpZFByZWZpeCIsInZhbGlkYXRlUHJlZml4ZWRWYWx1ZSIsInByZWZpeGVzIiwiUmVnRXhwIiwiam9pbiIsImV4ZWMiLCJsZW5ndGgiLCJOT19QUkVGSVhfTUFUQ0hFRCIsInByZWZpeEtleSIsImluY2x1ZGVzIiwic3BsaXQiLCJrdDFSZWdleCIsInRlc3QiLCJJTlZBTElEX0NIRUNLU1VNIiwiZGVjb2RlZCIsImRlY29kZVVuc2FmZSIsInNsaWNlIiwiSU5WQUxJRF9MRU5HVEgiLCJpbXBsaWNpdFByZWZpeCIsImNvbnRyYWN0UHJlZml4Iiwib3BlcmF0aW9uUHJlZml4IiwicHJvdG9jb2xQcmVmaXgiLCJibG9ja1ByZWZpeCIsInNtYXJ0Um9sbHVwUHJlZml4IiwidmFsaWRhdGVBZGRyZXNzIiwidmFsaWRhdGVDaGFpbiIsInZhbGlkYXRlQ29udHJhY3RBZGRyZXNzIiwidmFsaWRhdGVLZXlIYXNoIiwidmFsaWRhdGVPcGVyYXRpb24iLCJ2YWxpZGF0ZVByb3RvY29sIiwidmFsaWRhdGVCbG9jayIsInZhbGlkYXRlU3BlbmRpbmdLZXkiLCJ2YWxpZGF0ZVNtYXJ0Um9sbHVwQWRkcmVzcyIsIlZFUlNJT04iLCJUWl9ERUNJTUFMUyIsIk1UWl9ERUNJTUFMUyIsImdldERlY2ltYWwiLCJmb3JtYXQiLCJmcm9tIiwidG8iLCJhbW91bnQiLCJiaWdOdW0iLCJpc05hTiIsIm11bHRpcGxpZWRCeSIsIk1hdGgiLCJwb3ciLCJkaXZpZGVkQnkiLCJlbmNvZGVFeHByIiwiYmxha2VIYXNoIiwiYmxha2UyYiIsInVuZGVmaW5lZCIsImI1OGNlbmNvZGUiLCJlbmNvZGVPcEhhc2giLCJvIiwicGF5bG9hZEFyIiwibiIsInNldCIsImVuY29kZSIsImJ1ZmZlciIsImVuYyIsInByZWZpeEFyZyIsImRlY29kZSIsImI1OGRlY29kZSIsInBheWxvYWQiLCJidWYiLCJwcmVmaXhNYXAiLCJ0ejEiLCJ0b1N0cmluZyIsInR6MiIsInR6MyIsInByZWYiLCJoZXgiLCJiNThkZWNvZGVMMkFkZHJlc3MiLCJlbmNvZGVQdWJLZXkiLCJlbmNvZGVMMkFkZHJlc3MiLCJ0ejQiLCJlbmNvZGVLZXkiLCJlbmNvZGVLZXlIYXNoIiwiaGV4RGlnaXRzIiwic3RyaXBIZXhQcmVmaXgiLCJvdXQiLCJqIiwiaSIsInYiLCJwYXJzZUludCIsIk51bWJlciIsImIxIiwiYjIiLCJtaWMyYXJyIiwibWUyIiwicmV0IiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJjYWxsIiwicHJpbSIsInB1c2giLCJhcmdzIiwiY29uY2F0IiwidmFsIiwiQXJyYXkiLCJpc0FycmF5Iiwic2MiLCJrZXlzIiwidmFscyIsInN0cmluZyIsImludCIsImhleFBhcnRzIiwiZm9yRWFjaCIsImJ5dGUiLCJwYWRkZWRIZXgiLCJnZXRQa2hmcm9tUGsiLCJlbmNvZGluZ1ByZWZpeCIsInByZWZpeExlbiIsImtleVByZWZpeCIsImhhc2hlZCIsInJlc3VsdCIsImNoYXIyQnl0ZXMiLCJzdHIiLCJieXRlczJDaGFyIiwiaGV4MkJ5dGVzIiwidG9IZXhCdWYiLCJiaXRMZW5ndGgiLCJudW0yUGFkZGVkSGV4IiwiaXNQb3NpdGl2ZSIsIm5pYmJsZUxlbmd0aCIsImNlaWwiLCJ0YXJnZXRMZW5ndGgiLCJwYWRIZXhXaXRoWmVybyIsInR3b3NDb21wbGltZW50IiwibWludXMiLCJhYnMiLCJwYWRTdHJpbmciLCJwYWRMZW5ndGgiLCJyZXBlYXQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/utils/dist/taquito-utils.es6.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/base.js":
/*!********************************************************************!*\
  !*** ./node_modules/@taquito/utils/node_modules/bs58check/base.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar base58 = __webpack_require__(/*! bs58 */ \"(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/index.js\");\nmodule.exports = function(checksumFn) {\n    // Encode a buffer as a base58-check encoded string\n    function encode(payload) {\n        var payloadU8 = Uint8Array.from(payload);\n        var checksum = checksumFn(payloadU8);\n        var length = payloadU8.length + 4;\n        var both = new Uint8Array(length);\n        both.set(payloadU8, 0);\n        both.set(checksum.subarray(0, 4), payloadU8.length);\n        return base58.encode(both, length);\n    }\n    function decodeRaw(buffer) {\n        var payload = buffer.slice(0, -4);\n        var checksum = buffer.slice(-4);\n        var newChecksum = checksumFn(payload);\n        if (checksum[0] ^ newChecksum[0] | checksum[1] ^ newChecksum[1] | checksum[2] ^ newChecksum[2] | checksum[3] ^ newChecksum[3]) return;\n        return payload;\n    }\n    // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n    function decodeUnsafe(string) {\n        var buffer = base58.decodeUnsafe(string);\n        if (!buffer) return;\n        return decodeRaw(buffer);\n    }\n    function decode(string) {\n        var buffer = base58.decode(string);\n        var payload = decodeRaw(buffer, checksumFn);\n        if (!payload) throw new Error(\"Invalid checksum\");\n        return payload;\n    }\n    return {\n        encode: encode,\n        decode: decode,\n        decodeUnsafe: decodeUnsafe\n    };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vdXRpbHMvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9iYXNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsU0FBU0MsbUJBQU9BLENBQUM7QUFFckJDLE9BQU9DLE9BQU8sR0FBRyxTQUFVQyxVQUFVO0lBQ25DLG1EQUFtRDtJQUNuRCxTQUFTQyxPQUFRQyxPQUFPO1FBQ3RCLElBQUlDLFlBQVlDLFdBQVdDLElBQUksQ0FBQ0g7UUFDaEMsSUFBSUksV0FBV04sV0FBV0c7UUFDMUIsSUFBSUksU0FBU0osVUFBVUksTUFBTSxHQUFHO1FBQ2hDLElBQUlDLE9BQU8sSUFBSUosV0FBV0c7UUFDMUJDLEtBQUtDLEdBQUcsQ0FBQ04sV0FBVztRQUNwQkssS0FBS0MsR0FBRyxDQUFDSCxTQUFTSSxRQUFRLENBQUMsR0FBRyxJQUFJUCxVQUFVSSxNQUFNO1FBQ2xELE9BQU9YLE9BQU9LLE1BQU0sQ0FBQ08sTUFBTUQ7SUFDN0I7SUFFQSxTQUFTSSxVQUFXQyxNQUFNO1FBQ3hCLElBQUlWLFVBQVVVLE9BQU9DLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDL0IsSUFBSVAsV0FBV00sT0FBT0MsS0FBSyxDQUFDLENBQUM7UUFDN0IsSUFBSUMsY0FBY2QsV0FBV0U7UUFFN0IsSUFBSUksUUFBUSxDQUFDLEVBQUUsR0FBR1EsV0FBVyxDQUFDLEVBQUUsR0FDNUJSLFFBQVEsQ0FBQyxFQUFFLEdBQUdRLFdBQVcsQ0FBQyxFQUFFLEdBQzVCUixRQUFRLENBQUMsRUFBRSxHQUFHUSxXQUFXLENBQUMsRUFBRSxHQUM1QlIsUUFBUSxDQUFDLEVBQUUsR0FBR1EsV0FBVyxDQUFDLEVBQUUsRUFBRTtRQUVsQyxPQUFPWjtJQUNUO0lBRUEsbUZBQW1GO0lBQ25GLFNBQVNhLGFBQWNDLE1BQU07UUFDM0IsSUFBSUosU0FBU2hCLE9BQU9tQixZQUFZLENBQUNDO1FBQ2pDLElBQUksQ0FBQ0osUUFBUTtRQUViLE9BQU9ELFVBQVVDO0lBQ25CO0lBRUEsU0FBU0ssT0FBUUQsTUFBTTtRQUNyQixJQUFJSixTQUFTaEIsT0FBT3FCLE1BQU0sQ0FBQ0Q7UUFDM0IsSUFBSWQsVUFBVVMsVUFBVUMsUUFBUVo7UUFDaEMsSUFBSSxDQUFDRSxTQUFTLE1BQU0sSUFBSWdCLE1BQU07UUFDOUIsT0FBT2hCO0lBQ1Q7SUFFQSxPQUFPO1FBQ0xELFFBQVFBO1FBQ1JnQixRQUFRQTtRQUNSRixjQUFjQTtJQUNoQjtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdycGVya3MvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vdXRpbHMvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9iYXNlLmpzPzdiNGMiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNTggPSByZXF1aXJlKCdiczU4JylcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2hlY2tzdW1Gbikge1xuICAvLyBFbmNvZGUgYSBidWZmZXIgYXMgYSBiYXNlNTgtY2hlY2sgZW5jb2RlZCBzdHJpbmdcbiAgZnVuY3Rpb24gZW5jb2RlIChwYXlsb2FkKSB7XG4gICAgdmFyIHBheWxvYWRVOCA9IFVpbnQ4QXJyYXkuZnJvbShwYXlsb2FkKVxuICAgIHZhciBjaGVja3N1bSA9IGNoZWNrc3VtRm4ocGF5bG9hZFU4KVxuICAgIHZhciBsZW5ndGggPSBwYXlsb2FkVTgubGVuZ3RoICsgNFxuICAgIHZhciBib3RoID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICAgIGJvdGguc2V0KHBheWxvYWRVOCwgMClcbiAgICBib3RoLnNldChjaGVja3N1bS5zdWJhcnJheSgwLCA0KSwgcGF5bG9hZFU4Lmxlbmd0aClcbiAgICByZXR1cm4gYmFzZTU4LmVuY29kZShib3RoLCBsZW5ndGgpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGVSYXcgKGJ1ZmZlcikge1xuICAgIHZhciBwYXlsb2FkID0gYnVmZmVyLnNsaWNlKDAsIC00KVxuICAgIHZhciBjaGVja3N1bSA9IGJ1ZmZlci5zbGljZSgtNClcbiAgICB2YXIgbmV3Q2hlY2tzdW0gPSBjaGVja3N1bUZuKHBheWxvYWQpXG5cbiAgICBpZiAoY2hlY2tzdW1bMF0gXiBuZXdDaGVja3N1bVswXSB8XG4gICAgICAgIGNoZWNrc3VtWzFdIF4gbmV3Q2hlY2tzdW1bMV0gfFxuICAgICAgICBjaGVja3N1bVsyXSBeIG5ld0NoZWNrc3VtWzJdIHxcbiAgICAgICAgY2hlY2tzdW1bM10gXiBuZXdDaGVja3N1bVszXSkgcmV0dXJuXG5cbiAgICByZXR1cm4gcGF5bG9hZFxuICB9XG5cbiAgLy8gRGVjb2RlIGEgYmFzZTU4LWNoZWNrIGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyLCBubyByZXN1bHQgaWYgY2hlY2tzdW0gaXMgd3JvbmdcbiAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlIChzdHJpbmcpIHtcbiAgICB2YXIgYnVmZmVyID0gYmFzZTU4LmRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKCFidWZmZXIpIHJldHVyblxuXG4gICAgcmV0dXJuIGRlY29kZVJhdyhidWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBkZWNvZGUgKHN0cmluZykge1xuICAgIHZhciBidWZmZXIgPSBiYXNlNTguZGVjb2RlKHN0cmluZylcbiAgICB2YXIgcGF5bG9hZCA9IGRlY29kZVJhdyhidWZmZXIsIGNoZWNrc3VtRm4pXG4gICAgaWYgKCFwYXlsb2FkKSB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY2hlY2tzdW0nKVxuICAgIHJldHVybiBwYXlsb2FkXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGVuY29kZTogZW5jb2RlLFxuICAgIGRlY29kZTogZGVjb2RlLFxuICAgIGRlY29kZVVuc2FmZTogZGVjb2RlVW5zYWZlXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJiYXNlNTgiLCJyZXF1aXJlIiwibW9kdWxlIiwiZXhwb3J0cyIsImNoZWNrc3VtRm4iLCJlbmNvZGUiLCJwYXlsb2FkIiwicGF5bG9hZFU4IiwiVWludDhBcnJheSIsImZyb20iLCJjaGVja3N1bSIsImxlbmd0aCIsImJvdGgiLCJzZXQiLCJzdWJhcnJheSIsImRlY29kZVJhdyIsImJ1ZmZlciIsInNsaWNlIiwibmV3Q2hlY2tzdW0iLCJkZWNvZGVVbnNhZmUiLCJzdHJpbmciLCJkZWNvZGUiLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/base.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/index.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@taquito/utils/node_modules/bs58check/index.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nvar { sha256 } = __webpack_require__(/*! @noble/hashes/sha256 */ \"(ssr)/./node_modules/@noble/hashes/sha256.js\");\nvar bs58checkBase = __webpack_require__(/*! ./base */ \"(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/base.js\");\n// SHA256(SHA256(buffer))\nfunction sha256x2(buffer) {\n    return sha256(sha256(buffer));\n}\nmodule.exports = bs58checkBase(sha256x2);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vdXRpbHMvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLElBQUksRUFBRUEsTUFBTSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBQ3pCLElBQUlDLGdCQUFnQkQsbUJBQU9BLENBQUM7QUFFNUIseUJBQXlCO0FBQ3pCLFNBQVNFLFNBQVVDLE1BQU07SUFDdkIsT0FBT0osT0FBT0EsT0FBT0k7QUFDdkI7QUFFQUMsT0FBT0MsT0FBTyxHQUFHSixjQUFjQyIsInNvdXJjZXMiOlsid2VicGFjazovL3B3cnBlcmtzLy4vbm9kZV9tb2R1bGVzL0B0YXF1aXRvL3V0aWxzL25vZGVfbW9kdWxlcy9iczU4Y2hlY2svaW5kZXguanM/Yzc3YSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCdcblxudmFyIHsgc2hhMjU2IH0gPSByZXF1aXJlKCdAbm9ibGUvaGFzaGVzL3NoYTI1NicpXG52YXIgYnM1OGNoZWNrQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpXG5cbi8vIFNIQTI1NihTSEEyNTYoYnVmZmVyKSlcbmZ1bmN0aW9uIHNoYTI1NngyIChidWZmZXIpIHtcbiAgcmV0dXJuIHNoYTI1NihzaGEyNTYoYnVmZmVyKSlcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBiczU4Y2hlY2tCYXNlKHNoYTI1NngyKVxuIl0sIm5hbWVzIjpbInNoYTI1NiIsInJlcXVpcmUiLCJiczU4Y2hlY2tCYXNlIiwic2hhMjU2eDIiLCJidWZmZXIiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/index.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/index.js ***!
  \***************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst basex = __webpack_require__(/*! base-x */ \"(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js\");\nconst ALPHABET = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\nmodule.exports = basex(ALPHABET);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vdXRpbHMvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9ub2RlX21vZHVsZXMvYnM1OC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiO0FBQUEsTUFBTUEsUUFBUUMsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUMsV0FBVztBQUVqQkMsT0FBT0MsT0FBTyxHQUFHSixNQUFNRSIsInNvdXJjZXMiOlsid2VicGFjazovL3B3cnBlcmtzLy4vbm9kZV9tb2R1bGVzL0B0YXF1aXRvL3V0aWxzL25vZGVfbW9kdWxlcy9iczU4Y2hlY2svbm9kZV9tb2R1bGVzL2JzNTgvaW5kZXguanM/NDBhOCJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBiYXNleCA9IHJlcXVpcmUoJ2Jhc2UteCcpXG5jb25zdCBBTFBIQUJFVCA9ICcxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJhc2V4KEFMUEhBQkVUKVxuIl0sIm5hbWVzIjpbImJhc2V4IiwicmVxdWlyZSIsIkFMUEhBQkVUIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js ***!
  \***************************************************************************************************************/
/***/ ((module) => {

eval("\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base(ALPHABET) {\n    if (ALPHABET.length >= 255) {\n        throw new TypeError(\"Alphabet too long\");\n    }\n    var BASE_MAP = new Uint8Array(256);\n    for(var j = 0; j < BASE_MAP.length; j++){\n        BASE_MAP[j] = 255;\n    }\n    for(var i = 0; i < ALPHABET.length; i++){\n        var x = ALPHABET.charAt(i);\n        var xc = x.charCodeAt(0);\n        if (BASE_MAP[xc] !== 255) {\n            throw new TypeError(x + \" is ambiguous\");\n        }\n        BASE_MAP[xc] = i;\n    }\n    var BASE = ALPHABET.length;\n    var LEADER = ALPHABET.charAt(0);\n    var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n    ;\n    var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n    ;\n    function encode(source) {\n        if (source instanceof Uint8Array) {} else if (ArrayBuffer.isView(source)) {\n            source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);\n        } else if (Array.isArray(source)) {\n            source = Uint8Array.from(source);\n        }\n        if (!(source instanceof Uint8Array)) {\n            throw new TypeError(\"Expected Uint8Array\");\n        }\n        if (source.length === 0) {\n            return \"\";\n        }\n        // Skip & count leading zeroes.\n        var zeroes = 0;\n        var length = 0;\n        var pbegin = 0;\n        var pend = source.length;\n        while(pbegin !== pend && source[pbegin] === 0){\n            pbegin++;\n            zeroes++;\n        }\n        // Allocate enough space in big-endian base58 representation.\n        var size = (pend - pbegin) * iFACTOR + 1 >>> 0;\n        var b58 = new Uint8Array(size);\n        // Process the bytes.\n        while(pbegin !== pend){\n            var carry = source[pbegin];\n            // Apply \"b58 = b58 * 256 + ch\".\n            var i = 0;\n            for(var it1 = size - 1; (carry !== 0 || i < length) && it1 !== -1; it1--, i++){\n                carry += 256 * b58[it1] >>> 0;\n                b58[it1] = carry % BASE >>> 0;\n                carry = carry / BASE >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            pbegin++;\n        }\n        // Skip leading zeroes in base58 result.\n        var it2 = size - length;\n        while(it2 !== size && b58[it2] === 0){\n            it2++;\n        }\n        // Translate the result into a string.\n        var str = LEADER.repeat(zeroes);\n        for(; it2 < size; ++it2){\n            str += ALPHABET.charAt(b58[it2]);\n        }\n        return str;\n    }\n    function decodeUnsafe(source) {\n        if (typeof source !== \"string\") {\n            throw new TypeError(\"Expected String\");\n        }\n        if (source.length === 0) {\n            return new Uint8Array();\n        }\n        var psz = 0;\n        // Skip and count leading '1's.\n        var zeroes = 0;\n        var length = 0;\n        while(source[psz] === LEADER){\n            zeroes++;\n            psz++;\n        }\n        // Allocate enough space in big-endian base256 representation.\n        var size = (source.length - psz) * FACTOR + 1 >>> 0 // log(58) / log(256), rounded up.\n        ;\n        var b256 = new Uint8Array(size);\n        // Process the characters.\n        while(source[psz]){\n            // Decode character\n            var carry = BASE_MAP[source.charCodeAt(psz)];\n            // Invalid character\n            if (carry === 255) {\n                return;\n            }\n            var i = 0;\n            for(var it3 = size - 1; (carry !== 0 || i < length) && it3 !== -1; it3--, i++){\n                carry += BASE * b256[it3] >>> 0;\n                b256[it3] = carry % 256 >>> 0;\n                carry = carry / 256 >>> 0;\n            }\n            if (carry !== 0) {\n                throw new Error(\"Non-zero carry\");\n            }\n            length = i;\n            psz++;\n        }\n        // Skip leading zeroes in b256.\n        var it4 = size - length;\n        while(it4 !== size && b256[it4] === 0){\n            it4++;\n        }\n        var vch = new Uint8Array(zeroes + (size - it4));\n        var j = zeroes;\n        while(it4 !== size){\n            vch[j++] = b256[it4++];\n        }\n        return vch;\n    }\n    function decode(string) {\n        var buffer = decodeUnsafe(string);\n        if (buffer) {\n            return buffer;\n        }\n        throw new Error(\"Non-base\" + BASE + \" character\");\n    }\n    return {\n        encode: encode,\n        decodeUnsafe: decodeUnsafe,\n        decode: decode\n    };\n}\nmodule.exports = base;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHRhcXVpdG8vdXRpbHMvbm9kZV9tb2R1bGVzL2JzNThjaGVjay9ub2RlX21vZHVsZXMvYnM1OC9ub2RlX21vZHVsZXMvYmFzZS14L3NyYy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBLDZCQUE2QjtBQUM3Qix5Q0FBeUM7QUFDekMsbUVBQW1FO0FBQ25FLG1FQUFtRTtBQUNuRSxzRUFBc0U7QUFDdEUsU0FBU0EsS0FBTUMsUUFBUTtJQUNyQixJQUFJQSxTQUFTQyxNQUFNLElBQUksS0FBSztRQUFFLE1BQU0sSUFBSUMsVUFBVTtJQUFxQjtJQUN2RSxJQUFJQyxXQUFXLElBQUlDLFdBQVc7SUFDOUIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlGLFNBQVNGLE1BQU0sRUFBRUksSUFBSztRQUN4Q0YsUUFBUSxDQUFDRSxFQUFFLEdBQUc7SUFDaEI7SUFDQSxJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSU4sU0FBU0MsTUFBTSxFQUFFSyxJQUFLO1FBQ3hDLElBQUlDLElBQUlQLFNBQVNRLE1BQU0sQ0FBQ0Y7UUFDeEIsSUFBSUcsS0FBS0YsRUFBRUcsVUFBVSxDQUFDO1FBQ3RCLElBQUlQLFFBQVEsQ0FBQ00sR0FBRyxLQUFLLEtBQUs7WUFBRSxNQUFNLElBQUlQLFVBQVVLLElBQUk7UUFBaUI7UUFDckVKLFFBQVEsQ0FBQ00sR0FBRyxHQUFHSDtJQUNqQjtJQUNBLElBQUlLLE9BQU9YLFNBQVNDLE1BQU07SUFDMUIsSUFBSVcsU0FBU1osU0FBU1EsTUFBTSxDQUFDO0lBQzdCLElBQUlLLFNBQVNDLEtBQUtDLEdBQUcsQ0FBQ0osUUFBUUcsS0FBS0MsR0FBRyxDQUFDLEtBQUssbUNBQW1DOztJQUMvRSxJQUFJQyxVQUFVRixLQUFLQyxHQUFHLENBQUMsT0FBT0QsS0FBS0MsR0FBRyxDQUFDSixNQUFNLG1DQUFtQzs7SUFDaEYsU0FBU00sT0FBUUMsTUFBTTtRQUNyQixJQUFJQSxrQkFBa0JkLFlBQVksQ0FDbEMs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TCxNQUFLLEtBQU93QyxRQUFRLENBQUMsR0FBSUEsT0FBT25DLElBQUs7Z0JBQ2hGMEIsU0FBUyxPQUFRUSxJQUFJLENBQUNDLElBQUksS0FBTTtnQkFDaENELElBQUksQ0FBQ0MsSUFBSSxHQUFHLFFBQVMsUUFBUztnQkFDOUJULFFBQVEsUUFBUyxRQUFTO1lBQzVCO1lBQ0EsSUFBSUEsVUFBVSxHQUFHO2dCQUFFLE1BQU0sSUFBSUUsTUFBTTtZQUFrQjtZQUNyRGpDLFNBQVNLO1lBQ1RpQztRQUNGO1FBQ0ksK0JBQStCO1FBQ25DLElBQUlHLE1BQU1aLE9BQU83QjtRQUNqQixNQUFPeUMsUUFBUVosUUFBUVUsSUFBSSxDQUFDRSxJQUFJLEtBQUssRUFBRztZQUN0Q0E7UUFDRjtRQUNBLElBQUlDLE1BQU0sSUFBSXZDLFdBQVd1QixTQUFVRyxDQUFBQSxPQUFPWSxHQUFFO1FBQzVDLElBQUlyQyxJQUFJc0I7UUFDUixNQUFPZSxRQUFRWixLQUFNO1lBQ25CYSxHQUFHLENBQUN0QyxJQUFJLEdBQUdtQyxJQUFJLENBQUNFLE1BQU07UUFDeEI7UUFDQSxPQUFPQztJQUNUO0lBQ0EsU0FBU0MsT0FBUUMsTUFBTTtRQUNyQixJQUFJeEIsU0FBU2lCLGFBQWFPO1FBQzFCLElBQUl4QixRQUFRO1lBQUUsT0FBT0E7UUFBTztRQUM1QixNQUFNLElBQUlhLE1BQU0sYUFBYXZCLE9BQU87SUFDdEM7SUFDQSxPQUFPO1FBQ0xNLFFBQVFBO1FBQ1JxQixjQUFjQTtRQUNkTSxRQUFRQTtJQUNWO0FBQ0Y7QUFDQUUsT0FBT0MsT0FBTyxHQUFHaEQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wd3JwZXJrcy8uL25vZGVfbW9kdWxlcy9AdGFxdWl0by91dGlscy9ub2RlX21vZHVsZXMvYnM1OGNoZWNrL25vZGVfbW9kdWxlcy9iczU4L25vZGVfbW9kdWxlcy9iYXNlLXgvc3JjL2luZGV4LmpzPzFkMDAiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnXG4vLyBiYXNlLXggZW5jb2RpbmcgLyBkZWNvZGluZ1xuLy8gQ29weXJpZ2h0IChjKSAyMDE4IGJhc2UteCBjb250cmlidXRvcnNcbi8vIENvcHlyaWdodCAoYykgMjAxNC0yMDE4IFRoZSBCaXRjb2luIENvcmUgZGV2ZWxvcGVycyAoYmFzZTU4LmNwcClcbi8vIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgc29mdHdhcmUgbGljZW5zZSwgc2VlIHRoZSBhY2NvbXBhbnlpbmdcbi8vIGZpbGUgTElDRU5TRSBvciBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocC5cbmZ1bmN0aW9uIGJhc2UgKEFMUEhBQkVUKSB7XG4gIGlmIChBTFBIQUJFVC5sZW5ndGggPj0gMjU1KSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0FscGhhYmV0IHRvbyBsb25nJykgfVxuICB2YXIgQkFTRV9NQVAgPSBuZXcgVWludDhBcnJheSgyNTYpXG4gIGZvciAodmFyIGogPSAwOyBqIDwgQkFTRV9NQVAubGVuZ3RoOyBqKyspIHtcbiAgICBCQVNFX01BUFtqXSA9IDI1NVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgQUxQSEFCRVQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgeCA9IEFMUEhBQkVULmNoYXJBdChpKVxuICAgIHZhciB4YyA9IHguY2hhckNvZGVBdCgwKVxuICAgIGlmIChCQVNFX01BUFt4Y10gIT09IDI1NSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpIH1cbiAgICBCQVNFX01BUFt4Y10gPSBpXG4gIH1cbiAgdmFyIEJBU0UgPSBBTFBIQUJFVC5sZW5ndGhcbiAgdmFyIExFQURFUiA9IEFMUEhBQkVULmNoYXJBdCgwKVxuICB2YXIgRkFDVE9SID0gTWF0aC5sb2coQkFTRSkgLyBNYXRoLmxvZygyNTYpIC8vIGxvZyhCQVNFKSAvIGxvZygyNTYpLCByb3VuZGVkIHVwXG4gIHZhciBpRkFDVE9SID0gTWF0aC5sb2coMjU2KSAvIE1hdGgubG9nKEJBU0UpIC8vIGxvZygyNTYpIC8gbG9nKEJBU0UpLCByb3VuZGVkIHVwXG4gIGZ1bmN0aW9uIGVuY29kZSAoc291cmNlKSB7XG4gICAgaWYgKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzb3VyY2UpKSB7XG4gICAgICBzb3VyY2UgPSBuZXcgVWludDhBcnJheShzb3VyY2UuYnVmZmVyLCBzb3VyY2UuYnl0ZU9mZnNldCwgc291cmNlLmJ5dGVMZW5ndGgpXG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHNvdXJjZSA9IFVpbnQ4QXJyYXkuZnJvbShzb3VyY2UpXG4gICAgfVxuICAgIGlmICghKHNvdXJjZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFVpbnQ4QXJyYXknKSB9XG4gICAgaWYgKHNvdXJjZS5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnIH1cbiAgICAgICAgLy8gU2tpcCAmIGNvdW50IGxlYWRpbmcgemVyb2VzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB2YXIgcGJlZ2luID0gMFxuICAgIHZhciBwZW5kID0gc291cmNlLmxlbmd0aFxuICAgIHdoaWxlIChwYmVnaW4gIT09IHBlbmQgJiYgc291cmNlW3BiZWdpbl0gPT09IDApIHtcbiAgICAgIHBiZWdpbisrXG4gICAgICB6ZXJvZXMrK1xuICAgIH1cbiAgICAgICAgLy8gQWxsb2NhdGUgZW5vdWdoIHNwYWNlIGluIGJpZy1lbmRpYW4gYmFzZTU4IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKChwZW5kIC0gcGJlZ2luKSAqIGlGQUNUT1IgKyAxKSA+Pj4gMFxuICAgIHZhciBiNTggPSBuZXcgVWludDhBcnJheShzaXplKVxuICAgICAgICAvLyBQcm9jZXNzIHRoZSBieXRlcy5cbiAgICB3aGlsZSAocGJlZ2luICE9PSBwZW5kKSB7XG4gICAgICB2YXIgY2FycnkgPSBzb3VyY2VbcGJlZ2luXVxuICAgICAgICAgICAgLy8gQXBwbHkgXCJiNTggPSBiNTggKiAyNTYgKyBjaFwiLlxuICAgICAgdmFyIGkgPSAwXG4gICAgICBmb3IgKHZhciBpdDEgPSBzaXplIC0gMTsgKGNhcnJ5ICE9PSAwIHx8IGkgPCBsZW5ndGgpICYmIChpdDEgIT09IC0xKTsgaXQxLS0sIGkrKykge1xuICAgICAgICBjYXJyeSArPSAoMjU2ICogYjU4W2l0MV0pID4+PiAwXG4gICAgICAgIGI1OFtpdDFdID0gKGNhcnJ5ICUgQkFTRSkgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyBCQVNFKSA+Pj4gMFxuICAgICAgfVxuICAgICAgaWYgKGNhcnJ5ICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTm9uLXplcm8gY2FycnknKSB9XG4gICAgICBsZW5ndGggPSBpXG4gICAgICBwYmVnaW4rK1xuICAgIH1cbiAgICAgICAgLy8gU2tpcCBsZWFkaW5nIHplcm9lcyBpbiBiYXNlNTggcmVzdWx0LlxuICAgIHZhciBpdDIgPSBzaXplIC0gbGVuZ3RoXG4gICAgd2hpbGUgKGl0MiAhPT0gc2l6ZSAmJiBiNThbaXQyXSA9PT0gMCkge1xuICAgICAgaXQyKytcbiAgICB9XG4gICAgICAgIC8vIFRyYW5zbGF0ZSB0aGUgcmVzdWx0IGludG8gYSBzdHJpbmcuXG4gICAgdmFyIHN0ciA9IExFQURFUi5yZXBlYXQoemVyb2VzKVxuICAgIGZvciAoOyBpdDIgPCBzaXplOyArK2l0MikgeyBzdHIgKz0gQUxQSEFCRVQuY2hhckF0KGI1OFtpdDJdKSB9XG4gICAgcmV0dXJuIHN0clxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZVVuc2FmZSAoc291cmNlKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2UgIT09ICdzdHJpbmcnKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIFN0cmluZycpIH1cbiAgICBpZiAoc291cmNlLmxlbmd0aCA9PT0gMCkgeyByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoKSB9XG4gICAgdmFyIHBzeiA9IDBcbiAgICAgICAgLy8gU2tpcCBhbmQgY291bnQgbGVhZGluZyAnMSdzLlxuICAgIHZhciB6ZXJvZXMgPSAwXG4gICAgdmFyIGxlbmd0aCA9IDBcbiAgICB3aGlsZSAoc291cmNlW3Bzel0gPT09IExFQURFUikge1xuICAgICAgemVyb2VzKytcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBBbGxvY2F0ZSBlbm91Z2ggc3BhY2UgaW4gYmlnLWVuZGlhbiBiYXNlMjU2IHJlcHJlc2VudGF0aW9uLlxuICAgIHZhciBzaXplID0gKCgoc291cmNlLmxlbmd0aCAtIHBzeikgKiBGQUNUT1IpICsgMSkgPj4+IDAgLy8gbG9nKDU4KSAvIGxvZygyNTYpLCByb3VuZGVkIHVwLlxuICAgIHZhciBiMjU2ID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSlcbiAgICAgICAgLy8gUHJvY2VzcyB0aGUgY2hhcmFjdGVycy5cbiAgICB3aGlsZSAoc291cmNlW3Bzel0pIHtcbiAgICAgICAgICAgIC8vIERlY29kZSBjaGFyYWN0ZXJcbiAgICAgIHZhciBjYXJyeSA9IEJBU0VfTUFQW3NvdXJjZS5jaGFyQ29kZUF0KHBzeildXG4gICAgICAgICAgICAvLyBJbnZhbGlkIGNoYXJhY3RlclxuICAgICAgaWYgKGNhcnJ5ID09PSAyNTUpIHsgcmV0dXJuIH1cbiAgICAgIHZhciBpID0gMFxuICAgICAgZm9yICh2YXIgaXQzID0gc2l6ZSAtIDE7IChjYXJyeSAhPT0gMCB8fCBpIDwgbGVuZ3RoKSAmJiAoaXQzICE9PSAtMSk7IGl0My0tLCBpKyspIHtcbiAgICAgICAgY2FycnkgKz0gKEJBU0UgKiBiMjU2W2l0M10pID4+PiAwXG4gICAgICAgIGIyNTZbaXQzXSA9IChjYXJyeSAlIDI1NikgPj4+IDBcbiAgICAgICAgY2FycnkgPSAoY2FycnkgLyAyNTYpID4+PiAwXG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHsgdGhyb3cgbmV3IEVycm9yKCdOb24temVybyBjYXJyeScpIH1cbiAgICAgIGxlbmd0aCA9IGlcbiAgICAgIHBzeisrXG4gICAgfVxuICAgICAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzIGluIGIyNTYuXG4gICAgdmFyIGl0NCA9IHNpemUgLSBsZW5ndGhcbiAgICB3aGlsZSAoaXQ0ICE9PSBzaXplICYmIGIyNTZbaXQ0XSA9PT0gMCkge1xuICAgICAgaXQ0KytcbiAgICB9XG4gICAgdmFyIHZjaCA9IG5ldyBVaW50OEFycmF5KHplcm9lcyArIChzaXplIC0gaXQ0KSlcbiAgICB2YXIgaiA9IHplcm9lc1xuICAgIHdoaWxlIChpdDQgIT09IHNpemUpIHtcbiAgICAgIHZjaFtqKytdID0gYjI1NltpdDQrK11cbiAgICB9XG4gICAgcmV0dXJuIHZjaFxuICB9XG4gIGZ1bmN0aW9uIGRlY29kZSAoc3RyaW5nKSB7XG4gICAgdmFyIGJ1ZmZlciA9IGRlY29kZVVuc2FmZShzdHJpbmcpXG4gICAgaWYgKGJ1ZmZlcikgeyByZXR1cm4gYnVmZmVyIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbi1iYXNlJyArIEJBU0UgKyAnIGNoYXJhY3RlcicpXG4gIH1cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGU6IGVuY29kZSxcbiAgICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgICBkZWNvZGU6IGRlY29kZVxuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGJhc2VcbiJdLCJuYW1lcyI6WyJiYXNlIiwiQUxQSEFCRVQiLCJsZW5ndGgiLCJUeXBlRXJyb3IiLCJCQVNFX01BUCIsIlVpbnQ4QXJyYXkiLCJqIiwiaSIsIngiLCJjaGFyQXQiLCJ4YyIsImNoYXJDb2RlQXQiLCJCQVNFIiwiTEVBREVSIiwiRkFDVE9SIiwiTWF0aCIsImxvZyIsImlGQUNUT1IiLCJlbmNvZGUiLCJzb3VyY2UiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwiQXJyYXkiLCJpc0FycmF5IiwiZnJvbSIsInplcm9lcyIsInBiZWdpbiIsInBlbmQiLCJzaXplIiwiYjU4IiwiY2FycnkiLCJpdDEiLCJFcnJvciIsIml0MiIsInN0ciIsInJlcGVhdCIsImRlY29kZVVuc2FmZSIsInBzeiIsImIyNTYiLCJpdDMiLCJpdDQiLCJ2Y2giLCJkZWNvZGUiLCJzdHJpbmciLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@taquito/utils/node_modules/bs58check/node_modules/bs58/node_modules/base-x/src/index.js\n");

/***/ })

};
;