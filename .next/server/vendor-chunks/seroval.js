"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/seroval";
exports.ids = ["vendor-chunks/seroval"];
exports.modules = {

/***/ "(ssr)/./node_modules/seroval/dist/esm/development/index.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/seroval/dist/esm/development/index.mjs ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Feature: () => (/* binding */ Feature),\n/* harmony export */   Serializer: () => (/* binding */ Serializer),\n/* harmony export */   SerovalDeserializationError: () => (/* binding */ SerovalDeserializationError),\n/* harmony export */   SerovalError: () => (/* binding */ SerovalError),\n/* harmony export */   SerovalMissingInstanceError: () => (/* binding */ SerovalMissingInstanceError),\n/* harmony export */   SerovalMissingPluginError: () => (/* binding */ SerovalMissingPluginError),\n/* harmony export */   SerovalMissingReferenceError: () => (/* binding */ SerovalMissingReferenceError),\n/* harmony export */   SerovalMissingReferenceForIdError: () => (/* binding */ SerovalMissingReferenceForIdError),\n/* harmony export */   SerovalParserError: () => (/* binding */ SerovalParserError),\n/* harmony export */   SerovalSerializationError: () => (/* binding */ SerovalSerializationError),\n/* harmony export */   SerovalUnknownTypedArrayError: () => (/* binding */ SerovalUnknownTypedArrayError),\n/* harmony export */   SerovalUnsupportedNodeError: () => (/* binding */ SerovalUnsupportedNodeError),\n/* harmony export */   SerovalUnsupportedTypeError: () => (/* binding */ SerovalUnsupportedTypeError),\n/* harmony export */   compileJSON: () => (/* binding */ compileJSON),\n/* harmony export */   createPlugin: () => (/* binding */ createPlugin),\n/* harmony export */   createReference: () => (/* binding */ createReference),\n/* harmony export */   createStream: () => (/* binding */ createStream),\n/* harmony export */   crossSerialize: () => (/* binding */ crossSerialize),\n/* harmony export */   crossSerializeAsync: () => (/* binding */ crossSerializeAsync),\n/* harmony export */   crossSerializeStream: () => (/* binding */ crossSerializeStream),\n/* harmony export */   deserialize: () => (/* binding */ deserialize),\n/* harmony export */   fromCrossJSON: () => (/* binding */ fromCrossJSON),\n/* harmony export */   fromJSON: () => (/* binding */ fromJSON),\n/* harmony export */   getCrossReferenceHeader: () => (/* binding */ getCrossReferenceHeader),\n/* harmony export */   resolvePlugins: () => (/* binding */ resolvePlugins),\n/* harmony export */   serialize: () => (/* binding */ serialize),\n/* harmony export */   serializeAsync: () => (/* binding */ serializeAsync),\n/* harmony export */   toCrossJSON: () => (/* binding */ toCrossJSON),\n/* harmony export */   toCrossJSONAsync: () => (/* binding */ toCrossJSONAsync),\n/* harmony export */   toCrossJSONStream: () => (/* binding */ toCrossJSONStream),\n/* harmony export */   toJSON: () => (/* binding */ toJSON),\n/* harmony export */   toJSONAsync: () => (/* binding */ toJSONAsync)\n/* harmony export */ });\n// src/core/compat.ts\nvar Feature = /* @__PURE__ */ ((Feature2)=>{\n    Feature2[Feature2[\"AggregateError\"] = 1] = \"AggregateError\";\n    Feature2[Feature2[\"ArrowFunction\"] = 2] = \"ArrowFunction\";\n    Feature2[Feature2[\"ErrorPrototypeStack\"] = 4] = \"ErrorPrototypeStack\";\n    Feature2[Feature2[\"ObjectAssign\"] = 8] = \"ObjectAssign\";\n    Feature2[Feature2[\"BigIntTypedArray\"] = 16] = \"BigIntTypedArray\";\n    return Feature2;\n})(Feature || {});\nvar ALL_ENABLED = 31;\n// src/core/utils/assert.ts\nfunction assert(cond, error) {\n    if (!cond) {\n        throw error;\n    }\n}\n// src/core/string.ts\nfunction serializeChar(str) {\n    switch(str){\n        case '\"':\n            return '\\\\\"';\n        case \"\\\\\":\n            return \"\\\\\\\\\";\n        case \"\\n\":\n            return \"\\\\n\";\n        case \"\\r\":\n            return \"\\\\r\";\n        case \"\\b\":\n            return \"\\\\b\";\n        case \"\t\":\n            return \"\\\\t\";\n        case \"\\f\":\n            return \"\\\\f\";\n        case \"<\":\n            return \"\\\\x3C\";\n        case \"\\u2028\":\n            return \"\\\\u2028\";\n        case \"\\u2029\":\n            return \"\\\\u2029\";\n        default:\n            return void 0;\n    }\n}\nfunction serializeString(str) {\n    let result = \"\";\n    let lastPos = 0;\n    let replacement;\n    for(let i = 0, len = str.length; i < len; i++){\n        replacement = serializeChar(str[i]);\n        if (replacement) {\n            result += str.slice(lastPos, i) + replacement;\n            lastPos = i + 1;\n        }\n    }\n    if (lastPos === 0) {\n        result = str;\n    } else {\n        result += str.slice(lastPos);\n    }\n    return result;\n}\nfunction deserializeReplacer(str) {\n    switch(str){\n        case \"\\\\\\\\\":\n            return \"\\\\\";\n        case '\\\\\"':\n            return '\"';\n        case \"\\\\n\":\n            return \"\\n\";\n        case \"\\\\r\":\n            return \"\\r\";\n        case \"\\\\b\":\n            return \"\\b\";\n        case \"\\\\t\":\n            return \"\t\";\n        case \"\\\\f\":\n            return \"\\f\";\n        case \"\\\\x3C\":\n            return \"<\";\n        case \"\\\\u2028\":\n            return \"\\u2028\";\n        case \"\\\\u2029\":\n            return \"\\u2029\";\n        default:\n            return str;\n    }\n}\nfunction deserializeString(str) {\n    return str.replace(/(\\\\\\\\|\\\\\"|\\\\n|\\\\r|\\\\b|\\\\t|\\\\f|\\\\u2028|\\\\u2029|\\\\x3C)/g, deserializeReplacer);\n}\n// src/core/keys.ts\nvar REFERENCES_KEY = \"__SEROVAL_REFS__\";\nvar GLOBAL_CONTEXT_REFERENCES = \"$R\";\nvar GLOBAL_CONTEXT_R = `self.${GLOBAL_CONTEXT_REFERENCES}`;\nfunction getCrossReferenceHeader(id) {\n    if (id == null) {\n        return `${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||[]`;\n    }\n    return `(${GLOBAL_CONTEXT_R}=${GLOBAL_CONTEXT_R}||{})[\"${serializeString(id)}\"]=[]`;\n}\n// src/core/reference.ts\nvar REFERENCE = /* @__PURE__ */ new Map();\nvar INV_REFERENCE = /* @__PURE__ */ new Map();\nfunction createReference(id, value) {\n    REFERENCE.set(value, id);\n    INV_REFERENCE.set(id, value);\n    return value;\n}\nfunction hasReferenceID(value) {\n    return REFERENCE.has(value);\n}\nfunction hasReference(id) {\n    return INV_REFERENCE.has(id);\n}\nfunction getReferenceID(value) {\n    assert(hasReferenceID(value), new SerovalMissingReferenceError(value));\n    return REFERENCE.get(value);\n}\nfunction getReference(id) {\n    assert(hasReference(id), new SerovalMissingReferenceForIdError(id));\n    return INV_REFERENCE.get(id);\n}\nif (typeof globalThis !== \"undefined\") {\n    Object.defineProperty(globalThis, REFERENCES_KEY, {\n        value: INV_REFERENCE,\n        configurable: true,\n        writable: false,\n        enumerable: false\n    });\n} else if (false) {} else if (typeof self !== \"undefined\") {\n    Object.defineProperty(self, REFERENCES_KEY, {\n        value: INV_REFERENCE,\n        configurable: true,\n        writable: false,\n        enumerable: false\n    });\n} else if (typeof global !== \"undefined\") {\n    Object.defineProperty(global, REFERENCES_KEY, {\n        value: INV_REFERENCE,\n        configurable: true,\n        writable: false,\n        enumerable: false\n    });\n}\n// src/core/plugin.ts\nfunction createPlugin(plugin) {\n    return plugin;\n}\nfunction dedupePlugins(deduped, plugins) {\n    for(let i = 0, len = plugins.length; i < len; i++){\n        const current = plugins[i];\n        if (!deduped.has(current)) {\n            deduped.add(current);\n            if (current.extends) {\n                dedupePlugins(deduped, current.extends);\n            }\n        }\n    }\n}\nfunction resolvePlugins(plugins) {\n    if (plugins) {\n        const deduped = /* @__PURE__ */ new Set();\n        dedupePlugins(deduped, plugins);\n        return [\n            ...deduped\n        ];\n    }\n    return void 0;\n}\n// src/core/constants.ts\nvar SYMBOL_STRING = {\n    [0 /* AsyncIterator */ ]: \"Symbol.asyncIterator\",\n    [1 /* HasInstance */ ]: \"Symbol.hasInstance\",\n    [2 /* IsConcatSpreadable */ ]: \"Symbol.isConcatSpreadable\",\n    [3 /* Iterator */ ]: \"Symbol.iterator\",\n    [4 /* Match */ ]: \"Symbol.match\",\n    [5 /* MatchAll */ ]: \"Symbol.matchAll\",\n    [6 /* Replace */ ]: \"Symbol.replace\",\n    [7 /* Search */ ]: \"Symbol.search\",\n    [8 /* Species */ ]: \"Symbol.species\",\n    [9 /* Split */ ]: \"Symbol.split\",\n    [10 /* ToPrimitive */ ]: \"Symbol.toPrimitive\",\n    [11 /* ToStringTag */ ]: \"Symbol.toStringTag\",\n    [12 /* Unscopables */ ]: \"Symbol.unscopables\"\n};\nvar INV_SYMBOL_REF = {\n    [Symbol.asyncIterator]: 0 /* AsyncIterator */ ,\n    [Symbol.hasInstance]: 1 /* HasInstance */ ,\n    [Symbol.isConcatSpreadable]: 2 /* IsConcatSpreadable */ ,\n    [Symbol.iterator]: 3 /* Iterator */ ,\n    [Symbol.match]: 4 /* Match */ ,\n    [Symbol.matchAll]: 5 /* MatchAll */ ,\n    [Symbol.replace]: 6 /* Replace */ ,\n    [Symbol.search]: 7 /* Search */ ,\n    [Symbol.species]: 8 /* Species */ ,\n    [Symbol.split]: 9 /* Split */ ,\n    [Symbol.toPrimitive]: 10 /* ToPrimitive */ ,\n    [Symbol.toStringTag]: 11 /* ToStringTag */ ,\n    [Symbol.unscopables]: 12 /* Unscopables */ \n};\nvar SYMBOL_REF = {\n    [0 /* AsyncIterator */ ]: Symbol.asyncIterator,\n    [1 /* HasInstance */ ]: Symbol.hasInstance,\n    [2 /* IsConcatSpreadable */ ]: Symbol.isConcatSpreadable,\n    [3 /* Iterator */ ]: Symbol.iterator,\n    [4 /* Match */ ]: Symbol.match,\n    [5 /* MatchAll */ ]: Symbol.matchAll,\n    [6 /* Replace */ ]: Symbol.replace,\n    [7 /* Search */ ]: Symbol.search,\n    [8 /* Species */ ]: Symbol.species,\n    [9 /* Split */ ]: Symbol.split,\n    [10 /* ToPrimitive */ ]: Symbol.toPrimitive,\n    [11 /* ToStringTag */ ]: Symbol.toStringTag,\n    [12 /* Unscopables */ ]: Symbol.unscopables\n};\nvar CONSTANT_STRING = {\n    [2 /* True */ ]: \"!0\",\n    [3 /* False */ ]: \"!1\",\n    [1 /* Undefined */ ]: \"void 0\",\n    [0 /* Null */ ]: \"null\",\n    [4 /* NegativeZero */ ]: \"-0\",\n    [5 /* Infinity */ ]: \"1/0\",\n    [6 /* NegativeInfinity */ ]: \"-1/0\",\n    [7 /* NaN */ ]: \"0/0\"\n};\nvar CONSTANT_VAL = {\n    [2 /* True */ ]: true,\n    [3 /* False */ ]: false,\n    [1 /* Undefined */ ]: void 0,\n    [0 /* Null */ ]: null,\n    [4 /* NegativeZero */ ]: -0,\n    [5 /* Infinity */ ]: Infinity,\n    [6 /* NegativeInfinity */ ]: -Infinity,\n    [7 /* NaN */ ]: NaN\n};\nvar ERROR_CONSTRUCTOR_STRING = {\n    [0 /* Error */ ]: \"Error\",\n    [1 /* EvalError */ ]: \"EvalError\",\n    [2 /* RangeError */ ]: \"RangeError\",\n    [3 /* ReferenceError */ ]: \"ReferenceError\",\n    [4 /* SyntaxError */ ]: \"SyntaxError\",\n    [5 /* TypeError */ ]: \"TypeError\",\n    [6 /* URIError */ ]: \"URIError\"\n};\nvar ERROR_CONSTRUCTOR = {\n    [0 /* Error */ ]: Error,\n    [1 /* EvalError */ ]: EvalError,\n    [2 /* RangeError */ ]: RangeError,\n    [3 /* ReferenceError */ ]: ReferenceError,\n    [4 /* SyntaxError */ ]: SyntaxError,\n    [5 /* TypeError */ ]: TypeError,\n    [6 /* URIError */ ]: URIError\n};\n// src/core/literals.ts\nfunction createConstantNode(value) {\n    return {\n        t: 2 /* Constant */ ,\n        i: void 0,\n        s: value,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nvar TRUE_NODE = /* @__PURE__ */ createConstantNode(2 /* True */ );\nvar FALSE_NODE = /* @__PURE__ */ createConstantNode(3 /* False */ );\nvar UNDEFINED_NODE = /* @__PURE__ */ createConstantNode(1 /* Undefined */ );\nvar NULL_NODE = /* @__PURE__ */ createConstantNode(0 /* Null */ );\nvar NEG_ZERO_NODE = /* @__PURE__ */ createConstantNode(4 /* NegativeZero */ );\nvar INFINITY_NODE = /* @__PURE__ */ createConstantNode(5 /* Infinity */ );\nvar NEG_INFINITY_NODE = /* @__PURE__ */ createConstantNode(6 /* NegativeInfinity */ );\nvar NAN_NODE = /* @__PURE__ */ createConstantNode(7 /* NaN */ );\n// src/core/utils/error.ts\nfunction getErrorConstructor(error) {\n    if (error instanceof EvalError) {\n        return 1 /* EvalError */ ;\n    }\n    if (error instanceof RangeError) {\n        return 2 /* RangeError */ ;\n    }\n    if (error instanceof ReferenceError) {\n        return 3 /* ReferenceError */ ;\n    }\n    if (error instanceof SyntaxError) {\n        return 4 /* SyntaxError */ ;\n    }\n    if (error instanceof TypeError) {\n        return 5 /* TypeError */ ;\n    }\n    if (error instanceof URIError) {\n        return 6 /* URIError */ ;\n    }\n    return 0 /* Error */ ;\n}\nfunction getInitialErrorOptions(error) {\n    const construct = ERROR_CONSTRUCTOR_STRING[getErrorConstructor(error)];\n    if (error.name !== construct) {\n        return {\n            name: error.name\n        };\n    }\n    if (error.constructor.name !== construct) {\n        return {\n            name: error.constructor.name\n        };\n    }\n    return {};\n}\nfunction getErrorOptions(error, features) {\n    let options = getInitialErrorOptions(error);\n    const names = Object.getOwnPropertyNames(error);\n    for(let i = 0, len = names.length, name; i < len; i++){\n        name = names[i];\n        if (name !== \"name\" && name !== \"message\") {\n            if (name === \"stack\") {\n                if (features & 4 /* ErrorPrototypeStack */ ) {\n                    options = options || {};\n                    options[name] = error[name];\n                }\n            } else {\n                options = options || {};\n                options[name] = error[name];\n            }\n        }\n    }\n    return options;\n}\n// src/core/utils/get-object-flag.ts\nfunction getObjectFlag(obj) {\n    if (Object.isFrozen(obj)) {\n        return 3 /* Frozen */ ;\n    }\n    if (Object.isSealed(obj)) {\n        return 2 /* Sealed */ ;\n    }\n    if (Object.isExtensible(obj)) {\n        return 0 /* None */ ;\n    }\n    return 1 /* NonExtensible */ ;\n}\n// src/core/base-primitives.ts\nfunction createNumberNode(value) {\n    switch(value){\n        case Infinity:\n            return INFINITY_NODE;\n        case -Infinity:\n            return NEG_INFINITY_NODE;\n    }\n    if (value !== value) {\n        return NAN_NODE;\n    }\n    if (Object.is(value, -0)) {\n        return NEG_ZERO_NODE;\n    }\n    return {\n        t: 0 /* Number */ ,\n        i: void 0,\n        s: value,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createStringNode(value) {\n    return {\n        t: 1 /* String */ ,\n        i: void 0,\n        s: serializeString(value),\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createBigIntNode(current) {\n    return {\n        t: 3 /* BigInt */ ,\n        i: void 0,\n        s: \"\" + current,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createIndexedValueNode(id) {\n    return {\n        t: 4 /* IndexedValue */ ,\n        i: id,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createDateNode(id, current) {\n    return {\n        t: 5 /* Date */ ,\n        i: id,\n        s: current.toISOString(),\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        f: void 0,\n        a: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createRegExpNode(id, current) {\n    return {\n        t: 6 /* RegExp */ ,\n        i: id,\n        s: void 0,\n        l: void 0,\n        c: serializeString(current.source),\n        m: current.flags,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createArrayBufferNode(id, current) {\n    const bytes = new Uint8Array(current);\n    const len = bytes.length;\n    const values = new Array(len);\n    for(let i = 0; i < len; i++){\n        values[i] = bytes[i];\n    }\n    return {\n        t: 19 /* ArrayBuffer */ ,\n        i: id,\n        s: values,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createWKSymbolNode(id, current) {\n    return {\n        t: 17 /* WKSymbol */ ,\n        i: id,\n        s: INV_SYMBOL_REF[current],\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createReferenceNode(id, ref) {\n    return {\n        t: 18 /* Reference */ ,\n        i: id,\n        s: serializeString(getReferenceID(ref)),\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createPluginNode(id, tag, value) {\n    return {\n        t: 25 /* Plugin */ ,\n        i: id,\n        s: value,\n        l: void 0,\n        c: serializeString(tag),\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createArrayNode(id, current, parsedItems) {\n    return {\n        t: 9 /* Array */ ,\n        i: id,\n        s: void 0,\n        l: current.length,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: parsedItems,\n        f: void 0,\n        b: void 0,\n        o: getObjectFlag(current)\n    };\n}\nfunction createBoxedNode(id, boxed) {\n    return {\n        t: 21 /* Boxed */ ,\n        i: id,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: boxed,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createTypedArrayNode(id, current, buffer) {\n    return {\n        t: 15 /* TypedArray */ ,\n        i: id,\n        s: void 0,\n        l: current.length,\n        c: current.constructor.name,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: buffer,\n        b: current.byteOffset,\n        o: void 0\n    };\n}\nfunction createBigIntTypedArrayNode(id, current, buffer) {\n    return {\n        t: 16 /* BigIntTypedArray */ ,\n        i: id,\n        s: void 0,\n        l: current.length,\n        c: current.constructor.name,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: buffer,\n        b: current.byteOffset,\n        o: void 0\n    };\n}\nfunction createDataViewNode(id, current, buffer) {\n    return {\n        t: 20 /* DataView */ ,\n        i: id,\n        s: void 0,\n        l: current.byteLength,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: buffer,\n        b: current.byteOffset,\n        o: void 0\n    };\n}\nfunction createErrorNode(id, current, options) {\n    return {\n        t: 13 /* Error */ ,\n        i: id,\n        s: getErrorConstructor(current),\n        l: void 0,\n        c: void 0,\n        m: serializeString(current.message),\n        p: options,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createAggregateErrorNode(id, current, options) {\n    return {\n        t: 14 /* AggregateError */ ,\n        i: id,\n        s: getErrorConstructor(current),\n        l: void 0,\n        c: void 0,\n        m: serializeString(current.message),\n        p: options,\n        e: void 0,\n        a: void 0,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createSetNode(id, size, items) {\n    return {\n        t: 7 /* Set */ ,\n        i: id,\n        s: void 0,\n        l: size,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: items,\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createIteratorFactoryInstanceNode(factory, items) {\n    return {\n        t: 28 /* IteratorFactoryInstance */ ,\n        i: void 0,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: [\n            factory,\n            items\n        ],\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createAsyncIteratorFactoryInstanceNode(factory, items) {\n    return {\n        t: 30 /* AsyncIteratorFactoryInstance */ ,\n        i: void 0,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: [\n            factory,\n            items\n        ],\n        f: void 0,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createStreamConstructorNode(id, factory, sequence) {\n    return {\n        t: 31 /* StreamConstructor */ ,\n        i: id,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: sequence,\n        f: factory,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createStreamNextNode(id, parsed) {\n    return {\n        t: 32 /* StreamNext */ ,\n        i: id,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: parsed,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createStreamThrowNode(id, parsed) {\n    return {\n        t: 33 /* StreamThrow */ ,\n        i: id,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: parsed,\n        b: void 0,\n        o: void 0\n    };\n}\nfunction createStreamReturnNode(id, parsed) {\n    return {\n        t: 34 /* StreamReturn */ ,\n        i: id,\n        s: void 0,\n        l: void 0,\n        c: void 0,\n        m: void 0,\n        p: void 0,\n        e: void 0,\n        a: void 0,\n        f: parsed,\n        b: void 0,\n        o: void 0\n    };\n}\n// src/core/utils/iterator-to-sequence.ts\nfunction iteratorToSequence(source) {\n    const values = [];\n    let throwsAt = -1;\n    let doneAt = -1;\n    const iterator = source[Symbol.iterator]();\n    while(true){\n        try {\n            const value = iterator.next();\n            values.push(value.value);\n            if (value.done) {\n                doneAt = values.length - 1;\n                break;\n            }\n        } catch (error) {\n            throwsAt = values.length;\n            values.push(error);\n        }\n    }\n    return {\n        v: values,\n        t: throwsAt,\n        d: doneAt\n    };\n}\nfunction sequenceToIterator(sequence) {\n    return ()=>{\n        let index = 0;\n        return {\n            [Symbol.iterator] () {\n                return this;\n            },\n            next () {\n                if (index > sequence.d) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                const currentIndex = index++;\n                const currentItem = sequence.v[currentIndex];\n                if (currentIndex === sequence.t) {\n                    throw currentItem;\n                }\n                return {\n                    done: currentIndex === sequence.d,\n                    value: currentItem\n                };\n            }\n        };\n    };\n}\n// src/core/special-reference.ts\nvar ITERATOR = {};\nvar ASYNC_ITERATOR = {};\nvar SPECIAL_REFS = {\n    [0 /* MapSentinel */ ]: {},\n    [1 /* PromiseConstructor */ ]: {},\n    [2 /* PromiseResolve */ ]: {},\n    [3 /* PromiseReject */ ]: {},\n    [4 /* StreamConstructor */ ]: {}\n};\n// src/core/errors.ts\nvar { toString: objectToString } = Object.prototype;\nfunction getErrorMessage(type, cause) {\n    if (cause instanceof Error) {\n        return `Seroval caught an error during the ${type} process.\n  \n${cause.name}\n${cause.message}\n\n- For more information, please check the \"cause\" property of this error.\n- If you believe this is an error in Seroval, please submit an issue at https://github.com/lxsmnsyc/seroval/issues/new`;\n    }\n    return `Seroval caught an error during the ${type} process.\n\n\"${objectToString.call(cause)}\"\n\nFor more information, please check the \"cause\" property of this error.`;\n}\nvar SerovalError = class extends Error {\n    constructor(type, cause){\n        super(getErrorMessage(type, cause));\n        this.cause = cause;\n    }\n};\nvar SerovalParserError = class extends SerovalError {\n    constructor(cause){\n        super(\"parsing\", cause);\n    }\n};\nvar SerovalSerializationError = class extends SerovalError {\n    constructor(cause){\n        super(\"serialization\", cause);\n    }\n};\nvar SerovalDeserializationError = class extends SerovalError {\n    constructor(cause){\n        super(\"deserialization\", cause);\n    }\n};\nvar SerovalUnsupportedTypeError = class extends Error {\n    constructor(value){\n        super(`The value ${objectToString.call(value)} of type \"${typeof value}\" cannot be parsed/serialized.\n      \nThere are few workarounds for this problem:\n- Transform the value in a way that it can be serialized.\n- If the reference is present on multiple runtimes (isomorphic), you can use the Reference API to map the references.`);\n        this.value = value;\n    }\n};\nvar SerovalUnsupportedNodeError = class extends Error {\n    constructor(node){\n        super('Unsupported node type \"' + node.t + '\".');\n    }\n};\nvar SerovalMissingPluginError = class extends Error {\n    constructor(tag){\n        super('Missing plugin for tag \"' + tag + '\".');\n    }\n};\nvar SerovalMissingInstanceError = class extends Error {\n    constructor(tag){\n        super('Missing \"' + tag + '\" instance.');\n    }\n};\nvar SerovalMissingReferenceError = class extends Error {\n    constructor(value){\n        super('Missing reference for the value \"' + objectToString.call(value) + '\" of type \"' + typeof value + '\"');\n        this.value = value;\n    }\n};\nvar SerovalMissingReferenceForIdError = class extends Error {\n    constructor(id){\n        super('Missing reference for id \"' + serializeString(id) + '\"');\n    }\n};\nvar SerovalUnknownTypedArrayError = class extends Error {\n    constructor(name){\n        super('Unknown TypedArray \"' + name + '\"');\n    }\n};\n// src/core/context/parser.ts\nvar BaseParserContext = class {\n    constructor(options){\n        this.marked = /* @__PURE__ */ new Set();\n        this.plugins = options.plugins;\n        this.features = ALL_ENABLED ^ (options.disabledFeatures || 0);\n        this.refs = options.refs || /* @__PURE__ */ new Map();\n    }\n    markRef(id) {\n        this.marked.add(id);\n    }\n    isMarked(id) {\n        return this.marked.has(id);\n    }\n    getIndexedValue(current) {\n        const registeredId = this.refs.get(current);\n        if (registeredId != null) {\n            this.markRef(registeredId);\n            return {\n                type: 1 /* Indexed */ ,\n                value: createIndexedValueNode(registeredId)\n            };\n        }\n        const id = this.refs.size;\n        this.refs.set(current, id);\n        return {\n            type: 0 /* Fresh */ ,\n            value: id\n        };\n    }\n    getReference(current) {\n        const indexed = this.getIndexedValue(current);\n        if (indexed.type === 1 /* Indexed */ ) {\n            return indexed;\n        }\n        if (hasReferenceID(current)) {\n            return {\n                type: 2 /* Referenced */ ,\n                value: createReferenceNode(indexed.value, current)\n            };\n        }\n        return indexed;\n    }\n    getStrictReference(current) {\n        assert(hasReferenceID(current), new SerovalUnsupportedTypeError(current));\n        const result = this.getIndexedValue(current);\n        if (result.type === 1 /* Indexed */ ) {\n            return result.value;\n        }\n        return createReferenceNode(result.value, current);\n    }\n    parseFunction(current) {\n        return this.getStrictReference(current);\n    }\n    parseWellKnownSymbol(current) {\n        const ref = this.getReference(current);\n        if (ref.type !== 0 /* Fresh */ ) {\n            return ref.value;\n        }\n        assert(current in INV_SYMBOL_REF, new SerovalUnsupportedTypeError(current));\n        return createWKSymbolNode(ref.value, current);\n    }\n    parseSpecialReference(ref) {\n        const result = this.getIndexedValue(SPECIAL_REFS[ref]);\n        if (result.type === 1 /* Indexed */ ) {\n            return result.value;\n        }\n        return {\n            t: 26 /* SpecialReference */ ,\n            i: result.value,\n            s: ref,\n            l: void 0,\n            c: void 0,\n            m: void 0,\n            p: void 0,\n            e: void 0,\n            a: void 0,\n            f: void 0,\n            b: void 0,\n            o: void 0\n        };\n    }\n    parseIteratorFactory() {\n        const result = this.getIndexedValue(ITERATOR);\n        if (result.type === 1 /* Indexed */ ) {\n            return result.value;\n        }\n        return {\n            t: 27 /* IteratorFactory */ ,\n            i: result.value,\n            s: void 0,\n            l: void 0,\n            c: void 0,\n            m: void 0,\n            p: void 0,\n            e: void 0,\n            a: void 0,\n            f: this.parseWellKnownSymbol(Symbol.iterator),\n            b: void 0,\n            o: void 0\n        };\n    }\n    parseAsyncIteratorFactory() {\n        const result = this.getIndexedValue(ASYNC_ITERATOR);\n        if (result.type === 1 /* Indexed */ ) {\n            return result.value;\n        }\n        return {\n            t: 29 /* AsyncIteratorFactory */ ,\n            i: result.value,\n            s: void 0,\n            l: void 0,\n            c: void 0,\n            m: void 0,\n            p: void 0,\n            e: void 0,\n            a: [\n                this.parseSpecialReference(1 /* PromiseConstructor */ ),\n                this.parseWellKnownSymbol(Symbol.asyncIterator)\n            ],\n            f: void 0,\n            b: void 0,\n            o: void 0\n        };\n    }\n    createObjectNode(id, current, empty, record) {\n        return {\n            t: empty ? 11 /* NullConstructor */  : 10 /* Object */ ,\n            i: id,\n            s: void 0,\n            l: void 0,\n            c: void 0,\n            m: void 0,\n            p: record,\n            e: void 0,\n            a: void 0,\n            f: void 0,\n            b: void 0,\n            o: getObjectFlag(current)\n        };\n    }\n    createMapNode(id, k, v, s) {\n        return {\n            t: 8 /* Map */ ,\n            i: id,\n            s: void 0,\n            l: void 0,\n            c: void 0,\n            m: void 0,\n            p: void 0,\n            e: {\n                k,\n                v,\n                s\n            },\n            a: void 0,\n            f: this.parseSpecialReference(0 /* MapSentinel */ ),\n            b: void 0,\n            o: void 0\n        };\n    }\n    createPromiseConstructorNode(id) {\n        return {\n            t: 22 /* PromiseConstructor */ ,\n            i: id,\n            s: void 0,\n            l: void 0,\n            c: void 0,\n            m: void 0,\n            p: void 0,\n            e: void 0,\n            a: void 0,\n            f: this.parseSpecialReference(1 /* PromiseConstructor */ ),\n            b: void 0,\n            o: void 0\n        };\n    }\n};\n// src/core/utils/promise-to-result.ts\nasync function promiseToResult(current) {\n    try {\n        return [\n            1,\n            await current\n        ];\n    } catch (e) {\n        return [\n            0,\n            e\n        ];\n    }\n}\n// src/core/utils/deferred.ts\nfunction createDeferred() {\n    let resolve;\n    let reject;\n    return {\n        promise: new Promise((res, rej)=>{\n            resolve = res;\n            reject = rej;\n        }),\n        resolve (value) {\n            resolve(value);\n        },\n        reject (value) {\n            reject(value);\n        }\n    };\n}\n// src/core/stream.ts\nfunction isStream(value) {\n    return \"__SEROVAL_STREAM__\" in value;\n}\nfunction createStream() {\n    const listeners = /* @__PURE__ */ new Set();\n    const buffer = [];\n    let alive = true;\n    let success = false;\n    function flushNext(value) {\n        for (const listener of listeners.keys()){\n            listener.next(value);\n        }\n    }\n    function flushThrow(value) {\n        for (const listener of listeners.keys()){\n            listener.throw(value);\n        }\n    }\n    function flushReturn(value) {\n        for (const listener of listeners.keys()){\n            listener.return(value);\n        }\n    }\n    return {\n        __SEROVAL_STREAM__: true,\n        on (listener) {\n            if (alive) {\n                listeners.add(listener);\n            }\n            for(let i = 0, len = buffer.length; i < len; i++){\n                const value = buffer[i];\n                if (i === len - 1) {\n                    if (success) {\n                        listener.return(value);\n                    } else {\n                        listener.throw(value);\n                    }\n                } else {\n                    listener.next(value);\n                }\n            }\n            return ()=>{\n                if (alive) {\n                    listeners.delete(listener);\n                }\n            };\n        },\n        next (value) {\n            if (alive) {\n                buffer.push(value);\n                flushNext(value);\n            }\n        },\n        throw (value) {\n            if (alive) {\n                buffer.push(value);\n                flushThrow(value);\n                alive = false;\n                success = false;\n                listeners.clear();\n            }\n        },\n        return (value) {\n            if (alive) {\n                buffer.push(value);\n                flushReturn(value);\n                alive = false;\n                success = true;\n                listeners.clear();\n            }\n        }\n    };\n}\nfunction createStreamFromAsyncIterable(iterable) {\n    const stream = createStream();\n    const iterator = iterable[Symbol.asyncIterator]();\n    async function push() {\n        try {\n            const value = await iterator.next();\n            if (value.done) {\n                stream.return(value.value);\n            } else {\n                stream.next(value.value);\n                await push();\n            }\n        } catch (error) {\n            stream.throw(error);\n        }\n    }\n    push().catch(()=>{});\n    return stream;\n}\nfunction streamToAsyncIterable(stream) {\n    return ()=>{\n        const buffer = [];\n        const pending = [];\n        let count = 0;\n        let doneAt = -1;\n        let isThrow = false;\n        function resolveAll() {\n            for(let i = 0, len = pending.length; i < len; i++){\n                pending[i].resolve({\n                    done: true,\n                    value: void 0\n                });\n            }\n        }\n        stream.on({\n            next (value) {\n                const current = pending.shift();\n                if (current) {\n                    current.resolve({\n                        done: false,\n                        value\n                    });\n                }\n                buffer.push(value);\n            },\n            throw (value) {\n                const current = pending.shift();\n                if (current) {\n                    current.reject(value);\n                }\n                resolveAll();\n                doneAt = buffer.length;\n                buffer.push(value);\n                isThrow = true;\n            },\n            return (value) {\n                const current = pending.shift();\n                if (current) {\n                    current.resolve({\n                        done: true,\n                        value\n                    });\n                }\n                resolveAll();\n                doneAt = buffer.length;\n                buffer.push(value);\n            }\n        });\n        function finalize() {\n            const current = count++;\n            const value = buffer[current];\n            if (current !== doneAt) {\n                return {\n                    done: false,\n                    value\n                };\n            }\n            if (isThrow) {\n                throw value;\n            }\n            return {\n                done: true,\n                value\n            };\n        }\n        return {\n            [Symbol.asyncIterator] () {\n                return this;\n            },\n            async next () {\n                if (doneAt === -1) {\n                    const current = count++;\n                    if (current >= buffer.length) {\n                        const deferred = createDeferred();\n                        pending.push(deferred);\n                        return await deferred.promise;\n                    }\n                    return {\n                        done: false,\n                        value: buffer[current]\n                    };\n                }\n                if (count > doneAt) {\n                    return {\n                        done: true,\n                        value: void 0\n                    };\n                }\n                return finalize();\n            }\n        };\n    };\n}\n// src/core/context/parser/async.ts\nvar BaseAsyncParserContext = class extends BaseParserContext {\n    async parseItems(current) {\n        const nodes = [];\n        for(let i = 0, len = current.length; i < len; i++){\n            if (i in current) {\n                nodes[i] = await this.parse(current[i]);\n            }\n        }\n        return nodes;\n    }\n    async parseArray(id, current) {\n        return createArrayNode(id, current, await this.parseItems(current));\n    }\n    async parseProperties(properties) {\n        const entries = Object.entries(properties);\n        const keyNodes = [];\n        const valueNodes = [];\n        for(let i = 0, len = entries.length; i < len; i++){\n            keyNodes.push(serializeString(entries[i][0]));\n            valueNodes.push(await this.parse(entries[i][1]));\n        }\n        let symbol = Symbol.iterator;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createIteratorFactoryInstanceNode(this.parseIteratorFactory(), await this.parse(iteratorToSequence(properties))));\n        }\n        symbol = Symbol.asyncIterator;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createAsyncIteratorFactoryInstanceNode(this.parseAsyncIteratorFactory(), await this.parse(createStreamFromAsyncIterable(properties))));\n        }\n        symbol = Symbol.toStringTag;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createStringNode(properties[symbol]));\n        }\n        symbol = Symbol.isConcatSpreadable;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n        }\n        return {\n            k: keyNodes,\n            v: valueNodes,\n            s: keyNodes.length\n        };\n    }\n    async parsePlainObject(id, current, empty) {\n        return this.createObjectNode(id, current, empty, await this.parseProperties(current));\n    }\n    async parseBoxed(id, current) {\n        return createBoxedNode(id, await this.parse(current.valueOf()));\n    }\n    async parseTypedArray(id, current) {\n        return createTypedArrayNode(id, current, await this.parse(current.buffer));\n    }\n    async parseBigIntTypedArray(id, current) {\n        return createBigIntTypedArrayNode(id, current, await this.parse(current.buffer));\n    }\n    async parseDataView(id, current) {\n        return createDataViewNode(id, current, await this.parse(current.buffer));\n    }\n    async parseError(id, current) {\n        const options = getErrorOptions(current, this.features);\n        return createErrorNode(id, current, options ? await this.parseProperties(options) : void 0);\n    }\n    async parseAggregateError(id, current) {\n        const options = getErrorOptions(current, this.features);\n        return createAggregateErrorNode(id, current, options ? await this.parseProperties(options) : void 0);\n    }\n    async parseMap(id, current) {\n        const keyNodes = [];\n        const valueNodes = [];\n        for (const [key, value] of current.entries()){\n            keyNodes.push(await this.parse(key));\n            valueNodes.push(await this.parse(value));\n        }\n        return this.createMapNode(id, keyNodes, valueNodes, current.size);\n    }\n    async parseSet(id, current) {\n        const items = [];\n        for (const item of current.keys()){\n            items.push(await this.parse(item));\n        }\n        return createSetNode(id, current.size, items);\n    }\n    async parsePromise(id, current) {\n        const [status, result] = await promiseToResult(current);\n        return {\n            t: 12 /* Promise */ ,\n            i: id,\n            s: status,\n            l: void 0,\n            c: void 0,\n            m: void 0,\n            p: void 0,\n            e: void 0,\n            a: void 0,\n            f: await this.parse(result),\n            b: void 0,\n            o: void 0\n        };\n    }\n    async parsePlugin(id, current) {\n        const currentPlugins = this.plugins;\n        if (currentPlugins) {\n            for(let i = 0, len = currentPlugins.length; i < len; i++){\n                const plugin = currentPlugins[i];\n                if (plugin.parse.async && plugin.test(current)) {\n                    return createPluginNode(id, plugin.tag, await plugin.parse.async(current, this, {\n                        id\n                    }));\n                }\n            }\n        }\n        return void 0;\n    }\n    async parseStream(id, current) {\n        return createStreamConstructorNode(id, this.parseSpecialReference(4 /* StreamConstructor */ ), await new Promise((resolve, reject)=>{\n            const sequence = [];\n            const cleanup = current.on({\n                next: (value)=>{\n                    this.markRef(id);\n                    this.parse(value).then((data)=>{\n                        sequence.push(createStreamNextNode(id, data));\n                    }, (data)=>{\n                        reject(data);\n                        cleanup();\n                    });\n                },\n                throw: (value)=>{\n                    this.markRef(id);\n                    this.parse(value).then((data)=>{\n                        sequence.push(createStreamThrowNode(id, data));\n                        resolve(sequence);\n                        cleanup();\n                    }, (data)=>{\n                        reject(data);\n                        cleanup();\n                    });\n                },\n                return: (value)=>{\n                    this.markRef(id);\n                    this.parse(value).then((data)=>{\n                        sequence.push(createStreamReturnNode(id, data));\n                        resolve(sequence);\n                        cleanup();\n                    }, (data)=>{\n                        reject(data);\n                        cleanup();\n                    });\n                }\n            });\n        }));\n    }\n    async parseObject(id, current) {\n        if (Array.isArray(current)) {\n            return this.parseArray(id, current);\n        }\n        if (isStream(current)) {\n            return this.parseStream(id, current);\n        }\n        const parsed = await this.parsePlugin(id, current);\n        if (parsed) {\n            return parsed;\n        }\n        const currentClass = current.constructor;\n        switch(currentClass){\n            case Object:\n                return this.parsePlainObject(id, current, false);\n            case void 0:\n                return this.parsePlainObject(id, current, true);\n            case Date:\n                return createDateNode(id, current);\n            case RegExp:\n                return createRegExpNode(id, current);\n            case Error:\n            case EvalError:\n            case RangeError:\n            case ReferenceError:\n            case SyntaxError:\n            case TypeError:\n            case URIError:\n                return this.parseError(id, current);\n            case Number:\n            case Boolean:\n            case String:\n            case BigInt:\n                return this.parseBoxed(id, current);\n            case ArrayBuffer:\n                return createArrayBufferNode(id, current);\n            case Int8Array:\n            case Int16Array:\n            case Int32Array:\n            case Uint8Array:\n            case Uint16Array:\n            case Uint32Array:\n            case Uint8ClampedArray:\n            case Float32Array:\n            case Float64Array:\n                return this.parseTypedArray(id, current);\n            case DataView:\n                return this.parseDataView(id, current);\n            case Map:\n                return this.parseMap(id, current);\n            case Set:\n                return this.parseSet(id, current);\n            default:\n                break;\n        }\n        if (currentClass === Promise || current instanceof Promise) {\n            return this.parsePromise(id, current);\n        }\n        const currentFeatures = this.features;\n        if (currentFeatures & 16 /* BigIntTypedArray */ ) {\n            switch(currentClass){\n                case BigInt64Array:\n                case BigUint64Array:\n                    return this.parseBigIntTypedArray(id, current);\n                default:\n                    break;\n            }\n        }\n        if (currentFeatures & 1 /* AggregateError */  && typeof AggregateError !== \"undefined\" && (currentClass === AggregateError || current instanceof AggregateError)) {\n            return this.parseAggregateError(id, current);\n        }\n        if (current instanceof Error) {\n            return this.parseError(id, current);\n        }\n        if (Symbol.iterator in current || Symbol.asyncIterator in current) {\n            return this.parsePlainObject(id, current, !!currentClass);\n        }\n        throw new SerovalUnsupportedTypeError(current);\n    }\n    async parse(current) {\n        try {\n            switch(typeof current){\n                case \"boolean\":\n                    return current ? TRUE_NODE : FALSE_NODE;\n                case \"undefined\":\n                    return UNDEFINED_NODE;\n                case \"string\":\n                    return createStringNode(current);\n                case \"number\":\n                    return createNumberNode(current);\n                case \"bigint\":\n                    return createBigIntNode(current);\n                case \"object\":\n                    {\n                        if (current) {\n                            const ref = this.getReference(current);\n                            return ref.type === 0 ? await this.parseObject(ref.value, current) : ref.value;\n                        }\n                        return NULL_NODE;\n                    }\n                case \"symbol\":\n                    return this.parseWellKnownSymbol(current);\n                case \"function\":\n                    return this.parseFunction(current);\n                default:\n                    throw new SerovalUnsupportedTypeError(current);\n            }\n        } catch (error) {\n            throw new SerovalParserError(error);\n        }\n    }\n};\n// src/core/tree/async.ts\nvar AsyncParserContext = class extends BaseAsyncParserContext {\n    constructor(){\n        super(...arguments);\n        this.mode = \"vanilla\";\n    }\n};\n// src/core/utils/typed-array.ts\nfunction getTypedArrayConstructor(name) {\n    switch(name){\n        case \"Int8Array\":\n            return Int8Array;\n        case \"Int16Array\":\n            return Int16Array;\n        case \"Int32Array\":\n            return Int32Array;\n        case \"Uint8Array\":\n            return Uint8Array;\n        case \"Uint16Array\":\n            return Uint16Array;\n        case \"Uint32Array\":\n            return Uint32Array;\n        case \"Uint8ClampedArray\":\n            return Uint8ClampedArray;\n        case \"Float32Array\":\n            return Float32Array;\n        case \"Float64Array\":\n            return Float64Array;\n        case \"BigInt64Array\":\n            return BigInt64Array;\n        case \"BigUint64Array\":\n            return BigUint64Array;\n        default:\n            throw new SerovalUnknownTypedArrayError(name);\n    }\n}\n// src/core/context/deserializer.ts\nfunction applyObjectFlag(obj, flag) {\n    switch(flag){\n        case 3 /* Frozen */ :\n            return Object.freeze(obj);\n        case 1 /* NonExtensible */ :\n            return Object.preventExtensions(obj);\n        case 2 /* Sealed */ :\n            return Object.seal(obj);\n        default:\n            return obj;\n    }\n}\nvar BaseDeserializerContext = class {\n    constructor(options){\n        this.plugins = options.plugins;\n        this.refs = options.refs || /* @__PURE__ */ new Map();\n    }\n    deserializeReference(node) {\n        return this.assignIndexedValue(node.i, getReference(deserializeString(node.s)));\n    }\n    deserializeArray(node) {\n        const len = node.l;\n        const result = this.assignIndexedValue(node.i, new Array(len));\n        let item;\n        for(let i = 0; i < len; i++){\n            item = node.a[i];\n            if (item) {\n                result[i] = this.deserialize(item);\n            }\n        }\n        applyObjectFlag(result, node.o);\n        return result;\n    }\n    deserializeProperties(node, result) {\n        const len = node.s;\n        if (len) {\n            const keys = node.k;\n            const vals = node.v;\n            for(let i = 0, key; i < len; i++){\n                key = keys[i];\n                if (typeof key === \"string\") {\n                    result[deserializeString(key)] = this.deserialize(vals[i]);\n                } else {\n                    result[this.deserialize(key)] = this.deserialize(vals[i]);\n                }\n            }\n        }\n        return result;\n    }\n    deserializeObject(node) {\n        const result = this.assignIndexedValue(node.i, node.t === 10 /* Object */  ? {} : /* @__PURE__ */ Object.create(null));\n        this.deserializeProperties(node.p, result);\n        applyObjectFlag(result, node.o);\n        return result;\n    }\n    deserializeDate(node) {\n        return this.assignIndexedValue(node.i, new Date(node.s));\n    }\n    deserializeRegExp(node) {\n        return this.assignIndexedValue(node.i, new RegExp(deserializeString(node.c), node.m));\n    }\n    deserializeSet(node) {\n        const result = this.assignIndexedValue(node.i, /* @__PURE__ */ new Set());\n        const items = node.a;\n        for(let i = 0, len = node.l; i < len; i++){\n            result.add(this.deserialize(items[i]));\n        }\n        return result;\n    }\n    deserializeMap(node) {\n        const result = this.assignIndexedValue(node.i, /* @__PURE__ */ new Map());\n        const keys = node.e.k;\n        const vals = node.e.v;\n        for(let i = 0, len = node.e.s; i < len; i++){\n            result.set(this.deserialize(keys[i]), this.deserialize(vals[i]));\n        }\n        return result;\n    }\n    deserializeArrayBuffer(node) {\n        const bytes = new Uint8Array(node.s);\n        const result = this.assignIndexedValue(node.i, bytes.buffer);\n        return result;\n    }\n    deserializeTypedArray(node) {\n        const construct = getTypedArrayConstructor(node.c);\n        const source = this.deserialize(node.f);\n        const result = this.assignIndexedValue(node.i, new construct(source, node.b, node.l));\n        return result;\n    }\n    deserializeDataView(node) {\n        const source = this.deserialize(node.f);\n        const result = this.assignIndexedValue(node.i, new DataView(source, node.b, node.l));\n        return result;\n    }\n    deserializeDictionary(node, result) {\n        if (node.p) {\n            const fields = this.deserializeProperties(node.p, {});\n            Object.assign(result, fields);\n        }\n        return result;\n    }\n    deserializeAggregateError(node) {\n        const result = this.assignIndexedValue(node.i, new AggregateError([], deserializeString(node.m)));\n        return this.deserializeDictionary(node, result);\n    }\n    deserializeError(node) {\n        const construct = ERROR_CONSTRUCTOR[node.s];\n        const result = this.assignIndexedValue(node.i, new construct(deserializeString(node.m)));\n        return this.deserializeDictionary(node, result);\n    }\n    deserializePromise(node) {\n        const deferred = createDeferred();\n        const result = this.assignIndexedValue(node.i, deferred);\n        const deserialized = this.deserialize(node.f);\n        if (node.s) {\n            deferred.resolve(deserialized);\n        } else {\n            deferred.reject(deserialized);\n        }\n        return result.promise;\n    }\n    deserializeBoxed(node) {\n        return this.assignIndexedValue(node.i, Object(this.deserialize(node.f)));\n    }\n    deserializePlugin(node) {\n        const currentPlugins = this.plugins;\n        if (currentPlugins) {\n            const tag = deserializeString(node.c);\n            for(let i = 0, len = currentPlugins.length; i < len; i++){\n                const plugin = currentPlugins[i];\n                if (plugin.tag === tag) {\n                    return this.assignIndexedValue(node.i, plugin.deserialize(node.s, this, {\n                        id: node.i\n                    }));\n                }\n            }\n        }\n        throw new SerovalMissingPluginError(node.c);\n    }\n    deserializePromiseConstructor(node) {\n        return this.assignIndexedValue(node.i, createDeferred()).promise;\n    }\n    deserializePromiseResolve(node) {\n        const deferred = this.refs.get(node.i);\n        assert(deferred, new SerovalMissingInstanceError(\"Promise\"));\n        deferred.resolve(this.deserialize(node.a[1]));\n        return void 0;\n    }\n    deserializePromiseReject(node) {\n        const deferred = this.refs.get(node.i);\n        assert(deferred, new SerovalMissingInstanceError(\"Promise\"));\n        deferred.reject(this.deserialize(node.a[1]));\n        return void 0;\n    }\n    deserializeIteratorFactoryInstance(node) {\n        this.deserialize(node.a[0]);\n        const source = this.deserialize(node.a[1]);\n        return sequenceToIterator(source);\n    }\n    deserializeAsyncIteratorFactoryInstance(node) {\n        this.deserialize(node.a[0]);\n        const source = this.deserialize(node.a[1]);\n        return streamToAsyncIterable(source);\n    }\n    deserializeStreamConstructor(node) {\n        const result = this.assignIndexedValue(node.i, createStream());\n        const len = node.a.length;\n        if (len) {\n            for(let i = 0; i < len; i++){\n                this.deserialize(node.a[i]);\n            }\n        }\n        return result;\n    }\n    deserializeStreamNext(node) {\n        const deferred = this.refs.get(node.i);\n        assert(deferred, new SerovalMissingInstanceError(\"Stream\"));\n        deferred.next(this.deserialize(node.f));\n        return void 0;\n    }\n    deserializeStreamThrow(node) {\n        const deferred = this.refs.get(node.i);\n        assert(deferred, new SerovalMissingInstanceError(\"Stream\"));\n        deferred.throw(this.deserialize(node.f));\n        return void 0;\n    }\n    deserializeStreamReturn(node) {\n        const deferred = this.refs.get(node.i);\n        assert(deferred, new SerovalMissingInstanceError(\"Stream\"));\n        deferred.return(this.deserialize(node.f));\n        return void 0;\n    }\n    deserializeIteratorFactory(node) {\n        this.deserialize(node.f);\n        return void 0;\n    }\n    deserializeAsyncIteratorFactory(node) {\n        this.deserialize(node.a[1]);\n        return void 0;\n    }\n    deserialize(node) {\n        try {\n            switch(node.t){\n                case 2 /* Constant */ :\n                    return CONSTANT_VAL[node.s];\n                case 0 /* Number */ :\n                    return node.s;\n                case 1 /* String */ :\n                    return deserializeString(node.s);\n                case 3 /* BigInt */ :\n                    return BigInt(node.s);\n                case 4 /* IndexedValue */ :\n                    return this.refs.get(node.i);\n                case 18 /* Reference */ :\n                    return this.deserializeReference(node);\n                case 9 /* Array */ :\n                    return this.deserializeArray(node);\n                case 10 /* Object */ :\n                case 11 /* NullConstructor */ :\n                    return this.deserializeObject(node);\n                case 5 /* Date */ :\n                    return this.deserializeDate(node);\n                case 6 /* RegExp */ :\n                    return this.deserializeRegExp(node);\n                case 7 /* Set */ :\n                    return this.deserializeSet(node);\n                case 8 /* Map */ :\n                    return this.deserializeMap(node);\n                case 19 /* ArrayBuffer */ :\n                    return this.deserializeArrayBuffer(node);\n                case 16 /* BigIntTypedArray */ :\n                case 15 /* TypedArray */ :\n                    return this.deserializeTypedArray(node);\n                case 20 /* DataView */ :\n                    return this.deserializeDataView(node);\n                case 14 /* AggregateError */ :\n                    return this.deserializeAggregateError(node);\n                case 13 /* Error */ :\n                    return this.deserializeError(node);\n                case 12 /* Promise */ :\n                    return this.deserializePromise(node);\n                case 17 /* WKSymbol */ :\n                    return SYMBOL_REF[node.s];\n                case 21 /* Boxed */ :\n                    return this.deserializeBoxed(node);\n                case 25 /* Plugin */ :\n                    return this.deserializePlugin(node);\n                case 22 /* PromiseConstructor */ :\n                    return this.deserializePromiseConstructor(node);\n                case 23 /* PromiseResolve */ :\n                    return this.deserializePromiseResolve(node);\n                case 24 /* PromiseReject */ :\n                    return this.deserializePromiseReject(node);\n                case 28 /* IteratorFactoryInstance */ :\n                    return this.deserializeIteratorFactoryInstance(node);\n                case 30 /* AsyncIteratorFactoryInstance */ :\n                    return this.deserializeAsyncIteratorFactoryInstance(node);\n                case 31 /* StreamConstructor */ :\n                    return this.deserializeStreamConstructor(node);\n                case 32 /* StreamNext */ :\n                    return this.deserializeStreamNext(node);\n                case 33 /* StreamThrow */ :\n                    return this.deserializeStreamThrow(node);\n                case 34 /* StreamReturn */ :\n                    return this.deserializeStreamReturn(node);\n                case 27 /* IteratorFactory */ :\n                    return this.deserializeIteratorFactory(node);\n                case 29 /* AsyncIteratorFactory */ :\n                    return this.deserializeAsyncIteratorFactory(node);\n                default:\n                    throw new SerovalUnsupportedNodeError(node);\n            }\n        } catch (error) {\n            throw new SerovalDeserializationError(error);\n        }\n    }\n};\n// src/core/tree/deserializer.ts\nvar VanillaDeserializerContext = class extends BaseDeserializerContext {\n    constructor(options){\n        super(options);\n        this.mode = \"vanilla\";\n        this.marked = new Set(options.markedRefs);\n    }\n    assignIndexedValue(index, value) {\n        if (this.marked.has(index)) {\n            this.refs.set(index, value);\n        }\n        return value;\n    }\n};\n// src/core/utils/is-valid-identifier.ts\nvar IDENTIFIER_CHECK = /^[$A-Z_][0-9A-Z_$]*$/i;\nfunction isValidIdentifier(name) {\n    const char = name[0];\n    return (char === \"$\" || char === \"_\" || char >= \"A\" && char <= \"Z\" || char >= \"a\" && char <= \"z\") && IDENTIFIER_CHECK.test(name);\n}\n// src/core/context/serializer.ts\nfunction getAssignmentExpression(assignment) {\n    switch(assignment.t){\n        case 0 /* Index */ :\n            return assignment.s + \"=\" + assignment.v;\n        case 2 /* Set */ :\n            return assignment.s + \".set(\" + assignment.k + \",\" + assignment.v + \")\";\n        case 1 /* Add */ :\n            return assignment.s + \".add(\" + assignment.v + \")\";\n        case 3 /* Delete */ :\n            return assignment.s + \".delete(\" + assignment.k + \")\";\n    }\n}\nfunction mergeAssignments(assignments) {\n    const newAssignments = [];\n    let current = assignments[0];\n    for(let i = 1, len = assignments.length, item, prev = current; i < len; i++){\n        item = assignments[i];\n        if (item.t === 0 /* Index */  && item.v === prev.v) {\n            current = {\n                t: 0 /* Index */ ,\n                s: item.s,\n                k: void 0,\n                v: getAssignmentExpression(current)\n            };\n        } else if (item.t === 2 /* Set */  && item.s === prev.s) {\n            current = {\n                t: 2 /* Set */ ,\n                s: getAssignmentExpression(current),\n                k: item.k,\n                v: item.v\n            };\n        } else if (item.t === 1 /* Add */  && item.s === prev.s) {\n            current = {\n                t: 1 /* Add */ ,\n                s: getAssignmentExpression(current),\n                k: void 0,\n                v: item.v\n            };\n        } else if (item.t === 3 /* Delete */  && item.s === prev.s) {\n            current = {\n                t: 3 /* Delete */ ,\n                s: getAssignmentExpression(current),\n                k: item.k,\n                v: void 0\n            };\n        } else {\n            newAssignments.push(current);\n            current = item;\n        }\n        prev = item;\n    }\n    newAssignments.push(current);\n    return newAssignments;\n}\nfunction resolveAssignments(assignments) {\n    if (assignments.length) {\n        let result = \"\";\n        const merged = mergeAssignments(assignments);\n        for(let i = 0, len = merged.length; i < len; i++){\n            result += getAssignmentExpression(merged[i]) + \",\";\n        }\n        return result;\n    }\n    return void 0;\n}\nvar NULL_CONSTRUCTOR = \"Object.create(null)\";\nvar SET_CONSTRUCTOR = \"new Set\";\nvar MAP_CONSTRUCTOR = \"new Map\";\nvar PROMISE_RESOLVE = \"Promise.resolve\";\nvar PROMISE_REJECT = \"Promise.reject\";\nvar OBJECT_FLAG_CONSTRUCTOR = {\n    [3 /* Frozen */ ]: \"Object.freeze\",\n    [2 /* Sealed */ ]: \"Object.seal\",\n    [1 /* NonExtensible */ ]: \"Object.preventExtensions\",\n    [0 /* None */ ]: void 0\n};\nvar BaseSerializerContext = class {\n    constructor(options){\n        /**\n     * To check if an object is synchronously referencing itself\n     * @private\n     */ this.stack = [];\n        /**\n     * Array of object mutations\n     * @private\n     */ this.flags = [];\n        /**\n     * Array of assignments to be done (used for recursion)\n     * @private\n     */ this.assignments = [];\n        this.plugins = options.plugins;\n        this.features = options.features;\n        this.marked = new Set(options.markedRefs);\n    }\n    createFunction(parameters, body) {\n        if (this.features & 2 /* ArrowFunction */ ) {\n            const joined = parameters.length === 1 ? parameters[0] : \"(\" + parameters.join(\",\") + \")\";\n            return joined + \"=>\" + body;\n        }\n        return \"function(\" + parameters.join(\",\") + \"){return \" + body + \"}\";\n    }\n    createEffectfulFunction(parameters, body) {\n        if (this.features & 2 /* ArrowFunction */ ) {\n            const joined = parameters.length === 1 ? parameters[0] : \"(\" + parameters.join(\",\") + \")\";\n            return joined + \"=>{\" + body + \"}\";\n        }\n        return \"function(\" + parameters.join(\",\") + \"){\" + body + \"}\";\n    }\n    /**\n   * A tiny function that tells if a reference\n   * is to be accessed. This is a requirement for\n   * deciding whether or not we should generate\n   * an identifier for the object\n   */ markRef(id) {\n        this.marked.add(id);\n    }\n    isMarked(id) {\n        return this.marked.has(id);\n    }\n    pushObjectFlag(flag, id) {\n        if (flag !== 0 /* None */ ) {\n            this.markRef(id);\n            this.flags.push({\n                type: flag,\n                value: this.getRefParam(id)\n            });\n        }\n    }\n    resolveFlags() {\n        let result = \"\";\n        for(let i = 0, current = this.flags, len = current.length; i < len; i++){\n            const flag = current[i];\n            result += OBJECT_FLAG_CONSTRUCTOR[flag.type] + \"(\" + flag.value + \"),\";\n        }\n        return result;\n    }\n    resolvePatches() {\n        const assignments = resolveAssignments(this.assignments);\n        const flags = this.resolveFlags();\n        if (assignments) {\n            if (flags) {\n                return assignments + flags;\n            }\n            return assignments;\n        }\n        return flags;\n    }\n    /**\n   * Generates the inlined assignment for the reference\n   * This is different from the assignments array as this one\n   * signifies creation rather than mutation\n   */ createAssignment(source, value) {\n        this.assignments.push({\n            t: 0 /* Index */ ,\n            s: source,\n            k: void 0,\n            v: value\n        });\n    }\n    createAddAssignment(ref, value) {\n        this.assignments.push({\n            t: 1 /* Add */ ,\n            s: this.getRefParam(ref),\n            k: void 0,\n            v: value\n        });\n    }\n    createSetAssignment(ref, key, value) {\n        this.assignments.push({\n            t: 2 /* Set */ ,\n            s: this.getRefParam(ref),\n            k: key,\n            v: value\n        });\n    }\n    createDeleteAssignment(ref, key) {\n        this.assignments.push({\n            t: 3 /* Delete */ ,\n            s: this.getRefParam(ref),\n            k: key,\n            v: void 0\n        });\n    }\n    createArrayAssign(ref, index, value) {\n        this.createAssignment(this.getRefParam(ref) + \"[\" + index + \"]\", value);\n    }\n    createObjectAssign(ref, key, value) {\n        this.createAssignment(this.getRefParam(ref) + \".\" + key, value);\n    }\n    /**\n   * Checks if the value is in the stack. Stack here is a reference\n   * structure to know if a object is to be accessed in a TDZ.\n   */ isIndexedValueInStack(node) {\n        return node.t === 4 /* IndexedValue */  && this.stack.includes(node.i);\n    }\n    serializeReference(node) {\n        return this.assignIndexedValue(node.i, REFERENCES_KEY + '.get(\"' + node.s + '\")');\n    }\n    serializeArrayItem(id, item, index) {\n        if (item) {\n            if (this.isIndexedValueInStack(item)) {\n                this.markRef(id);\n                this.createArrayAssign(id, index, this.getRefParam(item.i));\n                return \"\";\n            }\n            return this.serialize(item);\n        }\n        return \"\";\n    }\n    serializeArray(node) {\n        const id = node.i;\n        if (node.l) {\n            this.stack.push(id);\n            const list = node.a;\n            let values = this.serializeArrayItem(id, list[0], 0);\n            let isHoley = values === \"\";\n            for(let i = 1, len = node.l, item; i < len; i++){\n                item = this.serializeArrayItem(id, list[i], i);\n                values += \",\" + item;\n                isHoley = item === \"\";\n            }\n            this.stack.pop();\n            this.pushObjectFlag(node.o, node.i);\n            return this.assignIndexedValue(id, \"[\" + values + (isHoley ? \",]\" : \"]\"));\n        }\n        return this.assignIndexedValue(id, \"[]\");\n    }\n    serializeProperty(source, key, val) {\n        if (typeof key === \"string\") {\n            const check = Number(key);\n            const isIdentifier = // Test if key is a valid positive number or JS identifier\n            // so that we don't have to serialize the key and wrap with brackets\n            check >= 0 && // It's also important to consider that if the key is\n            // indeed numeric, we need to make sure that when\n            // converted back into a string, it's still the same\n            // to the original key. This allows us to differentiate\n            // keys that has numeric formats but in a different\n            // format, which can cause unintentional key declaration\n            // Example: { 0x1: 1 } vs { '0x1': 1 }\n            check.toString() === key || isValidIdentifier(key);\n            if (this.isIndexedValueInStack(val)) {\n                const refParam = this.getRefParam(val.i);\n                this.markRef(source.i);\n                if (isIdentifier && check !== check) {\n                    this.createObjectAssign(source.i, key, refParam);\n                } else {\n                    this.createArrayAssign(source.i, isIdentifier ? key : '\"' + key + '\"', refParam);\n                }\n                return \"\";\n            }\n            return (isIdentifier ? key : '\"' + key + '\"') + \":\" + this.serialize(val);\n        }\n        return \"[\" + this.serialize(key) + \"]:\" + this.serialize(val);\n    }\n    serializeProperties(source, record) {\n        const len = record.s;\n        if (len) {\n            const keys = record.k;\n            const values = record.v;\n            this.stack.push(source.i);\n            let result = this.serializeProperty(source, keys[0], values[0]);\n            for(let i = 1, item = result; i < len; i++){\n                item = this.serializeProperty(source, keys[i], values[i]);\n                result += (item && result && \",\") + item;\n            }\n            this.stack.pop();\n            return \"{\" + result + \"}\";\n        }\n        return \"{}\";\n    }\n    serializeObject(node) {\n        this.pushObjectFlag(node.o, node.i);\n        return this.assignIndexedValue(node.i, this.serializeProperties(node, node.p));\n    }\n    serializeWithObjectAssign(source, value, serialized) {\n        const fields = this.serializeProperties(source, value);\n        if (fields !== \"{}\") {\n            return \"Object.assign(\" + serialized + \",\" + fields + \")\";\n        }\n        return serialized;\n    }\n    serializeStringKeyAssignment(source, mainAssignments, key, value) {\n        const serialized = this.serialize(value);\n        const check = Number(key);\n        const isIdentifier = // Test if key is a valid positive number or JS identifier\n        // so that we don't have to serialize the key and wrap with brackets\n        check >= 0 && // It's also important to consider that if the key is\n        // indeed numeric, we need to make sure that when\n        // converted back into a string, it's still the same\n        // to the original key. This allows us to differentiate\n        // keys that has numeric formats but in a different\n        // format, which can cause unintentional key declaration\n        // Example: { 0x1: 1 } vs { '0x1': 1 }\n        check.toString() === key || isValidIdentifier(key);\n        if (this.isIndexedValueInStack(value)) {\n            if (isIdentifier && check !== check) {\n                this.createObjectAssign(source.i, key, serialized);\n            } else {\n                this.createArrayAssign(source.i, isIdentifier ? key : '\"' + key + '\"', serialized);\n            }\n        } else {\n            const parentAssignment = this.assignments;\n            this.assignments = mainAssignments;\n            if (isIdentifier && check !== check) {\n                this.createObjectAssign(source.i, key, serialized);\n            } else {\n                this.createArrayAssign(source.i, isIdentifier ? key : '\"' + key + '\"', serialized);\n            }\n            this.assignments = parentAssignment;\n        }\n    }\n    serializeAssignment(source, mainAssignments, key, value) {\n        if (typeof key === \"string\") {\n            this.serializeStringKeyAssignment(source, mainAssignments, key, value);\n        } else {\n            const parent = this.stack;\n            this.stack = [];\n            const serialized = this.serialize(value);\n            this.stack = parent;\n            const parentAssignment = this.assignments;\n            this.assignments = mainAssignments;\n            this.createArrayAssign(source.i, this.serialize(key), serialized);\n            this.assignments = parentAssignment;\n        }\n    }\n    serializeAssignments(source, node) {\n        const len = node.s;\n        if (len) {\n            const mainAssignments = [];\n            const keys = node.k;\n            const values = node.v;\n            this.stack.push(source.i);\n            for(let i = 0; i < len; i++){\n                this.serializeAssignment(source, mainAssignments, keys[i], values[i]);\n            }\n            this.stack.pop();\n            return resolveAssignments(mainAssignments);\n        }\n        return void 0;\n    }\n    serializeDictionary(node, init) {\n        if (node.p) {\n            if (this.features & 8 /* ObjectAssign */ ) {\n                init = this.serializeWithObjectAssign(node, node.p, init);\n            } else {\n                this.markRef(node.i);\n                const assignments = this.serializeAssignments(node, node.p);\n                if (assignments) {\n                    return \"(\" + this.assignIndexedValue(node.i, init) + \",\" + assignments + this.getRefParam(node.i) + \")\";\n                }\n            }\n        }\n        return this.assignIndexedValue(node.i, init);\n    }\n    serializeNullConstructor(node) {\n        this.pushObjectFlag(node.o, node.i);\n        return this.serializeDictionary(node, NULL_CONSTRUCTOR);\n    }\n    serializeDate(node) {\n        return this.assignIndexedValue(node.i, 'new Date(\"' + node.s + '\")');\n    }\n    serializeRegExp(node) {\n        return this.assignIndexedValue(node.i, \"/\" + node.c + \"/\" + node.m);\n    }\n    serializeSetItem(id, item) {\n        if (this.isIndexedValueInStack(item)) {\n            this.markRef(id);\n            this.createAddAssignment(id, this.getRefParam(item.i));\n            return \"\";\n        }\n        return this.serialize(item);\n    }\n    serializeSet(node) {\n        let serialized = SET_CONSTRUCTOR;\n        const size = node.l;\n        const id = node.i;\n        if (size) {\n            const items = node.a;\n            this.stack.push(id);\n            let result = this.serializeSetItem(id, items[0]);\n            for(let i = 1, item = result; i < size; i++){\n                item = this.serializeSetItem(id, items[i]);\n                result += (item && result && \",\") + item;\n            }\n            this.stack.pop();\n            if (result) {\n                serialized += \"([\" + result + \"])\";\n            }\n        }\n        return this.assignIndexedValue(id, serialized);\n    }\n    serializeMapEntry(id, key, val, sentinel) {\n        if (this.isIndexedValueInStack(key)) {\n            const keyRef = this.getRefParam(key.i);\n            this.markRef(id);\n            if (this.isIndexedValueInStack(val)) {\n                const valueRef = this.getRefParam(val.i);\n                this.createSetAssignment(id, keyRef, valueRef);\n                return \"\";\n            }\n            if (val.t !== 4 /* IndexedValue */  && val.i != null && this.isMarked(val.i)) {\n                const serialized = \"(\" + this.serialize(val) + \",[\" + sentinel + \",\" + sentinel + \"])\";\n                this.createSetAssignment(id, keyRef, this.getRefParam(val.i));\n                this.createDeleteAssignment(id, sentinel);\n                return serialized;\n            }\n            const parent = this.stack;\n            this.stack = [];\n            this.createSetAssignment(id, keyRef, this.serialize(val));\n            this.stack = parent;\n            return \"\";\n        }\n        if (this.isIndexedValueInStack(val)) {\n            const valueRef = this.getRefParam(val.i);\n            this.markRef(id);\n            if (key.t !== 4 /* IndexedValue */  && key.i != null && this.isMarked(key.i)) {\n                const serialized = \"(\" + this.serialize(key) + \",[\" + sentinel + \",\" + sentinel + \"])\";\n                this.createSetAssignment(id, this.getRefParam(key.i), valueRef);\n                this.createDeleteAssignment(id, sentinel);\n                return serialized;\n            }\n            const parent = this.stack;\n            this.stack = [];\n            this.createSetAssignment(id, this.serialize(key), valueRef);\n            this.stack = parent;\n            return \"\";\n        }\n        return \"[\" + this.serialize(key) + \",\" + this.serialize(val) + \"]\";\n    }\n    serializeMap(node) {\n        let serialized = MAP_CONSTRUCTOR;\n        const size = node.e.s;\n        const id = node.i;\n        const sentinel = node.f;\n        const sentinelId = this.getRefParam(sentinel.i);\n        if (size) {\n            const keys = node.e.k;\n            const vals = node.e.v;\n            this.stack.push(id);\n            let result = this.serializeMapEntry(id, keys[0], vals[0], sentinelId);\n            for(let i = 1, item = result; i < size; i++){\n                item = this.serializeMapEntry(id, keys[i], vals[i], sentinelId);\n                result += (item && result && \",\") + item;\n            }\n            this.stack.pop();\n            if (result) {\n                serialized += \"([\" + result + \"])\";\n            }\n        }\n        if (sentinel.t === 26 /* SpecialReference */ ) {\n            this.markRef(sentinel.i);\n            serialized = \"(\" + this.serialize(sentinel) + \",\" + serialized + \")\";\n        }\n        return this.assignIndexedValue(id, serialized);\n    }\n    serializeArrayBuffer(node) {\n        let result = \"new Uint8Array(\";\n        const buffer = node.s;\n        const len = buffer.length;\n        if (len) {\n            result += \"[\" + buffer[0];\n            for(let i = 1; i < len; i++){\n                result += \",\" + buffer[i];\n            }\n            result += \"]\";\n        }\n        return this.assignIndexedValue(node.i, result + \").buffer\");\n    }\n    serializeTypedArray(node) {\n        return this.assignIndexedValue(node.i, \"new \" + node.c + \"(\" + this.serialize(node.f) + \",\" + node.b + \",\" + node.l + \")\");\n    }\n    serializeDataView(node) {\n        return this.assignIndexedValue(node.i, \"new DataView(\" + this.serialize(node.f) + \",\" + node.b + \",\" + node.l + \")\");\n    }\n    serializeAggregateError(node) {\n        const id = node.i;\n        this.stack.push(id);\n        const serialized = this.serializeDictionary(node, 'new AggregateError([],\"' + node.m + '\")');\n        this.stack.pop();\n        return serialized;\n    }\n    serializeError(node) {\n        return this.serializeDictionary(node, \"new \" + ERROR_CONSTRUCTOR_STRING[node.s] + '(\"' + node.m + '\")');\n    }\n    serializePromise(node) {\n        let serialized;\n        const fulfilled = node.f;\n        const id = node.i;\n        const promiseConstructor = node.s ? PROMISE_RESOLVE : PROMISE_REJECT;\n        if (this.isIndexedValueInStack(fulfilled)) {\n            const ref = this.getRefParam(fulfilled.i);\n            serialized = promiseConstructor + (node.s ? \"().then(\" + this.createFunction([], ref) + \")\" : \"().catch(\" + this.createEffectfulFunction([], \"throw \" + ref) + \")\");\n        } else {\n            this.stack.push(id);\n            const result = this.serialize(fulfilled);\n            this.stack.pop();\n            serialized = promiseConstructor + \"(\" + result + \")\";\n        }\n        return this.assignIndexedValue(id, serialized);\n    }\n    serializeWellKnownSymbol(node) {\n        return this.assignIndexedValue(node.i, SYMBOL_STRING[node.s]);\n    }\n    serializeBoxed(node) {\n        return this.assignIndexedValue(node.i, \"Object(\" + this.serialize(node.f) + \")\");\n    }\n    serializePlugin(node) {\n        const currentPlugins = this.plugins;\n        if (currentPlugins) {\n            for(let i = 0, len = currentPlugins.length; i < len; i++){\n                const plugin = currentPlugins[i];\n                if (plugin.tag === node.c) {\n                    return this.assignIndexedValue(node.i, plugin.serialize(node.s, this, {\n                        id: node.i\n                    }));\n                }\n            }\n        }\n        throw new SerovalMissingPluginError(node.c);\n    }\n    getConstructor(node) {\n        const current = this.serialize(node);\n        return current === this.getRefParam(node.i) ? current : \"(\" + current + \")\";\n    }\n    serializePromiseConstructor(node) {\n        return this.assignIndexedValue(node.i, this.getConstructor(node.f) + \"()\");\n    }\n    serializePromiseResolve(node) {\n        return this.getConstructor(node.a[0]) + \"(\" + this.getRefParam(node.i) + \",\" + this.serialize(node.a[1]) + \")\";\n    }\n    serializePromiseReject(node) {\n        return this.getConstructor(node.a[0]) + \"(\" + this.getRefParam(node.i) + \",\" + this.serialize(node.a[1]) + \")\";\n    }\n    serializeSpecialReferenceValue(ref) {\n        switch(ref){\n            case 0 /* MapSentinel */ :\n                return \"[]\";\n            case 1 /* PromiseConstructor */ :\n                return this.createFunction([\n                    \"s\",\n                    \"f\",\n                    \"p\"\n                ], \"((p=new Promise(\" + this.createEffectfulFunction([\n                    \"a\",\n                    \"b\"\n                ], \"s=a,f=b\") + \")).s=s,p.f=f,p)\");\n            case 2 /* PromiseResolve */ :\n                return this.createEffectfulFunction([\n                    \"p\",\n                    \"d\"\n                ], 'p.s(d),p.status=\"success\",p.value=d;delete p.s;delete p.f');\n            case 3 /* PromiseReject */ :\n                return this.createEffectfulFunction([\n                    \"p\",\n                    \"d\"\n                ], 'p.f(d),p.status=\"failure\",p.value=d;delete p.s;delete p.f');\n            case 4 /* StreamConstructor */ :\n                return this.createFunction([\n                    \"b\",\n                    \"a\",\n                    \"s\",\n                    \"l\",\n                    \"p\",\n                    \"f\",\n                    \"e\",\n                    \"n\"\n                ], \"(b=[],a=!0,s=!1,l=[],p=0,f=\" + this.createEffectfulFunction([\n                    \"v\",\n                    \"m\",\n                    \"x\"\n                ], \"for(x=0;x<p;x++)l[x]&&l[x][m](v)\") + \",n=\" + this.createEffectfulFunction([\n                    \"o\",\n                    \"x\",\n                    \"z\",\n                    \"c\"\n                ], 'for(x=0,z=b.length;x<z;x++)(c=b[x],x===z-1?o[s?\"return\":\"throw\"](c):o.next(c))') + \",e=\" + this.createFunction([\n                    \"o\",\n                    \"t\"\n                ], \"(a&&(l[t=p++]=o),n(o),\" + this.createEffectfulFunction([], \"a&&(l[t]=void 0)\") + \")\") + \",{__SEROVAL_STREAM__:!0,on:\" + this.createFunction([\n                    \"o\"\n                ], \"e(o)\") + \",next:\" + this.createEffectfulFunction([\n                    \"v\"\n                ], 'a&&(b.push(v),f(v,\"next\"))') + \",throw:\" + this.createEffectfulFunction([\n                    \"v\"\n                ], 'a&&(b.push(v),f(v,\"throw\"),a=s=!1,l.length=0)') + \",return:\" + this.createEffectfulFunction([\n                    \"v\"\n                ], 'a&&(b.push(v),f(v,\"return\"),a=!1,s=!0,l.length=0)') + \"})\");\n            default:\n                return \"\";\n        }\n    }\n    serializeSpecialReference(node) {\n        return this.assignIndexedValue(node.i, this.serializeSpecialReferenceValue(node.s));\n    }\n    serializeIteratorFactory(node) {\n        let result = \"\";\n        let initialized = false;\n        if (node.f.t !== 4 /* IndexedValue */ ) {\n            this.markRef(node.f.i);\n            result = \"(\" + this.serialize(node.f) + \",\";\n            initialized = true;\n        }\n        result += this.assignIndexedValue(node.i, this.createFunction([\n            \"s\"\n        ], this.createFunction([\n            \"i\",\n            \"c\",\n            \"d\",\n            \"t\"\n        ], \"(i=0,t={[\" + this.getRefParam(node.f.i) + \"]:\" + this.createFunction([], \"t\") + \",next:\" + this.createEffectfulFunction([], \"if(i>s.d)return{done:!0,value:void 0};if(d=s.v[c=i++],c===s.t)throw d;return{done:c===s.d,value:d}\") + \"})\")));\n        if (initialized) {\n            result += \")\";\n        }\n        return result;\n    }\n    serializeIteratorFactoryInstance(node) {\n        return this.getConstructor(node.a[0]) + \"(\" + this.serialize(node.a[1]) + \")\";\n    }\n    serializeAsyncIteratorFactory(node) {\n        const promise = node.a[0];\n        const symbol = node.a[1];\n        let result = \"\";\n        if (promise.t !== 4 /* IndexedValue */ ) {\n            this.markRef(promise.i);\n            result += \"(\" + this.serialize(promise);\n        }\n        if (symbol.t !== 4 /* IndexedValue */ ) {\n            this.markRef(symbol.i);\n            result += (result ? \",\" : \"(\") + this.serialize(symbol);\n        }\n        if (result) {\n            result += \",\";\n        }\n        const iterator = this.assignIndexedValue(node.i, this.createFunction([\n            \"s\"\n        ], this.createFunction([\n            \"b\",\n            \"c\",\n            \"p\",\n            \"d\",\n            \"e\",\n            \"t\",\n            \"f\"\n        ], \"(b=[],c=0,p=[],d=-1,e=!1,f=\" + this.createEffectfulFunction([\n            \"i\",\n            \"l\"\n        ], \"for(i=0,l=p.length;i<l;i++)p[i].s({done:!0,value:void 0})\") + \",s.on({next:\" + this.createEffectfulFunction([\n            \"v\",\n            \"t\"\n        ], \"if(t=p.shift())t.s({done:!1,value:v});b.push(v)\") + \",throw:\" + this.createEffectfulFunction([\n            \"v\",\n            \"t\"\n        ], \"if(t=p.shift())t.f(v);f(),d=b.length,e=!0,b.push(v)\") + \",return:\" + this.createEffectfulFunction([\n            \"v\",\n            \"t\"\n        ], \"if(t=p.shift())t.s({done:!0,value:v});f(),d=b.length,b.push(v)\") + \"}),t={[\" + this.getRefParam(symbol.i) + \"]:\" + this.createFunction([], \"t\") + \",next:\" + this.createEffectfulFunction([\n            \"i\",\n            \"t\",\n            \"v\"\n        ], \"if(d===-1){return((i=c++)>=b.length)?(p.push(t=\" + this.getRefParam(promise.i) + \"()),t):{done:!0,value:b[i]}}if(c>d)return{done:!0,value:void 0};if(v=b[i=c++],i!==d)return{done:!1,value:v};if(e)throw v;return{done:!0,value:v}\") + \"})\")));\n        if (result) {\n            return result + iterator + \")\";\n        }\n        return iterator;\n    }\n    serializeAsyncIteratorFactoryInstance(node) {\n        return this.getConstructor(node.a[0]) + \"(\" + this.serialize(node.a[1]) + \")\";\n    }\n    serializeStreamConstructor(node) {\n        const result = this.assignIndexedValue(node.i, this.getConstructor(node.f) + \"()\");\n        const len = node.a.length;\n        if (len) {\n            let values = this.serialize(node.a[0]);\n            for(let i = 1; i < len; i++){\n                values += \",\" + this.serialize(node.a[i]);\n            }\n            return \"(\" + result + \",\" + values + \",\" + this.getRefParam(node.i) + \")\";\n        }\n        return result;\n    }\n    serializeStreamNext(node) {\n        return this.getRefParam(node.i) + \".next(\" + this.serialize(node.f) + \")\";\n    }\n    serializeStreamThrow(node) {\n        return this.getRefParam(node.i) + \".throw(\" + this.serialize(node.f) + \")\";\n    }\n    serializeStreamReturn(node) {\n        return this.getRefParam(node.i) + \".return(\" + this.serialize(node.f) + \")\";\n    }\n    serialize(node) {\n        try {\n            switch(node.t){\n                case 2 /* Constant */ :\n                    return CONSTANT_STRING[node.s];\n                case 0 /* Number */ :\n                    return \"\" + node.s;\n                case 1 /* String */ :\n                    return '\"' + node.s + '\"';\n                case 3 /* BigInt */ :\n                    return node.s + \"n\";\n                case 4 /* IndexedValue */ :\n                    return this.getRefParam(node.i);\n                case 18 /* Reference */ :\n                    return this.serializeReference(node);\n                case 9 /* Array */ :\n                    return this.serializeArray(node);\n                case 10 /* Object */ :\n                    return this.serializeObject(node);\n                case 11 /* NullConstructor */ :\n                    return this.serializeNullConstructor(node);\n                case 5 /* Date */ :\n                    return this.serializeDate(node);\n                case 6 /* RegExp */ :\n                    return this.serializeRegExp(node);\n                case 7 /* Set */ :\n                    return this.serializeSet(node);\n                case 8 /* Map */ :\n                    return this.serializeMap(node);\n                case 19 /* ArrayBuffer */ :\n                    return this.serializeArrayBuffer(node);\n                case 16 /* BigIntTypedArray */ :\n                case 15 /* TypedArray */ :\n                    return this.serializeTypedArray(node);\n                case 20 /* DataView */ :\n                    return this.serializeDataView(node);\n                case 14 /* AggregateError */ :\n                    return this.serializeAggregateError(node);\n                case 13 /* Error */ :\n                    return this.serializeError(node);\n                case 12 /* Promise */ :\n                    return this.serializePromise(node);\n                case 17 /* WKSymbol */ :\n                    return this.serializeWellKnownSymbol(node);\n                case 21 /* Boxed */ :\n                    return this.serializeBoxed(node);\n                case 22 /* PromiseConstructor */ :\n                    return this.serializePromiseConstructor(node);\n                case 23 /* PromiseResolve */ :\n                    return this.serializePromiseResolve(node);\n                case 24 /* PromiseReject */ :\n                    return this.serializePromiseReject(node);\n                case 25 /* Plugin */ :\n                    return this.serializePlugin(node);\n                case 26 /* SpecialReference */ :\n                    return this.serializeSpecialReference(node);\n                case 27 /* IteratorFactory */ :\n                    return this.serializeIteratorFactory(node);\n                case 28 /* IteratorFactoryInstance */ :\n                    return this.serializeIteratorFactoryInstance(node);\n                case 29 /* AsyncIteratorFactory */ :\n                    return this.serializeAsyncIteratorFactory(node);\n                case 30 /* AsyncIteratorFactoryInstance */ :\n                    return this.serializeAsyncIteratorFactoryInstance(node);\n                case 31 /* StreamConstructor */ :\n                    return this.serializeStreamConstructor(node);\n                case 32 /* StreamNext */ :\n                    return this.serializeStreamNext(node);\n                case 33 /* StreamThrow */ :\n                    return this.serializeStreamThrow(node);\n                case 34 /* StreamReturn */ :\n                    return this.serializeStreamReturn(node);\n                default:\n                    throw new SerovalUnsupportedNodeError(node);\n            }\n        } catch (error) {\n            throw new SerovalSerializationError(error);\n        }\n    }\n};\n// src/core/utils/get-identifier.ts\nvar REF_START_CHARS = \"hjkmoquxzABCDEFGHIJKLNPQRTUVWXYZ$_\";\nvar REF_START_CHARS_LEN = REF_START_CHARS.length;\nvar REF_CHARS = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789$_\";\nvar REF_CHARS_LEN = REF_CHARS.length;\nfunction getIdentifier(index) {\n    let mod = index % REF_START_CHARS_LEN;\n    let ref = REF_START_CHARS[mod];\n    index = (index - mod) / REF_START_CHARS_LEN;\n    while(index > 0){\n        mod = index % REF_CHARS_LEN;\n        ref += REF_CHARS[mod];\n        index = (index - mod) / REF_CHARS_LEN;\n    }\n    return ref;\n}\n// src/core/tree/serializer.ts\nvar VanillaSerializerContext = class extends BaseSerializerContext {\n    constructor(){\n        super(...arguments);\n        this.mode = \"vanilla\";\n        /**\n     * Map tree refs to actual refs\n     * @private\n     */ this.valid = /* @__PURE__ */ new Map();\n        /**\n     * Variables\n     * @private\n     */ this.vars = [];\n    }\n    /**\n   * Creates the reference param (identifier) from the given reference ID\n   * Calling this function means the value has been referenced somewhere\n   */ getRefParam(index) {\n        let actualIndex = this.valid.get(index);\n        if (actualIndex == null) {\n            actualIndex = this.valid.size;\n            this.valid.set(index, actualIndex);\n        }\n        let identifier = this.vars[actualIndex];\n        if (identifier == null) {\n            identifier = getIdentifier(actualIndex);\n            this.vars[actualIndex] = identifier;\n        }\n        return identifier;\n    }\n    assignIndexedValue(index, value) {\n        if (this.isMarked(index)) {\n            return this.getRefParam(index) + \"=\" + value;\n        }\n        return value;\n    }\n    serializePromiseConstructor(node) {\n        throw new SerovalUnsupportedNodeError(node);\n    }\n    serializePromiseResolve(node) {\n        throw new SerovalUnsupportedNodeError(node);\n    }\n    serializePromiseReject(node) {\n        throw new SerovalUnsupportedNodeError(node);\n    }\n    serializeTop(tree) {\n        const result = this.serialize(tree);\n        if (tree.i != null && this.vars.length) {\n            const patches = this.resolvePatches();\n            let body = result;\n            if (patches) {\n                const index = this.getRefParam(tree.i);\n                body = result + \",\" + patches + index;\n                if (!result.startsWith(index + \"=\")) {\n                    body = index + \"=\" + body;\n                }\n            }\n            return \"(\" + this.createFunction(this.vars, \"(\" + body + \")\") + \")()\";\n        }\n        if (tree.t === 10 /* Object */ ) {\n            return \"(\" + result + \")\";\n        }\n        return result;\n    }\n};\n// src/core/context/parser/sync.ts\nvar BaseSyncParserContext = class extends BaseParserContext {\n    parseItems(current) {\n        const nodes = [];\n        for(let i = 0, len = current.length; i < len; i++){\n            if (i in current) {\n                nodes[i] = this.parse(current[i]);\n            }\n        }\n        return nodes;\n    }\n    parseArray(id, current) {\n        return createArrayNode(id, current, this.parseItems(current));\n    }\n    parseProperties(properties) {\n        const entries = Object.entries(properties);\n        const keyNodes = [];\n        const valueNodes = [];\n        for(let i = 0, len = entries.length; i < len; i++){\n            keyNodes.push(serializeString(entries[i][0]));\n            valueNodes.push(this.parse(entries[i][1]));\n        }\n        let symbol = Symbol.iterator;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createIteratorFactoryInstanceNode(this.parseIteratorFactory(), this.parse(iteratorToSequence(properties))));\n        }\n        symbol = Symbol.asyncIterator;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createAsyncIteratorFactoryInstanceNode(this.parseAsyncIteratorFactory(), this.parse(createStream())));\n        }\n        symbol = Symbol.toStringTag;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createStringNode(properties[symbol]));\n        }\n        symbol = Symbol.isConcatSpreadable;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n        }\n        return {\n            k: keyNodes,\n            v: valueNodes,\n            s: keyNodes.length\n        };\n    }\n    parsePlainObject(id, current, empty) {\n        return this.createObjectNode(id, current, empty, this.parseProperties(current));\n    }\n    parseBoxed(id, current) {\n        return createBoxedNode(id, this.parse(current.valueOf()));\n    }\n    parseTypedArray(id, current) {\n        return createTypedArrayNode(id, current, this.parse(current.buffer));\n    }\n    parseBigIntTypedArray(id, current) {\n        return createBigIntTypedArrayNode(id, current, this.parse(current.buffer));\n    }\n    parseDataView(id, current) {\n        return createDataViewNode(id, current, this.parse(current.buffer));\n    }\n    parseError(id, current) {\n        const options = getErrorOptions(current, this.features);\n        return createErrorNode(id, current, options ? this.parseProperties(options) : void 0);\n    }\n    parseAggregateError(id, current) {\n        const options = getErrorOptions(current, this.features);\n        return createAggregateErrorNode(id, current, options ? this.parseProperties(options) : void 0);\n    }\n    parseMap(id, current) {\n        const keyNodes = [];\n        const valueNodes = [];\n        for (const [key, value] of current.entries()){\n            keyNodes.push(this.parse(key));\n            valueNodes.push(this.parse(value));\n        }\n        return this.createMapNode(id, keyNodes, valueNodes, current.size);\n    }\n    parseSet(id, current) {\n        const items = [];\n        for (const item of current.keys()){\n            items.push(this.parse(item));\n        }\n        return createSetNode(id, current.size, items);\n    }\n    parsePlugin(id, current) {\n        const currentPlugins = this.plugins;\n        if (currentPlugins) {\n            for(let i = 0, len = currentPlugins.length; i < len; i++){\n                const plugin = currentPlugins[i];\n                if (plugin.parse.sync && plugin.test(current)) {\n                    return createPluginNode(id, plugin.tag, plugin.parse.sync(current, this, {\n                        id\n                    }));\n                }\n            }\n        }\n        return void 0;\n    }\n    parseStream(id, _current) {\n        return createStreamConstructorNode(id, this.parseSpecialReference(4 /* StreamConstructor */ ), []);\n    }\n    parsePromise(id, _current) {\n        return this.createPromiseConstructorNode(id);\n    }\n    parseObject(id, current) {\n        if (Array.isArray(current)) {\n            return this.parseArray(id, current);\n        }\n        if (isStream(current)) {\n            return this.parseStream(id, current);\n        }\n        const parsed = this.parsePlugin(id, current);\n        if (parsed) {\n            return parsed;\n        }\n        const currentClass = current.constructor;\n        switch(currentClass){\n            case Object:\n                return this.parsePlainObject(id, current, false);\n            case void 0:\n                return this.parsePlainObject(id, current, true);\n            case Date:\n                return createDateNode(id, current);\n            case RegExp:\n                return createRegExpNode(id, current);\n            case Error:\n            case EvalError:\n            case RangeError:\n            case ReferenceError:\n            case SyntaxError:\n            case TypeError:\n            case URIError:\n                return this.parseError(id, current);\n            case Number:\n            case Boolean:\n            case String:\n            case BigInt:\n                return this.parseBoxed(id, current);\n            case ArrayBuffer:\n                return createArrayBufferNode(id, current);\n            case Int8Array:\n            case Int16Array:\n            case Int32Array:\n            case Uint8Array:\n            case Uint16Array:\n            case Uint32Array:\n            case Uint8ClampedArray:\n            case Float32Array:\n            case Float64Array:\n                return this.parseTypedArray(id, current);\n            case DataView:\n                return this.parseDataView(id, current);\n            case Map:\n                return this.parseMap(id, current);\n            case Set:\n                return this.parseSet(id, current);\n            default:\n                break;\n        }\n        if (currentClass === Promise || current instanceof Promise) {\n            return this.parsePromise(id, current);\n        }\n        const currentFeatures = this.features;\n        if (currentFeatures & 16 /* BigIntTypedArray */ ) {\n            switch(currentClass){\n                case BigInt64Array:\n                case BigUint64Array:\n                    return this.parseBigIntTypedArray(id, current);\n                default:\n                    break;\n            }\n        }\n        if (currentFeatures & 1 /* AggregateError */  && typeof AggregateError !== \"undefined\" && (currentClass === AggregateError || current instanceof AggregateError)) {\n            return this.parseAggregateError(id, current);\n        }\n        if (current instanceof Error) {\n            return this.parseError(id, current);\n        }\n        if (Symbol.iterator in current || Symbol.asyncIterator in current) {\n            return this.parsePlainObject(id, current, !!currentClass);\n        }\n        throw new SerovalUnsupportedTypeError(current);\n    }\n    parse(current) {\n        try {\n            switch(typeof current){\n                case \"boolean\":\n                    return current ? TRUE_NODE : FALSE_NODE;\n                case \"undefined\":\n                    return UNDEFINED_NODE;\n                case \"string\":\n                    return createStringNode(current);\n                case \"number\":\n                    return createNumberNode(current);\n                case \"bigint\":\n                    return createBigIntNode(current);\n                case \"object\":\n                    {\n                        if (current) {\n                            const ref = this.getReference(current);\n                            return ref.type === 0 ? this.parseObject(ref.value, current) : ref.value;\n                        }\n                        return NULL_NODE;\n                    }\n                case \"symbol\":\n                    return this.parseWellKnownSymbol(current);\n                case \"function\":\n                    return this.parseFunction(current);\n                default:\n                    throw new SerovalUnsupportedTypeError(current);\n            }\n        } catch (error) {\n            throw new SerovalParserError(error);\n        }\n    }\n};\n// src/core/tree/sync.ts\nvar SyncParserContext = class extends BaseSyncParserContext {\n    constructor(){\n        super(...arguments);\n        this.mode = \"vanilla\";\n    }\n};\n// src/core/tree/index.ts\nfunction serialize(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new SyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures\n    });\n    const tree = ctx.parse(source);\n    const serial = new VanillaSerializerContext({\n        plugins,\n        features: ctx.features,\n        markedRefs: ctx.marked\n    });\n    return serial.serializeTop(tree);\n}\nasync function serializeAsync(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new AsyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures\n    });\n    const tree = await ctx.parse(source);\n    const serial = new VanillaSerializerContext({\n        plugins,\n        features: ctx.features,\n        markedRefs: ctx.marked\n    });\n    return serial.serializeTop(tree);\n}\nfunction deserialize(source) {\n    return (0, eval)(source);\n}\nfunction toJSON(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new SyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures\n    });\n    return {\n        t: ctx.parse(source),\n        f: ctx.features,\n        m: Array.from(ctx.marked)\n    };\n}\nasync function toJSONAsync(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new AsyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures\n    });\n    return {\n        t: await ctx.parse(source),\n        f: ctx.features,\n        m: Array.from(ctx.marked)\n    };\n}\nfunction compileJSON(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new VanillaSerializerContext({\n        plugins,\n        features: source.f,\n        markedRefs: source.m\n    });\n    return ctx.serializeTop(source.t);\n}\nfunction fromJSON(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new VanillaDeserializerContext({\n        plugins,\n        markedRefs: source.m\n    });\n    return ctx.deserialize(source.t);\n}\n// src/core/cross/async.ts\nvar CrossAsyncParserContext = class extends BaseAsyncParserContext {\n    constructor(){\n        super(...arguments);\n        this.mode = \"cross\";\n    }\n};\n// src/core/cross/deserializer.ts\nvar CrossDeserializerContext = class extends BaseDeserializerContext {\n    constructor(){\n        super(...arguments);\n        this.mode = \"cross\";\n    }\n    assignIndexedValue(index, value) {\n        if (!this.refs.has(index)) {\n            this.refs.set(index, value);\n        }\n        return value;\n    }\n};\n// src/core/cross/serializer.ts\nvar CrossSerializerContext = class extends BaseSerializerContext {\n    constructor(options){\n        super(options);\n        this.mode = \"cross\";\n        this.scopeId = options.scopeId;\n    }\n    getRefParam(id) {\n        return GLOBAL_CONTEXT_REFERENCES + \"[\" + id + \"]\";\n    }\n    assignIndexedValue(index, value) {\n        return this.getRefParam(index) + \"=\" + value;\n    }\n    serializeTop(tree) {\n        const result = this.serialize(tree);\n        const id = tree.i;\n        if (id == null) {\n            return result;\n        }\n        const patches = this.resolvePatches();\n        const ref = this.getRefParam(id);\n        const params = this.scopeId == null ? \"\" : GLOBAL_CONTEXT_REFERENCES;\n        const body = patches ? result + \",\" + patches + ref : result;\n        if (params === \"\") {\n            return patches ? \"(\" + body + \")\" : body;\n        }\n        const args = this.scopeId == null ? \"()\" : \"(\" + GLOBAL_CONTEXT_REFERENCES + '[\"' + serializeString(this.scopeId) + '\"])';\n        return \"(\" + this.createFunction([\n            params\n        ], body) + \")\" + args;\n    }\n};\n// src/core/context/parser/stream.ts\nvar BaseStreamParserContext = class extends BaseSyncParserContext {\n    constructor(options){\n        super(options);\n        // Life\n        this.alive = true;\n        // Amount of pending promises/streams\n        this.pending = 0;\n        this.initial = true;\n        this.buffer = [];\n        this.onParseCallback = options.onParse;\n        this.onErrorCallback = options.onError;\n        this.onDoneCallback = options.onDone;\n    }\n    onParseInternal(node, initial) {\n        try {\n            this.onParseCallback(node, initial);\n        } catch (error) {\n            this.onError(error);\n        }\n    }\n    flush() {\n        for(let i = 0, len = this.buffer.length; i < len; i++){\n            this.onParseInternal(this.buffer[i], false);\n        }\n    }\n    onParse(node) {\n        if (this.initial) {\n            this.buffer.push(node);\n        } else {\n            this.onParseInternal(node, false);\n        }\n    }\n    onError(error) {\n        if (this.onErrorCallback) {\n            this.onErrorCallback(error);\n        } else {\n            throw error;\n        }\n    }\n    onDone() {\n        if (this.onDoneCallback) {\n            this.onDoneCallback();\n        }\n    }\n    pushPendingState() {\n        this.pending++;\n    }\n    popPendingState() {\n        if (--this.pending <= 0) {\n            this.onDone();\n        }\n    }\n    parseProperties(properties) {\n        const entries = Object.entries(properties);\n        const keyNodes = [];\n        const valueNodes = [];\n        for(let i = 0, len = entries.length; i < len; i++){\n            keyNodes.push(serializeString(entries[i][0]));\n            valueNodes.push(this.parse(entries[i][1]));\n        }\n        let symbol = Symbol.iterator;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createIteratorFactoryInstanceNode(this.parseIteratorFactory(), this.parse(iteratorToSequence(properties))));\n        }\n        symbol = Symbol.asyncIterator;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createAsyncIteratorFactoryInstanceNode(this.parseAsyncIteratorFactory(), this.parse(createStreamFromAsyncIterable(properties))));\n        }\n        symbol = Symbol.toStringTag;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(createStringNode(properties[symbol]));\n        }\n        symbol = Symbol.isConcatSpreadable;\n        if (symbol in properties) {\n            keyNodes.push(this.parseWellKnownSymbol(symbol));\n            valueNodes.push(properties[symbol] ? TRUE_NODE : FALSE_NODE);\n        }\n        return {\n            k: keyNodes,\n            v: valueNodes,\n            s: keyNodes.length\n        };\n    }\n    parsePromise(id, current) {\n        current.then((data)=>{\n            const parsed = this.parseWithError(data);\n            if (parsed) {\n                this.onParse({\n                    t: 23 /* PromiseResolve */ ,\n                    i: id,\n                    s: void 0,\n                    l: void 0,\n                    c: void 0,\n                    m: void 0,\n                    p: void 0,\n                    e: void 0,\n                    a: [\n                        this.parseSpecialReference(2 /* PromiseResolve */ ),\n                        parsed\n                    ],\n                    f: void 0,\n                    b: void 0,\n                    o: void 0\n                });\n            }\n            this.popPendingState();\n        }, (data)=>{\n            if (this.alive) {\n                const parsed = this.parseWithError(data);\n                if (parsed) {\n                    this.onParse({\n                        t: 24 /* PromiseReject */ ,\n                        i: id,\n                        s: void 0,\n                        l: void 0,\n                        c: void 0,\n                        m: void 0,\n                        p: void 0,\n                        e: void 0,\n                        a: [\n                            this.parseSpecialReference(3 /* PromiseReject */ ),\n                            parsed\n                        ],\n                        f: void 0,\n                        b: void 0,\n                        o: void 0\n                    });\n                }\n            }\n            this.popPendingState();\n        });\n        this.pushPendingState();\n        return this.createPromiseConstructorNode(id);\n    }\n    parsePlugin(id, current) {\n        const currentPlugins = this.plugins;\n        if (currentPlugins) {\n            for(let i = 0, len = currentPlugins.length; i < len; i++){\n                const plugin = currentPlugins[i];\n                if (plugin.parse.stream && plugin.test(current)) {\n                    return createPluginNode(id, plugin.tag, plugin.parse.stream(current, this, {\n                        id\n                    }));\n                }\n            }\n        }\n        return void 0;\n    }\n    parseStream(id, current) {\n        const result = createStreamConstructorNode(id, this.parseSpecialReference(4 /* StreamConstructor */ ), []);\n        this.pushPendingState();\n        current.on({\n            next: (value)=>{\n                if (this.alive) {\n                    const parsed = this.parseWithError(value);\n                    if (parsed) {\n                        this.onParse(createStreamNextNode(id, parsed));\n                    }\n                }\n            },\n            throw: (value)=>{\n                if (this.alive) {\n                    const parsed = this.parseWithError(value);\n                    if (parsed) {\n                        this.onParse(createStreamThrowNode(id, parsed));\n                    }\n                }\n                this.popPendingState();\n            },\n            return: (value)=>{\n                if (this.alive) {\n                    const parsed = this.parseWithError(value);\n                    if (parsed) {\n                        this.onParse(createStreamReturnNode(id, parsed));\n                    }\n                }\n                this.popPendingState();\n            }\n        });\n        return result;\n    }\n    parseWithError(current) {\n        try {\n            return this.parse(current);\n        } catch (err) {\n            this.onError(err);\n            return void 0;\n        }\n    }\n    /**\n   * @private\n   */ start(current) {\n        const parsed = this.parseWithError(current);\n        if (parsed) {\n            this.onParseInternal(parsed, true);\n            this.initial = false;\n            this.flush();\n            if (this.pending <= 0) {\n                this.destroy();\n            }\n        }\n    }\n    /**\n   * @private\n   */ destroy() {\n        if (this.alive) {\n            this.onDone();\n            this.alive = false;\n        }\n    }\n    isAlive() {\n        return this.alive;\n    }\n};\n// src/core/cross/stream.ts\nvar CrossStreamParserContext = class extends BaseStreamParserContext {\n    constructor(){\n        super(...arguments);\n        this.mode = \"cross\";\n    }\n};\n// src/core/cross/sync.ts\nvar CrossSyncParserContext = class extends BaseSyncParserContext {\n    constructor(){\n        super(...arguments);\n        this.mode = \"cross\";\n    }\n};\n// src/core/cross/index.ts\nfunction crossSerialize(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new CrossSyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures,\n        refs: options.refs\n    });\n    const tree = ctx.parse(source);\n    const serial = new CrossSerializerContext({\n        plugins,\n        features: ctx.features,\n        scopeId: options.scopeId,\n        markedRefs: ctx.marked\n    });\n    return serial.serializeTop(tree);\n}\nasync function crossSerializeAsync(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new CrossAsyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures,\n        refs: options.refs\n    });\n    const tree = await ctx.parse(source);\n    const serial = new CrossSerializerContext({\n        plugins,\n        features: ctx.features,\n        scopeId: options.scopeId,\n        markedRefs: ctx.marked\n    });\n    return serial.serializeTop(tree);\n}\nfunction toCrossJSON(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new CrossSyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures,\n        refs: options.refs\n    });\n    return ctx.parse(source);\n}\nasync function toCrossJSONAsync(source, options = {}) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new CrossAsyncParserContext({\n        plugins,\n        disabledFeatures: options.disabledFeatures,\n        refs: options.refs\n    });\n    return await ctx.parse(source);\n}\nfunction crossSerializeStream(source, options) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new CrossStreamParserContext({\n        plugins,\n        refs: options.refs,\n        disabledFeatures: options.disabledFeatures,\n        onParse (node, initial) {\n            const serial = new CrossSerializerContext({\n                plugins,\n                features: ctx.features,\n                scopeId: options.scopeId,\n                markedRefs: ctx.marked\n            });\n            let serialized;\n            try {\n                serialized = serial.serializeTop(node);\n            } catch (err) {\n                if (options.onError) {\n                    options.onError(err);\n                }\n                return;\n            }\n            options.onSerialize(serialized, initial);\n        },\n        onError: options.onError,\n        onDone: options.onDone\n    });\n    ctx.start(source);\n    return ()=>{\n        ctx.destroy();\n    };\n}\nfunction toCrossJSONStream(source, options) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new CrossStreamParserContext({\n        plugins,\n        refs: options.refs,\n        disabledFeatures: options.disabledFeatures,\n        onParse: options.onParse,\n        onError: options.onError,\n        onDone: options.onDone\n    });\n    ctx.start(source);\n    return ()=>{\n        ctx.destroy();\n    };\n}\nfunction fromCrossJSON(source, options) {\n    const plugins = resolvePlugins(options.plugins);\n    const ctx = new CrossDeserializerContext({\n        plugins,\n        refs: options.refs\n    });\n    return ctx.deserialize(source);\n}\n// src/core/Serializer.ts\nvar Serializer = class {\n    constructor(options){\n        this.options = options;\n        this.alive = true;\n        this.flushed = false;\n        this.done = false;\n        this.pending = 0;\n        this.cleanups = [];\n        this.refs = /* @__PURE__ */ new Map();\n        this.keys = /* @__PURE__ */ new Set();\n        this.ids = 0;\n        this.plugins = resolvePlugins(options.plugins);\n    }\n    write(key, value) {\n        if (this.alive && !this.flushed) {\n            this.pending++;\n            this.keys.add(key);\n            this.cleanups.push(crossSerializeStream(value, {\n                plugins: this.plugins,\n                scopeId: this.options.scopeId,\n                refs: this.refs,\n                disabledFeatures: this.options.disabledFeatures,\n                onError: this.options.onError,\n                onSerialize: (data, initial)=>{\n                    if (this.alive) {\n                        this.options.onData(initial ? this.options.globalIdentifier + '[\"' + serializeString(key) + '\"]=' + data : data);\n                    }\n                },\n                onDone: ()=>{\n                    if (this.alive) {\n                        this.pending--;\n                        if (this.pending <= 0 && this.flushed && !this.done && this.options.onDone) {\n                            this.options.onDone();\n                            this.done = true;\n                        }\n                    }\n                }\n            }));\n        }\n    }\n    getNextID() {\n        while(this.keys.has(\"\" + this.ids)){\n            this.ids++;\n        }\n        return \"\" + this.ids;\n    }\n    push(value) {\n        const newID = this.getNextID();\n        this.write(newID, value);\n        return newID;\n    }\n    flush() {\n        if (this.alive) {\n            this.flushed = true;\n            if (this.pending <= 0 && !this.done && this.options.onDone) {\n                this.options.onDone();\n                this.done = true;\n            }\n        }\n    }\n    close() {\n        if (this.alive) {\n            for(let i = 0, len = this.cleanups.length; i < len; i++){\n                this.cleanups[i]();\n            }\n            if (!this.done && this.options.onDone) {\n                this.options.onDone();\n                this.done = true;\n            }\n            this.alive = false;\n        }\n    }\n};\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvc2Vyb3ZhbC9kaXN0L2VzbS9kZXZlbG9wbWVudC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxxQkFBcUI7QUFDckIsSUFBSUEsVUFBMEIsYUFBSCxHQUFJLEVBQUNDO0lBQzlCQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxpQkFBaUIsR0FBRyxFQUFFLEdBQUc7SUFDM0NBLFFBQVEsQ0FBQ0EsUUFBUSxDQUFDLGdCQUFnQixHQUFHLEVBQUUsR0FBRztJQUMxQ0EsUUFBUSxDQUFDQSxRQUFRLENBQUMsc0JBQXNCLEdBQUcsRUFBRSxHQUFHO0lBQ2hEQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxlQUFlLEdBQUcsRUFBRSxHQUFHO0lBQ3pDQSxRQUFRLENBQUNBLFFBQVEsQ0FBQyxtQkFBbUIsR0FBRyxHQUFHLEdBQUc7SUFDOUMsT0FBT0E7QUFDVCxHQUFHRCxXQUFXLENBQUM7QUFDZixJQUFJRSxjQUFjO0FBRWxCLDJCQUEyQjtBQUMzQixTQUFTQyxPQUFPQyxJQUFJLEVBQUVDLEtBQUs7SUFDekIsSUFBSSxDQUFDRCxNQUFNO1FBQ1QsTUFBTUM7SUFDUjtBQUNGO0FBRUEscUJBQXFCO0FBQ3JCLFNBQVNDLGNBQWNDLEdBQUc7SUFDeEIsT0FBUUE7UUFDTixLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNULEtBQUs7WUFDSCxPQUFPO1FBQ1QsS0FBSztZQUNILE9BQU87UUFDVCxLQUFLO1lBQ0gsT0FBTztRQUNUO1lBQ0UsT0FBTyxLQUFLO0lBQ2hCO0FBQ0Y7QUFDQSxTQUFTQyxnQkFBZ0JELEdBQUc7SUFDMUIsSUFBSUUsU0FBUztJQUNiLElBQUlDLFVBQVU7SUFD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Q3RVLElBQUksR0FBRztZQUNkO1lBQ0EsSUFBSSxDQUFDMkQsS0FBSyxHQUFHO1FBQ2Y7SUFDRjtBQUNGO0FBa0NFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHdycGVya3MvLi9ub2RlX21vZHVsZXMvc2Vyb3ZhbC9kaXN0L2VzbS9kZXZlbG9wbWVudC9pbmRleC5tanM/MjljOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29yZS9jb21wYXQudHNcbnZhciBGZWF0dXJlID0gLyogQF9fUFVSRV9fICovICgoRmVhdHVyZTIpID0+IHtcbiAgRmVhdHVyZTJbRmVhdHVyZTJbXCJBZ2dyZWdhdGVFcnJvclwiXSA9IDFdID0gXCJBZ2dyZWdhdGVFcnJvclwiO1xuICBGZWF0dXJlMltGZWF0dXJlMltcIkFycm93RnVuY3Rpb25cIl0gPSAyXSA9IFwiQXJyb3dGdW5jdGlvblwiO1xuICBGZWF0dXJlMltGZWF0dXJlMltcIkVycm9yUHJvdG90eXBlU3RhY2tcIl0gPSA0XSA9IFwiRXJyb3JQcm90b3R5cGVTdGFja1wiO1xuICBGZWF0dXJlMltGZWF0dXJlMltcIk9iamVjdEFzc2lnblwiXSA9IDhdID0gXCJPYmplY3RBc3NpZ25cIjtcbiAgRmVhdHVyZTJbRmVhdHVyZTJbXCJCaWdJbnRUeXBlZEFycmF5XCJdID0gMTZdID0gXCJCaWdJbnRUeXBlZEFycmF5XCI7XG4gIHJldHVybiBGZWF0dXJlMjtcbn0pKEZlYXR1cmUgfHwge30pO1xudmFyIEFMTF9FTkFCTEVEID0gMzE7XG5cbi8vIHNyYy9jb3JlL3V0aWxzL2Fzc2VydC50c1xuZnVuY3Rpb24gYXNzZXJ0KGNvbmQsIGVycm9yKSB7XG4gIGlmICghY29uZCkge1xuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbi8vIHNyYy9jb3JlL3N0cmluZy50c1xuZnVuY3Rpb24gc2VyaWFsaXplQ2hhcihzdHIpIHtcbiAgc3dpdGNoIChzdHIpIHtcbiAgICBjYXNlICdcIic6XG4gICAgICByZXR1cm4gJ1xcXFxcIic7XG4gICAgY2FzZSBcIlxcXFxcIjpcbiAgICAgIHJldHVybiBcIlxcXFxcXFxcXCI7XG4gICAgY2FzZSBcIlxcblwiOlxuICAgICAgcmV0dXJuIFwiXFxcXG5cIjtcbiAgICBjYXNlIFwiXFxyXCI6XG4gICAgICByZXR1cm4gXCJcXFxcclwiO1xuICAgIGNhc2UgXCJcXGJcIjpcbiAgICAgIHJldHVybiBcIlxcXFxiXCI7XG4gICAgY2FzZSBcIlx0XCI6XG4gICAgICByZXR1cm4gXCJcXFxcdFwiO1xuICAgIGNhc2UgXCJcXGZcIjpcbiAgICAgIHJldHVybiBcIlxcXFxmXCI7XG4gICAgY2FzZSBcIjxcIjpcbiAgICAgIHJldHVybiBcIlxcXFx4M0NcIjtcbiAgICBjYXNlIFwiXFx1MjAyOFwiOlxuICAgICAgcmV0dXJuIFwiXFxcXHUyMDI4XCI7XG4gICAgY2FzZSBcIlxcdTIwMjlcIjpcbiAgICAgIHJldHVybiBcIlxcXFx1MjAyOVwiO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICB9XG59XG5mdW5jdGlvbiBzZXJpYWxpemVTdHJpbmcoc3RyKSB7XG4gIGxldCByZXN1bHQgPSBcIlwiO1xuICBsZXQgbGFzdFBvcyA9IDA7XG4gIGxldCByZXBsYWNlbWVudDtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHJlcGxhY2VtZW50ID0gc2VyaWFsaXplQ2hhcihzdHJbaV0pO1xuICAgIGlmIChyZXBsYWNlbWVudCkge1xuICAgICAgcmVzdWx0ICs9IHN0ci5zbGljZShsYXN0UG9zLCBpKSArIHJlcGxhY2VtZW50O1xuICAgICAgbGFzdFBvcyA9IGkgKyAxO1xuICAgIH1cbiAgfVxuICBpZiAobGFzdFBvcyA9PT0gMCkge1xuICAgIHJlc3VsdCA9IHN0cjtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgKz0gc3RyLnNsaWNlKGxhc3RQb3MpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVJlcGxhY2VyKHN0cikge1xuICBzd2l0Y2ggKHN0cikge1xuICAgIGNhc2UgXCJcXFxcXFxcXFwiOlxuICAgICAgcmV0dXJuIFwiXFxcXFwiO1xuICAgIGNhc2UgJ1xcXFxcIic6XG4gICAgICByZXR1cm4gJ1wiJztcbiAgICBjYXNlIFwiXFxcXG5cIjpcbiAgICAgIHJldHVybiBcIlxcblwiO1xuICAgIGNhc2UgXCJcXFxcclwiOlxuICAgICAgcmV0dXJuIFwiXFxyXCI7XG4gICAgY2FzZSBcIlxcXFxiXCI6XG4gICAgICByZXR1cm4gXCJcXGJcIjtcbiAgICBjYXNlIFwiXFxcXHRcIjpcbiAgICAgIHJldHVybiBcIlx0XCI7XG4gICAgY2FzZSBcIlxcXFxmXCI6XG4gICAgICByZXR1cm4gXCJcXGZcIjtcbiAgICBjYXNlIFwiXFxcXHgzQ1wiOlxuICAgICAgcmV0dXJuIFwiPFwiO1xuICAgIGNhc2UgXCJcXFxcdTIwMjhcIjpcbiAgICAgIHJldHVybiBcIlxcdTIwMjhcIjtcbiAgICBjYXNlIFwiXFxcXHUyMDI5XCI6XG4gICAgICByZXR1cm4gXCJcXHUyMDI5XCI7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBzdHI7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplU3RyaW5nKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoXG4gICAgLyhcXFxcXFxcXHxcXFxcXCJ8XFxcXG58XFxcXHJ8XFxcXGJ8XFxcXHR8XFxcXGZ8XFxcXHUyMDI4fFxcXFx1MjAyOXxcXFxceDNDKS9nLFxuICAgIGRlc2VyaWFsaXplUmVwbGFjZXJcbiAgKTtcbn1cblxuLy8gc3JjL2NvcmUva2V5cy50c1xudmFyIFJFRkVSRU5DRVNfS0VZID0gXCJfX1NFUk9WQUxfUkVGU19fXCI7XG52YXIgR0xPQkFMX0NPTlRFWFRfUkVGRVJFTkNFUyA9IFwiJFJcIjtcbnZhciBHTE9CQUxfQ09OVEVYVF9SID0gYHNlbGYuJHtHTE9CQUxfQ09OVEVYVF9SRUZFUkVOQ0VTfWA7XG5mdW5jdGlvbiBnZXRDcm9zc1JlZmVyZW5jZUhlYWRlcihpZCkge1xuICBpZiAoaWQgPT0gbnVsbCkge1xuICAgIHJldHVybiBgJHtHTE9CQUxfQ09OVEVYVF9SfT0ke0dMT0JBTF9DT05URVhUX1J9fHxbXWA7XG4gIH1cbiAgcmV0dXJuIGAoJHtHTE9CQUxfQ09OVEVYVF9SfT0ke0dMT0JBTF9DT05URVhUX1J9fHx7fSlbXCIke3NlcmlhbGl6ZVN0cmluZyhcbiAgICBpZFxuICApfVwiXT1bXWA7XG59XG5cbi8vIHNyYy9jb3JlL3JlZmVyZW5jZS50c1xudmFyIFJFRkVSRU5DRSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG52YXIgSU5WX1JFRkVSRU5DRSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5mdW5jdGlvbiBjcmVhdGVSZWZlcmVuY2UoaWQsIHZhbHVlKSB7XG4gIFJFRkVSRU5DRS5zZXQodmFsdWUsIGlkKTtcbiAgSU5WX1JFRkVSRU5DRS5zZXQoaWQsIHZhbHVlKTtcbiAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlSUQodmFsdWUpIHtcbiAgcmV0dXJuIFJFRkVSRU5DRS5oYXModmFsdWUpO1xufVxuZnVuY3Rpb24gaGFzUmVmZXJlbmNlKGlkKSB7XG4gIHJldHVybiBJTlZfUkVGRVJFTkNFLmhhcyhpZCk7XG59XG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VJRCh2YWx1ZSkge1xuICBhc3NlcnQoaGFzUmVmZXJlbmNlSUQodmFsdWUpLCBuZXcgU2Vyb3ZhbE1pc3NpbmdSZWZlcmVuY2VFcnJvcih2YWx1ZSkpO1xuICByZXR1cm4gUkVGRVJFTkNFLmdldCh2YWx1ZSk7XG59XG5mdW5jdGlvbiBnZXRSZWZlcmVuY2UoaWQpIHtcbiAgYXNzZXJ0KGhhc1JlZmVyZW5jZShpZCksIG5ldyBTZXJvdmFsTWlzc2luZ1JlZmVyZW5jZUZvcklkRXJyb3IoaWQpKTtcbiAgcmV0dXJuIElOVl9SRUZFUkVOQ0UuZ2V0KGlkKTtcbn1cbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsVGhpcywgUkVGRVJFTkNFU19LRVksIHtcbiAgICB2YWx1ZTogSU5WX1JFRkVSRU5DRSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlXG4gIH0pO1xufSBlbHNlIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3aW5kb3csIFJFRkVSRU5DRVNfS0VZLCB7XG4gICAgdmFsdWU6IElOVl9SRUZFUkVOQ0UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHNlbGYsIFJFRkVSRU5DRVNfS0VZLCB7XG4gICAgdmFsdWU6IElOVl9SRUZFUkVOQ0UsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZVxuICB9KTtcbn0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZ2xvYmFsLCBSRUZFUkVOQ0VTX0tFWSwge1xuICAgIHZhbHVlOiBJTlZfUkVGRVJFTkNFLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgZW51bWVyYWJsZTogZmFsc2VcbiAgfSk7XG59XG5cbi8vIHNyYy9jb3JlL3BsdWdpbi50c1xuZnVuY3Rpb24gY3JlYXRlUGx1Z2luKHBsdWdpbikge1xuICByZXR1cm4gcGx1Z2luO1xufVxuZnVuY3Rpb24gZGVkdXBlUGx1Z2lucyhkZWR1cGVkLCBwbHVnaW5zKSB7XG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwbHVnaW5zLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHBsdWdpbnNbaV07XG4gICAgaWYgKCFkZWR1cGVkLmhhcyhjdXJyZW50KSkge1xuICAgICAgZGVkdXBlZC5hZGQoY3VycmVudCk7XG4gICAgICBpZiAoY3VycmVudC5leHRlbmRzKSB7XG4gICAgICAgIGRlZHVwZVBsdWdpbnMoZGVkdXBlZCwgY3VycmVudC5leHRlbmRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc29sdmVQbHVnaW5zKHBsdWdpbnMpIHtcbiAgaWYgKHBsdWdpbnMpIHtcbiAgICBjb25zdCBkZWR1cGVkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICBkZWR1cGVQbHVnaW5zKGRlZHVwZWQsIHBsdWdpbnMpO1xuICAgIHJldHVybiBbLi4uZGVkdXBlZF07XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cblxuLy8gc3JjL2NvcmUvY29uc3RhbnRzLnRzXG52YXIgU1lNQk9MX1NUUklORyA9IHtcbiAgWzAgLyogQXN5bmNJdGVyYXRvciAqL106IFwiU3ltYm9sLmFzeW5jSXRlcmF0b3JcIixcbiAgWzEgLyogSGFzSW5zdGFuY2UgKi9dOiBcIlN5bWJvbC5oYXNJbnN0YW5jZVwiLFxuICBbMiAvKiBJc0NvbmNhdFNwcmVhZGFibGUgKi9dOiBcIlN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVcIixcbiAgWzMgLyogSXRlcmF0b3IgKi9dOiBcIlN5bWJvbC5pdGVyYXRvclwiLFxuICBbNCAvKiBNYXRjaCAqL106IFwiU3ltYm9sLm1hdGNoXCIsXG4gIFs1IC8qIE1hdGNoQWxsICovXTogXCJTeW1ib2wubWF0Y2hBbGxcIixcbiAgWzYgLyogUmVwbGFjZSAqL106IFwiU3ltYm9sLnJlcGxhY2VcIixcbiAgWzcgLyogU2VhcmNoICovXTogXCJTeW1ib2wuc2VhcmNoXCIsXG4gIFs4IC8qIFNwZWNpZXMgKi9dOiBcIlN5bWJvbC5zcGVjaWVzXCIsXG4gIFs5IC8qIFNwbGl0ICovXTogXCJTeW1ib2wuc3BsaXRcIixcbiAgWzEwIC8qIFRvUHJpbWl0aXZlICovXTogXCJTeW1ib2wudG9QcmltaXRpdmVcIixcbiAgWzExIC8qIFRvU3RyaW5nVGFnICovXTogXCJTeW1ib2wudG9TdHJpbmdUYWdcIixcbiAgWzEyIC8qIFVuc2NvcGFibGVzICovXTogXCJTeW1ib2wudW5zY29wYWJsZXNcIlxufTtcbnZhciBJTlZfU1lNQk9MX1JFRiA9IHtcbiAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXTogMCAvKiBBc3luY0l0ZXJhdG9yICovLFxuICBbU3ltYm9sLmhhc0luc3RhbmNlXTogMSAvKiBIYXNJbnN0YW5jZSAqLyxcbiAgW1N5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGVdOiAyIC8qIElzQ29uY2F0U3ByZWFkYWJsZSAqLyxcbiAgW1N5bWJvbC5pdGVyYXRvcl06IDMgLyogSXRlcmF0b3IgKi8sXG4gIFtTeW1ib2wubWF0Y2hdOiA0IC8qIE1hdGNoICovLFxuICBbU3ltYm9sLm1hdGNoQWxsXTogNSAvKiBNYXRjaEFsbCAqLyxcbiAgW1N5bWJvbC5yZXBsYWNlXTogNiAvKiBSZXBsYWNlICovLFxuICBbU3ltYm9sLnNlYXJjaF06IDcgLyogU2VhcmNoICovLFxuICBbU3ltYm9sLnNwZWNpZXNdOiA4IC8qIFNwZWNpZXMgKi8sXG4gIFtTeW1ib2wuc3BsaXRdOiA5IC8qIFNwbGl0ICovLFxuICBbU3ltYm9sLnRvUHJpbWl0aXZlXTogMTAgLyogVG9QcmltaXRpdmUgKi8sXG4gIFtTeW1ib2wudG9TdHJpbmdUYWddOiAxMSAvKiBUb1N0cmluZ1RhZyAqLyxcbiAgW1N5bWJvbC51bnNjb3BhYmxlc106IDEyIC8qIFVuc2NvcGFibGVzICovXG59O1xudmFyIFNZTUJPTF9SRUYgPSB7XG4gIFswIC8qIEFzeW5jSXRlcmF0b3IgKi9dOiBTeW1ib2wuYXN5bmNJdGVyYXRvcixcbiAgWzEgLyogSGFzSW5zdGFuY2UgKi9dOiBTeW1ib2wuaGFzSW5zdGFuY2UsXG4gIFsyIC8qIElzQ29uY2F0U3ByZWFkYWJsZSAqL106IFN5bWJvbC5pc0NvbmNhdFNwcmVhZGFibGUsXG4gIFszIC8qIEl0ZXJhdG9yICovXTogU3ltYm9sLml0ZXJhdG9yLFxuICBbNCAvKiBNYXRjaCAqL106IFN5bWJvbC5tYXRjaCxcbiAgWzUgLyogTWF0Y2hBbGwgKi9dOiBTeW1ib2wubWF0Y2hBbGwsXG4gIFs2IC8qIFJlcGxhY2UgKi9dOiBTeW1ib2wucmVwbGFjZSxcbiAgWzcgLyogU2VhcmNoICovXTogU3ltYm9sLnNlYXJjaCxcbiAgWzggLyogU3BlY2llcyAqL106IFN5bWJvbC5zcGVjaWVzLFxuICBbOSAvKiBTcGxpdCAqL106IFN5bWJvbC5zcGxpdCxcbiAgWzEwIC8qIFRvUHJpbWl0aXZlICovXTogU3ltYm9sLnRvUHJpbWl0aXZlLFxuICBbMTEgLyogVG9TdHJpbmdUYWcgKi9dOiBTeW1ib2wudG9TdHJpbmdUYWcsXG4gIFsxMiAvKiBVbnNjb3BhYmxlcyAqL106IFN5bWJvbC51bnNjb3BhYmxlc1xufTtcbnZhciBDT05TVEFOVF9TVFJJTkcgPSB7XG4gIFsyIC8qIFRydWUgKi9dOiBcIiEwXCIsXG4gIFszIC8qIEZhbHNlICovXTogXCIhMVwiLFxuICBbMSAvKiBVbmRlZmluZWQgKi9dOiBcInZvaWQgMFwiLFxuICBbMCAvKiBOdWxsICovXTogXCJudWxsXCIsXG4gIFs0IC8qIE5lZ2F0aXZlWmVybyAqL106IFwiLTBcIixcbiAgWzUgLyogSW5maW5pdHkgKi9dOiBcIjEvMFwiLFxuICBbNiAvKiBOZWdhdGl2ZUluZmluaXR5ICovXTogXCItMS8wXCIsXG4gIFs3IC8qIE5hTiAqL106IFwiMC8wXCJcbn07XG52YXIgQ09OU1RBTlRfVkFMID0ge1xuICBbMiAvKiBUcnVlICovXTogdHJ1ZSxcbiAgWzMgLyogRmFsc2UgKi9dOiBmYWxzZSxcbiAgWzEgLyogVW5kZWZpbmVkICovXTogdm9pZCAwLFxuICBbMCAvKiBOdWxsICovXTogbnVsbCxcbiAgWzQgLyogTmVnYXRpdmVaZXJvICovXTogLTAsXG4gIFs1IC8qIEluZmluaXR5ICovXTogSW5maW5pdHksXG4gIFs2IC8qIE5lZ2F0aXZlSW5maW5pdHkgKi9dOiAtSW5maW5pdHksXG4gIFs3IC8qIE5hTiAqL106IE5hTlxufTtcbnZhciBFUlJPUl9DT05TVFJVQ1RPUl9TVFJJTkcgPSB7XG4gIFswIC8qIEVycm9yICovXTogXCJFcnJvclwiLFxuICBbMSAvKiBFdmFsRXJyb3IgKi9dOiBcIkV2YWxFcnJvclwiLFxuICBbMiAvKiBSYW5nZUVycm9yICovXTogXCJSYW5nZUVycm9yXCIsXG4gIFszIC8qIFJlZmVyZW5jZUVycm9yICovXTogXCJSZWZlcmVuY2VFcnJvclwiLFxuICBbNCAvKiBTeW50YXhFcnJvciAqL106IFwiU3ludGF4RXJyb3JcIixcbiAgWzUgLyogVHlwZUVycm9yICovXTogXCJUeXBlRXJyb3JcIixcbiAgWzYgLyogVVJJRXJyb3IgKi9dOiBcIlVSSUVycm9yXCJcbn07XG52YXIgRVJST1JfQ09OU1RSVUNUT1IgPSB7XG4gIFswIC8qIEVycm9yICovXTogRXJyb3IsXG4gIFsxIC8qIEV2YWxFcnJvciAqL106IEV2YWxFcnJvcixcbiAgWzIgLyogUmFuZ2VFcnJvciAqL106IFJhbmdlRXJyb3IsXG4gIFszIC8qIFJlZmVyZW5jZUVycm9yICovXTogUmVmZXJlbmNlRXJyb3IsXG4gIFs0IC8qIFN5bnRheEVycm9yICovXTogU3ludGF4RXJyb3IsXG4gIFs1IC8qIFR5cGVFcnJvciAqL106IFR5cGVFcnJvcixcbiAgWzYgLyogVVJJRXJyb3IgKi9dOiBVUklFcnJvclxufTtcblxuLy8gc3JjL2NvcmUvbGl0ZXJhbHMudHNcbmZ1bmN0aW9uIGNyZWF0ZUNvbnN0YW50Tm9kZSh2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHQ6IDIgLyogQ29uc3RhbnQgKi8sXG4gICAgaTogdm9pZCAwLFxuICAgIHM6IHZhbHVlLFxuICAgIGw6IHZvaWQgMCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogdm9pZCAwLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG52YXIgVFJVRV9OT0RFID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0YW50Tm9kZShcbiAgMiAvKiBUcnVlICovXG4pO1xudmFyIEZBTFNFX05PREUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RhbnROb2RlKFxuICAzIC8qIEZhbHNlICovXG4pO1xudmFyIFVOREVGSU5FRF9OT0RFID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0YW50Tm9kZShcbiAgMSAvKiBVbmRlZmluZWQgKi9cbik7XG52YXIgTlVMTF9OT0RFID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0YW50Tm9kZShcbiAgMCAvKiBOdWxsICovXG4pO1xudmFyIE5FR19aRVJPX05PREUgPSAvKiBAX19QVVJFX18gKi8gY3JlYXRlQ29uc3RhbnROb2RlKFxuICA0IC8qIE5lZ2F0aXZlWmVybyAqL1xuKTtcbnZhciBJTkZJTklUWV9OT0RFID0gLyogQF9fUFVSRV9fICovIGNyZWF0ZUNvbnN0YW50Tm9kZShcbiAgNSAvKiBJbmZpbml0eSAqL1xuKTtcbnZhciBORUdfSU5GSU5JVFlfTk9ERSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdGFudE5vZGUoXG4gIDYgLyogTmVnYXRpdmVJbmZpbml0eSAqL1xuKTtcbnZhciBOQU5fTk9ERSA9IC8qIEBfX1BVUkVfXyAqLyBjcmVhdGVDb25zdGFudE5vZGUoNyAvKiBOYU4gKi8pO1xuXG4vLyBzcmMvY29yZS91dGlscy9lcnJvci50c1xuZnVuY3Rpb24gZ2V0RXJyb3JDb25zdHJ1Y3RvcihlcnJvcikge1xuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFdmFsRXJyb3IpIHtcbiAgICByZXR1cm4gMSAvKiBFdmFsRXJyb3IgKi87XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmFuZ2VFcnJvcikge1xuICAgIHJldHVybiAyIC8qIFJhbmdlRXJyb3IgKi87XG4gIH1cbiAgaWYgKGVycm9yIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3IpIHtcbiAgICByZXR1cm4gMyAvKiBSZWZlcmVuY2VFcnJvciAqLztcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgIHJldHVybiA0IC8qIFN5bnRheEVycm9yICovO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcikge1xuICAgIHJldHVybiA1IC8qIFR5cGVFcnJvciAqLztcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBVUklFcnJvcikge1xuICAgIHJldHVybiA2IC8qIFVSSUVycm9yICovO1xuICB9XG4gIHJldHVybiAwIC8qIEVycm9yICovO1xufVxuZnVuY3Rpb24gZ2V0SW5pdGlhbEVycm9yT3B0aW9ucyhlcnJvcikge1xuICBjb25zdCBjb25zdHJ1Y3QgPSBFUlJPUl9DT05TVFJVQ1RPUl9TVFJJTkdbZ2V0RXJyb3JDb25zdHJ1Y3RvcihlcnJvcildO1xuICBpZiAoZXJyb3IubmFtZSAhPT0gY29uc3RydWN0KSB7XG4gICAgcmV0dXJuIHsgbmFtZTogZXJyb3IubmFtZSB9O1xuICB9XG4gIGlmIChlcnJvci5jb25zdHJ1Y3Rvci5uYW1lICE9PSBjb25zdHJ1Y3QpIHtcbiAgICByZXR1cm4geyBuYW1lOiBlcnJvci5jb25zdHJ1Y3Rvci5uYW1lIH07XG4gIH1cbiAgcmV0dXJuIHt9O1xufVxuZnVuY3Rpb24gZ2V0RXJyb3JPcHRpb25zKGVycm9yLCBmZWF0dXJlcykge1xuICBsZXQgb3B0aW9ucyA9IGdldEluaXRpYWxFcnJvck9wdGlvbnMoZXJyb3IpO1xuICBjb25zdCBuYW1lcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKGVycm9yKTtcbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5hbWVzLmxlbmd0aCwgbmFtZTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgbmFtZSA9IG5hbWVzW2ldO1xuICAgIGlmIChuYW1lICE9PSBcIm5hbWVcIiAmJiBuYW1lICE9PSBcIm1lc3NhZ2VcIikge1xuICAgICAgaWYgKG5hbWUgPT09IFwic3RhY2tcIikge1xuICAgICAgICBpZiAoZmVhdHVyZXMgJiA0IC8qIEVycm9yUHJvdG90eXBlU3RhY2sgKi8pIHtcbiAgICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgICBvcHRpb25zW25hbWVdID0gZXJyb3JbbmFtZV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zW25hbWVdID0gZXJyb3JbbmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vLyBzcmMvY29yZS91dGlscy9nZXQtb2JqZWN0LWZsYWcudHNcbmZ1bmN0aW9uIGdldE9iamVjdEZsYWcob2JqKSB7XG4gIGlmIChPYmplY3QuaXNGcm96ZW4ob2JqKSkge1xuICAgIHJldHVybiAzIC8qIEZyb3plbiAqLztcbiAgfVxuICBpZiAoT2JqZWN0LmlzU2VhbGVkKG9iaikpIHtcbiAgICByZXR1cm4gMiAvKiBTZWFsZWQgKi87XG4gIH1cbiAgaWYgKE9iamVjdC5pc0V4dGVuc2libGUob2JqKSkge1xuICAgIHJldHVybiAwIC8qIE5vbmUgKi87XG4gIH1cbiAgcmV0dXJuIDEgLyogTm9uRXh0ZW5zaWJsZSAqLztcbn1cblxuLy8gc3JjL2NvcmUvYmFzZS1wcmltaXRpdmVzLnRzXG5mdW5jdGlvbiBjcmVhdGVOdW1iZXJOb2RlKHZhbHVlKSB7XG4gIHN3aXRjaCAodmFsdWUpIHtcbiAgICBjYXNlIEluZmluaXR5OlxuICAgICAgcmV0dXJuIElORklOSVRZX05PREU7XG4gICAgY2FzZSAtSW5maW5pdHk6XG4gICAgICByZXR1cm4gTkVHX0lORklOSVRZX05PREU7XG4gIH1cbiAgaWYgKHZhbHVlICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBOQU5fTk9ERTtcbiAgfVxuICBpZiAoT2JqZWN0LmlzKHZhbHVlLCAtMCkpIHtcbiAgICByZXR1cm4gTkVHX1pFUk9fTk9ERTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHQ6IDAgLyogTnVtYmVyICovLFxuICAgIGk6IHZvaWQgMCxcbiAgICBzOiB2YWx1ZSxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHZvaWQgMCxcbiAgICBmOiB2b2lkIDAsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyaW5nTm9kZSh2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHQ6IDEgLyogU3RyaW5nICovLFxuICAgIGk6IHZvaWQgMCxcbiAgICBzOiBzZXJpYWxpemVTdHJpbmcodmFsdWUpLFxuICAgIGw6IHZvaWQgMCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogdm9pZCAwLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVCaWdJbnROb2RlKGN1cnJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0OiAzIC8qIEJpZ0ludCAqLyxcbiAgICBpOiB2b2lkIDAsXG4gICAgczogXCJcIiArIGN1cnJlbnQsXG4gICAgbDogdm9pZCAwLFxuICAgIGM6IHZvaWQgMCxcbiAgICBtOiB2b2lkIDAsXG4gICAgcDogdm9pZCAwLFxuICAgIGU6IHZvaWQgMCxcbiAgICBhOiB2b2lkIDAsXG4gICAgZjogdm9pZCAwLFxuICAgIGI6IHZvaWQgMCxcbiAgICBvOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUluZGV4ZWRWYWx1ZU5vZGUoaWQpIHtcbiAgcmV0dXJuIHtcbiAgICB0OiA0IC8qIEluZGV4ZWRWYWx1ZSAqLyxcbiAgICBpOiBpZCxcbiAgICBzOiB2b2lkIDAsXG4gICAgbDogdm9pZCAwLFxuICAgIGM6IHZvaWQgMCxcbiAgICBtOiB2b2lkIDAsXG4gICAgcDogdm9pZCAwLFxuICAgIGU6IHZvaWQgMCxcbiAgICBhOiB2b2lkIDAsXG4gICAgZjogdm9pZCAwLFxuICAgIGI6IHZvaWQgMCxcbiAgICBvOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGVOb2RlKGlkLCBjdXJyZW50KSB7XG4gIHJldHVybiB7XG4gICAgdDogNSAvKiBEYXRlICovLFxuICAgIGk6IGlkLFxuICAgIHM6IGN1cnJlbnQudG9JU09TdHJpbmcoKSxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBhOiB2b2lkIDAsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVnRXhwTm9kZShpZCwgY3VycmVudCkge1xuICByZXR1cm4ge1xuICAgIHQ6IDYgLyogUmVnRXhwICovLFxuICAgIGk6IGlkLFxuICAgIHM6IHZvaWQgMCxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogc2VyaWFsaXplU3RyaW5nKGN1cnJlbnQuc291cmNlKSxcbiAgICBtOiBjdXJyZW50LmZsYWdzLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBcnJheUJ1ZmZlck5vZGUoaWQsIGN1cnJlbnQpIHtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShjdXJyZW50KTtcbiAgY29uc3QgbGVuID0gYnl0ZXMubGVuZ3RoO1xuICBjb25zdCB2YWx1ZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhbHVlc1tpXSA9IGJ5dGVzW2ldO1xuICB9XG4gIHJldHVybiB7XG4gICAgdDogMTkgLyogQXJyYXlCdWZmZXIgKi8sXG4gICAgaTogaWQsXG4gICAgczogdmFsdWVzLFxuICAgIGw6IHZvaWQgMCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogdm9pZCAwLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVXS1N5bWJvbE5vZGUoaWQsIGN1cnJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICB0OiAxNyAvKiBXS1N5bWJvbCAqLyxcbiAgICBpOiBpZCxcbiAgICBzOiBJTlZfU1lNQk9MX1JFRltjdXJyZW50XSxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHZvaWQgMCxcbiAgICBmOiB2b2lkIDAsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUmVmZXJlbmNlTm9kZShpZCwgcmVmKSB7XG4gIHJldHVybiB7XG4gICAgdDogMTggLyogUmVmZXJlbmNlICovLFxuICAgIGk6IGlkLFxuICAgIHM6IHNlcmlhbGl6ZVN0cmluZyhnZXRSZWZlcmVuY2VJRChyZWYpKSxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHZvaWQgMCxcbiAgICBmOiB2b2lkIDAsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlUGx1Z2luTm9kZShpZCwgdGFnLCB2YWx1ZSkge1xuICByZXR1cm4ge1xuICAgIHQ6IDI1IC8qIFBsdWdpbiAqLyxcbiAgICBpOiBpZCxcbiAgICBzOiB2YWx1ZSxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogc2VyaWFsaXplU3RyaW5nKHRhZyksXG4gICAgbTogdm9pZCAwLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBcnJheU5vZGUoaWQsIGN1cnJlbnQsIHBhcnNlZEl0ZW1zKSB7XG4gIHJldHVybiB7XG4gICAgdDogOSAvKiBBcnJheSAqLyxcbiAgICBpOiBpZCxcbiAgICBzOiB2b2lkIDAsXG4gICAgbDogY3VycmVudC5sZW5ndGgsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHBhcnNlZEl0ZW1zLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogZ2V0T2JqZWN0RmxhZyhjdXJyZW50KVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQm94ZWROb2RlKGlkLCBib3hlZCkge1xuICByZXR1cm4ge1xuICAgIHQ6IDIxIC8qIEJveGVkICovLFxuICAgIGk6IGlkLFxuICAgIHM6IHZvaWQgMCxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHZvaWQgMCxcbiAgICBmOiBib3hlZCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVUeXBlZEFycmF5Tm9kZShpZCwgY3VycmVudCwgYnVmZmVyKSB7XG4gIHJldHVybiB7XG4gICAgdDogMTUgLyogVHlwZWRBcnJheSAqLyxcbiAgICBpOiBpZCxcbiAgICBzOiB2b2lkIDAsXG4gICAgbDogY3VycmVudC5sZW5ndGgsXG4gICAgYzogY3VycmVudC5jb25zdHJ1Y3Rvci5uYW1lLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHZvaWQgMCxcbiAgICBmOiBidWZmZXIsXG4gICAgYjogY3VycmVudC5ieXRlT2Zmc2V0LFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlQmlnSW50VHlwZWRBcnJheU5vZGUoaWQsIGN1cnJlbnQsIGJ1ZmZlcikge1xuICByZXR1cm4ge1xuICAgIHQ6IDE2IC8qIEJpZ0ludFR5cGVkQXJyYXkgKi8sXG4gICAgaTogaWQsXG4gICAgczogdm9pZCAwLFxuICAgIGw6IGN1cnJlbnQubGVuZ3RoLFxuICAgIGM6IGN1cnJlbnQuY29uc3RydWN0b3IubmFtZSxcbiAgICBtOiB2b2lkIDAsXG4gICAgcDogdm9pZCAwLFxuICAgIGU6IHZvaWQgMCxcbiAgICBhOiB2b2lkIDAsXG4gICAgZjogYnVmZmVyLFxuICAgIGI6IGN1cnJlbnQuYnl0ZU9mZnNldCxcbiAgICBvOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZURhdGFWaWV3Tm9kZShpZCwgY3VycmVudCwgYnVmZmVyKSB7XG4gIHJldHVybiB7XG4gICAgdDogMjAgLyogRGF0YVZpZXcgKi8sXG4gICAgaTogaWQsXG4gICAgczogdm9pZCAwLFxuICAgIGw6IGN1cnJlbnQuYnl0ZUxlbmd0aCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogdm9pZCAwLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IGJ1ZmZlcixcbiAgICBiOiBjdXJyZW50LmJ5dGVPZmZzZXQsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVFcnJvck5vZGUoaWQsIGN1cnJlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0OiAxMyAvKiBFcnJvciAqLyxcbiAgICBpOiBpZCxcbiAgICBzOiBnZXRFcnJvckNvbnN0cnVjdG9yKGN1cnJlbnQpLFxuICAgIGw6IHZvaWQgMCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogc2VyaWFsaXplU3RyaW5nKGN1cnJlbnQubWVzc2FnZSksXG4gICAgcDogb3B0aW9ucyxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVBZ2dyZWdhdGVFcnJvck5vZGUoaWQsIGN1cnJlbnQsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHtcbiAgICB0OiAxNCAvKiBBZ2dyZWdhdGVFcnJvciAqLyxcbiAgICBpOiBpZCxcbiAgICBzOiBnZXRFcnJvckNvbnN0cnVjdG9yKGN1cnJlbnQpLFxuICAgIGw6IHZvaWQgMCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogc2VyaWFsaXplU3RyaW5nKGN1cnJlbnQubWVzc2FnZSksXG4gICAgcDogb3B0aW9ucyxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHZvaWQgMCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTZXROb2RlKGlkLCBzaXplLCBpdGVtcykge1xuICByZXR1cm4ge1xuICAgIHQ6IDcgLyogU2V0ICovLFxuICAgIGk6IGlkLFxuICAgIHM6IHZvaWQgMCxcbiAgICBsOiBzaXplLFxuICAgIGM6IHZvaWQgMCxcbiAgICBtOiB2b2lkIDAsXG4gICAgcDogdm9pZCAwLFxuICAgIGU6IHZvaWQgMCxcbiAgICBhOiBpdGVtcyxcbiAgICBmOiB2b2lkIDAsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2VOb2RlKGZhY3RvcnksIGl0ZW1zKSB7XG4gIHJldHVybiB7XG4gICAgdDogMjggLyogSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2UgKi8sXG4gICAgaTogdm9pZCAwLFxuICAgIHM6IHZvaWQgMCxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IFtmYWN0b3J5LCBpdGVtc10sXG4gICAgZjogdm9pZCAwLFxuICAgIGI6IHZvaWQgMCxcbiAgICBvOiB2b2lkIDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2VOb2RlKGZhY3RvcnksIGl0ZW1zKSB7XG4gIHJldHVybiB7XG4gICAgdDogMzAgLyogQXN5bmNJdGVyYXRvckZhY3RvcnlJbnN0YW5jZSAqLyxcbiAgICBpOiB2b2lkIDAsXG4gICAgczogdm9pZCAwLFxuICAgIGw6IHZvaWQgMCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogdm9pZCAwLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogW2ZhY3RvcnksIGl0ZW1zXSxcbiAgICBmOiB2b2lkIDAsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtQ29uc3RydWN0b3JOb2RlKGlkLCBmYWN0b3J5LCBzZXF1ZW5jZSkge1xuICByZXR1cm4ge1xuICAgIHQ6IDMxIC8qIFN0cmVhbUNvbnN0cnVjdG9yICovLFxuICAgIGk6IGlkLFxuICAgIHM6IHZvaWQgMCxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHNlcXVlbmNlLFxuICAgIGY6IGZhY3RvcnksXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtTmV4dE5vZGUoaWQsIHBhcnNlZCkge1xuICByZXR1cm4ge1xuICAgIHQ6IDMyIC8qIFN0cmVhbU5leHQgKi8sXG4gICAgaTogaWQsXG4gICAgczogdm9pZCAwLFxuICAgIGw6IHZvaWQgMCxcbiAgICBjOiB2b2lkIDAsXG4gICAgbTogdm9pZCAwLFxuICAgIHA6IHZvaWQgMCxcbiAgICBlOiB2b2lkIDAsXG4gICAgYTogdm9pZCAwLFxuICAgIGY6IHBhcnNlZCxcbiAgICBiOiB2b2lkIDAsXG4gICAgbzogdm9pZCAwXG4gIH07XG59XG5mdW5jdGlvbiBjcmVhdGVTdHJlYW1UaHJvd05vZGUoaWQsIHBhcnNlZCkge1xuICByZXR1cm4ge1xuICAgIHQ6IDMzIC8qIFN0cmVhbVRocm93ICovLFxuICAgIGk6IGlkLFxuICAgIHM6IHZvaWQgMCxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHZvaWQgMCxcbiAgICBmOiBwYXJzZWQsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtUmV0dXJuTm9kZShpZCwgcGFyc2VkKSB7XG4gIHJldHVybiB7XG4gICAgdDogMzQgLyogU3RyZWFtUmV0dXJuICovLFxuICAgIGk6IGlkLFxuICAgIHM6IHZvaWQgMCxcbiAgICBsOiB2b2lkIDAsXG4gICAgYzogdm9pZCAwLFxuICAgIG06IHZvaWQgMCxcbiAgICBwOiB2b2lkIDAsXG4gICAgZTogdm9pZCAwLFxuICAgIGE6IHZvaWQgMCxcbiAgICBmOiBwYXJzZWQsXG4gICAgYjogdm9pZCAwLFxuICAgIG86IHZvaWQgMFxuICB9O1xufVxuXG4vLyBzcmMvY29yZS91dGlscy9pdGVyYXRvci10by1zZXF1ZW5jZS50c1xuZnVuY3Rpb24gaXRlcmF0b3JUb1NlcXVlbmNlKHNvdXJjZSkge1xuICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgbGV0IHRocm93c0F0ID0gLTE7XG4gIGxldCBkb25lQXQgPSAtMTtcbiAgY29uc3QgaXRlcmF0b3IgPSBzb3VyY2VbU3ltYm9sLml0ZXJhdG9yXSgpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGl0ZXJhdG9yLm5leHQoKTtcbiAgICAgIHZhbHVlcy5wdXNoKHZhbHVlLnZhbHVlKTtcbiAgICAgIGlmICh2YWx1ZS5kb25lKSB7XG4gICAgICAgIGRvbmVBdCA9IHZhbHVlcy5sZW5ndGggLSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3dzQXQgPSB2YWx1ZXMubGVuZ3RoO1xuICAgICAgdmFsdWVzLnB1c2goZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIHY6IHZhbHVlcyxcbiAgICB0OiB0aHJvd3NBdCxcbiAgICBkOiBkb25lQXRcbiAgfTtcbn1cbmZ1bmN0aW9uIHNlcXVlbmNlVG9JdGVyYXRvcihzZXF1ZW5jZSkge1xuICByZXR1cm4gKCkgPT4ge1xuICAgIGxldCBpbmRleCA9IDA7XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuaXRlcmF0b3JdKCkge1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH0sXG4gICAgICBuZXh0KCkge1xuICAgICAgICBpZiAoaW5kZXggPiBzZXF1ZW5jZS5kKSB7XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRvbmU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdm9pZCAwXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjdXJyZW50SW5kZXggPSBpbmRleCsrO1xuICAgICAgICBjb25zdCBjdXJyZW50SXRlbSA9IHNlcXVlbmNlLnZbY3VycmVudEluZGV4XTtcbiAgICAgICAgaWYgKGN1cnJlbnRJbmRleCA9PT0gc2VxdWVuY2UudCkge1xuICAgICAgICAgIHRocm93IGN1cnJlbnRJdGVtO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZG9uZTogY3VycmVudEluZGV4ID09PSBzZXF1ZW5jZS5kLFxuICAgICAgICAgIHZhbHVlOiBjdXJyZW50SXRlbVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG59XG5cbi8vIHNyYy9jb3JlL3NwZWNpYWwtcmVmZXJlbmNlLnRzXG52YXIgSVRFUkFUT1IgPSB7fTtcbnZhciBBU1lOQ19JVEVSQVRPUiA9IHt9O1xudmFyIFNQRUNJQUxfUkVGUyA9IHtcbiAgWzAgLyogTWFwU2VudGluZWwgKi9dOiB7fSxcbiAgWzEgLyogUHJvbWlzZUNvbnN0cnVjdG9yICovXToge30sXG4gIFsyIC8qIFByb21pc2VSZXNvbHZlICovXToge30sXG4gIFszIC8qIFByb21pc2VSZWplY3QgKi9dOiB7fSxcbiAgWzQgLyogU3RyZWFtQ29uc3RydWN0b3IgKi9dOiB7fVxufTtcblxuLy8gc3JjL2NvcmUvZXJyb3JzLnRzXG52YXIgeyB0b1N0cmluZzogb2JqZWN0VG9TdHJpbmcgfSA9IE9iamVjdC5wcm90b3R5cGU7XG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UodHlwZSwgY2F1c2UpIHtcbiAgaWYgKGNhdXNlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICByZXR1cm4gYFNlcm92YWwgY2F1Z2h0IGFuIGVycm9yIGR1cmluZyB0aGUgJHt0eXBlfSBwcm9jZXNzLlxuICBcbiR7Y2F1c2UubmFtZX1cbiR7Y2F1c2UubWVzc2FnZX1cblxuLSBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIGNoZWNrIHRoZSBcImNhdXNlXCIgcHJvcGVydHkgb2YgdGhpcyBlcnJvci5cbi0gSWYgeW91IGJlbGlldmUgdGhpcyBpcyBhbiBlcnJvciBpbiBTZXJvdmFsLCBwbGVhc2Ugc3VibWl0IGFuIGlzc3VlIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9seHNtbnN5Yy9zZXJvdmFsL2lzc3Vlcy9uZXdgO1xuICB9XG4gIHJldHVybiBgU2Vyb3ZhbCBjYXVnaHQgYW4gZXJyb3IgZHVyaW5nIHRoZSAke3R5cGV9IHByb2Nlc3MuXG5cblwiJHtvYmplY3RUb1N0cmluZy5jYWxsKGNhdXNlKX1cIlxuXG5Gb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIGNoZWNrIHRoZSBcImNhdXNlXCIgcHJvcGVydHkgb2YgdGhpcyBlcnJvci5gO1xufVxudmFyIFNlcm92YWxFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBjYXVzZSkge1xuICAgIHN1cGVyKGdldEVycm9yTWVzc2FnZSh0eXBlLCBjYXVzZSkpO1xuICAgIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxufTtcbnZhciBTZXJvdmFsUGFyc2VyRXJyb3IgPSBjbGFzcyBleHRlbmRzIFNlcm92YWxFcnJvciB7XG4gIGNvbnN0cnVjdG9yKGNhdXNlKSB7XG4gICAgc3VwZXIoXCJwYXJzaW5nXCIsIGNhdXNlKTtcbiAgfVxufTtcbnZhciBTZXJvdmFsU2VyaWFsaXphdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBTZXJvdmFsRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSkge1xuICAgIHN1cGVyKFwic2VyaWFsaXphdGlvblwiLCBjYXVzZSk7XG4gIH1cbn07XG52YXIgU2Vyb3ZhbERlc2VyaWFsaXphdGlvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBTZXJvdmFsRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihjYXVzZSkge1xuICAgIHN1cGVyKFwiZGVzZXJpYWxpemF0aW9uXCIsIGNhdXNlKTtcbiAgfVxufTtcbnZhciBTZXJvdmFsVW5zdXBwb3J0ZWRUeXBlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihcbiAgICAgIGBUaGUgdmFsdWUgJHtvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKX0gb2YgdHlwZSBcIiR7dHlwZW9mIHZhbHVlfVwiIGNhbm5vdCBiZSBwYXJzZWQvc2VyaWFsaXplZC5cbiAgICAgIFxuVGhlcmUgYXJlIGZldyB3b3JrYXJvdW5kcyBmb3IgdGhpcyBwcm9ibGVtOlxuLSBUcmFuc2Zvcm0gdGhlIHZhbHVlIGluIGEgd2F5IHRoYXQgaXQgY2FuIGJlIHNlcmlhbGl6ZWQuXG4tIElmIHRoZSByZWZlcmVuY2UgaXMgcHJlc2VudCBvbiBtdWx0aXBsZSBydW50aW1lcyAoaXNvbW9ycGhpYyksIHlvdSBjYW4gdXNlIHRoZSBSZWZlcmVuY2UgQVBJIHRvIG1hcCB0aGUgcmVmZXJlbmNlcy5gXG4gICAgKTtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbn07XG52YXIgU2Vyb3ZhbFVuc3VwcG9ydGVkTm9kZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBzdXBlcignVW5zdXBwb3J0ZWQgbm9kZSB0eXBlIFwiJyArIG5vZGUudCArICdcIi4nKTtcbiAgfVxufTtcbnZhciBTZXJvdmFsTWlzc2luZ1BsdWdpbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHRhZykge1xuICAgIHN1cGVyKCdNaXNzaW5nIHBsdWdpbiBmb3IgdGFnIFwiJyArIHRhZyArICdcIi4nKTtcbiAgfVxufTtcbnZhciBTZXJvdmFsTWlzc2luZ0luc3RhbmNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodGFnKSB7XG4gICAgc3VwZXIoJ01pc3NpbmcgXCInICsgdGFnICsgJ1wiIGluc3RhbmNlLicpO1xuICB9XG59O1xudmFyIFNlcm92YWxNaXNzaW5nUmVmZXJlbmNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IodmFsdWUpIHtcbiAgICBzdXBlcihcbiAgICAgICdNaXNzaW5nIHJlZmVyZW5jZSBmb3IgdGhlIHZhbHVlIFwiJyArIG9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpICsgJ1wiIG9mIHR5cGUgXCInICsgdHlwZW9mIHZhbHVlICsgJ1wiJ1xuICAgICk7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB9XG59O1xudmFyIFNlcm92YWxNaXNzaW5nUmVmZXJlbmNlRm9ySWRFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihpZCkge1xuICAgIHN1cGVyKCdNaXNzaW5nIHJlZmVyZW5jZSBmb3IgaWQgXCInICsgc2VyaWFsaXplU3RyaW5nKGlkKSArICdcIicpO1xuICB9XG59O1xudmFyIFNlcm92YWxVbmtub3duVHlwZWRBcnJheUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG5hbWUpIHtcbiAgICBzdXBlcignVW5rbm93biBUeXBlZEFycmF5IFwiJyArIG5hbWUgKyAnXCInKTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvY29udGV4dC9wYXJzZXIudHNcbnZhciBCYXNlUGFyc2VyQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMubWFya2VkID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgICB0aGlzLnBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7XG4gICAgdGhpcy5mZWF0dXJlcyA9IEFMTF9FTkFCTEVEIF4gKG9wdGlvbnMuZGlzYWJsZWRGZWF0dXJlcyB8fCAwKTtcbiAgICB0aGlzLnJlZnMgPSBvcHRpb25zLnJlZnMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBtYXJrUmVmKGlkKSB7XG4gICAgdGhpcy5tYXJrZWQuYWRkKGlkKTtcbiAgfVxuICBpc01hcmtlZChpZCkge1xuICAgIHJldHVybiB0aGlzLm1hcmtlZC5oYXMoaWQpO1xuICB9XG4gIGdldEluZGV4ZWRWYWx1ZShjdXJyZW50KSB7XG4gICAgY29uc3QgcmVnaXN0ZXJlZElkID0gdGhpcy5yZWZzLmdldChjdXJyZW50KTtcbiAgICBpZiAocmVnaXN0ZXJlZElkICE9IG51bGwpIHtcbiAgICAgIHRoaXMubWFya1JlZihyZWdpc3RlcmVkSWQpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogMSAvKiBJbmRleGVkICovLFxuICAgICAgICB2YWx1ZTogY3JlYXRlSW5kZXhlZFZhbHVlTm9kZShyZWdpc3RlcmVkSWQpXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBpZCA9IHRoaXMucmVmcy5zaXplO1xuICAgIHRoaXMucmVmcy5zZXQoY3VycmVudCwgaWQpO1xuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiAwIC8qIEZyZXNoICovLFxuICAgICAgdmFsdWU6IGlkXG4gICAgfTtcbiAgfVxuICBnZXRSZWZlcmVuY2UoY3VycmVudCkge1xuICAgIGNvbnN0IGluZGV4ZWQgPSB0aGlzLmdldEluZGV4ZWRWYWx1ZShjdXJyZW50KTtcbiAgICBpZiAoaW5kZXhlZC50eXBlID09PSAxIC8qIEluZGV4ZWQgKi8pIHtcbiAgICAgIHJldHVybiBpbmRleGVkO1xuICAgIH1cbiAgICBpZiAoaGFzUmVmZXJlbmNlSUQoY3VycmVudCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6IDIgLyogUmVmZXJlbmNlZCAqLyxcbiAgICAgICAgdmFsdWU6IGNyZWF0ZVJlZmVyZW5jZU5vZGUoaW5kZXhlZC52YWx1ZSwgY3VycmVudClcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBpbmRleGVkO1xuICB9XG4gIGdldFN0cmljdFJlZmVyZW5jZShjdXJyZW50KSB7XG4gICAgYXNzZXJ0KGhhc1JlZmVyZW5jZUlEKGN1cnJlbnQpLCBuZXcgU2Vyb3ZhbFVuc3VwcG9ydGVkVHlwZUVycm9yKGN1cnJlbnQpKTtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEluZGV4ZWRWYWx1ZShjdXJyZW50KTtcbiAgICBpZiAocmVzdWx0LnR5cGUgPT09IDEgLyogSW5kZXhlZCAqLykge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVJlZmVyZW5jZU5vZGUocmVzdWx0LnZhbHVlLCBjdXJyZW50KTtcbiAgfVxuICBwYXJzZUZ1bmN0aW9uKGN1cnJlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRTdHJpY3RSZWZlcmVuY2UoY3VycmVudCk7XG4gIH1cbiAgcGFyc2VXZWxsS25vd25TeW1ib2woY3VycmVudCkge1xuICAgIGNvbnN0IHJlZiA9IHRoaXMuZ2V0UmVmZXJlbmNlKGN1cnJlbnQpO1xuICAgIGlmIChyZWYudHlwZSAhPT0gMCAvKiBGcmVzaCAqLykge1xuICAgICAgcmV0dXJuIHJlZi52YWx1ZTtcbiAgICB9XG4gICAgYXNzZXJ0KGN1cnJlbnQgaW4gSU5WX1NZTUJPTF9SRUYsIG5ldyBTZXJvdmFsVW5zdXBwb3J0ZWRUeXBlRXJyb3IoY3VycmVudCkpO1xuICAgIHJldHVybiBjcmVhdGVXS1N5bWJvbE5vZGUocmVmLnZhbHVlLCBjdXJyZW50KTtcbiAgfVxuICBwYXJzZVNwZWNpYWxSZWZlcmVuY2UocmVmKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRJbmRleGVkVmFsdWUoU1BFQ0lBTF9SRUZTW3JlZl0pO1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gMSAvKiBJbmRleGVkICovKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdDogMjYgLyogU3BlY2lhbFJlZmVyZW5jZSAqLyxcbiAgICAgIGk6IHJlc3VsdC52YWx1ZSxcbiAgICAgIHM6IHJlZixcbiAgICAgIGw6IHZvaWQgMCxcbiAgICAgIGM6IHZvaWQgMCxcbiAgICAgIG06IHZvaWQgMCxcbiAgICAgIHA6IHZvaWQgMCxcbiAgICAgIGU6IHZvaWQgMCxcbiAgICAgIGE6IHZvaWQgMCxcbiAgICAgIGY6IHZvaWQgMCxcbiAgICAgIGI6IHZvaWQgMCxcbiAgICAgIG86IHZvaWQgMFxuICAgIH07XG4gIH1cbiAgcGFyc2VJdGVyYXRvckZhY3RvcnkoKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5nZXRJbmRleGVkVmFsdWUoSVRFUkFUT1IpO1xuICAgIGlmIChyZXN1bHQudHlwZSA9PT0gMSAvKiBJbmRleGVkICovKSB7XG4gICAgICByZXR1cm4gcmVzdWx0LnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdDogMjcgLyogSXRlcmF0b3JGYWN0b3J5ICovLFxuICAgICAgaTogcmVzdWx0LnZhbHVlLFxuICAgICAgczogdm9pZCAwLFxuICAgICAgbDogdm9pZCAwLFxuICAgICAgYzogdm9pZCAwLFxuICAgICAgbTogdm9pZCAwLFxuICAgICAgcDogdm9pZCAwLFxuICAgICAgZTogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwLFxuICAgICAgZjogdGhpcy5wYXJzZVdlbGxLbm93blN5bWJvbChTeW1ib2wuaXRlcmF0b3IpLFxuICAgICAgYjogdm9pZCAwLFxuICAgICAgbzogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBwYXJzZUFzeW5jSXRlcmF0b3JGYWN0b3J5KCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZ2V0SW5kZXhlZFZhbHVlKEFTWU5DX0lURVJBVE9SKTtcbiAgICBpZiAocmVzdWx0LnR5cGUgPT09IDEgLyogSW5kZXhlZCAqLykge1xuICAgICAgcmV0dXJuIHJlc3VsdC52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHQ6IDI5IC8qIEFzeW5jSXRlcmF0b3JGYWN0b3J5ICovLFxuICAgICAgaTogcmVzdWx0LnZhbHVlLFxuICAgICAgczogdm9pZCAwLFxuICAgICAgbDogdm9pZCAwLFxuICAgICAgYzogdm9pZCAwLFxuICAgICAgbTogdm9pZCAwLFxuICAgICAgcDogdm9pZCAwLFxuICAgICAgZTogdm9pZCAwLFxuICAgICAgYTogW1xuICAgICAgICB0aGlzLnBhcnNlU3BlY2lhbFJlZmVyZW5jZSgxIC8qIFByb21pc2VDb25zdHJ1Y3RvciAqLyksXG4gICAgICAgIHRoaXMucGFyc2VXZWxsS25vd25TeW1ib2woU3ltYm9sLmFzeW5jSXRlcmF0b3IpXG4gICAgICBdLFxuICAgICAgZjogdm9pZCAwLFxuICAgICAgYjogdm9pZCAwLFxuICAgICAgbzogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjcmVhdGVPYmplY3ROb2RlKGlkLCBjdXJyZW50LCBlbXB0eSwgcmVjb3JkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHQ6IGVtcHR5ID8gMTEgLyogTnVsbENvbnN0cnVjdG9yICovIDogMTAgLyogT2JqZWN0ICovLFxuICAgICAgaTogaWQsXG4gICAgICBzOiB2b2lkIDAsXG4gICAgICBsOiB2b2lkIDAsXG4gICAgICBjOiB2b2lkIDAsXG4gICAgICBtOiB2b2lkIDAsXG4gICAgICBwOiByZWNvcmQsXG4gICAgICBlOiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDAsXG4gICAgICBmOiB2b2lkIDAsXG4gICAgICBiOiB2b2lkIDAsXG4gICAgICBvOiBnZXRPYmplY3RGbGFnKGN1cnJlbnQpXG4gICAgfTtcbiAgfVxuICBjcmVhdGVNYXBOb2RlKGlkLCBrLCB2LCBzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHQ6IDggLyogTWFwICovLFxuICAgICAgaTogaWQsXG4gICAgICBzOiB2b2lkIDAsXG4gICAgICBsOiB2b2lkIDAsXG4gICAgICBjOiB2b2lkIDAsXG4gICAgICBtOiB2b2lkIDAsXG4gICAgICBwOiB2b2lkIDAsXG4gICAgICBlOiB7IGssIHYsIHMgfSxcbiAgICAgIGE6IHZvaWQgMCxcbiAgICAgIGY6IHRoaXMucGFyc2VTcGVjaWFsUmVmZXJlbmNlKDAgLyogTWFwU2VudGluZWwgKi8pLFxuICAgICAgYjogdm9pZCAwLFxuICAgICAgbzogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjcmVhdGVQcm9taXNlQ29uc3RydWN0b3JOb2RlKGlkKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHQ6IDIyIC8qIFByb21pc2VDb25zdHJ1Y3RvciAqLyxcbiAgICAgIGk6IGlkLFxuICAgICAgczogdm9pZCAwLFxuICAgICAgbDogdm9pZCAwLFxuICAgICAgYzogdm9pZCAwLFxuICAgICAgbTogdm9pZCAwLFxuICAgICAgcDogdm9pZCAwLFxuICAgICAgZTogdm9pZCAwLFxuICAgICAgYTogdm9pZCAwLFxuICAgICAgZjogdGhpcy5wYXJzZVNwZWNpYWxSZWZlcmVuY2UoMSAvKiBQcm9taXNlQ29uc3RydWN0b3IgKi8pLFxuICAgICAgYjogdm9pZCAwLFxuICAgICAgbzogdm9pZCAwXG4gICAgfTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvdXRpbHMvcHJvbWlzZS10by1yZXN1bHQudHNcbmFzeW5jIGZ1bmN0aW9uIHByb21pc2VUb1Jlc3VsdChjdXJyZW50KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIFsxLCBhd2FpdCBjdXJyZW50XTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBbMCwgZV07XG4gIH1cbn1cblxuLy8gc3JjL2NvcmUvdXRpbHMvZGVmZXJyZWQudHNcbmZ1bmN0aW9uIGNyZWF0ZURlZmVycmVkKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlOiBuZXcgUHJvbWlzZSgocmVzLCByZWopID0+IHtcbiAgICAgIHJlc29sdmUgPSByZXM7XG4gICAgICByZWplY3QgPSByZWo7XG4gICAgfSksXG4gICAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgfSxcbiAgICByZWplY3QodmFsdWUpIHtcbiAgICAgIHJlamVjdCh2YWx1ZSk7XG4gICAgfVxuICB9O1xufVxuXG4vLyBzcmMvY29yZS9zdHJlYW0udHNcbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbHVlKSB7XG4gIHJldHVybiBcIl9fU0VST1ZBTF9TVFJFQU1fX1wiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtKCkge1xuICBjb25zdCBsaXN0ZW5lcnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBidWZmZXIgPSBbXTtcbiAgbGV0IGFsaXZlID0gdHJ1ZTtcbiAgbGV0IHN1Y2Nlc3MgPSBmYWxzZTtcbiAgZnVuY3Rpb24gZmx1c2hOZXh0KHZhbHVlKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMua2V5cygpKSB7XG4gICAgICBsaXN0ZW5lci5uZXh0KHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gZmx1c2hUaHJvdyh2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzLmtleXMoKSkge1xuICAgICAgbGlzdGVuZXIudGhyb3codmFsdWUpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBmbHVzaFJldHVybih2YWx1ZSkge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgbGlzdGVuZXJzLmtleXMoKSkge1xuICAgICAgbGlzdGVuZXIucmV0dXJuKHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBfX1NFUk9WQUxfU1RSRUFNX186IHRydWUsXG4gICAgb24obGlzdGVuZXIpIHtcbiAgICAgIGlmIChhbGl2ZSkge1xuICAgICAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBidWZmZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBidWZmZXJbaV07XG4gICAgICAgIGlmIChpID09PSBsZW4gLSAxKSB7XG4gICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnJldHVybih2YWx1ZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxpc3RlbmVyLnRocm93KHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbGlzdGVuZXIubmV4dCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChhbGl2ZSkge1xuICAgICAgICAgIGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG4gICAgbmV4dCh2YWx1ZSkge1xuICAgICAgaWYgKGFsaXZlKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgZmx1c2hOZXh0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHRocm93KHZhbHVlKSB7XG4gICAgICBpZiAoYWxpdmUpIHtcbiAgICAgICAgYnVmZmVyLnB1c2godmFsdWUpO1xuICAgICAgICBmbHVzaFRocm93KHZhbHVlKTtcbiAgICAgICAgYWxpdmUgPSBmYWxzZTtcbiAgICAgICAgc3VjY2VzcyA9IGZhbHNlO1xuICAgICAgICBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHJldHVybih2YWx1ZSkge1xuICAgICAgaWYgKGFsaXZlKSB7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgZmx1c2hSZXR1cm4odmFsdWUpO1xuICAgICAgICBhbGl2ZSA9IGZhbHNlO1xuICAgICAgICBzdWNjZXNzID0gdHJ1ZTtcbiAgICAgICAgbGlzdGVuZXJzLmNsZWFyKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlU3RyZWFtRnJvbUFzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgY29uc3Qgc3RyZWFtID0gY3JlYXRlU3RyZWFtKCk7XG4gIGNvbnN0IGl0ZXJhdG9yID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIGFzeW5jIGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHZhbHVlID0gYXdhaXQgaXRlcmF0b3IubmV4dCgpO1xuICAgICAgaWYgKHZhbHVlLmRvbmUpIHtcbiAgICAgICAgc3RyZWFtLnJldHVybih2YWx1ZS52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdHJlYW0ubmV4dCh2YWx1ZS52YWx1ZSk7XG4gICAgICAgIGF3YWl0IHB1c2goKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgc3RyZWFtLnRocm93KGVycm9yKTtcbiAgICB9XG4gIH1cbiAgcHVzaCgpLmNhdGNoKCgpID0+IHtcbiAgfSk7XG4gIHJldHVybiBzdHJlYW07XG59XG5mdW5jdGlvbiBzdHJlYW1Ub0FzeW5jSXRlcmFibGUoc3RyZWFtKSB7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29uc3QgYnVmZmVyID0gW107XG4gICAgY29uc3QgcGVuZGluZyA9IFtdO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgbGV0IGRvbmVBdCA9IC0xO1xuICAgIGxldCBpc1Rocm93ID0gZmFsc2U7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZUFsbCgpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBwZW5kaW5nLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHBlbmRpbmdbaV0ucmVzb2x2ZSh7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHN0cmVhbS5vbih7XG4gICAgICBuZXh0KHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgY3VycmVudC5yZXNvbHZlKHsgZG9uZTogZmFsc2UsIHZhbHVlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICB0aHJvdyh2YWx1ZSkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gcGVuZGluZy5zaGlmdCgpO1xuICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgIGN1cnJlbnQucmVqZWN0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlQWxsKCk7XG4gICAgICAgIGRvbmVBdCA9IGJ1ZmZlci5sZW5ndGg7XG4gICAgICAgIGJ1ZmZlci5wdXNoKHZhbHVlKTtcbiAgICAgICAgaXNUaHJvdyA9IHRydWU7XG4gICAgICB9LFxuICAgICAgcmV0dXJuKHZhbHVlKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBwZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgY3VycmVudC5yZXNvbHZlKHsgZG9uZTogdHJ1ZSwgdmFsdWUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzb2x2ZUFsbCgpO1xuICAgICAgICBkb25lQXQgPSBidWZmZXIubGVuZ3RoO1xuICAgICAgICBidWZmZXIucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgZnVuY3Rpb24gZmluYWxpemUoKSB7XG4gICAgICBjb25zdCBjdXJyZW50ID0gY291bnQrKztcbiAgICAgIGNvbnN0IHZhbHVlID0gYnVmZmVyW2N1cnJlbnRdO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IGRvbmVBdCkge1xuICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWUgfTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1Rocm93KSB7XG4gICAgICAgIHRocm93IHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGlmIChkb25lQXQgPT09IC0xKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudCA9IGNvdW50Kys7XG4gICAgICAgICAgaWYgKGN1cnJlbnQgPj0gYnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgZGVmZXJyZWQgPSBjcmVhdGVEZWZlcnJlZCgpO1xuICAgICAgICAgICAgcGVuZGluZy5wdXNoKGRlZmVycmVkKTtcbiAgICAgICAgICAgIHJldHVybiBhd2FpdCBkZWZlcnJlZC5wcm9taXNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4geyBkb25lOiBmYWxzZSwgdmFsdWU6IGJ1ZmZlcltjdXJyZW50XSB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb3VudCA+IGRvbmVBdCkge1xuICAgICAgICAgIHJldHVybiB7IGRvbmU6IHRydWUsIHZhbHVlOiB2b2lkIDAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmluYWxpemUoKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xufVxuXG4vLyBzcmMvY29yZS9jb250ZXh0L3BhcnNlci9hc3luYy50c1xudmFyIEJhc2VBc3luY1BhcnNlckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIEJhc2VQYXJzZXJDb250ZXh0IHtcbiAgYXN5bmMgcGFyc2VJdGVtcyhjdXJyZW50KSB7XG4gICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3VycmVudC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgaWYgKGkgaW4gY3VycmVudCkge1xuICAgICAgICBub2Rlc1tpXSA9IGF3YWl0IHRoaXMucGFyc2UoY3VycmVudFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2RlcztcbiAgfVxuICBhc3luYyBwYXJzZUFycmF5KGlkLCBjdXJyZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFycmF5Tm9kZShpZCwgY3VycmVudCwgYXdhaXQgdGhpcy5wYXJzZUl0ZW1zKGN1cnJlbnQpKTtcbiAgfVxuICBhc3luYyBwYXJzZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKTtcbiAgICBjb25zdCBrZXlOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlTm9kZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5Tm9kZXMucHVzaChzZXJpYWxpemVTdHJpbmcoZW50cmllc1tpXVswXSkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKGF3YWl0IHRoaXMucGFyc2UoZW50cmllc1tpXVsxXSkpO1xuICAgIH1cbiAgICBsZXQgc3ltYm9sID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgIGlmIChzeW1ib2wgaW4gcHJvcGVydGllcykge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKHN5bWJvbCkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKFxuICAgICAgICBjcmVhdGVJdGVyYXRvckZhY3RvcnlJbnN0YW5jZU5vZGUoXG4gICAgICAgICAgdGhpcy5wYXJzZUl0ZXJhdG9yRmFjdG9yeSgpLFxuICAgICAgICAgIGF3YWl0IHRoaXMucGFyc2UoXG4gICAgICAgICAgICBpdGVyYXRvclRvU2VxdWVuY2UocHJvcGVydGllcylcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHN5bWJvbCA9IFN5bWJvbC5hc3luY0l0ZXJhdG9yO1xuICAgIGlmIChzeW1ib2wgaW4gcHJvcGVydGllcykge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKHN5bWJvbCkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKFxuICAgICAgICBjcmVhdGVBc3luY0l0ZXJhdG9yRmFjdG9yeUluc3RhbmNlTm9kZShcbiAgICAgICAgICB0aGlzLnBhcnNlQXN5bmNJdGVyYXRvckZhY3RvcnkoKSxcbiAgICAgICAgICBhd2FpdCB0aGlzLnBhcnNlKFxuICAgICAgICAgICAgY3JlYXRlU3RyZWFtRnJvbUFzeW5jSXRlcmFibGUoXG4gICAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHN5bWJvbCA9IFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICBpZiAoc3ltYm9sIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGtleU5vZGVzLnB1c2godGhpcy5wYXJzZVdlbGxLbm93blN5bWJvbChzeW1ib2wpKTtcbiAgICAgIHZhbHVlTm9kZXMucHVzaChjcmVhdGVTdHJpbmdOb2RlKHByb3BlcnRpZXNbc3ltYm9sXSkpO1xuICAgIH1cbiAgICBzeW1ib2wgPSBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlO1xuICAgIGlmIChzeW1ib2wgaW4gcHJvcGVydGllcykge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKHN5bWJvbCkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKHByb3BlcnRpZXNbc3ltYm9sXSA/IFRSVUVfTk9ERSA6IEZBTFNFX05PREUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgazoga2V5Tm9kZXMsXG4gICAgICB2OiB2YWx1ZU5vZGVzLFxuICAgICAgczoga2V5Tm9kZXMubGVuZ3RoXG4gICAgfTtcbiAgfVxuICBhc3luYyBwYXJzZVBsYWluT2JqZWN0KGlkLCBjdXJyZW50LCBlbXB0eSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZU9iamVjdE5vZGUoXG4gICAgICBpZCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBlbXB0eSxcbiAgICAgIGF3YWl0IHRoaXMucGFyc2VQcm9wZXJ0aWVzKGN1cnJlbnQpXG4gICAgKTtcbiAgfVxuICBhc3luYyBwYXJzZUJveGVkKGlkLCBjdXJyZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJveGVkTm9kZShpZCwgYXdhaXQgdGhpcy5wYXJzZShjdXJyZW50LnZhbHVlT2YoKSkpO1xuICB9XG4gIGFzeW5jIHBhcnNlVHlwZWRBcnJheShpZCwgY3VycmVudCkge1xuICAgIHJldHVybiBjcmVhdGVUeXBlZEFycmF5Tm9kZShpZCwgY3VycmVudCwgYXdhaXQgdGhpcy5wYXJzZShjdXJyZW50LmJ1ZmZlcikpO1xuICB9XG4gIGFzeW5jIHBhcnNlQmlnSW50VHlwZWRBcnJheShpZCwgY3VycmVudCkge1xuICAgIHJldHVybiBjcmVhdGVCaWdJbnRUeXBlZEFycmF5Tm9kZShcbiAgICAgIGlkLFxuICAgICAgY3VycmVudCxcbiAgICAgIGF3YWl0IHRoaXMucGFyc2UoY3VycmVudC5idWZmZXIpXG4gICAgKTtcbiAgfVxuICBhc3luYyBwYXJzZURhdGFWaWV3KGlkLCBjdXJyZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZURhdGFWaWV3Tm9kZShpZCwgY3VycmVudCwgYXdhaXQgdGhpcy5wYXJzZShjdXJyZW50LmJ1ZmZlcikpO1xuICB9XG4gIGFzeW5jIHBhcnNlRXJyb3IoaWQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0RXJyb3JPcHRpb25zKGN1cnJlbnQsIHRoaXMuZmVhdHVyZXMpO1xuICAgIHJldHVybiBjcmVhdGVFcnJvck5vZGUoXG4gICAgICBpZCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBvcHRpb25zID8gYXdhaXQgdGhpcy5wYXJzZVByb3BlcnRpZXMob3B0aW9ucykgOiB2b2lkIDBcbiAgICApO1xuICB9XG4gIGFzeW5jIHBhcnNlQWdncmVnYXRlRXJyb3IoaWQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBvcHRpb25zID0gZ2V0RXJyb3JPcHRpb25zKGN1cnJlbnQsIHRoaXMuZmVhdHVyZXMpO1xuICAgIHJldHVybiBjcmVhdGVBZ2dyZWdhdGVFcnJvck5vZGUoXG4gICAgICBpZCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBvcHRpb25zID8gYXdhaXQgdGhpcy5wYXJzZVByb3BlcnRpZXMob3B0aW9ucykgOiB2b2lkIDBcbiAgICApO1xuICB9XG4gIGFzeW5jIHBhcnNlTWFwKGlkLCBjdXJyZW50KSB7XG4gICAgY29uc3Qga2V5Tm9kZXMgPSBbXTtcbiAgICBjb25zdCB2YWx1ZU5vZGVzID0gW107XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgY3VycmVudC5lbnRyaWVzKCkpIHtcbiAgICAgIGtleU5vZGVzLnB1c2goYXdhaXQgdGhpcy5wYXJzZShrZXkpKTtcbiAgICAgIHZhbHVlTm9kZXMucHVzaChhd2FpdCB0aGlzLnBhcnNlKHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNyZWF0ZU1hcE5vZGUoaWQsIGtleU5vZGVzLCB2YWx1ZU5vZGVzLCBjdXJyZW50LnNpemUpO1xuICB9XG4gIGFzeW5jIHBhcnNlU2V0KGlkLCBjdXJyZW50KSB7XG4gICAgY29uc3QgaXRlbXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgY3VycmVudC5rZXlzKCkpIHtcbiAgICAgIGl0ZW1zLnB1c2goYXdhaXQgdGhpcy5wYXJzZShpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVTZXROb2RlKGlkLCBjdXJyZW50LnNpemUsIGl0ZW1zKTtcbiAgfVxuICBhc3luYyBwYXJzZVByb21pc2UoaWQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBbc3RhdHVzLCByZXN1bHRdID0gYXdhaXQgcHJvbWlzZVRvUmVzdWx0KGN1cnJlbnQpO1xuICAgIHJldHVybiB7XG4gICAgICB0OiAxMiAvKiBQcm9taXNlICovLFxuICAgICAgaTogaWQsXG4gICAgICBzOiBzdGF0dXMsXG4gICAgICBsOiB2b2lkIDAsXG4gICAgICBjOiB2b2lkIDAsXG4gICAgICBtOiB2b2lkIDAsXG4gICAgICBwOiB2b2lkIDAsXG4gICAgICBlOiB2b2lkIDAsXG4gICAgICBhOiB2b2lkIDAsXG4gICAgICBmOiBhd2FpdCB0aGlzLnBhcnNlKHJlc3VsdCksXG4gICAgICBiOiB2b2lkIDAsXG4gICAgICBvOiB2b2lkIDBcbiAgICB9O1xuICB9XG4gIGFzeW5jIHBhcnNlUGx1Z2luKGlkLCBjdXJyZW50KSB7XG4gICAgY29uc3QgY3VycmVudFBsdWdpbnMgPSB0aGlzLnBsdWdpbnM7XG4gICAgaWYgKGN1cnJlbnRQbHVnaW5zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3VycmVudFBsdWdpbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gY3VycmVudFBsdWdpbnNbaV07XG4gICAgICAgIGlmIChwbHVnaW4ucGFyc2UuYXN5bmMgJiYgcGx1Z2luLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUGx1Z2luTm9kZShcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGx1Z2luLnRhZyxcbiAgICAgICAgICAgIGF3YWl0IHBsdWdpbi5wYXJzZS5hc3luYyhjdXJyZW50LCB0aGlzLCB7XG4gICAgICAgICAgICAgIGlkXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBhc3luYyBwYXJzZVN0cmVhbShpZCwgY3VycmVudCkge1xuICAgIHJldHVybiBjcmVhdGVTdHJlYW1Db25zdHJ1Y3Rvck5vZGUoXG4gICAgICBpZCxcbiAgICAgIHRoaXMucGFyc2VTcGVjaWFsUmVmZXJlbmNlKDQgLyogU3RyZWFtQ29uc3RydWN0b3IgKi8pLFxuICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCBzZXF1ZW5jZSA9IFtdO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gY3VycmVudC5vbih7XG4gICAgICAgICAgbmV4dDogKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm1hcmtSZWYoaWQpO1xuICAgICAgICAgICAgdGhpcy5wYXJzZSh2YWx1ZSkudGhlbihcbiAgICAgICAgICAgICAgKGRhdGEpID0+IHtcbiAgICAgICAgICAgICAgICBzZXF1ZW5jZS5wdXNoKGNyZWF0ZVN0cmVhbU5leHROb2RlKGlkLCBkYXRhKSk7XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGRhdGEpO1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIHRocm93OiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMubWFya1JlZihpZCk7XG4gICAgICAgICAgICB0aGlzLnBhcnNlKHZhbHVlKS50aGVuKFxuICAgICAgICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHNlcXVlbmNlLnB1c2goY3JlYXRlU3RyZWFtVGhyb3dOb2RlKGlkLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZXF1ZW5jZSk7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChkYXRhKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZXR1cm46ICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tYXJrUmVmKGlkKTtcbiAgICAgICAgICAgIHRoaXMucGFyc2UodmFsdWUpLnRoZW4oXG4gICAgICAgICAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgc2VxdWVuY2UucHVzaChjcmVhdGVTdHJlYW1SZXR1cm5Ob2RlKGlkLCBkYXRhKSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShzZXF1ZW5jZSk7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHJlamVjdChkYXRhKTtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBhc3luYyBwYXJzZU9iamVjdChpZCwgY3VycmVudCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUFycmF5KGlkLCBjdXJyZW50KTtcbiAgICB9XG4gICAgaWYgKGlzU3RyZWFtKGN1cnJlbnQpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVN0cmVhbShpZCwgY3VycmVudCk7XG4gICAgfVxuICAgIGNvbnN0IHBhcnNlZCA9IGF3YWl0IHRoaXMucGFyc2VQbHVnaW4oaWQsIGN1cnJlbnQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHJldHVybiBwYXJzZWQ7XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRDbGFzcyA9IGN1cnJlbnQuY29uc3RydWN0b3I7XG4gICAgc3dpdGNoIChjdXJyZW50Q2xhc3MpIHtcbiAgICAgIGNhc2UgT2JqZWN0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWluT2JqZWN0KFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgZmFsc2VcbiAgICAgICAgKTtcbiAgICAgIGNhc2Ugdm9pZCAwOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWluT2JqZWN0KFxuICAgICAgICAgIGlkLFxuICAgICAgICAgIGN1cnJlbnQsXG4gICAgICAgICAgdHJ1ZVxuICAgICAgICApO1xuICAgICAgY2FzZSBEYXRlOlxuICAgICAgICByZXR1cm4gY3JlYXRlRGF0ZU5vZGUoaWQsIGN1cnJlbnQpO1xuICAgICAgY2FzZSBSZWdFeHA6XG4gICAgICAgIHJldHVybiBjcmVhdGVSZWdFeHBOb2RlKGlkLCBjdXJyZW50KTtcbiAgICAgIGNhc2UgRXJyb3I6XG4gICAgICBjYXNlIEV2YWxFcnJvcjpcbiAgICAgIGNhc2UgUmFuZ2VFcnJvcjpcbiAgICAgIGNhc2UgUmVmZXJlbmNlRXJyb3I6XG4gICAgICBjYXNlIFN5bnRheEVycm9yOlxuICAgICAgY2FzZSBUeXBlRXJyb3I6XG4gICAgICBjYXNlIFVSSUVycm9yOlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKGlkLCBjdXJyZW50KTtcbiAgICAgIGNhc2UgTnVtYmVyOlxuICAgICAgY2FzZSBCb29sZWFuOlxuICAgICAgY2FzZSBTdHJpbmc6XG4gICAgICBjYXNlIEJpZ0ludDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCb3hlZChpZCwgY3VycmVudCk7XG4gICAgICBjYXNlIEFycmF5QnVmZmVyOlxuICAgICAgICByZXR1cm4gY3JlYXRlQXJyYXlCdWZmZXJOb2RlKGlkLCBjdXJyZW50KTtcbiAgICAgIGNhc2UgSW50OEFycmF5OlxuICAgICAgY2FzZSBJbnQxNkFycmF5OlxuICAgICAgY2FzZSBJbnQzMkFycmF5OlxuICAgICAgY2FzZSBVaW50OEFycmF5OlxuICAgICAgY2FzZSBVaW50MTZBcnJheTpcbiAgICAgIGNhc2UgVWludDMyQXJyYXk6XG4gICAgICBjYXNlIFVpbnQ4Q2xhbXBlZEFycmF5OlxuICAgICAgY2FzZSBGbG9hdDMyQXJyYXk6XG4gICAgICBjYXNlIEZsb2F0NjRBcnJheTpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VUeXBlZEFycmF5KGlkLCBjdXJyZW50KTtcbiAgICAgIGNhc2UgRGF0YVZpZXc6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRGF0YVZpZXcoaWQsIGN1cnJlbnQpO1xuICAgICAgY2FzZSBNYXA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlTWFwKGlkLCBjdXJyZW50KTtcbiAgICAgIGNhc2UgU2V0OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVNldChpZCwgY3VycmVudCk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgaWYgKGN1cnJlbnRDbGFzcyA9PT0gUHJvbWlzZSB8fCBjdXJyZW50IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VQcm9taXNlKGlkLCBjdXJyZW50KTtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEZlYXR1cmVzID0gdGhpcy5mZWF0dXJlcztcbiAgICBpZiAoY3VycmVudEZlYXR1cmVzICYgMTYgLyogQmlnSW50VHlwZWRBcnJheSAqLykge1xuICAgICAgc3dpdGNoIChjdXJyZW50Q2xhc3MpIHtcbiAgICAgICAgY2FzZSBCaWdJbnQ2NEFycmF5OlxuICAgICAgICBjYXNlIEJpZ1VpbnQ2NEFycmF5OlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlQmlnSW50VHlwZWRBcnJheShcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgY3VycmVudFxuICAgICAgICAgICk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjdXJyZW50RmVhdHVyZXMgJiAxIC8qIEFnZ3JlZ2F0ZUVycm9yICovICYmIHR5cGVvZiBBZ2dyZWdhdGVFcnJvciAhPT0gXCJ1bmRlZmluZWRcIiAmJiAoY3VycmVudENsYXNzID09PSBBZ2dyZWdhdGVFcnJvciB8fCBjdXJyZW50IGluc3RhbmNlb2YgQWdncmVnYXRlRXJyb3IpKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUFnZ3JlZ2F0ZUVycm9yKGlkLCBjdXJyZW50KTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcihpZCwgY3VycmVudCk7XG4gICAgfVxuICAgIGlmIChTeW1ib2wuaXRlcmF0b3IgaW4gY3VycmVudCB8fCBTeW1ib2wuYXN5bmNJdGVyYXRvciBpbiBjdXJyZW50KSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVBsYWluT2JqZWN0KGlkLCBjdXJyZW50LCAhIWN1cnJlbnRDbGFzcyk7XG4gICAgfVxuICAgIHRocm93IG5ldyBTZXJvdmFsVW5zdXBwb3J0ZWRUeXBlRXJyb3IoY3VycmVudCk7XG4gIH1cbiAgYXN5bmMgcGFyc2UoY3VycmVudCkge1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKHR5cGVvZiBjdXJyZW50KSB7XG4gICAgICAgIGNhc2UgXCJib29sZWFuXCI6XG4gICAgICAgICAgcmV0dXJuIGN1cnJlbnQgPyBUUlVFX05PREUgOiBGQUxTRV9OT0RFO1xuICAgICAgICBjYXNlIFwidW5kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIFVOREVGSU5FRF9OT0RFO1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVN0cmluZ05vZGUoY3VycmVudCk7XG4gICAgICAgIGNhc2UgXCJudW1iZXJcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlTnVtYmVyTm9kZShjdXJyZW50KTtcbiAgICAgICAgY2FzZSBcImJpZ2ludFwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVCaWdJbnROb2RlKGN1cnJlbnQpO1xuICAgICAgICBjYXNlIFwib2JqZWN0XCI6IHtcbiAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgY29uc3QgcmVmID0gdGhpcy5nZXRSZWZlcmVuY2UoY3VycmVudCk7XG4gICAgICAgICAgICByZXR1cm4gcmVmLnR5cGUgPT09IDAgPyBhd2FpdCB0aGlzLnBhcnNlT2JqZWN0KHJlZi52YWx1ZSwgY3VycmVudCkgOiByZWYudmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBOVUxMX05PREU7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInN5bWJvbFwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKGN1cnJlbnQpO1xuICAgICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUZ1bmN0aW9uKGN1cnJlbnQpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXJvdmFsVW5zdXBwb3J0ZWRUeXBlRXJyb3IoY3VycmVudCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBTZXJvdmFsUGFyc2VyRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvdHJlZS9hc3luYy50c1xudmFyIEFzeW5jUGFyc2VyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgQmFzZUFzeW5jUGFyc2VyQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tb2RlID0gXCJ2YW5pbGxhXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL3V0aWxzL3R5cGVkLWFycmF5LnRzXG5mdW5jdGlvbiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IobmFtZSkge1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFwiSW50OEFycmF5XCI6XG4gICAgICByZXR1cm4gSW50OEFycmF5O1xuICAgIGNhc2UgXCJJbnQxNkFycmF5XCI6XG4gICAgICByZXR1cm4gSW50MTZBcnJheTtcbiAgICBjYXNlIFwiSW50MzJBcnJheVwiOlxuICAgICAgcmV0dXJuIEludDMyQXJyYXk7XG4gICAgY2FzZSBcIlVpbnQ4QXJyYXlcIjpcbiAgICAgIHJldHVybiBVaW50OEFycmF5O1xuICAgIGNhc2UgXCJVaW50MTZBcnJheVwiOlxuICAgICAgcmV0dXJuIFVpbnQxNkFycmF5O1xuICAgIGNhc2UgXCJVaW50MzJBcnJheVwiOlxuICAgICAgcmV0dXJuIFVpbnQzMkFycmF5O1xuICAgIGNhc2UgXCJVaW50OENsYW1wZWRBcnJheVwiOlxuICAgICAgcmV0dXJuIFVpbnQ4Q2xhbXBlZEFycmF5O1xuICAgIGNhc2UgXCJGbG9hdDMyQXJyYXlcIjpcbiAgICAgIHJldHVybiBGbG9hdDMyQXJyYXk7XG4gICAgY2FzZSBcIkZsb2F0NjRBcnJheVwiOlxuICAgICAgcmV0dXJuIEZsb2F0NjRBcnJheTtcbiAgICBjYXNlIFwiQmlnSW50NjRBcnJheVwiOlxuICAgICAgcmV0dXJuIEJpZ0ludDY0QXJyYXk7XG4gICAgY2FzZSBcIkJpZ1VpbnQ2NEFycmF5XCI6XG4gICAgICByZXR1cm4gQmlnVWludDY0QXJyYXk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBTZXJvdmFsVW5rbm93blR5cGVkQXJyYXlFcnJvcihuYW1lKTtcbiAgfVxufVxuXG4vLyBzcmMvY29yZS9jb250ZXh0L2Rlc2VyaWFsaXplci50c1xuZnVuY3Rpb24gYXBwbHlPYmplY3RGbGFnKG9iaiwgZmxhZykge1xuICBzd2l0Y2ggKGZsYWcpIHtcbiAgICBjYXNlIDMgLyogRnJvemVuICovOlxuICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqKTtcbiAgICBjYXNlIDEgLyogTm9uRXh0ZW5zaWJsZSAqLzpcbiAgICAgIHJldHVybiBPYmplY3QucHJldmVudEV4dGVuc2lvbnMob2JqKTtcbiAgICBjYXNlIDIgLyogU2VhbGVkICovOlxuICAgICAgcmV0dXJuIE9iamVjdC5zZWFsKG9iaik7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBvYmo7XG4gIH1cbn1cbnZhciBCYXNlRGVzZXJpYWxpemVyQ29udGV4dCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMucGx1Z2lucyA9IG9wdGlvbnMucGx1Z2lucztcbiAgICB0aGlzLnJlZnMgPSBvcHRpb25zLnJlZnMgfHwgLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgfVxuICBkZXNlcmlhbGl6ZVJlZmVyZW5jZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKFxuICAgICAgbm9kZS5pLFxuICAgICAgZ2V0UmVmZXJlbmNlKGRlc2VyaWFsaXplU3RyaW5nKG5vZGUucykpXG4gICAgKTtcbiAgfVxuICBkZXNlcmlhbGl6ZUFycmF5KG5vZGUpIHtcbiAgICBjb25zdCBsZW4gPSBub2RlLmw7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUoXG4gICAgICBub2RlLmksXG4gICAgICBuZXcgQXJyYXkobGVuKVxuICAgICk7XG4gICAgbGV0IGl0ZW07XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgaXRlbSA9IG5vZGUuYVtpXTtcbiAgICAgIGlmIChpdGVtKSB7XG4gICAgICAgIHJlc3VsdFtpXSA9IHRoaXMuZGVzZXJpYWxpemUoaXRlbSk7XG4gICAgICB9XG4gICAgfVxuICAgIGFwcGx5T2JqZWN0RmxhZyhyZXN1bHQsIG5vZGUubyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZXNlcmlhbGl6ZVByb3BlcnRpZXMobm9kZSwgcmVzdWx0KSB7XG4gICAgY29uc3QgbGVuID0gbm9kZS5zO1xuICAgIGlmIChsZW4pIHtcbiAgICAgIGNvbnN0IGtleXMgPSBub2RlLms7XG4gICAgICBjb25zdCB2YWxzID0gbm9kZS52O1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGtleTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICAgIGlmICh0eXBlb2Yga2V5ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgcmVzdWx0W2Rlc2VyaWFsaXplU3RyaW5nKGtleSldID0gdGhpcy5kZXNlcmlhbGl6ZSh2YWxzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHRbdGhpcy5kZXNlcmlhbGl6ZShrZXkpXSA9IHRoaXMuZGVzZXJpYWxpemUodmFsc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZXNlcmlhbGl6ZU9iamVjdChub2RlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUoXG4gICAgICBub2RlLmksXG4gICAgICBub2RlLnQgPT09IDEwIC8qIE9iamVjdCAqLyA/IHt9IDogLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbClcbiAgICApO1xuICAgIHRoaXMuZGVzZXJpYWxpemVQcm9wZXJ0aWVzKG5vZGUucCwgcmVzdWx0KTtcbiAgICBhcHBseU9iamVjdEZsYWcocmVzdWx0LCBub2RlLm8pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVzZXJpYWxpemVEYXRlKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCBuZXcgRGF0ZShub2RlLnMpKTtcbiAgfVxuICBkZXNlcmlhbGl6ZVJlZ0V4cChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKFxuICAgICAgbm9kZS5pLFxuICAgICAgbmV3IFJlZ0V4cChkZXNlcmlhbGl6ZVN0cmluZyhub2RlLmMpLCBub2RlLm0pXG4gICAgKTtcbiAgfVxuICBkZXNlcmlhbGl6ZVNldChub2RlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcbiAgICBjb25zdCBpdGVtcyA9IG5vZGUuYTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gbm9kZS5sOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdC5hZGQodGhpcy5kZXNlcmlhbGl6ZShpdGVtc1tpXSkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlc2VyaWFsaXplTWFwKG5vZGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShub2RlLmksIC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCkpO1xuICAgIGNvbnN0IGtleXMgPSBub2RlLmUuaztcbiAgICBjb25zdCB2YWxzID0gbm9kZS5lLnY7XG4gICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IG5vZGUuZS5zOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdC5zZXQodGhpcy5kZXNlcmlhbGl6ZShrZXlzW2ldKSwgdGhpcy5kZXNlcmlhbGl6ZSh2YWxzW2ldKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVzZXJpYWxpemVBcnJheUJ1ZmZlcihub2RlKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShub2RlLnMpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKG5vZGUuaSwgYnl0ZXMuYnVmZmVyKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGRlc2VyaWFsaXplVHlwZWRBcnJheShub2RlKSB7XG4gICAgY29uc3QgY29uc3RydWN0ID0gZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKG5vZGUuYyk7XG4gICAgY29uc3Qgc291cmNlID0gdGhpcy5kZXNlcmlhbGl6ZShub2RlLmYpO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKFxuICAgICAgbm9kZS5pLFxuICAgICAgbmV3IGNvbnN0cnVjdChzb3VyY2UsIG5vZGUuYiwgbm9kZS5sKVxuICAgICk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZXNlcmlhbGl6ZURhdGFWaWV3KG5vZGUpIHtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmRlc2VyaWFsaXplKG5vZGUuZik7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUoXG4gICAgICBub2RlLmksXG4gICAgICBuZXcgRGF0YVZpZXcoc291cmNlLCBub2RlLmIsIG5vZGUubClcbiAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVzZXJpYWxpemVEaWN0aW9uYXJ5KG5vZGUsIHJlc3VsdCkge1xuICAgIGlmIChub2RlLnApIHtcbiAgICAgIGNvbnN0IGZpZWxkcyA9IHRoaXMuZGVzZXJpYWxpemVQcm9wZXJ0aWVzKG5vZGUucCwge30pO1xuICAgICAgT2JqZWN0LmFzc2lnbihyZXN1bHQsIGZpZWxkcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgZGVzZXJpYWxpemVBZ2dyZWdhdGVFcnJvcihub2RlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUoXG4gICAgICBub2RlLmksXG4gICAgICBuZXcgQWdncmVnYXRlRXJyb3IoW10sIGRlc2VyaWFsaXplU3RyaW5nKG5vZGUubSkpXG4gICAgKTtcbiAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZURpY3Rpb25hcnkobm9kZSwgcmVzdWx0KTtcbiAgfVxuICBkZXNlcmlhbGl6ZUVycm9yKG5vZGUpIHtcbiAgICBjb25zdCBjb25zdHJ1Y3QgPSBFUlJPUl9DT05TVFJVQ1RPUltub2RlLnNdO1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKFxuICAgICAgbm9kZS5pLFxuICAgICAgbmV3IGNvbnN0cnVjdChkZXNlcmlhbGl6ZVN0cmluZyhub2RlLm0pKVxuICAgICk7XG4gICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVEaWN0aW9uYXJ5KG5vZGUsIHJlc3VsdCk7XG4gIH1cbiAgZGVzZXJpYWxpemVQcm9taXNlKG5vZGUpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IGNyZWF0ZURlZmVycmVkKCk7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCBkZWZlcnJlZCk7XG4gICAgY29uc3QgZGVzZXJpYWxpemVkID0gdGhpcy5kZXNlcmlhbGl6ZShub2RlLmYpO1xuICAgIGlmIChub2RlLnMpIHtcbiAgICAgIGRlZmVycmVkLnJlc29sdmUoZGVzZXJpYWxpemVkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmZXJyZWQucmVqZWN0KGRlc2VyaWFsaXplZCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQucHJvbWlzZTtcbiAgfVxuICBkZXNlcmlhbGl6ZUJveGVkKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCBPYmplY3QodGhpcy5kZXNlcmlhbGl6ZShub2RlLmYpKSk7XG4gIH1cbiAgZGVzZXJpYWxpemVQbHVnaW4obm9kZSkge1xuICAgIGNvbnN0IGN1cnJlbnRQbHVnaW5zID0gdGhpcy5wbHVnaW5zO1xuICAgIGlmIChjdXJyZW50UGx1Z2lucykge1xuICAgICAgY29uc3QgdGFnID0gZGVzZXJpYWxpemVTdHJpbmcobm9kZS5jKTtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjdXJyZW50UGx1Z2lucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBjdXJyZW50UGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi50YWcgPT09IHRhZykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShcbiAgICAgICAgICAgIG5vZGUuaSxcbiAgICAgICAgICAgIHBsdWdpbi5kZXNlcmlhbGl6ZShub2RlLnMsIHRoaXMsIHtcbiAgICAgICAgICAgICAgaWQ6IG5vZGUuaVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IG5ldyBTZXJvdmFsTWlzc2luZ1BsdWdpbkVycm9yKG5vZGUuYyk7XG4gIH1cbiAgZGVzZXJpYWxpemVQcm9taXNlQ29uc3RydWN0b3Iobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShub2RlLmksIGNyZWF0ZURlZmVycmVkKCkpLnByb21pc2U7XG4gIH1cbiAgZGVzZXJpYWxpemVQcm9taXNlUmVzb2x2ZShub2RlKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLnJlZnMuZ2V0KG5vZGUuaSk7XG4gICAgYXNzZXJ0KGRlZmVycmVkLCBuZXcgU2Vyb3ZhbE1pc3NpbmdJbnN0YW5jZUVycm9yKFwiUHJvbWlzZVwiKSk7XG4gICAgZGVmZXJyZWQucmVzb2x2ZSh0aGlzLmRlc2VyaWFsaXplKG5vZGUuYVsxXSkpO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZGVzZXJpYWxpemVQcm9taXNlUmVqZWN0KG5vZGUpIHtcbiAgICBjb25zdCBkZWZlcnJlZCA9IHRoaXMucmVmcy5nZXQobm9kZS5pKTtcbiAgICBhc3NlcnQoZGVmZXJyZWQsIG5ldyBTZXJvdmFsTWlzc2luZ0luc3RhbmNlRXJyb3IoXCJQcm9taXNlXCIpKTtcbiAgICBkZWZlcnJlZC5yZWplY3QodGhpcy5kZXNlcmlhbGl6ZShub2RlLmFbMV0pKTtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIGRlc2VyaWFsaXplSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2Uobm9kZSkge1xuICAgIHRoaXMuZGVzZXJpYWxpemUobm9kZS5hWzBdKTtcbiAgICBjb25zdCBzb3VyY2UgPSB0aGlzLmRlc2VyaWFsaXplKG5vZGUuYVsxXSk7XG4gICAgcmV0dXJuIHNlcXVlbmNlVG9JdGVyYXRvcihzb3VyY2UpO1xuICB9XG4gIGRlc2VyaWFsaXplQXN5bmNJdGVyYXRvckZhY3RvcnlJbnN0YW5jZShub2RlKSB7XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShub2RlLmFbMF0pO1xuICAgIGNvbnN0IHNvdXJjZSA9IHRoaXMuZGVzZXJpYWxpemUobm9kZS5hWzFdKTtcbiAgICByZXR1cm4gc3RyZWFtVG9Bc3luY0l0ZXJhYmxlKHNvdXJjZSk7XG4gIH1cbiAgZGVzZXJpYWxpemVTdHJlYW1Db25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCBjcmVhdGVTdHJlYW0oKSk7XG4gICAgY29uc3QgbGVuID0gbm9kZS5hLmxlbmd0aDtcbiAgICBpZiAobGVuKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHRoaXMuZGVzZXJpYWxpemUobm9kZS5hW2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBkZXNlcmlhbGl6ZVN0cmVhbU5leHQobm9kZSkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5yZWZzLmdldChub2RlLmkpO1xuICAgIGFzc2VydChkZWZlcnJlZCwgbmV3IFNlcm92YWxNaXNzaW5nSW5zdGFuY2VFcnJvcihcIlN0cmVhbVwiKSk7XG4gICAgZGVmZXJyZWQubmV4dCh0aGlzLmRlc2VyaWFsaXplKG5vZGUuZikpO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZGVzZXJpYWxpemVTdHJlYW1UaHJvdyhub2RlKSB7XG4gICAgY29uc3QgZGVmZXJyZWQgPSB0aGlzLnJlZnMuZ2V0KG5vZGUuaSk7XG4gICAgYXNzZXJ0KGRlZmVycmVkLCBuZXcgU2Vyb3ZhbE1pc3NpbmdJbnN0YW5jZUVycm9yKFwiU3RyZWFtXCIpKTtcbiAgICBkZWZlcnJlZC50aHJvdyh0aGlzLmRlc2VyaWFsaXplKG5vZGUuZikpO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZGVzZXJpYWxpemVTdHJlYW1SZXR1cm4obm9kZSkge1xuICAgIGNvbnN0IGRlZmVycmVkID0gdGhpcy5yZWZzLmdldChub2RlLmkpO1xuICAgIGFzc2VydChkZWZlcnJlZCwgbmV3IFNlcm92YWxNaXNzaW5nSW5zdGFuY2VFcnJvcihcIlN0cmVhbVwiKSk7XG4gICAgZGVmZXJyZWQucmV0dXJuKHRoaXMuZGVzZXJpYWxpemUobm9kZS5mKSk7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBkZXNlcmlhbGl6ZUl0ZXJhdG9yRmFjdG9yeShub2RlKSB7XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShub2RlLmYpO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZGVzZXJpYWxpemVBc3luY0l0ZXJhdG9yRmFjdG9yeShub2RlKSB7XG4gICAgdGhpcy5kZXNlcmlhbGl6ZShub2RlLmFbMV0pO1xuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgZGVzZXJpYWxpemUobm9kZSkge1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudCkge1xuICAgICAgICBjYXNlIDIgLyogQ29uc3RhbnQgKi86XG4gICAgICAgICAgcmV0dXJuIENPTlNUQU5UX1ZBTFtub2RlLnNdO1xuICAgICAgICBjYXNlIDAgLyogTnVtYmVyICovOlxuICAgICAgICAgIHJldHVybiBub2RlLnM7XG4gICAgICAgIGNhc2UgMSAvKiBTdHJpbmcgKi86XG4gICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplU3RyaW5nKG5vZGUucyk7XG4gICAgICAgIGNhc2UgMyAvKiBCaWdJbnQgKi86XG4gICAgICAgICAgcmV0dXJuIEJpZ0ludChub2RlLnMpO1xuICAgICAgICBjYXNlIDQgLyogSW5kZXhlZFZhbHVlICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnJlZnMuZ2V0KG5vZGUuaSk7XG4gICAgICAgIGNhc2UgMTggLyogUmVmZXJlbmNlICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplUmVmZXJlbmNlKG5vZGUpO1xuICAgICAgICBjYXNlIDkgLyogQXJyYXkgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVBcnJheShub2RlKTtcbiAgICAgICAgY2FzZSAxMCAvKiBPYmplY3QgKi86XG4gICAgICAgIGNhc2UgMTEgLyogTnVsbENvbnN0cnVjdG9yICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplT2JqZWN0KG5vZGUpO1xuICAgICAgICBjYXNlIDUgLyogRGF0ZSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZURhdGUobm9kZSk7XG4gICAgICAgIGNhc2UgNiAvKiBSZWdFeHAgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVSZWdFeHAobm9kZSk7XG4gICAgICAgIGNhc2UgNyAvKiBTZXQgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVTZXQobm9kZSk7XG4gICAgICAgIGNhc2UgOCAvKiBNYXAgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVNYXAobm9kZSk7XG4gICAgICAgIGNhc2UgMTkgLyogQXJyYXlCdWZmZXIgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVBcnJheUJ1ZmZlcihub2RlKTtcbiAgICAgICAgY2FzZSAxNiAvKiBCaWdJbnRUeXBlZEFycmF5ICovOlxuICAgICAgICBjYXNlIDE1IC8qIFR5cGVkQXJyYXkgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVUeXBlZEFycmF5KG5vZGUpO1xuICAgICAgICBjYXNlIDIwIC8qIERhdGFWaWV3ICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplRGF0YVZpZXcobm9kZSk7XG4gICAgICAgIGNhc2UgMTQgLyogQWdncmVnYXRlRXJyb3IgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVBZ2dyZWdhdGVFcnJvcihub2RlKTtcbiAgICAgICAgY2FzZSAxMyAvKiBFcnJvciAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUVycm9yKG5vZGUpO1xuICAgICAgICBjYXNlIDEyIC8qIFByb21pc2UgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVQcm9taXNlKG5vZGUpO1xuICAgICAgICBjYXNlIDE3IC8qIFdLU3ltYm9sICovOlxuICAgICAgICAgIHJldHVybiBTWU1CT0xfUkVGW25vZGUuc107XG4gICAgICAgIGNhc2UgMjEgLyogQm94ZWQgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVCb3hlZChub2RlKTtcbiAgICAgICAgY2FzZSAyNSAvKiBQbHVnaW4gKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVQbHVnaW4obm9kZSk7XG4gICAgICAgIGNhc2UgMjIgLyogUHJvbWlzZUNvbnN0cnVjdG9yICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplUHJvbWlzZUNvbnN0cnVjdG9yKG5vZGUpO1xuICAgICAgICBjYXNlIDIzIC8qIFByb21pc2VSZXNvbHZlICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplUHJvbWlzZVJlc29sdmUobm9kZSk7XG4gICAgICAgIGNhc2UgMjQgLyogUHJvbWlzZVJlamVjdCAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZVByb21pc2VSZWplY3Qobm9kZSk7XG4gICAgICAgIGNhc2UgMjggLyogSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2UgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVJdGVyYXRvckZhY3RvcnlJbnN0YW5jZShub2RlKTtcbiAgICAgICAgY2FzZSAzMCAvKiBBc3luY0l0ZXJhdG9yRmFjdG9yeUluc3RhbmNlICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplQXN5bmNJdGVyYXRvckZhY3RvcnlJbnN0YW5jZShub2RlKTtcbiAgICAgICAgY2FzZSAzMSAvKiBTdHJlYW1Db25zdHJ1Y3RvciAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZVN0cmVhbUNvbnN0cnVjdG9yKG5vZGUpO1xuICAgICAgICBjYXNlIDMyIC8qIFN0cmVhbU5leHQgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZGVzZXJpYWxpemVTdHJlYW1OZXh0KG5vZGUpO1xuICAgICAgICBjYXNlIDMzIC8qIFN0cmVhbVRocm93ICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplU3RyZWFtVGhyb3cobm9kZSk7XG4gICAgICAgIGNhc2UgMzQgLyogU3RyZWFtUmV0dXJuICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLmRlc2VyaWFsaXplU3RyZWFtUmV0dXJuKG5vZGUpO1xuICAgICAgICBjYXNlIDI3IC8qIEl0ZXJhdG9yRmFjdG9yeSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUl0ZXJhdG9yRmFjdG9yeShub2RlKTtcbiAgICAgICAgY2FzZSAyOSAvKiBBc3luY0l0ZXJhdG9yRmFjdG9yeSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5kZXNlcmlhbGl6ZUFzeW5jSXRlcmF0b3JGYWN0b3J5KG5vZGUpO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBTZXJvdmFsVW5zdXBwb3J0ZWROb2RlRXJyb3Iobm9kZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IG5ldyBTZXJvdmFsRGVzZXJpYWxpemF0aW9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvdHJlZS9kZXNlcmlhbGl6ZXIudHNcbnZhciBWYW5pbGxhRGVzZXJpYWxpemVyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgQmFzZURlc2VyaWFsaXplckNvbnRleHQge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5tb2RlID0gXCJ2YW5pbGxhXCI7XG4gICAgdGhpcy5tYXJrZWQgPSBuZXcgU2V0KG9wdGlvbnMubWFya2VkUmVmcyk7XG4gIH1cbiAgYXNzaWduSW5kZXhlZFZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLm1hcmtlZC5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLnJlZnMuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvdXRpbHMvaXMtdmFsaWQtaWRlbnRpZmllci50c1xudmFyIElERU5USUZJRVJfQ0hFQ0sgPSAvXlskQS1aX11bMC05QS1aXyRdKiQvaTtcbmZ1bmN0aW9uIGlzVmFsaWRJZGVudGlmaWVyKG5hbWUpIHtcbiAgY29uc3QgY2hhciA9IG5hbWVbMF07XG4gIHJldHVybiAoY2hhciA9PT0gXCIkXCIgfHwgY2hhciA9PT0gXCJfXCIgfHwgY2hhciA+PSBcIkFcIiAmJiBjaGFyIDw9IFwiWlwiIHx8IGNoYXIgPj0gXCJhXCIgJiYgY2hhciA8PSBcInpcIikgJiYgSURFTlRJRklFUl9DSEVDSy50ZXN0KG5hbWUpO1xufVxuXG4vLyBzcmMvY29yZS9jb250ZXh0L3NlcmlhbGl6ZXIudHNcbmZ1bmN0aW9uIGdldEFzc2lnbm1lbnRFeHByZXNzaW9uKGFzc2lnbm1lbnQpIHtcbiAgc3dpdGNoIChhc3NpZ25tZW50LnQpIHtcbiAgICBjYXNlIDAgLyogSW5kZXggKi86XG4gICAgICByZXR1cm4gYXNzaWdubWVudC5zICsgXCI9XCIgKyBhc3NpZ25tZW50LnY7XG4gICAgY2FzZSAyIC8qIFNldCAqLzpcbiAgICAgIHJldHVybiBhc3NpZ25tZW50LnMgKyBcIi5zZXQoXCIgKyBhc3NpZ25tZW50LmsgKyBcIixcIiArIGFzc2lnbm1lbnQudiArIFwiKVwiO1xuICAgIGNhc2UgMSAvKiBBZGQgKi86XG4gICAgICByZXR1cm4gYXNzaWdubWVudC5zICsgXCIuYWRkKFwiICsgYXNzaWdubWVudC52ICsgXCIpXCI7XG4gICAgY2FzZSAzIC8qIERlbGV0ZSAqLzpcbiAgICAgIHJldHVybiBhc3NpZ25tZW50LnMgKyBcIi5kZWxldGUoXCIgKyBhc3NpZ25tZW50LmsgKyBcIilcIjtcbiAgfVxufVxuZnVuY3Rpb24gbWVyZ2VBc3NpZ25tZW50cyhhc3NpZ25tZW50cykge1xuICBjb25zdCBuZXdBc3NpZ25tZW50cyA9IFtdO1xuICBsZXQgY3VycmVudCA9IGFzc2lnbm1lbnRzWzBdO1xuICBmb3IgKGxldCBpID0gMSwgbGVuID0gYXNzaWdubWVudHMubGVuZ3RoLCBpdGVtLCBwcmV2ID0gY3VycmVudDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaXRlbSA9IGFzc2lnbm1lbnRzW2ldO1xuICAgIGlmIChpdGVtLnQgPT09IDAgLyogSW5kZXggKi8gJiYgaXRlbS52ID09PSBwcmV2LnYpIHtcbiAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgIHQ6IDAgLyogSW5kZXggKi8sXG4gICAgICAgIHM6IGl0ZW0ucyxcbiAgICAgICAgazogdm9pZCAwLFxuICAgICAgICB2OiBnZXRBc3NpZ25tZW50RXhwcmVzc2lvbihjdXJyZW50KVxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGl0ZW0udCA9PT0gMiAvKiBTZXQgKi8gJiYgaXRlbS5zID09PSBwcmV2LnMpIHtcbiAgICAgIGN1cnJlbnQgPSB7XG4gICAgICAgIHQ6IDIgLyogU2V0ICovLFxuICAgICAgICBzOiBnZXRBc3NpZ25tZW50RXhwcmVzc2lvbihjdXJyZW50KSxcbiAgICAgICAgazogaXRlbS5rLFxuICAgICAgICB2OiBpdGVtLnZcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChpdGVtLnQgPT09IDEgLyogQWRkICovICYmIGl0ZW0ucyA9PT0gcHJldi5zKSB7XG4gICAgICBjdXJyZW50ID0ge1xuICAgICAgICB0OiAxIC8qIEFkZCAqLyxcbiAgICAgICAgczogZ2V0QXNzaWdubWVudEV4cHJlc3Npb24oY3VycmVudCksXG4gICAgICAgIGs6IHZvaWQgMCxcbiAgICAgICAgdjogaXRlbS52XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAoaXRlbS50ID09PSAzIC8qIERlbGV0ZSAqLyAmJiBpdGVtLnMgPT09IHByZXYucykge1xuICAgICAgY3VycmVudCA9IHtcbiAgICAgICAgdDogMyAvKiBEZWxldGUgKi8sXG4gICAgICAgIHM6IGdldEFzc2lnbm1lbnRFeHByZXNzaW9uKGN1cnJlbnQpLFxuICAgICAgICBrOiBpdGVtLmssXG4gICAgICAgIHY6IHZvaWQgMFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3QXNzaWdubWVudHMucHVzaChjdXJyZW50KTtcbiAgICAgIGN1cnJlbnQgPSBpdGVtO1xuICAgIH1cbiAgICBwcmV2ID0gaXRlbTtcbiAgfVxuICBuZXdBc3NpZ25tZW50cy5wdXNoKGN1cnJlbnQpO1xuICByZXR1cm4gbmV3QXNzaWdubWVudHM7XG59XG5mdW5jdGlvbiByZXNvbHZlQXNzaWdubWVudHMoYXNzaWdubWVudHMpIHtcbiAgaWYgKGFzc2lnbm1lbnRzLmxlbmd0aCkge1xuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGNvbnN0IG1lcmdlZCA9IG1lcmdlQXNzaWdubWVudHMoYXNzaWdubWVudHMpO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBtZXJnZWQubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHJlc3VsdCArPSBnZXRBc3NpZ25tZW50RXhwcmVzc2lvbihtZXJnZWRbaV0pICsgXCIsXCI7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIHZvaWQgMDtcbn1cbnZhciBOVUxMX0NPTlNUUlVDVE9SID0gXCJPYmplY3QuY3JlYXRlKG51bGwpXCI7XG52YXIgU0VUX0NPTlNUUlVDVE9SID0gXCJuZXcgU2V0XCI7XG52YXIgTUFQX0NPTlNUUlVDVE9SID0gXCJuZXcgTWFwXCI7XG52YXIgUFJPTUlTRV9SRVNPTFZFID0gXCJQcm9taXNlLnJlc29sdmVcIjtcbnZhciBQUk9NSVNFX1JFSkVDVCA9IFwiUHJvbWlzZS5yZWplY3RcIjtcbnZhciBPQkpFQ1RfRkxBR19DT05TVFJVQ1RPUiA9IHtcbiAgWzMgLyogRnJvemVuICovXTogXCJPYmplY3QuZnJlZXplXCIsXG4gIFsyIC8qIFNlYWxlZCAqL106IFwiT2JqZWN0LnNlYWxcIixcbiAgWzEgLyogTm9uRXh0ZW5zaWJsZSAqL106IFwiT2JqZWN0LnByZXZlbnRFeHRlbnNpb25zXCIsXG4gIFswIC8qIE5vbmUgKi9dOiB2b2lkIDBcbn07XG52YXIgQmFzZVNlcmlhbGl6ZXJDb250ZXh0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgLyoqXG4gICAgICogVG8gY2hlY2sgaWYgYW4gb2JqZWN0IGlzIHN5bmNocm9ub3VzbHkgcmVmZXJlbmNpbmcgaXRzZWxmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnN0YWNrID0gW107XG4gICAgLyoqXG4gICAgICogQXJyYXkgb2Ygb2JqZWN0IG11dGF0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgdGhpcy5mbGFncyA9IFtdO1xuICAgIC8qKlxuICAgICAqIEFycmF5IG9mIGFzc2lnbm1lbnRzIHRvIGJlIGRvbmUgKHVzZWQgZm9yIHJlY3Vyc2lvbilcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMuYXNzaWdubWVudHMgPSBbXTtcbiAgICB0aGlzLnBsdWdpbnMgPSBvcHRpb25zLnBsdWdpbnM7XG4gICAgdGhpcy5mZWF0dXJlcyA9IG9wdGlvbnMuZmVhdHVyZXM7XG4gICAgdGhpcy5tYXJrZWQgPSBuZXcgU2V0KG9wdGlvbnMubWFya2VkUmVmcyk7XG4gIH1cbiAgY3JlYXRlRnVuY3Rpb24ocGFyYW1ldGVycywgYm9keSkge1xuICAgIGlmICh0aGlzLmZlYXR1cmVzICYgMiAvKiBBcnJvd0Z1bmN0aW9uICovKSB7XG4gICAgICBjb25zdCBqb2luZWQgPSBwYXJhbWV0ZXJzLmxlbmd0aCA9PT0gMSA/IHBhcmFtZXRlcnNbMF0gOiBcIihcIiArIHBhcmFtZXRlcnMuam9pbihcIixcIikgKyBcIilcIjtcbiAgICAgIHJldHVybiBqb2luZWQgKyBcIj0+XCIgKyBib2R5O1xuICAgIH1cbiAgICByZXR1cm4gXCJmdW5jdGlvbihcIiArIHBhcmFtZXRlcnMuam9pbihcIixcIikgKyBcIil7cmV0dXJuIFwiICsgYm9keSArIFwifVwiO1xuICB9XG4gIGNyZWF0ZUVmZmVjdGZ1bEZ1bmN0aW9uKHBhcmFtZXRlcnMsIGJvZHkpIHtcbiAgICBpZiAodGhpcy5mZWF0dXJlcyAmIDIgLyogQXJyb3dGdW5jdGlvbiAqLykge1xuICAgICAgY29uc3Qgam9pbmVkID0gcGFyYW1ldGVycy5sZW5ndGggPT09IDEgPyBwYXJhbWV0ZXJzWzBdIDogXCIoXCIgKyBwYXJhbWV0ZXJzLmpvaW4oXCIsXCIpICsgXCIpXCI7XG4gICAgICByZXR1cm4gam9pbmVkICsgXCI9PntcIiArIGJvZHkgKyBcIn1cIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiZnVuY3Rpb24oXCIgKyBwYXJhbWV0ZXJzLmpvaW4oXCIsXCIpICsgXCIpe1wiICsgYm9keSArIFwifVwiO1xuICB9XG4gIC8qKlxuICAgKiBBIHRpbnkgZnVuY3Rpb24gdGhhdCB0ZWxscyBpZiBhIHJlZmVyZW5jZVxuICAgKiBpcyB0byBiZSBhY2Nlc3NlZC4gVGhpcyBpcyBhIHJlcXVpcmVtZW50IGZvclxuICAgKiBkZWNpZGluZyB3aGV0aGVyIG9yIG5vdCB3ZSBzaG91bGQgZ2VuZXJhdGVcbiAgICogYW4gaWRlbnRpZmllciBmb3IgdGhlIG9iamVjdFxuICAgKi9cbiAgbWFya1JlZihpZCkge1xuICAgIHRoaXMubWFya2VkLmFkZChpZCk7XG4gIH1cbiAgaXNNYXJrZWQoaWQpIHtcbiAgICByZXR1cm4gdGhpcy5tYXJrZWQuaGFzKGlkKTtcbiAgfVxuICBwdXNoT2JqZWN0RmxhZyhmbGFnLCBpZCkge1xuICAgIGlmIChmbGFnICE9PSAwIC8qIE5vbmUgKi8pIHtcbiAgICAgIHRoaXMubWFya1JlZihpZCk7XG4gICAgICB0aGlzLmZsYWdzLnB1c2goe1xuICAgICAgICB0eXBlOiBmbGFnLFxuICAgICAgICB2YWx1ZTogdGhpcy5nZXRSZWZQYXJhbShpZClcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXNvbHZlRmxhZ3MoKSB7XG4gICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDAsIGN1cnJlbnQgPSB0aGlzLmZsYWdzLCBsZW4gPSBjdXJyZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBjb25zdCBmbGFnID0gY3VycmVudFtpXTtcbiAgICAgIHJlc3VsdCArPSBPQkpFQ1RfRkxBR19DT05TVFJVQ1RPUltmbGFnLnR5cGVdICsgXCIoXCIgKyBmbGFnLnZhbHVlICsgXCIpLFwiO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIHJlc29sdmVQYXRjaGVzKCkge1xuICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gcmVzb2x2ZUFzc2lnbm1lbnRzKHRoaXMuYXNzaWdubWVudHMpO1xuICAgIGNvbnN0IGZsYWdzID0gdGhpcy5yZXNvbHZlRmxhZ3MoKTtcbiAgICBpZiAoYXNzaWdubWVudHMpIHtcbiAgICAgIGlmIChmbGFncykge1xuICAgICAgICByZXR1cm4gYXNzaWdubWVudHMgKyBmbGFncztcbiAgICAgIH1cbiAgICAgIHJldHVybiBhc3NpZ25tZW50cztcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdzO1xuICB9XG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgdGhlIGlubGluZWQgYXNzaWdubWVudCBmb3IgdGhlIHJlZmVyZW5jZVxuICAgKiBUaGlzIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBhc3NpZ25tZW50cyBhcnJheSBhcyB0aGlzIG9uZVxuICAgKiBzaWduaWZpZXMgY3JlYXRpb24gcmF0aGVyIHRoYW4gbXV0YXRpb25cbiAgICovXG4gIGNyZWF0ZUFzc2lnbm1lbnQoc291cmNlLCB2YWx1ZSkge1xuICAgIHRoaXMuYXNzaWdubWVudHMucHVzaCh7XG4gICAgICB0OiAwIC8qIEluZGV4ICovLFxuICAgICAgczogc291cmNlLFxuICAgICAgazogdm9pZCAwLFxuICAgICAgdjogdmFsdWVcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVBZGRBc3NpZ25tZW50KHJlZiwgdmFsdWUpIHtcbiAgICB0aGlzLmFzc2lnbm1lbnRzLnB1c2goe1xuICAgICAgdDogMSAvKiBBZGQgKi8sXG4gICAgICBzOiB0aGlzLmdldFJlZlBhcmFtKHJlZiksXG4gICAgICBrOiB2b2lkIDAsXG4gICAgICB2OiB2YWx1ZVxuICAgIH0pO1xuICB9XG4gIGNyZWF0ZVNldEFzc2lnbm1lbnQocmVmLCBrZXksIHZhbHVlKSB7XG4gICAgdGhpcy5hc3NpZ25tZW50cy5wdXNoKHtcbiAgICAgIHQ6IDIgLyogU2V0ICovLFxuICAgICAgczogdGhpcy5nZXRSZWZQYXJhbShyZWYpLFxuICAgICAgazoga2V5LFxuICAgICAgdjogdmFsdWVcbiAgICB9KTtcbiAgfVxuICBjcmVhdGVEZWxldGVBc3NpZ25tZW50KHJlZiwga2V5KSB7XG4gICAgdGhpcy5hc3NpZ25tZW50cy5wdXNoKHtcbiAgICAgIHQ6IDMgLyogRGVsZXRlICovLFxuICAgICAgczogdGhpcy5nZXRSZWZQYXJhbShyZWYpLFxuICAgICAgazoga2V5LFxuICAgICAgdjogdm9pZCAwXG4gICAgfSk7XG4gIH1cbiAgY3JlYXRlQXJyYXlBc3NpZ24ocmVmLCBpbmRleCwgdmFsdWUpIHtcbiAgICB0aGlzLmNyZWF0ZUFzc2lnbm1lbnQodGhpcy5nZXRSZWZQYXJhbShyZWYpICsgXCJbXCIgKyBpbmRleCArIFwiXVwiLCB2YWx1ZSk7XG4gIH1cbiAgY3JlYXRlT2JqZWN0QXNzaWduKHJlZiwga2V5LCB2YWx1ZSkge1xuICAgIHRoaXMuY3JlYXRlQXNzaWdubWVudCh0aGlzLmdldFJlZlBhcmFtKHJlZikgKyBcIi5cIiArIGtleSwgdmFsdWUpO1xuICB9XG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIHZhbHVlIGlzIGluIHRoZSBzdGFjay4gU3RhY2sgaGVyZSBpcyBhIHJlZmVyZW5jZVxuICAgKiBzdHJ1Y3R1cmUgdG8ga25vdyBpZiBhIG9iamVjdCBpcyB0byBiZSBhY2Nlc3NlZCBpbiBhIFREWi5cbiAgICovXG4gIGlzSW5kZXhlZFZhbHVlSW5TdGFjayhub2RlKSB7XG4gICAgcmV0dXJuIG5vZGUudCA9PT0gNCAvKiBJbmRleGVkVmFsdWUgKi8gJiYgdGhpcy5zdGFjay5pbmNsdWRlcyhub2RlLmkpO1xuICB9XG4gIHNlcmlhbGl6ZVJlZmVyZW5jZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKFxuICAgICAgbm9kZS5pLFxuICAgICAgUkVGRVJFTkNFU19LRVkgKyAnLmdldChcIicgKyBub2RlLnMgKyAnXCIpJ1xuICAgICk7XG4gIH1cbiAgc2VyaWFsaXplQXJyYXlJdGVtKGlkLCBpdGVtLCBpbmRleCkge1xuICAgIGlmIChpdGVtKSB7XG4gICAgICBpZiAodGhpcy5pc0luZGV4ZWRWYWx1ZUluU3RhY2soaXRlbSkpIHtcbiAgICAgICAgdGhpcy5tYXJrUmVmKGlkKTtcbiAgICAgICAgdGhpcy5jcmVhdGVBcnJheUFzc2lnbihcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBpbmRleCxcbiAgICAgICAgICB0aGlzLmdldFJlZlBhcmFtKGl0ZW0uaSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoaXRlbSk7XG4gICAgfVxuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIHNlcmlhbGl6ZUFycmF5KG5vZGUpIHtcbiAgICBjb25zdCBpZCA9IG5vZGUuaTtcbiAgICBpZiAobm9kZS5sKSB7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goaWQpO1xuICAgICAgY29uc3QgbGlzdCA9IG5vZGUuYTtcbiAgICAgIGxldCB2YWx1ZXMgPSB0aGlzLnNlcmlhbGl6ZUFycmF5SXRlbShpZCwgbGlzdFswXSwgMCk7XG4gICAgICBsZXQgaXNIb2xleSA9IHZhbHVlcyA9PT0gXCJcIjtcbiAgICAgIGZvciAobGV0IGkgPSAxLCBsZW4gPSBub2RlLmwsIGl0ZW07IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtID0gdGhpcy5zZXJpYWxpemVBcnJheUl0ZW0oaWQsIGxpc3RbaV0sIGkpO1xuICAgICAgICB2YWx1ZXMgKz0gXCIsXCIgKyBpdGVtO1xuICAgICAgICBpc0hvbGV5ID0gaXRlbSA9PT0gXCJcIjtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICB0aGlzLnB1c2hPYmplY3RGbGFnKG5vZGUubywgbm9kZS5pKTtcbiAgICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShpZCwgXCJbXCIgKyB2YWx1ZXMgKyAoaXNIb2xleSA/IFwiLF1cIiA6IFwiXVwiKSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShpZCwgXCJbXVwiKTtcbiAgfVxuICBzZXJpYWxpemVQcm9wZXJ0eShzb3VyY2UsIGtleSwgdmFsKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGNvbnN0IGNoZWNrID0gTnVtYmVyKGtleSk7XG4gICAgICBjb25zdCBpc0lkZW50aWZpZXIgPSAoXG4gICAgICAgIC8vIFRlc3QgaWYga2V5IGlzIGEgdmFsaWQgcG9zaXRpdmUgbnVtYmVyIG9yIEpTIGlkZW50aWZpZXJcbiAgICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHNlcmlhbGl6ZSB0aGUga2V5IGFuZCB3cmFwIHdpdGggYnJhY2tldHNcbiAgICAgICAgY2hlY2sgPj0gMCAmJiAvLyBJdCdzIGFsc28gaW1wb3J0YW50IHRvIGNvbnNpZGVyIHRoYXQgaWYgdGhlIGtleSBpc1xuICAgICAgICAvLyBpbmRlZWQgbnVtZXJpYywgd2UgbmVlZCB0byBtYWtlIHN1cmUgdGhhdCB3aGVuXG4gICAgICAgIC8vIGNvbnZlcnRlZCBiYWNrIGludG8gYSBzdHJpbmcsIGl0J3Mgc3RpbGwgdGhlIHNhbWVcbiAgICAgICAgLy8gdG8gdGhlIG9yaWdpbmFsIGtleS4gVGhpcyBhbGxvd3MgdXMgdG8gZGlmZmVyZW50aWF0ZVxuICAgICAgICAvLyBrZXlzIHRoYXQgaGFzIG51bWVyaWMgZm9ybWF0cyBidXQgaW4gYSBkaWZmZXJlbnRcbiAgICAgICAgLy8gZm9ybWF0LCB3aGljaCBjYW4gY2F1c2UgdW5pbnRlbnRpb25hbCBrZXkgZGVjbGFyYXRpb25cbiAgICAgICAgLy8gRXhhbXBsZTogeyAweDE6IDEgfSB2cyB7ICcweDEnOiAxIH1cbiAgICAgICAgY2hlY2sudG9TdHJpbmcoKSA9PT0ga2V5IHx8IGlzVmFsaWRJZGVudGlmaWVyKGtleSlcbiAgICAgICk7XG4gICAgICBpZiAodGhpcy5pc0luZGV4ZWRWYWx1ZUluU3RhY2sodmFsKSkge1xuICAgICAgICBjb25zdCByZWZQYXJhbSA9IHRoaXMuZ2V0UmVmUGFyYW0odmFsLmkpO1xuICAgICAgICB0aGlzLm1hcmtSZWYoc291cmNlLmkpO1xuICAgICAgICBpZiAoaXNJZGVudGlmaWVyICYmIGNoZWNrICE9PSBjaGVjaykge1xuICAgICAgICAgIHRoaXMuY3JlYXRlT2JqZWN0QXNzaWduKHNvdXJjZS5pLCBrZXksIHJlZlBhcmFtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmNyZWF0ZUFycmF5QXNzaWduKFxuICAgICAgICAgICAgc291cmNlLmksXG4gICAgICAgICAgICBpc0lkZW50aWZpZXIgPyBrZXkgOiAnXCInICsga2V5ICsgJ1wiJyxcbiAgICAgICAgICAgIHJlZlBhcmFtXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoaXNJZGVudGlmaWVyID8ga2V5IDogJ1wiJyArIGtleSArICdcIicpICsgXCI6XCIgKyB0aGlzLnNlcmlhbGl6ZSh2YWwpO1xuICAgIH1cbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLnNlcmlhbGl6ZShrZXkpICsgXCJdOlwiICsgdGhpcy5zZXJpYWxpemUodmFsKTtcbiAgfVxuICBzZXJpYWxpemVQcm9wZXJ0aWVzKHNvdXJjZSwgcmVjb3JkKSB7XG4gICAgY29uc3QgbGVuID0gcmVjb3JkLnM7XG4gICAgaWYgKGxlbikge1xuICAgICAgY29uc3Qga2V5cyA9IHJlY29yZC5rO1xuICAgICAgY29uc3QgdmFsdWVzID0gcmVjb3JkLnY7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goc291cmNlLmkpO1xuICAgICAgbGV0IHJlc3VsdCA9IHRoaXMuc2VyaWFsaXplUHJvcGVydHkoc291cmNlLCBrZXlzWzBdLCB2YWx1ZXNbMF0pO1xuICAgICAgZm9yIChsZXQgaSA9IDEsIGl0ZW0gPSByZXN1bHQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBpdGVtID0gdGhpcy5zZXJpYWxpemVQcm9wZXJ0eShzb3VyY2UsIGtleXNbaV0sIHZhbHVlc1tpXSk7XG4gICAgICAgIHJlc3VsdCArPSAoaXRlbSAmJiByZXN1bHQgJiYgXCIsXCIpICsgaXRlbTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICByZXR1cm4gXCJ7XCIgKyByZXN1bHQgKyBcIn1cIjtcbiAgICB9XG4gICAgcmV0dXJuIFwie31cIjtcbiAgfVxuICBzZXJpYWxpemVPYmplY3Qobm9kZSkge1xuICAgIHRoaXMucHVzaE9iamVjdEZsYWcobm9kZS5vLCBub2RlLmkpO1xuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShcbiAgICAgIG5vZGUuaSxcbiAgICAgIHRoaXMuc2VyaWFsaXplUHJvcGVydGllcyhub2RlLCBub2RlLnApXG4gICAgKTtcbiAgfVxuICBzZXJpYWxpemVXaXRoT2JqZWN0QXNzaWduKHNvdXJjZSwgdmFsdWUsIHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnNlcmlhbGl6ZVByb3BlcnRpZXMoc291cmNlLCB2YWx1ZSk7XG4gICAgaWYgKGZpZWxkcyAhPT0gXCJ7fVwiKSB7XG4gICAgICByZXR1cm4gXCJPYmplY3QuYXNzaWduKFwiICsgc2VyaWFsaXplZCArIFwiLFwiICsgZmllbGRzICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG4gIHNlcmlhbGl6ZVN0cmluZ0tleUFzc2lnbm1lbnQoc291cmNlLCBtYWluQXNzaWdubWVudHMsIGtleSwgdmFsdWUpIHtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgIGNvbnN0IGNoZWNrID0gTnVtYmVyKGtleSk7XG4gICAgY29uc3QgaXNJZGVudGlmaWVyID0gKFxuICAgICAgLy8gVGVzdCBpZiBrZXkgaXMgYSB2YWxpZCBwb3NpdGl2ZSBudW1iZXIgb3IgSlMgaWRlbnRpZmllclxuICAgICAgLy8gc28gdGhhdCB3ZSBkb24ndCBoYXZlIHRvIHNlcmlhbGl6ZSB0aGUga2V5IGFuZCB3cmFwIHdpdGggYnJhY2tldHNcbiAgICAgIGNoZWNrID49IDAgJiYgLy8gSXQncyBhbHNvIGltcG9ydGFudCB0byBjb25zaWRlciB0aGF0IGlmIHRoZSBrZXkgaXNcbiAgICAgIC8vIGluZGVlZCBudW1lcmljLCB3ZSBuZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IHdoZW5cbiAgICAgIC8vIGNvbnZlcnRlZCBiYWNrIGludG8gYSBzdHJpbmcsIGl0J3Mgc3RpbGwgdGhlIHNhbWVcbiAgICAgIC8vIHRvIHRoZSBvcmlnaW5hbCBrZXkuIFRoaXMgYWxsb3dzIHVzIHRvIGRpZmZlcmVudGlhdGVcbiAgICAgIC8vIGtleXMgdGhhdCBoYXMgbnVtZXJpYyBmb3JtYXRzIGJ1dCBpbiBhIGRpZmZlcmVudFxuICAgICAgLy8gZm9ybWF0LCB3aGljaCBjYW4gY2F1c2UgdW5pbnRlbnRpb25hbCBrZXkgZGVjbGFyYXRpb25cbiAgICAgIC8vIEV4YW1wbGU6IHsgMHgxOiAxIH0gdnMgeyAnMHgxJzogMSB9XG4gICAgICBjaGVjay50b1N0cmluZygpID09PSBrZXkgfHwgaXNWYWxpZElkZW50aWZpZXIoa2V5KVxuICAgICk7XG4gICAgaWYgKHRoaXMuaXNJbmRleGVkVmFsdWVJblN0YWNrKHZhbHVlKSkge1xuICAgICAgaWYgKGlzSWRlbnRpZmllciAmJiBjaGVjayAhPT0gY2hlY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVPYmplY3RBc3NpZ24oc291cmNlLmksIGtleSwgc2VyaWFsaXplZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNyZWF0ZUFycmF5QXNzaWduKFxuICAgICAgICAgIHNvdXJjZS5pLFxuICAgICAgICAgIGlzSWRlbnRpZmllciA/IGtleSA6ICdcIicgKyBrZXkgKyAnXCInLFxuICAgICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcGFyZW50QXNzaWdubWVudCA9IHRoaXMuYXNzaWdubWVudHM7XG4gICAgICB0aGlzLmFzc2lnbm1lbnRzID0gbWFpbkFzc2lnbm1lbnRzO1xuICAgICAgaWYgKGlzSWRlbnRpZmllciAmJiBjaGVjayAhPT0gY2hlY2spIHtcbiAgICAgICAgdGhpcy5jcmVhdGVPYmplY3RBc3NpZ24oc291cmNlLmksIGtleSwgc2VyaWFsaXplZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmNyZWF0ZUFycmF5QXNzaWduKFxuICAgICAgICAgIHNvdXJjZS5pLFxuICAgICAgICAgIGlzSWRlbnRpZmllciA/IGtleSA6ICdcIicgKyBrZXkgKyAnXCInLFxuICAgICAgICAgIHNlcmlhbGl6ZWRcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXNzaWdubWVudHMgPSBwYXJlbnRBc3NpZ25tZW50O1xuICAgIH1cbiAgfVxuICBzZXJpYWxpemVBc3NpZ25tZW50KHNvdXJjZSwgbWFpbkFzc2lnbm1lbnRzLCBrZXksIHZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRoaXMuc2VyaWFsaXplU3RyaW5nS2V5QXNzaWdubWVudChzb3VyY2UsIG1haW5Bc3NpZ25tZW50cywga2V5LCB2YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuc3RhY2s7XG4gICAgICB0aGlzLnN0YWNrID0gW107XG4gICAgICBjb25zdCBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemUodmFsdWUpO1xuICAgICAgdGhpcy5zdGFjayA9IHBhcmVudDtcbiAgICAgIGNvbnN0IHBhcmVudEFzc2lnbm1lbnQgPSB0aGlzLmFzc2lnbm1lbnRzO1xuICAgICAgdGhpcy5hc3NpZ25tZW50cyA9IG1haW5Bc3NpZ25tZW50cztcbiAgICAgIHRoaXMuY3JlYXRlQXJyYXlBc3NpZ24oc291cmNlLmksIHRoaXMuc2VyaWFsaXplKGtleSksIHNlcmlhbGl6ZWQpO1xuICAgICAgdGhpcy5hc3NpZ25tZW50cyA9IHBhcmVudEFzc2lnbm1lbnQ7XG4gICAgfVxuICB9XG4gIHNlcmlhbGl6ZUFzc2lnbm1lbnRzKHNvdXJjZSwgbm9kZSkge1xuICAgIGNvbnN0IGxlbiA9IG5vZGUucztcbiAgICBpZiAobGVuKSB7XG4gICAgICBjb25zdCBtYWluQXNzaWdubWVudHMgPSBbXTtcbiAgICAgIGNvbnN0IGtleXMgPSBub2RlLms7XG4gICAgICBjb25zdCB2YWx1ZXMgPSBub2RlLnY7XG4gICAgICB0aGlzLnN0YWNrLnB1c2goc291cmNlLmkpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB0aGlzLnNlcmlhbGl6ZUFzc2lnbm1lbnQoc291cmNlLCBtYWluQXNzaWdubWVudHMsIGtleXNbaV0sIHZhbHVlc1tpXSk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgcmV0dXJuIHJlc29sdmVBc3NpZ25tZW50cyhtYWluQXNzaWdubWVudHMpO1xuICAgIH1cbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHNlcmlhbGl6ZURpY3Rpb25hcnkobm9kZSwgaW5pdCkge1xuICAgIGlmIChub2RlLnApIHtcbiAgICAgIGlmICh0aGlzLmZlYXR1cmVzICYgOCAvKiBPYmplY3RBc3NpZ24gKi8pIHtcbiAgICAgICAgaW5pdCA9IHRoaXMuc2VyaWFsaXplV2l0aE9iamVjdEFzc2lnbihub2RlLCBub2RlLnAsIGluaXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5tYXJrUmVmKG5vZGUuaSk7XG4gICAgICAgIGNvbnN0IGFzc2lnbm1lbnRzID0gdGhpcy5zZXJpYWxpemVBc3NpZ25tZW50cyhub2RlLCBub2RlLnApO1xuICAgICAgICBpZiAoYXNzaWdubWVudHMpIHtcbiAgICAgICAgICByZXR1cm4gXCIoXCIgKyB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShub2RlLmksIGluaXQpICsgXCIsXCIgKyBhc3NpZ25tZW50cyArIHRoaXMuZ2V0UmVmUGFyYW0obm9kZS5pKSArIFwiKVwiO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShub2RlLmksIGluaXQpO1xuICB9XG4gIHNlcmlhbGl6ZU51bGxDb25zdHJ1Y3Rvcihub2RlKSB7XG4gICAgdGhpcy5wdXNoT2JqZWN0RmxhZyhub2RlLm8sIG5vZGUuaSk7XG4gICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplRGljdGlvbmFyeShub2RlLCBOVUxMX0NPTlNUUlVDVE9SKTtcbiAgfVxuICBzZXJpYWxpemVEYXRlKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCAnbmV3IERhdGUoXCInICsgbm9kZS5zICsgJ1wiKScpO1xuICB9XG4gIHNlcmlhbGl6ZVJlZ0V4cChub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKG5vZGUuaSwgXCIvXCIgKyBub2RlLmMgKyBcIi9cIiArIG5vZGUubSk7XG4gIH1cbiAgc2VyaWFsaXplU2V0SXRlbShpZCwgaXRlbSkge1xuICAgIGlmICh0aGlzLmlzSW5kZXhlZFZhbHVlSW5TdGFjayhpdGVtKSkge1xuICAgICAgdGhpcy5tYXJrUmVmKGlkKTtcbiAgICAgIHRoaXMuY3JlYXRlQWRkQXNzaWdubWVudChcbiAgICAgICAgaWQsXG4gICAgICAgIHRoaXMuZ2V0UmVmUGFyYW0oaXRlbS5pKVxuICAgICAgKTtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXJpYWxpemUoaXRlbSk7XG4gIH1cbiAgc2VyaWFsaXplU2V0KG5vZGUpIHtcbiAgICBsZXQgc2VyaWFsaXplZCA9IFNFVF9DT05TVFJVQ1RPUjtcbiAgICBjb25zdCBzaXplID0gbm9kZS5sO1xuICAgIGNvbnN0IGlkID0gbm9kZS5pO1xuICAgIGlmIChzaXplKSB7XG4gICAgICBjb25zdCBpdGVtcyA9IG5vZGUuYTtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChpZCk7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zZXJpYWxpemVTZXRJdGVtKGlkLCBpdGVtc1swXSk7XG4gICAgICBmb3IgKGxldCBpID0gMSwgaXRlbSA9IHJlc3VsdDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBpdGVtID0gdGhpcy5zZXJpYWxpemVTZXRJdGVtKGlkLCBpdGVtc1tpXSk7XG4gICAgICAgIHJlc3VsdCArPSAoaXRlbSAmJiByZXN1bHQgJiYgXCIsXCIpICsgaXRlbTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gXCIoW1wiICsgcmVzdWx0ICsgXCJdKVwiO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUoaWQsIHNlcmlhbGl6ZWQpO1xuICB9XG4gIHNlcmlhbGl6ZU1hcEVudHJ5KGlkLCBrZXksIHZhbCwgc2VudGluZWwpIHtcbiAgICBpZiAodGhpcy5pc0luZGV4ZWRWYWx1ZUluU3RhY2soa2V5KSkge1xuICAgICAgY29uc3Qga2V5UmVmID0gdGhpcy5nZXRSZWZQYXJhbShrZXkuaSk7XG4gICAgICB0aGlzLm1hcmtSZWYoaWQpO1xuICAgICAgaWYgKHRoaXMuaXNJbmRleGVkVmFsdWVJblN0YWNrKHZhbCkpIHtcbiAgICAgICAgY29uc3QgdmFsdWVSZWYgPSB0aGlzLmdldFJlZlBhcmFtKHZhbC5pKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTZXRBc3NpZ25tZW50KGlkLCBrZXlSZWYsIHZhbHVlUmVmKTtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICB9XG4gICAgICBpZiAodmFsLnQgIT09IDQgLyogSW5kZXhlZFZhbHVlICovICYmIHZhbC5pICE9IG51bGwgJiYgdGhpcy5pc01hcmtlZCh2YWwuaSkpIHtcbiAgICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IFwiKFwiICsgdGhpcy5zZXJpYWxpemUodmFsKSArIFwiLFtcIiArIHNlbnRpbmVsICsgXCIsXCIgKyBzZW50aW5lbCArIFwiXSlcIjtcbiAgICAgICAgdGhpcy5jcmVhdGVTZXRBc3NpZ25tZW50KGlkLCBrZXlSZWYsIHRoaXMuZ2V0UmVmUGFyYW0odmFsLmkpKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEZWxldGVBc3NpZ25tZW50KGlkLCBzZW50aW5lbCk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5zdGFjaztcbiAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuY3JlYXRlU2V0QXNzaWdubWVudChpZCwga2V5UmVmLCB0aGlzLnNlcmlhbGl6ZSh2YWwpKTtcbiAgICAgIHRoaXMuc3RhY2sgPSBwYXJlbnQ7XG4gICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNJbmRleGVkVmFsdWVJblN0YWNrKHZhbCkpIHtcbiAgICAgIGNvbnN0IHZhbHVlUmVmID0gdGhpcy5nZXRSZWZQYXJhbSh2YWwuaSk7XG4gICAgICB0aGlzLm1hcmtSZWYoaWQpO1xuICAgICAgaWYgKGtleS50ICE9PSA0IC8qIEluZGV4ZWRWYWx1ZSAqLyAmJiBrZXkuaSAhPSBudWxsICYmIHRoaXMuaXNNYXJrZWQoa2V5LmkpKSB7XG4gICAgICAgIGNvbnN0IHNlcmlhbGl6ZWQgPSBcIihcIiArIHRoaXMuc2VyaWFsaXplKGtleSkgKyBcIixbXCIgKyBzZW50aW5lbCArIFwiLFwiICsgc2VudGluZWwgKyBcIl0pXCI7XG4gICAgICAgIHRoaXMuY3JlYXRlU2V0QXNzaWdubWVudChpZCwgdGhpcy5nZXRSZWZQYXJhbShrZXkuaSksIHZhbHVlUmVmKTtcbiAgICAgICAgdGhpcy5jcmVhdGVEZWxldGVBc3NpZ25tZW50KGlkLCBzZW50aW5lbCk7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5zdGFjaztcbiAgICAgIHRoaXMuc3RhY2sgPSBbXTtcbiAgICAgIHRoaXMuY3JlYXRlU2V0QXNzaWdubWVudChpZCwgdGhpcy5zZXJpYWxpemUoa2V5KSwgdmFsdWVSZWYpO1xuICAgICAgdGhpcy5zdGFjayA9IHBhcmVudDtcbiAgICAgIHJldHVybiBcIlwiO1xuICAgIH1cbiAgICByZXR1cm4gXCJbXCIgKyB0aGlzLnNlcmlhbGl6ZShrZXkpICsgXCIsXCIgKyB0aGlzLnNlcmlhbGl6ZSh2YWwpICsgXCJdXCI7XG4gIH1cbiAgc2VyaWFsaXplTWFwKG5vZGUpIHtcbiAgICBsZXQgc2VyaWFsaXplZCA9IE1BUF9DT05TVFJVQ1RPUjtcbiAgICBjb25zdCBzaXplID0gbm9kZS5lLnM7XG4gICAgY29uc3QgaWQgPSBub2RlLmk7XG4gICAgY29uc3Qgc2VudGluZWwgPSBub2RlLmY7XG4gICAgY29uc3Qgc2VudGluZWxJZCA9IHRoaXMuZ2V0UmVmUGFyYW0oc2VudGluZWwuaSk7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIGNvbnN0IGtleXMgPSBub2RlLmUuaztcbiAgICAgIGNvbnN0IHZhbHMgPSBub2RlLmUudjtcbiAgICAgIHRoaXMuc3RhY2sucHVzaChpZCk7XG4gICAgICBsZXQgcmVzdWx0ID0gdGhpcy5zZXJpYWxpemVNYXBFbnRyeShpZCwga2V5c1swXSwgdmFsc1swXSwgc2VudGluZWxJZCk7XG4gICAgICBmb3IgKGxldCBpID0gMSwgaXRlbSA9IHJlc3VsdDsgaSA8IHNpemU7IGkrKykge1xuICAgICAgICBpdGVtID0gdGhpcy5zZXJpYWxpemVNYXBFbnRyeShpZCwga2V5c1tpXSwgdmFsc1tpXSwgc2VudGluZWxJZCk7XG4gICAgICAgIHJlc3VsdCArPSAoaXRlbSAmJiByZXN1bHQgJiYgXCIsXCIpICsgaXRlbTtcbiAgICAgIH1cbiAgICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgIHNlcmlhbGl6ZWQgKz0gXCIoW1wiICsgcmVzdWx0ICsgXCJdKVwiO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoc2VudGluZWwudCA9PT0gMjYgLyogU3BlY2lhbFJlZmVyZW5jZSAqLykge1xuICAgICAgdGhpcy5tYXJrUmVmKHNlbnRpbmVsLmkpO1xuICAgICAgc2VyaWFsaXplZCA9IFwiKFwiICsgdGhpcy5zZXJpYWxpemUoc2VudGluZWwpICsgXCIsXCIgKyBzZXJpYWxpemVkICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShpZCwgc2VyaWFsaXplZCk7XG4gIH1cbiAgc2VyaWFsaXplQXJyYXlCdWZmZXIobm9kZSkge1xuICAgIGxldCByZXN1bHQgPSBcIm5ldyBVaW50OEFycmF5KFwiO1xuICAgIGNvbnN0IGJ1ZmZlciA9IG5vZGUucztcbiAgICBjb25zdCBsZW4gPSBidWZmZXIubGVuZ3RoO1xuICAgIGlmIChsZW4pIHtcbiAgICAgIHJlc3VsdCArPSBcIltcIiArIGJ1ZmZlclswXTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcmVzdWx0ICs9IFwiLFwiICsgYnVmZmVyW2ldO1xuICAgICAgfVxuICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCByZXN1bHQgKyBcIikuYnVmZmVyXCIpO1xuICB9XG4gIHNlcmlhbGl6ZVR5cGVkQXJyYXkobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShcbiAgICAgIG5vZGUuaSxcbiAgICAgIFwibmV3IFwiICsgbm9kZS5jICsgXCIoXCIgKyB0aGlzLnNlcmlhbGl6ZShub2RlLmYpICsgXCIsXCIgKyBub2RlLmIgKyBcIixcIiArIG5vZGUubCArIFwiKVwiXG4gICAgKTtcbiAgfVxuICBzZXJpYWxpemVEYXRhVmlldyhub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKFxuICAgICAgbm9kZS5pLFxuICAgICAgXCJuZXcgRGF0YVZpZXcoXCIgKyB0aGlzLnNlcmlhbGl6ZShub2RlLmYpICsgXCIsXCIgKyBub2RlLmIgKyBcIixcIiArIG5vZGUubCArIFwiKVwiXG4gICAgKTtcbiAgfVxuICBzZXJpYWxpemVBZ2dyZWdhdGVFcnJvcihub2RlKSB7XG4gICAgY29uc3QgaWQgPSBub2RlLmk7XG4gICAgdGhpcy5zdGFjay5wdXNoKGlkKTtcbiAgICBjb25zdCBzZXJpYWxpemVkID0gdGhpcy5zZXJpYWxpemVEaWN0aW9uYXJ5KFxuICAgICAgbm9kZSxcbiAgICAgICduZXcgQWdncmVnYXRlRXJyb3IoW10sXCInICsgbm9kZS5tICsgJ1wiKSdcbiAgICApO1xuICAgIHRoaXMuc3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgc2VyaWFsaXplRXJyb3Iobm9kZSkge1xuICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURpY3Rpb25hcnkoXG4gICAgICBub2RlLFxuICAgICAgXCJuZXcgXCIgKyBFUlJPUl9DT05TVFJVQ1RPUl9TVFJJTkdbbm9kZS5zXSArICcoXCInICsgbm9kZS5tICsgJ1wiKSdcbiAgICApO1xuICB9XG4gIHNlcmlhbGl6ZVByb21pc2Uobm9kZSkge1xuICAgIGxldCBzZXJpYWxpemVkO1xuICAgIGNvbnN0IGZ1bGZpbGxlZCA9IG5vZGUuZjtcbiAgICBjb25zdCBpZCA9IG5vZGUuaTtcbiAgICBjb25zdCBwcm9taXNlQ29uc3RydWN0b3IgPSBub2RlLnMgPyBQUk9NSVNFX1JFU09MVkUgOiBQUk9NSVNFX1JFSkVDVDtcbiAgICBpZiAodGhpcy5pc0luZGV4ZWRWYWx1ZUluU3RhY2soZnVsZmlsbGVkKSkge1xuICAgICAgY29uc3QgcmVmID0gdGhpcy5nZXRSZWZQYXJhbShmdWxmaWxsZWQuaSk7XG4gICAgICBzZXJpYWxpemVkID0gcHJvbWlzZUNvbnN0cnVjdG9yICsgKG5vZGUucyA/IFwiKCkudGhlbihcIiArIHRoaXMuY3JlYXRlRnVuY3Rpb24oW10sIHJlZikgKyBcIilcIiA6IFwiKCkuY2F0Y2goXCIgKyB0aGlzLmNyZWF0ZUVmZmVjdGZ1bEZ1bmN0aW9uKFtdLCBcInRocm93IFwiICsgcmVmKSArIFwiKVwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zdGFjay5wdXNoKGlkKTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2VyaWFsaXplKGZ1bGZpbGxlZCk7XG4gICAgICB0aGlzLnN0YWNrLnBvcCgpO1xuICAgICAgc2VyaWFsaXplZCA9IHByb21pc2VDb25zdHJ1Y3RvciArIFwiKFwiICsgcmVzdWx0ICsgXCIpXCI7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShpZCwgc2VyaWFsaXplZCk7XG4gIH1cbiAgc2VyaWFsaXplV2VsbEtub3duU3ltYm9sKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUobm9kZS5pLCBTWU1CT0xfU1RSSU5HW25vZGUuc10pO1xuICB9XG4gIHNlcmlhbGl6ZUJveGVkKG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUoXG4gICAgICBub2RlLmksXG4gICAgICBcIk9iamVjdChcIiArIHRoaXMuc2VyaWFsaXplKG5vZGUuZikgKyBcIilcIlxuICAgICk7XG4gIH1cbiAgc2VyaWFsaXplUGx1Z2luKG5vZGUpIHtcbiAgICBjb25zdCBjdXJyZW50UGx1Z2lucyA9IHRoaXMucGx1Z2lucztcbiAgICBpZiAoY3VycmVudFBsdWdpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjdXJyZW50UGx1Z2lucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBjdXJyZW50UGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi50YWcgPT09IG5vZGUuYykge1xuICAgICAgICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShcbiAgICAgICAgICAgIG5vZGUuaSxcbiAgICAgICAgICAgIHBsdWdpbi5zZXJpYWxpemUobm9kZS5zLCB0aGlzLCB7XG4gICAgICAgICAgICAgIGlkOiBub2RlLmlcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgU2Vyb3ZhbE1pc3NpbmdQbHVnaW5FcnJvcihub2RlLmMpO1xuICB9XG4gIGdldENvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5zZXJpYWxpemUobm9kZSk7XG4gICAgcmV0dXJuIGN1cnJlbnQgPT09IHRoaXMuZ2V0UmVmUGFyYW0obm9kZS5pKSA/IGN1cnJlbnQgOiBcIihcIiArIGN1cnJlbnQgKyBcIilcIjtcbiAgfVxuICBzZXJpYWxpemVQcm9taXNlQ29uc3RydWN0b3Iobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShub2RlLmksIHRoaXMuZ2V0Q29uc3RydWN0b3Iobm9kZS5mKSArIFwiKClcIik7XG4gIH1cbiAgc2VyaWFsaXplUHJvbWlzZVJlc29sdmUobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnN0cnVjdG9yKG5vZGUuYVswXSkgKyBcIihcIiArIHRoaXMuZ2V0UmVmUGFyYW0obm9kZS5pKSArIFwiLFwiICsgdGhpcy5zZXJpYWxpemUobm9kZS5hWzFdKSArIFwiKVwiO1xuICB9XG4gIHNlcmlhbGl6ZVByb21pc2VSZWplY3Qobm9kZSkge1xuICAgIHJldHVybiB0aGlzLmdldENvbnN0cnVjdG9yKG5vZGUuYVswXSkgKyBcIihcIiArIHRoaXMuZ2V0UmVmUGFyYW0obm9kZS5pKSArIFwiLFwiICsgdGhpcy5zZXJpYWxpemUobm9kZS5hWzFdKSArIFwiKVwiO1xuICB9XG4gIHNlcmlhbGl6ZVNwZWNpYWxSZWZlcmVuY2VWYWx1ZShyZWYpIHtcbiAgICBzd2l0Y2ggKHJlZikge1xuICAgICAgY2FzZSAwIC8qIE1hcFNlbnRpbmVsICovOlxuICAgICAgICByZXR1cm4gXCJbXVwiO1xuICAgICAgY2FzZSAxIC8qIFByb21pc2VDb25zdHJ1Y3RvciAqLzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRnVuY3Rpb24oXG4gICAgICAgICAgW1wic1wiLCBcImZcIiwgXCJwXCJdLFxuICAgICAgICAgIFwiKChwPW5ldyBQcm9taXNlKFwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihbXCJhXCIsIFwiYlwiXSwgXCJzPWEsZj1iXCIpICsgXCIpKS5zPXMscC5mPWYscClcIlxuICAgICAgICApO1xuICAgICAgY2FzZSAyIC8qIFByb21pc2VSZXNvbHZlICovOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihcbiAgICAgICAgICBbXCJwXCIsIFwiZFwiXSxcbiAgICAgICAgICAncC5zKGQpLHAuc3RhdHVzPVwic3VjY2Vzc1wiLHAudmFsdWU9ZDtkZWxldGUgcC5zO2RlbGV0ZSBwLmYnXG4gICAgICAgICk7XG4gICAgICBjYXNlIDMgLyogUHJvbWlzZVJlamVjdCAqLzpcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlRWZmZWN0ZnVsRnVuY3Rpb24oXG4gICAgICAgICAgW1wicFwiLCBcImRcIl0sXG4gICAgICAgICAgJ3AuZihkKSxwLnN0YXR1cz1cImZhaWx1cmVcIixwLnZhbHVlPWQ7ZGVsZXRlIHAucztkZWxldGUgcC5mJ1xuICAgICAgICApO1xuICAgICAgY2FzZSA0IC8qIFN0cmVhbUNvbnN0cnVjdG9yICovOlxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGdW5jdGlvbihcbiAgICAgICAgICBbXCJiXCIsIFwiYVwiLCBcInNcIiwgXCJsXCIsIFwicFwiLCBcImZcIiwgXCJlXCIsIFwiblwiXSxcbiAgICAgICAgICBcIihiPVtdLGE9ITAscz0hMSxsPVtdLHA9MCxmPVwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihcbiAgICAgICAgICAgIFtcInZcIiwgXCJtXCIsIFwieFwiXSxcbiAgICAgICAgICAgIFwiZm9yKHg9MDt4PHA7eCsrKWxbeF0mJmxbeF1bbV0odilcIlxuICAgICAgICAgICkgKyBcIixuPVwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihcbiAgICAgICAgICAgIFtcIm9cIiwgXCJ4XCIsIFwielwiLCBcImNcIl0sXG4gICAgICAgICAgICAnZm9yKHg9MCx6PWIubGVuZ3RoO3g8ejt4KyspKGM9Ylt4XSx4PT09ei0xP29bcz9cInJldHVyblwiOlwidGhyb3dcIl0oYyk6by5uZXh0KGMpKSdcbiAgICAgICAgICApICsgXCIsZT1cIiArIHRoaXMuY3JlYXRlRnVuY3Rpb24oXG4gICAgICAgICAgICBbXCJvXCIsIFwidFwiXSxcbiAgICAgICAgICAgIFwiKGEmJihsW3Q9cCsrXT1vKSxuKG8pLFwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihbXSwgXCJhJiYobFt0XT12b2lkIDApXCIpICsgXCIpXCJcbiAgICAgICAgICApICsgXCIse19fU0VST1ZBTF9TVFJFQU1fXzohMCxvbjpcIiArIHRoaXMuY3JlYXRlRnVuY3Rpb24oW1wib1wiXSwgXCJlKG8pXCIpICsgXCIsbmV4dDpcIiArIHRoaXMuY3JlYXRlRWZmZWN0ZnVsRnVuY3Rpb24oW1widlwiXSwgJ2EmJihiLnB1c2godiksZih2LFwibmV4dFwiKSknKSArIFwiLHRocm93OlwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihcbiAgICAgICAgICAgIFtcInZcIl0sXG4gICAgICAgICAgICAnYSYmKGIucHVzaCh2KSxmKHYsXCJ0aHJvd1wiKSxhPXM9ITEsbC5sZW5ndGg9MCknXG4gICAgICAgICAgKSArIFwiLHJldHVybjpcIiArIHRoaXMuY3JlYXRlRWZmZWN0ZnVsRnVuY3Rpb24oXG4gICAgICAgICAgICBbXCJ2XCJdLFxuICAgICAgICAgICAgJ2EmJihiLnB1c2godiksZih2LFwicmV0dXJuXCIpLGE9ITEscz0hMCxsLmxlbmd0aD0wKSdcbiAgICAgICAgICApICsgXCJ9KVwiXG4gICAgICAgICk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gIH1cbiAgc2VyaWFsaXplU3BlY2lhbFJlZmVyZW5jZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuYXNzaWduSW5kZXhlZFZhbHVlKFxuICAgICAgbm9kZS5pLFxuICAgICAgdGhpcy5zZXJpYWxpemVTcGVjaWFsUmVmZXJlbmNlVmFsdWUobm9kZS5zKVxuICAgICk7XG4gIH1cbiAgc2VyaWFsaXplSXRlcmF0b3JGYWN0b3J5KG5vZGUpIHtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBsZXQgaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgICBpZiAobm9kZS5mLnQgIT09IDQgLyogSW5kZXhlZFZhbHVlICovKSB7XG4gICAgICB0aGlzLm1hcmtSZWYobm9kZS5mLmkpO1xuICAgICAgcmVzdWx0ID0gXCIoXCIgKyB0aGlzLnNlcmlhbGl6ZShub2RlLmYpICsgXCIsXCI7XG4gICAgICBpbml0aWFsaXplZCA9IHRydWU7XG4gICAgfVxuICAgIHJlc3VsdCArPSB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShcbiAgICAgIG5vZGUuaSxcbiAgICAgIHRoaXMuY3JlYXRlRnVuY3Rpb24oXG4gICAgICAgIFtcInNcIl0sXG4gICAgICAgIHRoaXMuY3JlYXRlRnVuY3Rpb24oXG4gICAgICAgICAgW1wiaVwiLCBcImNcIiwgXCJkXCIsIFwidFwiXSxcbiAgICAgICAgICBcIihpPTAsdD17W1wiICsgdGhpcy5nZXRSZWZQYXJhbShub2RlLmYuaSkgKyBcIl06XCIgKyB0aGlzLmNyZWF0ZUZ1bmN0aW9uKFtdLCBcInRcIikgKyBcIixuZXh0OlwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihcbiAgICAgICAgICAgIFtdLFxuICAgICAgICAgICAgXCJpZihpPnMuZClyZXR1cm57ZG9uZTohMCx2YWx1ZTp2b2lkIDB9O2lmKGQ9cy52W2M9aSsrXSxjPT09cy50KXRocm93IGQ7cmV0dXJue2RvbmU6Yz09PXMuZCx2YWx1ZTpkfVwiXG4gICAgICAgICAgKSArIFwifSlcIlxuICAgICAgICApXG4gICAgICApXG4gICAgKTtcbiAgICBpZiAoaW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJlc3VsdCArPSBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXJpYWxpemVJdGVyYXRvckZhY3RvcnlJbnN0YW5jZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29uc3RydWN0b3Iobm9kZS5hWzBdKSArIFwiKFwiICsgdGhpcy5zZXJpYWxpemUobm9kZS5hWzFdKSArIFwiKVwiO1xuICB9XG4gIHNlcmlhbGl6ZUFzeW5jSXRlcmF0b3JGYWN0b3J5KG5vZGUpIHtcbiAgICBjb25zdCBwcm9taXNlID0gbm9kZS5hWzBdO1xuICAgIGNvbnN0IHN5bWJvbCA9IG5vZGUuYVsxXTtcbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBpZiAocHJvbWlzZS50ICE9PSA0IC8qIEluZGV4ZWRWYWx1ZSAqLykge1xuICAgICAgdGhpcy5tYXJrUmVmKHByb21pc2UuaSk7XG4gICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLnNlcmlhbGl6ZShwcm9taXNlKTtcbiAgICB9XG4gICAgaWYgKHN5bWJvbC50ICE9PSA0IC8qIEluZGV4ZWRWYWx1ZSAqLykge1xuICAgICAgdGhpcy5tYXJrUmVmKHN5bWJvbC5pKTtcbiAgICAgIHJlc3VsdCArPSAocmVzdWx0ID8gXCIsXCIgOiBcIihcIikgKyB0aGlzLnNlcmlhbGl6ZShzeW1ib2wpO1xuICAgIH1cbiAgICBpZiAocmVzdWx0KSB7XG4gICAgICByZXN1bHQgKz0gXCIsXCI7XG4gICAgfVxuICAgIGNvbnN0IGl0ZXJhdG9yID0gdGhpcy5hc3NpZ25JbmRleGVkVmFsdWUoXG4gICAgICBub2RlLmksXG4gICAgICB0aGlzLmNyZWF0ZUZ1bmN0aW9uKFxuICAgICAgICBbXCJzXCJdLFxuICAgICAgICB0aGlzLmNyZWF0ZUZ1bmN0aW9uKFxuICAgICAgICAgIFtcImJcIiwgXCJjXCIsIFwicFwiLCBcImRcIiwgXCJlXCIsIFwidFwiLCBcImZcIl0sXG4gICAgICAgICAgXCIoYj1bXSxjPTAscD1bXSxkPS0xLGU9ITEsZj1cIiArIHRoaXMuY3JlYXRlRWZmZWN0ZnVsRnVuY3Rpb24oXG4gICAgICAgICAgICBbXCJpXCIsIFwibFwiXSxcbiAgICAgICAgICAgIFwiZm9yKGk9MCxsPXAubGVuZ3RoO2k8bDtpKyspcFtpXS5zKHtkb25lOiEwLHZhbHVlOnZvaWQgMH0pXCJcbiAgICAgICAgICApICsgXCIscy5vbih7bmV4dDpcIiArIHRoaXMuY3JlYXRlRWZmZWN0ZnVsRnVuY3Rpb24oXG4gICAgICAgICAgICBbXCJ2XCIsIFwidFwiXSxcbiAgICAgICAgICAgIFwiaWYodD1wLnNoaWZ0KCkpdC5zKHtkb25lOiExLHZhbHVlOnZ9KTtiLnB1c2godilcIlxuICAgICAgICAgICkgKyBcIix0aHJvdzpcIiArIHRoaXMuY3JlYXRlRWZmZWN0ZnVsRnVuY3Rpb24oXG4gICAgICAgICAgICBbXCJ2XCIsIFwidFwiXSxcbiAgICAgICAgICAgIFwiaWYodD1wLnNoaWZ0KCkpdC5mKHYpO2YoKSxkPWIubGVuZ3RoLGU9ITAsYi5wdXNoKHYpXCJcbiAgICAgICAgICApICsgXCIscmV0dXJuOlwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihcbiAgICAgICAgICAgIFtcInZcIiwgXCJ0XCJdLFxuICAgICAgICAgICAgXCJpZih0PXAuc2hpZnQoKSl0LnMoe2RvbmU6ITAsdmFsdWU6dn0pO2YoKSxkPWIubGVuZ3RoLGIucHVzaCh2KVwiXG4gICAgICAgICAgKSArIFwifSksdD17W1wiICsgdGhpcy5nZXRSZWZQYXJhbShzeW1ib2wuaSkgKyBcIl06XCIgKyB0aGlzLmNyZWF0ZUZ1bmN0aW9uKFtdLCBcInRcIikgKyBcIixuZXh0OlwiICsgdGhpcy5jcmVhdGVFZmZlY3RmdWxGdW5jdGlvbihcbiAgICAgICAgICAgIFtcImlcIiwgXCJ0XCIsIFwidlwiXSxcbiAgICAgICAgICAgIFwiaWYoZD09PS0xKXtyZXR1cm4oKGk9YysrKT49Yi5sZW5ndGgpPyhwLnB1c2godD1cIiArIHRoaXMuZ2V0UmVmUGFyYW0ocHJvbWlzZS5pKSArIFwiKCkpLHQpOntkb25lOiEwLHZhbHVlOmJbaV19fWlmKGM+ZClyZXR1cm57ZG9uZTohMCx2YWx1ZTp2b2lkIDB9O2lmKHY9YltpPWMrK10saSE9PWQpcmV0dXJue2RvbmU6ITEsdmFsdWU6dn07aWYoZSl0aHJvdyB2O3JldHVybntkb25lOiEwLHZhbHVlOnZ9XCJcbiAgICAgICAgICApICsgXCJ9KVwiXG4gICAgICAgIClcbiAgICAgIClcbiAgICApO1xuICAgIGlmIChyZXN1bHQpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyBpdGVyYXRvciArIFwiKVwiO1xuICAgIH1cbiAgICByZXR1cm4gaXRlcmF0b3I7XG4gIH1cbiAgc2VyaWFsaXplQXN5bmNJdGVyYXRvckZhY3RvcnlJbnN0YW5jZShub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0Q29uc3RydWN0b3Iobm9kZS5hWzBdKSArIFwiKFwiICsgdGhpcy5zZXJpYWxpemUobm9kZS5hWzFdKSArIFwiKVwiO1xuICB9XG4gIHNlcmlhbGl6ZVN0cmVhbUNvbnN0cnVjdG9yKG5vZGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLmFzc2lnbkluZGV4ZWRWYWx1ZShcbiAgICAgIG5vZGUuaSxcbiAgICAgIHRoaXMuZ2V0Q29uc3RydWN0b3Iobm9kZS5mKSArIFwiKClcIlxuICAgICk7XG4gICAgY29uc3QgbGVuID0gbm9kZS5hLmxlbmd0aDtcbiAgICBpZiAobGVuKSB7XG4gICAgICBsZXQgdmFsdWVzID0gdGhpcy5zZXJpYWxpemUobm9kZS5hWzBdKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFsdWVzICs9IFwiLFwiICsgdGhpcy5zZXJpYWxpemUobm9kZS5hW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBcIihcIiArIHJlc3VsdCArIFwiLFwiICsgdmFsdWVzICsgXCIsXCIgKyB0aGlzLmdldFJlZlBhcmFtKG5vZGUuaSkgKyBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBzZXJpYWxpemVTdHJlYW1OZXh0KG5vZGUpIHtcbiAgICByZXR1cm4gdGhpcy5nZXRSZWZQYXJhbShub2RlLmkpICsgXCIubmV4dChcIiArIHRoaXMuc2VyaWFsaXplKG5vZGUuZikgKyBcIilcIjtcbiAgfVxuICBzZXJpYWxpemVTdHJlYW1UaHJvdyhub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVmUGFyYW0obm9kZS5pKSArIFwiLnRocm93KFwiICsgdGhpcy5zZXJpYWxpemUobm9kZS5mKSArIFwiKVwiO1xuICB9XG4gIHNlcmlhbGl6ZVN0cmVhbVJldHVybihub2RlKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0UmVmUGFyYW0obm9kZS5pKSArIFwiLnJldHVybihcIiArIHRoaXMuc2VyaWFsaXplKG5vZGUuZikgKyBcIilcIjtcbiAgfVxuICBzZXJpYWxpemUobm9kZSkge1xuICAgIHRyeSB7XG4gICAgICBzd2l0Y2ggKG5vZGUudCkge1xuICAgICAgICBjYXNlIDIgLyogQ29uc3RhbnQgKi86XG4gICAgICAgICAgcmV0dXJuIENPTlNUQU5UX1NUUklOR1tub2RlLnNdO1xuICAgICAgICBjYXNlIDAgLyogTnVtYmVyICovOlxuICAgICAgICAgIHJldHVybiBcIlwiICsgbm9kZS5zO1xuICAgICAgICBjYXNlIDEgLyogU3RyaW5nICovOlxuICAgICAgICAgIHJldHVybiAnXCInICsgbm9kZS5zICsgJ1wiJztcbiAgICAgICAgY2FzZSAzIC8qIEJpZ0ludCAqLzpcbiAgICAgICAgICByZXR1cm4gbm9kZS5zICsgXCJuXCI7XG4gICAgICAgIGNhc2UgNCAvKiBJbmRleGVkVmFsdWUgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0UmVmUGFyYW0obm9kZS5pKTtcbiAgICAgICAgY2FzZSAxOCAvKiBSZWZlcmVuY2UgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplUmVmZXJlbmNlKG5vZGUpO1xuICAgICAgICBjYXNlIDkgLyogQXJyYXkgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplQXJyYXkobm9kZSk7XG4gICAgICAgIGNhc2UgMTAgLyogT2JqZWN0ICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZU9iamVjdChub2RlKTtcbiAgICAgICAgY2FzZSAxMSAvKiBOdWxsQ29uc3RydWN0b3IgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplTnVsbENvbnN0cnVjdG9yKG5vZGUpO1xuICAgICAgICBjYXNlIDUgLyogRGF0ZSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVEYXRlKG5vZGUpO1xuICAgICAgICBjYXNlIDYgLyogUmVnRXhwICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVJlZ0V4cChub2RlKTtcbiAgICAgICAgY2FzZSA3IC8qIFNldCAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVTZXQobm9kZSk7XG4gICAgICAgIGNhc2UgOCAvKiBNYXAgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplTWFwKG5vZGUpO1xuICAgICAgICBjYXNlIDE5IC8qIEFycmF5QnVmZmVyICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZUFycmF5QnVmZmVyKG5vZGUpO1xuICAgICAgICBjYXNlIDE2IC8qIEJpZ0ludFR5cGVkQXJyYXkgKi86XG4gICAgICAgIGNhc2UgMTUgLyogVHlwZWRBcnJheSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVUeXBlZEFycmF5KG5vZGUpO1xuICAgICAgICBjYXNlIDIwIC8qIERhdGFWaWV3ICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZURhdGFWaWV3KG5vZGUpO1xuICAgICAgICBjYXNlIDE0IC8qIEFnZ3JlZ2F0ZUVycm9yICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZUFnZ3JlZ2F0ZUVycm9yKG5vZGUpO1xuICAgICAgICBjYXNlIDEzIC8qIEVycm9yICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZUVycm9yKG5vZGUpO1xuICAgICAgICBjYXNlIDEyIC8qIFByb21pc2UgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplUHJvbWlzZShub2RlKTtcbiAgICAgICAgY2FzZSAxNyAvKiBXS1N5bWJvbCAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVXZWxsS25vd25TeW1ib2wobm9kZSk7XG4gICAgICAgIGNhc2UgMjEgLyogQm94ZWQgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplQm94ZWQobm9kZSk7XG4gICAgICAgIGNhc2UgMjIgLyogUHJvbWlzZUNvbnN0cnVjdG9yICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVByb21pc2VDb25zdHJ1Y3Rvcihub2RlKTtcbiAgICAgICAgY2FzZSAyMyAvKiBQcm9taXNlUmVzb2x2ZSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVQcm9taXNlUmVzb2x2ZShub2RlKTtcbiAgICAgICAgY2FzZSAyNCAvKiBQcm9taXNlUmVqZWN0ICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVByb21pc2VSZWplY3Qobm9kZSk7XG4gICAgICAgIGNhc2UgMjUgLyogUGx1Z2luICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVBsdWdpbihub2RlKTtcbiAgICAgICAgY2FzZSAyNiAvKiBTcGVjaWFsUmVmZXJlbmNlICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVNwZWNpYWxSZWZlcmVuY2Uobm9kZSk7XG4gICAgICAgIGNhc2UgMjcgLyogSXRlcmF0b3JGYWN0b3J5ICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZUl0ZXJhdG9yRmFjdG9yeShub2RlKTtcbiAgICAgICAgY2FzZSAyOCAvKiBJdGVyYXRvckZhY3RvcnlJbnN0YW5jZSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVJdGVyYXRvckZhY3RvcnlJbnN0YW5jZShub2RlKTtcbiAgICAgICAgY2FzZSAyOSAvKiBBc3luY0l0ZXJhdG9yRmFjdG9yeSAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVBc3luY0l0ZXJhdG9yRmFjdG9yeShub2RlKTtcbiAgICAgICAgY2FzZSAzMCAvKiBBc3luY0l0ZXJhdG9yRmFjdG9yeUluc3RhbmNlICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZUFzeW5jSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2Uobm9kZSk7XG4gICAgICAgIGNhc2UgMzEgLyogU3RyZWFtQ29uc3RydWN0b3IgKi86XG4gICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWFsaXplU3RyZWFtQ29uc3RydWN0b3Iobm9kZSk7XG4gICAgICAgIGNhc2UgMzIgLyogU3RyZWFtTmV4dCAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVTdHJlYW1OZXh0KG5vZGUpO1xuICAgICAgICBjYXNlIDMzIC8qIFN0cmVhbVRocm93ICovOlxuICAgICAgICAgIHJldHVybiB0aGlzLnNlcmlhbGl6ZVN0cmVhbVRocm93KG5vZGUpO1xuICAgICAgICBjYXNlIDM0IC8qIFN0cmVhbVJldHVybiAqLzpcbiAgICAgICAgICByZXR1cm4gdGhpcy5zZXJpYWxpemVTdHJlYW1SZXR1cm4obm9kZSk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcm92YWxVbnN1cHBvcnRlZE5vZGVFcnJvcihub2RlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFNlcm92YWxTZXJpYWxpemF0aW9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvdXRpbHMvZ2V0LWlkZW50aWZpZXIudHNcbnZhciBSRUZfU1RBUlRfQ0hBUlMgPSBcImhqa21vcXV4ekFCQ0RFRkdISUpLTE5QUVJUVVZXWFlaJF9cIjtcbnZhciBSRUZfU1RBUlRfQ0hBUlNfTEVOID0gUkVGX1NUQVJUX0NIQVJTLmxlbmd0aDtcbnZhciBSRUZfQ0hBUlMgPSBcImFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6QUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVowMTIzNDU2Nzg5JF9cIjtcbnZhciBSRUZfQ0hBUlNfTEVOID0gUkVGX0NIQVJTLmxlbmd0aDtcbmZ1bmN0aW9uIGdldElkZW50aWZpZXIoaW5kZXgpIHtcbiAgbGV0IG1vZCA9IGluZGV4ICUgUkVGX1NUQVJUX0NIQVJTX0xFTjtcbiAgbGV0IHJlZiA9IFJFRl9TVEFSVF9DSEFSU1ttb2RdO1xuICBpbmRleCA9IChpbmRleCAtIG1vZCkgLyBSRUZfU1RBUlRfQ0hBUlNfTEVOO1xuICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgbW9kID0gaW5kZXggJSBSRUZfQ0hBUlNfTEVOO1xuICAgIHJlZiArPSBSRUZfQ0hBUlNbbW9kXTtcbiAgICBpbmRleCA9IChpbmRleCAtIG1vZCkgLyBSRUZfQ0hBUlNfTEVOO1xuICB9XG4gIHJldHVybiByZWY7XG59XG5cbi8vIHNyYy9jb3JlL3RyZWUvc2VyaWFsaXplci50c1xudmFyIFZhbmlsbGFTZXJpYWxpemVyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgQmFzZVNlcmlhbGl6ZXJDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1vZGUgPSBcInZhbmlsbGFcIjtcbiAgICAvKipcbiAgICAgKiBNYXAgdHJlZSByZWZzIHRvIGFjdHVhbCByZWZzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICB0aGlzLnZhbGlkID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKTtcbiAgICAvKipcbiAgICAgKiBWYXJpYWJsZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHRoaXMudmFycyA9IFtdO1xuICB9XG4gIC8qKlxuICAgKiBDcmVhdGVzIHRoZSByZWZlcmVuY2UgcGFyYW0gKGlkZW50aWZpZXIpIGZyb20gdGhlIGdpdmVuIHJlZmVyZW5jZSBJRFxuICAgKiBDYWxsaW5nIHRoaXMgZnVuY3Rpb24gbWVhbnMgdGhlIHZhbHVlIGhhcyBiZWVuIHJlZmVyZW5jZWQgc29tZXdoZXJlXG4gICAqL1xuICBnZXRSZWZQYXJhbShpbmRleCkge1xuICAgIGxldCBhY3R1YWxJbmRleCA9IHRoaXMudmFsaWQuZ2V0KGluZGV4KTtcbiAgICBpZiAoYWN0dWFsSW5kZXggPT0gbnVsbCkge1xuICAgICAgYWN0dWFsSW5kZXggPSB0aGlzLnZhbGlkLnNpemU7XG4gICAgICB0aGlzLnZhbGlkLnNldChpbmRleCwgYWN0dWFsSW5kZXgpO1xuICAgIH1cbiAgICBsZXQgaWRlbnRpZmllciA9IHRoaXMudmFyc1thY3R1YWxJbmRleF07XG4gICAgaWYgKGlkZW50aWZpZXIgPT0gbnVsbCkge1xuICAgICAgaWRlbnRpZmllciA9IGdldElkZW50aWZpZXIoYWN0dWFsSW5kZXgpO1xuICAgICAgdGhpcy52YXJzW2FjdHVhbEluZGV4XSA9IGlkZW50aWZpZXI7XG4gICAgfVxuICAgIHJldHVybiBpZGVudGlmaWVyO1xuICB9XG4gIGFzc2lnbkluZGV4ZWRWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc01hcmtlZChpbmRleCkpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFJlZlBhcmFtKGluZGV4KSArIFwiPVwiICsgdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzZXJpYWxpemVQcm9taXNlQ29uc3RydWN0b3Iobm9kZSkge1xuICAgIHRocm93IG5ldyBTZXJvdmFsVW5zdXBwb3J0ZWROb2RlRXJyb3Iobm9kZSk7XG4gIH1cbiAgc2VyaWFsaXplUHJvbWlzZVJlc29sdmUobm9kZSkge1xuICAgIHRocm93IG5ldyBTZXJvdmFsVW5zdXBwb3J0ZWROb2RlRXJyb3Iobm9kZSk7XG4gIH1cbiAgc2VyaWFsaXplUHJvbWlzZVJlamVjdChub2RlKSB7XG4gICAgdGhyb3cgbmV3IFNlcm92YWxVbnN1cHBvcnRlZE5vZGVFcnJvcihub2RlKTtcbiAgfVxuICBzZXJpYWxpemVUb3AodHJlZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuc2VyaWFsaXplKHRyZWUpO1xuICAgIGlmICh0cmVlLmkgIT0gbnVsbCAmJiB0aGlzLnZhcnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBwYXRjaGVzID0gdGhpcy5yZXNvbHZlUGF0Y2hlcygpO1xuICAgICAgbGV0IGJvZHkgPSByZXN1bHQ7XG4gICAgICBpZiAocGF0Y2hlcykge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuZ2V0UmVmUGFyYW0odHJlZS5pKTtcbiAgICAgICAgYm9keSA9IHJlc3VsdCArIFwiLFwiICsgcGF0Y2hlcyArIGluZGV4O1xuICAgICAgICBpZiAoIXJlc3VsdC5zdGFydHNXaXRoKGluZGV4ICsgXCI9XCIpKSB7XG4gICAgICAgICAgYm9keSA9IGluZGV4ICsgXCI9XCIgKyBib2R5O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gXCIoXCIgKyB0aGlzLmNyZWF0ZUZ1bmN0aW9uKHRoaXMudmFycywgXCIoXCIgKyBib2R5ICsgXCIpXCIpICsgXCIpKClcIjtcbiAgICB9XG4gICAgaWYgKHRyZWUudCA9PT0gMTAgLyogT2JqZWN0ICovKSB7XG4gICAgICByZXR1cm4gXCIoXCIgKyByZXN1bHQgKyBcIilcIjtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvY29udGV4dC9wYXJzZXIvc3luYy50c1xudmFyIEJhc2VTeW5jUGFyc2VyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgQmFzZVBhcnNlckNvbnRleHQge1xuICBwYXJzZUl0ZW1zKGN1cnJlbnQpIHtcbiAgICBjb25zdCBub2RlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjdXJyZW50Lmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBpZiAoaSBpbiBjdXJyZW50KSB7XG4gICAgICAgIG5vZGVzW2ldID0gdGhpcy5wYXJzZShjdXJyZW50W2ldKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG4gIHBhcnNlQXJyYXkoaWQsIGN1cnJlbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlQXJyYXlOb2RlKGlkLCBjdXJyZW50LCB0aGlzLnBhcnNlSXRlbXMoY3VycmVudCkpO1xuICB9XG4gIHBhcnNlUHJvcGVydGllcyhwcm9wZXJ0aWVzKSB7XG4gICAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHByb3BlcnRpZXMpO1xuICAgIGNvbnN0IGtleU5vZGVzID0gW107XG4gICAgY29uc3QgdmFsdWVOb2RlcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBlbnRyaWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBrZXlOb2Rlcy5wdXNoKHNlcmlhbGl6ZVN0cmluZyhlbnRyaWVzW2ldWzBdKSk7XG4gICAgICB2YWx1ZU5vZGVzLnB1c2godGhpcy5wYXJzZShlbnRyaWVzW2ldWzFdKSk7XG4gICAgfVxuICAgIGxldCBzeW1ib2wgPSBTeW1ib2wuaXRlcmF0b3I7XG4gICAgaWYgKHN5bWJvbCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBrZXlOb2Rlcy5wdXNoKHRoaXMucGFyc2VXZWxsS25vd25TeW1ib2woc3ltYm9sKSk7XG4gICAgICB2YWx1ZU5vZGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZUl0ZXJhdG9yRmFjdG9yeUluc3RhbmNlTm9kZShcbiAgICAgICAgICB0aGlzLnBhcnNlSXRlcmF0b3JGYWN0b3J5KCksXG4gICAgICAgICAgdGhpcy5wYXJzZShcbiAgICAgICAgICAgIGl0ZXJhdG9yVG9TZXF1ZW5jZShwcm9wZXJ0aWVzKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKTtcbiAgICB9XG4gICAgc3ltYm9sID0gU3ltYm9sLmFzeW5jSXRlcmF0b3I7XG4gICAgaWYgKHN5bWJvbCBpbiBwcm9wZXJ0aWVzKSB7XG4gICAgICBrZXlOb2Rlcy5wdXNoKHRoaXMucGFyc2VXZWxsS25vd25TeW1ib2woc3ltYm9sKSk7XG4gICAgICB2YWx1ZU5vZGVzLnB1c2goXG4gICAgICAgIGNyZWF0ZUFzeW5jSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2VOb2RlKFxuICAgICAgICAgIHRoaXMucGFyc2VBc3luY0l0ZXJhdG9yRmFjdG9yeSgpLFxuICAgICAgICAgIHRoaXMucGFyc2UoY3JlYXRlU3RyZWFtKCkpXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHN5bWJvbCA9IFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICBpZiAoc3ltYm9sIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGtleU5vZGVzLnB1c2godGhpcy5wYXJzZVdlbGxLbm93blN5bWJvbChzeW1ib2wpKTtcbiAgICAgIHZhbHVlTm9kZXMucHVzaChjcmVhdGVTdHJpbmdOb2RlKHByb3BlcnRpZXNbc3ltYm9sXSkpO1xuICAgIH1cbiAgICBzeW1ib2wgPSBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlO1xuICAgIGlmIChzeW1ib2wgaW4gcHJvcGVydGllcykge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKHN5bWJvbCkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKHByb3BlcnRpZXNbc3ltYm9sXSA/IFRSVUVfTk9ERSA6IEZBTFNFX05PREUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgazoga2V5Tm9kZXMsXG4gICAgICB2OiB2YWx1ZU5vZGVzLFxuICAgICAgczoga2V5Tm9kZXMubGVuZ3RoXG4gICAgfTtcbiAgfVxuICBwYXJzZVBsYWluT2JqZWN0KGlkLCBjdXJyZW50LCBlbXB0eSkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZU9iamVjdE5vZGUoXG4gICAgICBpZCxcbiAgICAgIGN1cnJlbnQsXG4gICAgICBlbXB0eSxcbiAgICAgIHRoaXMucGFyc2VQcm9wZXJ0aWVzKGN1cnJlbnQpXG4gICAgKTtcbiAgfVxuICBwYXJzZUJveGVkKGlkLCBjdXJyZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJveGVkTm9kZShpZCwgdGhpcy5wYXJzZShjdXJyZW50LnZhbHVlT2YoKSkpO1xuICB9XG4gIHBhcnNlVHlwZWRBcnJheShpZCwgY3VycmVudCkge1xuICAgIHJldHVybiBjcmVhdGVUeXBlZEFycmF5Tm9kZShpZCwgY3VycmVudCwgdGhpcy5wYXJzZShjdXJyZW50LmJ1ZmZlcikpO1xuICB9XG4gIHBhcnNlQmlnSW50VHlwZWRBcnJheShpZCwgY3VycmVudCkge1xuICAgIHJldHVybiBjcmVhdGVCaWdJbnRUeXBlZEFycmF5Tm9kZShpZCwgY3VycmVudCwgdGhpcy5wYXJzZShjdXJyZW50LmJ1ZmZlcikpO1xuICB9XG4gIHBhcnNlRGF0YVZpZXcoaWQsIGN1cnJlbnQpIHtcbiAgICByZXR1cm4gY3JlYXRlRGF0YVZpZXdOb2RlKGlkLCBjdXJyZW50LCB0aGlzLnBhcnNlKGN1cnJlbnQuYnVmZmVyKSk7XG4gIH1cbiAgcGFyc2VFcnJvcihpZCwgY3VycmVudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRFcnJvck9wdGlvbnMoY3VycmVudCwgdGhpcy5mZWF0dXJlcyk7XG4gICAgcmV0dXJuIGNyZWF0ZUVycm9yTm9kZShcbiAgICAgIGlkLFxuICAgICAgY3VycmVudCxcbiAgICAgIG9wdGlvbnMgPyB0aGlzLnBhcnNlUHJvcGVydGllcyhvcHRpb25zKSA6IHZvaWQgMFxuICAgICk7XG4gIH1cbiAgcGFyc2VBZ2dyZWdhdGVFcnJvcihpZCwgY3VycmVudCkge1xuICAgIGNvbnN0IG9wdGlvbnMgPSBnZXRFcnJvck9wdGlvbnMoY3VycmVudCwgdGhpcy5mZWF0dXJlcyk7XG4gICAgcmV0dXJuIGNyZWF0ZUFnZ3JlZ2F0ZUVycm9yTm9kZShcbiAgICAgIGlkLFxuICAgICAgY3VycmVudCxcbiAgICAgIG9wdGlvbnMgPyB0aGlzLnBhcnNlUHJvcGVydGllcyhvcHRpb25zKSA6IHZvaWQgMFxuICAgICk7XG4gIH1cbiAgcGFyc2VNYXAoaWQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBrZXlOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlTm9kZXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBjdXJyZW50LmVudHJpZXMoKSkge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlKGtleSkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKHRoaXMucGFyc2UodmFsdWUpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlTWFwTm9kZShpZCwga2V5Tm9kZXMsIHZhbHVlTm9kZXMsIGN1cnJlbnQuc2l6ZSk7XG4gIH1cbiAgcGFyc2VTZXQoaWQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBpdGVtcyA9IFtdO1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjdXJyZW50LmtleXMoKSkge1xuICAgICAgaXRlbXMucHVzaCh0aGlzLnBhcnNlKGl0ZW0pKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZVNldE5vZGUoaWQsIGN1cnJlbnQuc2l6ZSwgaXRlbXMpO1xuICB9XG4gIHBhcnNlUGx1Z2luKGlkLCBjdXJyZW50KSB7XG4gICAgY29uc3QgY3VycmVudFBsdWdpbnMgPSB0aGlzLnBsdWdpbnM7XG4gICAgaWYgKGN1cnJlbnRQbHVnaW5zKSB7XG4gICAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gY3VycmVudFBsdWdpbnMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgY29uc3QgcGx1Z2luID0gY3VycmVudFBsdWdpbnNbaV07XG4gICAgICAgIGlmIChwbHVnaW4ucGFyc2Uuc3luYyAmJiBwbHVnaW4udGVzdChjdXJyZW50KSkge1xuICAgICAgICAgIHJldHVybiBjcmVhdGVQbHVnaW5Ob2RlKFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBwbHVnaW4udGFnLFxuICAgICAgICAgICAgcGx1Z2luLnBhcnNlLnN5bmMoY3VycmVudCwgdGhpcywge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcGFyc2VTdHJlYW0oaWQsIF9jdXJyZW50KSB7XG4gICAgcmV0dXJuIGNyZWF0ZVN0cmVhbUNvbnN0cnVjdG9yTm9kZShcbiAgICAgIGlkLFxuICAgICAgdGhpcy5wYXJzZVNwZWNpYWxSZWZlcmVuY2UoNCAvKiBTdHJlYW1Db25zdHJ1Y3RvciAqLyksXG4gICAgICBbXVxuICAgICk7XG4gIH1cbiAgcGFyc2VQcm9taXNlKGlkLCBfY3VycmVudCkge1xuICAgIHJldHVybiB0aGlzLmNyZWF0ZVByb21pc2VDb25zdHJ1Y3Rvck5vZGUoaWQpO1xuICB9XG4gIHBhcnNlT2JqZWN0KGlkLCBjdXJyZW50KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY3VycmVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQXJyYXkoaWQsIGN1cnJlbnQpO1xuICAgIH1cbiAgICBpZiAoaXNTdHJlYW0oY3VycmVudCkpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlU3RyZWFtKGlkLCBjdXJyZW50KTtcbiAgICB9XG4gICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVBsdWdpbihpZCwgY3VycmVudCk7XG4gICAgaWYgKHBhcnNlZCkge1xuICAgICAgcmV0dXJuIHBhcnNlZDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudENsYXNzID0gY3VycmVudC5jb25zdHJ1Y3RvcjtcbiAgICBzd2l0Y2ggKGN1cnJlbnRDbGFzcykge1xuICAgICAgY2FzZSBPYmplY3Q6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGxhaW5PYmplY3QoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICBmYWxzZVxuICAgICAgICApO1xuICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlUGxhaW5PYmplY3QoXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgY3VycmVudCxcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICBjYXNlIERhdGU6XG4gICAgICAgIHJldHVybiBjcmVhdGVEYXRlTm9kZShpZCwgY3VycmVudCk7XG4gICAgICBjYXNlIFJlZ0V4cDpcbiAgICAgICAgcmV0dXJuIGNyZWF0ZVJlZ0V4cE5vZGUoaWQsIGN1cnJlbnQpO1xuICAgICAgY2FzZSBFcnJvcjpcbiAgICAgIGNhc2UgRXZhbEVycm9yOlxuICAgICAgY2FzZSBSYW5nZUVycm9yOlxuICAgICAgY2FzZSBSZWZlcmVuY2VFcnJvcjpcbiAgICAgIGNhc2UgU3ludGF4RXJyb3I6XG4gICAgICBjYXNlIFR5cGVFcnJvcjpcbiAgICAgIGNhc2UgVVJJRXJyb3I6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoaWQsIGN1cnJlbnQpO1xuICAgICAgY2FzZSBOdW1iZXI6XG4gICAgICBjYXNlIEJvb2xlYW46XG4gICAgICBjYXNlIFN0cmluZzpcbiAgICAgIGNhc2UgQmlnSW50OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUJveGVkKGlkLCBjdXJyZW50KTtcbiAgICAgIGNhc2UgQXJyYXlCdWZmZXI6XG4gICAgICAgIHJldHVybiBjcmVhdGVBcnJheUJ1ZmZlck5vZGUoaWQsIGN1cnJlbnQpO1xuICAgICAgY2FzZSBJbnQ4QXJyYXk6XG4gICAgICBjYXNlIEludDE2QXJyYXk6XG4gICAgICBjYXNlIEludDMyQXJyYXk6XG4gICAgICBjYXNlIFVpbnQ4QXJyYXk6XG4gICAgICBjYXNlIFVpbnQxNkFycmF5OlxuICAgICAgY2FzZSBVaW50MzJBcnJheTpcbiAgICAgIGNhc2UgVWludDhDbGFtcGVkQXJyYXk6XG4gICAgICBjYXNlIEZsb2F0MzJBcnJheTpcbiAgICAgIGNhc2UgRmxvYXQ2NEFycmF5OlxuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZVR5cGVkQXJyYXkoaWQsIGN1cnJlbnQpO1xuICAgICAgY2FzZSBEYXRhVmlldzpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VEYXRhVmlldyhpZCwgY3VycmVudCk7XG4gICAgICBjYXNlIE1hcDpcbiAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VNYXAoaWQsIGN1cnJlbnQpO1xuICAgICAgY2FzZSBTZXQ6XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnNlU2V0KGlkLCBjdXJyZW50KTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBpZiAoY3VycmVudENsYXNzID09PSBQcm9taXNlIHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZVByb21pc2UoaWQsIGN1cnJlbnQpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50RmVhdHVyZXMgPSB0aGlzLmZlYXR1cmVzO1xuICAgIGlmIChjdXJyZW50RmVhdHVyZXMgJiAxNiAvKiBCaWdJbnRUeXBlZEFycmF5ICovKSB7XG4gICAgICBzd2l0Y2ggKGN1cnJlbnRDbGFzcykge1xuICAgICAgICBjYXNlIEJpZ0ludDY0QXJyYXk6XG4gICAgICAgIGNhc2UgQmlnVWludDY0QXJyYXk6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VCaWdJbnRUeXBlZEFycmF5KFxuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBjdXJyZW50XG4gICAgICAgICAgKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGN1cnJlbnRGZWF0dXJlcyAmIDEgLyogQWdncmVnYXRlRXJyb3IgKi8gJiYgdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yICE9PSBcInVuZGVmaW5lZFwiICYmIChjdXJyZW50Q2xhc3MgPT09IEFnZ3JlZ2F0ZUVycm9yIHx8IGN1cnJlbnQgaW5zdGFuY2VvZiBBZ2dyZWdhdGVFcnJvcikpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlQWdncmVnYXRlRXJyb3IoaWQsIGN1cnJlbnQpO1xuICAgIH1cbiAgICBpZiAoY3VycmVudCBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKGlkLCBjdXJyZW50KTtcbiAgICB9XG4gICAgaWYgKFN5bWJvbC5pdGVyYXRvciBpbiBjdXJyZW50IHx8IFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIGN1cnJlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlUGxhaW5PYmplY3QoaWQsIGN1cnJlbnQsICEhY3VycmVudENsYXNzKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IFNlcm92YWxVbnN1cHBvcnRlZFR5cGVFcnJvcihjdXJyZW50KTtcbiAgfVxuICBwYXJzZShjdXJyZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHN3aXRjaCAodHlwZW9mIGN1cnJlbnQpIHtcbiAgICAgICAgY2FzZSBcImJvb2xlYW5cIjpcbiAgICAgICAgICByZXR1cm4gY3VycmVudCA/IFRSVUVfTk9ERSA6IEZBTFNFX05PREU7XG4gICAgICAgIGNhc2UgXCJ1bmRlZmluZWRcIjpcbiAgICAgICAgICByZXR1cm4gVU5ERUZJTkVEX05PREU7XG4gICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICByZXR1cm4gY3JlYXRlU3RyaW5nTm9kZShjdXJyZW50KTtcbiAgICAgICAgY2FzZSBcIm51bWJlclwiOlxuICAgICAgICAgIHJldHVybiBjcmVhdGVOdW1iZXJOb2RlKGN1cnJlbnQpO1xuICAgICAgICBjYXNlIFwiYmlnaW50XCI6XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZUJpZ0ludE5vZGUoY3VycmVudCk7XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjoge1xuICAgICAgICAgIGlmIChjdXJyZW50KSB7XG4gICAgICAgICAgICBjb25zdCByZWYgPSB0aGlzLmdldFJlZmVyZW5jZShjdXJyZW50KTtcbiAgICAgICAgICAgIHJldHVybiByZWYudHlwZSA9PT0gMCA/IHRoaXMucGFyc2VPYmplY3QocmVmLnZhbHVlLCBjdXJyZW50KSA6IHJlZi52YWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIE5VTExfTk9ERTtcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3ltYm9sXCI6XG4gICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VXZWxsS25vd25TeW1ib2woY3VycmVudCk7XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRnVuY3Rpb24oY3VycmVudCk7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFNlcm92YWxVbnN1cHBvcnRlZFR5cGVFcnJvcihjdXJyZW50KTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhyb3cgbmV3IFNlcm92YWxQYXJzZXJFcnJvcihlcnJvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBzcmMvY29yZS90cmVlL3N5bmMudHNcbnZhciBTeW5jUGFyc2VyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgQmFzZVN5bmNQYXJzZXJDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1vZGUgPSBcInZhbmlsbGFcIjtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvdHJlZS9pbmRleC50c1xuZnVuY3Rpb24gc2VyaWFsaXplKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBsdWdpbnMgPSByZXNvbHZlUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICBjb25zdCBjdHggPSBuZXcgU3luY1BhcnNlckNvbnRleHQoe1xuICAgIHBsdWdpbnMsXG4gICAgZGlzYWJsZWRGZWF0dXJlczogb3B0aW9ucy5kaXNhYmxlZEZlYXR1cmVzXG4gIH0pO1xuICBjb25zdCB0cmVlID0gY3R4LnBhcnNlKHNvdXJjZSk7XG4gIGNvbnN0IHNlcmlhbCA9IG5ldyBWYW5pbGxhU2VyaWFsaXplckNvbnRleHQoe1xuICAgIHBsdWdpbnMsXG4gICAgZmVhdHVyZXM6IGN0eC5mZWF0dXJlcyxcbiAgICBtYXJrZWRSZWZzOiBjdHgubWFya2VkXG4gIH0pO1xuICByZXR1cm4gc2VyaWFsLnNlcmlhbGl6ZVRvcCh0cmVlKTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHNlcmlhbGl6ZUFzeW5jKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBsdWdpbnMgPSByZXNvbHZlUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICBjb25zdCBjdHggPSBuZXcgQXN5bmNQYXJzZXJDb250ZXh0KHtcbiAgICBwbHVnaW5zLFxuICAgIGRpc2FibGVkRmVhdHVyZXM6IG9wdGlvbnMuZGlzYWJsZWRGZWF0dXJlc1xuICB9KTtcbiAgY29uc3QgdHJlZSA9IGF3YWl0IGN0eC5wYXJzZShzb3VyY2UpO1xuICBjb25zdCBzZXJpYWwgPSBuZXcgVmFuaWxsYVNlcmlhbGl6ZXJDb250ZXh0KHtcbiAgICBwbHVnaW5zLFxuICAgIGZlYXR1cmVzOiBjdHguZmVhdHVyZXMsXG4gICAgbWFya2VkUmVmczogY3R4Lm1hcmtlZFxuICB9KTtcbiAgcmV0dXJuIHNlcmlhbC5zZXJpYWxpemVUb3AodHJlZSk7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZShzb3VyY2UpIHtcbiAgcmV0dXJuICgwLCBldmFsKShzb3VyY2UpO1xufVxuZnVuY3Rpb24gdG9KU09OKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBsdWdpbnMgPSByZXNvbHZlUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICBjb25zdCBjdHggPSBuZXcgU3luY1BhcnNlckNvbnRleHQoe1xuICAgIHBsdWdpbnMsXG4gICAgZGlzYWJsZWRGZWF0dXJlczogb3B0aW9ucy5kaXNhYmxlZEZlYXR1cmVzXG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHQ6IGN0eC5wYXJzZShzb3VyY2UpLFxuICAgIGY6IGN0eC5mZWF0dXJlcyxcbiAgICBtOiBBcnJheS5mcm9tKGN0eC5tYXJrZWQpXG4gIH07XG59XG5hc3luYyBmdW5jdGlvbiB0b0pTT05Bc3luYyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwbHVnaW5zID0gcmVzb2x2ZVBsdWdpbnMob3B0aW9ucy5wbHVnaW5zKTtcbiAgY29uc3QgY3R4ID0gbmV3IEFzeW5jUGFyc2VyQ29udGV4dCh7XG4gICAgcGx1Z2lucyxcbiAgICBkaXNhYmxlZEZlYXR1cmVzOiBvcHRpb25zLmRpc2FibGVkRmVhdHVyZXNcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdDogYXdhaXQgY3R4LnBhcnNlKHNvdXJjZSksXG4gICAgZjogY3R4LmZlYXR1cmVzLFxuICAgIG06IEFycmF5LmZyb20oY3R4Lm1hcmtlZClcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbXBpbGVKU09OKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBsdWdpbnMgPSByZXNvbHZlUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICBjb25zdCBjdHggPSBuZXcgVmFuaWxsYVNlcmlhbGl6ZXJDb250ZXh0KHtcbiAgICBwbHVnaW5zLFxuICAgIGZlYXR1cmVzOiBzb3VyY2UuZixcbiAgICBtYXJrZWRSZWZzOiBzb3VyY2UubVxuICB9KTtcbiAgcmV0dXJuIGN0eC5zZXJpYWxpemVUb3Aoc291cmNlLnQpO1xufVxuZnVuY3Rpb24gZnJvbUpTT04oc291cmNlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3QgcGx1Z2lucyA9IHJlc29sdmVQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG4gIGNvbnN0IGN0eCA9IG5ldyBWYW5pbGxhRGVzZXJpYWxpemVyQ29udGV4dCh7XG4gICAgcGx1Z2lucyxcbiAgICBtYXJrZWRSZWZzOiBzb3VyY2UubVxuICB9KTtcbiAgcmV0dXJuIGN0eC5kZXNlcmlhbGl6ZShzb3VyY2UudCk7XG59XG5cbi8vIHNyYy9jb3JlL2Nyb3NzL2FzeW5jLnRzXG52YXIgQ3Jvc3NBc3luY1BhcnNlckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIEJhc2VBc3luY1BhcnNlckNvbnRleHQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubW9kZSA9IFwiY3Jvc3NcIjtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvY3Jvc3MvZGVzZXJpYWxpemVyLnRzXG52YXIgQ3Jvc3NEZXNlcmlhbGl6ZXJDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBCYXNlRGVzZXJpYWxpemVyQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKC4uLmFyZ3VtZW50cyk7XG4gICAgdGhpcy5tb2RlID0gXCJjcm9zc1wiO1xuICB9XG4gIGFzc2lnbkluZGV4ZWRWYWx1ZShpbmRleCwgdmFsdWUpIHtcbiAgICBpZiAoIXRoaXMucmVmcy5oYXMoaW5kZXgpKSB7XG4gICAgICB0aGlzLnJlZnMuc2V0KGluZGV4LCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvY3Jvc3Mvc2VyaWFsaXplci50c1xudmFyIENyb3NzU2VyaWFsaXplckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIEJhc2VTZXJpYWxpemVyQ29udGV4dCB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICBzdXBlcihvcHRpb25zKTtcbiAgICB0aGlzLm1vZGUgPSBcImNyb3NzXCI7XG4gICAgdGhpcy5zY29wZUlkID0gb3B0aW9ucy5zY29wZUlkO1xuICB9XG4gIGdldFJlZlBhcmFtKGlkKSB7XG4gICAgcmV0dXJuIEdMT0JBTF9DT05URVhUX1JFRkVSRU5DRVMgKyBcIltcIiArIGlkICsgXCJdXCI7XG4gIH1cbiAgYXNzaWduSW5kZXhlZFZhbHVlKGluZGV4LCB2YWx1ZSkge1xuICAgIHJldHVybiB0aGlzLmdldFJlZlBhcmFtKGluZGV4KSArIFwiPVwiICsgdmFsdWU7XG4gIH1cbiAgc2VyaWFsaXplVG9wKHRyZWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLnNlcmlhbGl6ZSh0cmVlKTtcbiAgICBjb25zdCBpZCA9IHRyZWUuaTtcbiAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29uc3QgcGF0Y2hlcyA9IHRoaXMucmVzb2x2ZVBhdGNoZXMoKTtcbiAgICBjb25zdCByZWYgPSB0aGlzLmdldFJlZlBhcmFtKGlkKTtcbiAgICBjb25zdCBwYXJhbXMgPSB0aGlzLnNjb3BlSWQgPT0gbnVsbCA/IFwiXCIgOiBHTE9CQUxfQ09OVEVYVF9SRUZFUkVOQ0VTO1xuICAgIGNvbnN0IGJvZHkgPSBwYXRjaGVzID8gcmVzdWx0ICsgXCIsXCIgKyBwYXRjaGVzICsgcmVmIDogcmVzdWx0O1xuICAgIGlmIChwYXJhbXMgPT09IFwiXCIpIHtcbiAgICAgIHJldHVybiBwYXRjaGVzID8gXCIoXCIgKyBib2R5ICsgXCIpXCIgOiBib2R5O1xuICAgIH1cbiAgICBjb25zdCBhcmdzID0gdGhpcy5zY29wZUlkID09IG51bGwgPyBcIigpXCIgOiBcIihcIiArIEdMT0JBTF9DT05URVhUX1JFRkVSRU5DRVMgKyAnW1wiJyArIHNlcmlhbGl6ZVN0cmluZyh0aGlzLnNjb3BlSWQpICsgJ1wiXSknO1xuICAgIHJldHVybiBcIihcIiArIHRoaXMuY3JlYXRlRnVuY3Rpb24oW3BhcmFtc10sIGJvZHkpICsgXCIpXCIgKyBhcmdzO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9jb250ZXh0L3BhcnNlci9zdHJlYW0udHNcbnZhciBCYXNlU3RyZWFtUGFyc2VyQ29udGV4dCA9IGNsYXNzIGV4dGVuZHMgQmFzZVN5bmNQYXJzZXJDb250ZXh0IHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKG9wdGlvbnMpO1xuICAgIC8vIExpZmVcbiAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICAvLyBBbW91bnQgb2YgcGVuZGluZyBwcm9taXNlcy9zdHJlYW1zXG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgICB0aGlzLmluaXRpYWwgPSB0cnVlO1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy5vblBhcnNlQ2FsbGJhY2sgPSBvcHRpb25zLm9uUGFyc2U7XG4gICAgdGhpcy5vbkVycm9yQ2FsbGJhY2sgPSBvcHRpb25zLm9uRXJyb3I7XG4gICAgdGhpcy5vbkRvbmVDYWxsYmFjayA9IG9wdGlvbnMub25Eb25lO1xuICB9XG4gIG9uUGFyc2VJbnRlcm5hbChub2RlLCBpbml0aWFsKSB7XG4gICAgdHJ5IHtcbiAgICAgIHRoaXMub25QYXJzZUNhbGxiYWNrKG5vZGUsIGluaXRpYWwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aGlzLm9uRXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBmbHVzaCgpIHtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gdGhpcy5idWZmZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHRoaXMub25QYXJzZUludGVybmFsKHRoaXMuYnVmZmVyW2ldLCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIG9uUGFyc2Uobm9kZSkge1xuICAgIGlmICh0aGlzLmluaXRpYWwpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2gobm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub25QYXJzZUludGVybmFsKG5vZGUsIGZhbHNlKTtcbiAgICB9XG4gIH1cbiAgb25FcnJvcihlcnJvcikge1xuICAgIGlmICh0aGlzLm9uRXJyb3JDYWxsYmFjaykge1xuICAgICAgdGhpcy5vbkVycm9yQ2FsbGJhY2soZXJyb3IpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH1cbiAgb25Eb25lKCkge1xuICAgIGlmICh0aGlzLm9uRG9uZUNhbGxiYWNrKSB7XG4gICAgICB0aGlzLm9uRG9uZUNhbGxiYWNrKCk7XG4gICAgfVxuICB9XG4gIHB1c2hQZW5kaW5nU3RhdGUoKSB7XG4gICAgdGhpcy5wZW5kaW5nKys7XG4gIH1cbiAgcG9wUGVuZGluZ1N0YXRlKCkge1xuICAgIGlmICgtLXRoaXMucGVuZGluZyA8PSAwKSB7XG4gICAgICB0aGlzLm9uRG9uZSgpO1xuICAgIH1cbiAgfVxuICBwYXJzZVByb3BlcnRpZXMocHJvcGVydGllcykge1xuICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyhwcm9wZXJ0aWVzKTtcbiAgICBjb25zdCBrZXlOb2RlcyA9IFtdO1xuICAgIGNvbnN0IHZhbHVlTm9kZXMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbGVuID0gZW50cmllcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAga2V5Tm9kZXMucHVzaChzZXJpYWxpemVTdHJpbmcoZW50cmllc1tpXVswXSkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKHRoaXMucGFyc2UoZW50cmllc1tpXVsxXSkpO1xuICAgIH1cbiAgICBsZXQgc3ltYm9sID0gU3ltYm9sLml0ZXJhdG9yO1xuICAgIGlmIChzeW1ib2wgaW4gcHJvcGVydGllcykge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKHN5bWJvbCkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKFxuICAgICAgICBjcmVhdGVJdGVyYXRvckZhY3RvcnlJbnN0YW5jZU5vZGUoXG4gICAgICAgICAgdGhpcy5wYXJzZUl0ZXJhdG9yRmFjdG9yeSgpLFxuICAgICAgICAgIHRoaXMucGFyc2UoXG4gICAgICAgICAgICBpdGVyYXRvclRvU2VxdWVuY2UocHJvcGVydGllcylcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHN5bWJvbCA9IFN5bWJvbC5hc3luY0l0ZXJhdG9yO1xuICAgIGlmIChzeW1ib2wgaW4gcHJvcGVydGllcykge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKHN5bWJvbCkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKFxuICAgICAgICBjcmVhdGVBc3luY0l0ZXJhdG9yRmFjdG9yeUluc3RhbmNlTm9kZShcbiAgICAgICAgICB0aGlzLnBhcnNlQXN5bmNJdGVyYXRvckZhY3RvcnkoKSxcbiAgICAgICAgICB0aGlzLnBhcnNlKFxuICAgICAgICAgICAgY3JlYXRlU3RyZWFtRnJvbUFzeW5jSXRlcmFibGUoXG4gICAgICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgICAgIClcbiAgICAgICAgICApXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIHN5bWJvbCA9IFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICBpZiAoc3ltYm9sIGluIHByb3BlcnRpZXMpIHtcbiAgICAgIGtleU5vZGVzLnB1c2godGhpcy5wYXJzZVdlbGxLbm93blN5bWJvbChzeW1ib2wpKTtcbiAgICAgIHZhbHVlTm9kZXMucHVzaChjcmVhdGVTdHJpbmdOb2RlKHByb3BlcnRpZXNbc3ltYm9sXSkpO1xuICAgIH1cbiAgICBzeW1ib2wgPSBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlO1xuICAgIGlmIChzeW1ib2wgaW4gcHJvcGVydGllcykge1xuICAgICAga2V5Tm9kZXMucHVzaCh0aGlzLnBhcnNlV2VsbEtub3duU3ltYm9sKHN5bWJvbCkpO1xuICAgICAgdmFsdWVOb2Rlcy5wdXNoKHByb3BlcnRpZXNbc3ltYm9sXSA/IFRSVUVfTk9ERSA6IEZBTFNFX05PREUpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgazoga2V5Tm9kZXMsXG4gICAgICB2OiB2YWx1ZU5vZGVzLFxuICAgICAgczoga2V5Tm9kZXMubGVuZ3RoXG4gICAgfTtcbiAgfVxuICBwYXJzZVByb21pc2UoaWQsIGN1cnJlbnQpIHtcbiAgICBjdXJyZW50LnRoZW4oXG4gICAgICAoZGF0YSkgPT4ge1xuICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlV2l0aEVycm9yKGRhdGEpO1xuICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgdGhpcy5vblBhcnNlKHtcbiAgICAgICAgICAgIHQ6IDIzIC8qIFByb21pc2VSZXNvbHZlICovLFxuICAgICAgICAgICAgaTogaWQsXG4gICAgICAgICAgICBzOiB2b2lkIDAsXG4gICAgICAgICAgICBsOiB2b2lkIDAsXG4gICAgICAgICAgICBjOiB2b2lkIDAsXG4gICAgICAgICAgICBtOiB2b2lkIDAsXG4gICAgICAgICAgICBwOiB2b2lkIDAsXG4gICAgICAgICAgICBlOiB2b2lkIDAsXG4gICAgICAgICAgICBhOiBbXG4gICAgICAgICAgICAgIHRoaXMucGFyc2VTcGVjaWFsUmVmZXJlbmNlKDIgLyogUHJvbWlzZVJlc29sdmUgKi8pLFxuICAgICAgICAgICAgICBwYXJzZWRcbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBmOiB2b2lkIDAsXG4gICAgICAgICAgICBiOiB2b2lkIDAsXG4gICAgICAgICAgICBvOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcFBlbmRpbmdTdGF0ZSgpO1xuICAgICAgfSxcbiAgICAgIChkYXRhKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFsaXZlKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVdpdGhFcnJvcihkYXRhKTtcbiAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uUGFyc2Uoe1xuICAgICAgICAgICAgICB0OiAyNCAvKiBQcm9taXNlUmVqZWN0ICovLFxuICAgICAgICAgICAgICBpOiBpZCxcbiAgICAgICAgICAgICAgczogdm9pZCAwLFxuICAgICAgICAgICAgICBsOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGM6IHZvaWQgMCxcbiAgICAgICAgICAgICAgbTogdm9pZCAwLFxuICAgICAgICAgICAgICBwOiB2b2lkIDAsXG4gICAgICAgICAgICAgIGU6IHZvaWQgMCxcbiAgICAgICAgICAgICAgYTogW1xuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VTcGVjaWFsUmVmZXJlbmNlKDMgLyogUHJvbWlzZVJlamVjdCAqLyksXG4gICAgICAgICAgICAgICAgcGFyc2VkXG4gICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgIGY6IHZvaWQgMCxcbiAgICAgICAgICAgICAgYjogdm9pZCAwLFxuICAgICAgICAgICAgICBvOiB2b2lkIDBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnBvcFBlbmRpbmdTdGF0ZSgpO1xuICAgICAgfVxuICAgICk7XG4gICAgdGhpcy5wdXNoUGVuZGluZ1N0YXRlKCk7XG4gICAgcmV0dXJuIHRoaXMuY3JlYXRlUHJvbWlzZUNvbnN0cnVjdG9yTm9kZShpZCk7XG4gIH1cbiAgcGFyc2VQbHVnaW4oaWQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCBjdXJyZW50UGx1Z2lucyA9IHRoaXMucGx1Z2lucztcbiAgICBpZiAoY3VycmVudFBsdWdpbnMpIHtcbiAgICAgIGZvciAobGV0IGkgPSAwLCBsZW4gPSBjdXJyZW50UGx1Z2lucy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBjb25zdCBwbHVnaW4gPSBjdXJyZW50UGx1Z2luc1tpXTtcbiAgICAgICAgaWYgKHBsdWdpbi5wYXJzZS5zdHJlYW0gJiYgcGx1Z2luLnRlc3QoY3VycmVudCkpIHtcbiAgICAgICAgICByZXR1cm4gY3JlYXRlUGx1Z2luTm9kZShcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgcGx1Z2luLnRhZyxcbiAgICAgICAgICAgIHBsdWdpbi5wYXJzZS5zdHJlYW0oY3VycmVudCwgdGhpcywge1xuICAgICAgICAgICAgICBpZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB2b2lkIDA7XG4gIH1cbiAgcGFyc2VTdHJlYW0oaWQsIGN1cnJlbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBjcmVhdGVTdHJlYW1Db25zdHJ1Y3Rvck5vZGUoXG4gICAgICBpZCxcbiAgICAgIHRoaXMucGFyc2VTcGVjaWFsUmVmZXJlbmNlKDQgLyogU3RyZWFtQ29uc3RydWN0b3IgKi8pLFxuICAgICAgW11cbiAgICApO1xuICAgIHRoaXMucHVzaFBlbmRpbmdTdGF0ZSgpO1xuICAgIGN1cnJlbnQub24oe1xuICAgICAgbmV4dDogKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFsaXZlKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVdpdGhFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblBhcnNlKGNyZWF0ZVN0cmVhbU5leHROb2RlKGlkLCBwYXJzZWQpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB0aHJvdzogKHZhbHVlKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLmFsaXZlKSB7XG4gICAgICAgICAgY29uc3QgcGFyc2VkID0gdGhpcy5wYXJzZVdpdGhFcnJvcih2YWx1ZSk7XG4gICAgICAgICAgaWYgKHBhcnNlZCkge1xuICAgICAgICAgICAgdGhpcy5vblBhcnNlKGNyZWF0ZVN0cmVhbVRocm93Tm9kZShpZCwgcGFyc2VkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wUGVuZGluZ1N0YXRlKCk7XG4gICAgICB9LFxuICAgICAgcmV0dXJuOiAodmFsdWUpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuYWxpdmUpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlV2l0aEVycm9yKHZhbHVlKTtcbiAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICB0aGlzLm9uUGFyc2UoY3JlYXRlU3RyZWFtUmV0dXJuTm9kZShpZCwgcGFyc2VkKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMucG9wUGVuZGluZ1N0YXRlKCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBwYXJzZVdpdGhFcnJvcihjdXJyZW50KSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLnBhcnNlKGN1cnJlbnQpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhpcy5vbkVycm9yKGVycik7XG4gICAgICByZXR1cm4gdm9pZCAwO1xuICAgIH1cbiAgfVxuICAvKipcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0KGN1cnJlbnQpIHtcbiAgICBjb25zdCBwYXJzZWQgPSB0aGlzLnBhcnNlV2l0aEVycm9yKGN1cnJlbnQpO1xuICAgIGlmIChwYXJzZWQpIHtcbiAgICAgIHRoaXMub25QYXJzZUludGVybmFsKHBhcnNlZCwgdHJ1ZSk7XG4gICAgICB0aGlzLmluaXRpYWwgPSBmYWxzZTtcbiAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmcgPD0gMCkge1xuICAgICAgICB0aGlzLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmFsaXZlKSB7XG4gICAgICB0aGlzLm9uRG9uZSgpO1xuICAgICAgdGhpcy5hbGl2ZSA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBpc0FsaXZlKCkge1xuICAgIHJldHVybiB0aGlzLmFsaXZlO1xuICB9XG59O1xuXG4vLyBzcmMvY29yZS9jcm9zcy9zdHJlYW0udHNcbnZhciBDcm9zc1N0cmVhbVBhcnNlckNvbnRleHQgPSBjbGFzcyBleHRlbmRzIEJhc2VTdHJlYW1QYXJzZXJDb250ZXh0IHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLm1vZGUgPSBcImNyb3NzXCI7XG4gIH1cbn07XG5cbi8vIHNyYy9jb3JlL2Nyb3NzL3N5bmMudHNcbnZhciBDcm9zc1N5bmNQYXJzZXJDb250ZXh0ID0gY2xhc3MgZXh0ZW5kcyBCYXNlU3luY1BhcnNlckNvbnRleHQge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgIHRoaXMubW9kZSA9IFwiY3Jvc3NcIjtcbiAgfVxufTtcblxuLy8gc3JjL2NvcmUvY3Jvc3MvaW5kZXgudHNcbmZ1bmN0aW9uIGNyb3NzU2VyaWFsaXplKHNvdXJjZSwgb3B0aW9ucyA9IHt9KSB7XG4gIGNvbnN0IHBsdWdpbnMgPSByZXNvbHZlUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICBjb25zdCBjdHggPSBuZXcgQ3Jvc3NTeW5jUGFyc2VyQ29udGV4dCh7XG4gICAgcGx1Z2lucyxcbiAgICBkaXNhYmxlZEZlYXR1cmVzOiBvcHRpb25zLmRpc2FibGVkRmVhdHVyZXMsXG4gICAgcmVmczogb3B0aW9ucy5yZWZzXG4gIH0pO1xuICBjb25zdCB0cmVlID0gY3R4LnBhcnNlKHNvdXJjZSk7XG4gIGNvbnN0IHNlcmlhbCA9IG5ldyBDcm9zc1NlcmlhbGl6ZXJDb250ZXh0KHtcbiAgICBwbHVnaW5zLFxuICAgIGZlYXR1cmVzOiBjdHguZmVhdHVyZXMsXG4gICAgc2NvcGVJZDogb3B0aW9ucy5zY29wZUlkLFxuICAgIG1hcmtlZFJlZnM6IGN0eC5tYXJrZWRcbiAgfSk7XG4gIHJldHVybiBzZXJpYWwuc2VyaWFsaXplVG9wKHRyZWUpO1xufVxuYXN5bmMgZnVuY3Rpb24gY3Jvc3NTZXJpYWxpemVBc3luYyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwbHVnaW5zID0gcmVzb2x2ZVBsdWdpbnMob3B0aW9ucy5wbHVnaW5zKTtcbiAgY29uc3QgY3R4ID0gbmV3IENyb3NzQXN5bmNQYXJzZXJDb250ZXh0KHtcbiAgICBwbHVnaW5zLFxuICAgIGRpc2FibGVkRmVhdHVyZXM6IG9wdGlvbnMuZGlzYWJsZWRGZWF0dXJlcyxcbiAgICByZWZzOiBvcHRpb25zLnJlZnNcbiAgfSk7XG4gIGNvbnN0IHRyZWUgPSBhd2FpdCBjdHgucGFyc2Uoc291cmNlKTtcbiAgY29uc3Qgc2VyaWFsID0gbmV3IENyb3NzU2VyaWFsaXplckNvbnRleHQoe1xuICAgIHBsdWdpbnMsXG4gICAgZmVhdHVyZXM6IGN0eC5mZWF0dXJlcyxcbiAgICBzY29wZUlkOiBvcHRpb25zLnNjb3BlSWQsXG4gICAgbWFya2VkUmVmczogY3R4Lm1hcmtlZFxuICB9KTtcbiAgcmV0dXJuIHNlcmlhbC5zZXJpYWxpemVUb3AodHJlZSk7XG59XG5mdW5jdGlvbiB0b0Nyb3NzSlNPTihzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwbHVnaW5zID0gcmVzb2x2ZVBsdWdpbnMob3B0aW9ucy5wbHVnaW5zKTtcbiAgY29uc3QgY3R4ID0gbmV3IENyb3NzU3luY1BhcnNlckNvbnRleHQoe1xuICAgIHBsdWdpbnMsXG4gICAgZGlzYWJsZWRGZWF0dXJlczogb3B0aW9ucy5kaXNhYmxlZEZlYXR1cmVzLFxuICAgIHJlZnM6IG9wdGlvbnMucmVmc1xuICB9KTtcbiAgcmV0dXJuIGN0eC5wYXJzZShzb3VyY2UpO1xufVxuYXN5bmMgZnVuY3Rpb24gdG9Dcm9zc0pTT05Bc3luYyhzb3VyY2UsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBwbHVnaW5zID0gcmVzb2x2ZVBsdWdpbnMob3B0aW9ucy5wbHVnaW5zKTtcbiAgY29uc3QgY3R4ID0gbmV3IENyb3NzQXN5bmNQYXJzZXJDb250ZXh0KHtcbiAgICBwbHVnaW5zLFxuICAgIGRpc2FibGVkRmVhdHVyZXM6IG9wdGlvbnMuZGlzYWJsZWRGZWF0dXJlcyxcbiAgICByZWZzOiBvcHRpb25zLnJlZnNcbiAgfSk7XG4gIHJldHVybiBhd2FpdCBjdHgucGFyc2Uoc291cmNlKTtcbn1cbmZ1bmN0aW9uIGNyb3NzU2VyaWFsaXplU3RyZWFtKHNvdXJjZSwgb3B0aW9ucykge1xuICBjb25zdCBwbHVnaW5zID0gcmVzb2x2ZVBsdWdpbnMob3B0aW9ucy5wbHVnaW5zKTtcbiAgY29uc3QgY3R4ID0gbmV3IENyb3NzU3RyZWFtUGFyc2VyQ29udGV4dCh7XG4gICAgcGx1Z2lucyxcbiAgICByZWZzOiBvcHRpb25zLnJlZnMsXG4gICAgZGlzYWJsZWRGZWF0dXJlczogb3B0aW9ucy5kaXNhYmxlZEZlYXR1cmVzLFxuICAgIG9uUGFyc2Uobm9kZSwgaW5pdGlhbCkge1xuICAgICAgY29uc3Qgc2VyaWFsID0gbmV3IENyb3NzU2VyaWFsaXplckNvbnRleHQoe1xuICAgICAgICBwbHVnaW5zLFxuICAgICAgICBmZWF0dXJlczogY3R4LmZlYXR1cmVzLFxuICAgICAgICBzY29wZUlkOiBvcHRpb25zLnNjb3BlSWQsXG4gICAgICAgIG1hcmtlZFJlZnM6IGN0eC5tYXJrZWRcbiAgICAgIH0pO1xuICAgICAgbGV0IHNlcmlhbGl6ZWQ7XG4gICAgICB0cnkge1xuICAgICAgICBzZXJpYWxpemVkID0gc2VyaWFsLnNlcmlhbGl6ZVRvcChub2RlKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAob3B0aW9ucy5vbkVycm9yKSB7XG4gICAgICAgICAgb3B0aW9ucy5vbkVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgb3B0aW9ucy5vblNlcmlhbGl6ZShzZXJpYWxpemVkLCBpbml0aWFsKTtcbiAgICB9LFxuICAgIG9uRXJyb3I6IG9wdGlvbnMub25FcnJvcixcbiAgICBvbkRvbmU6IG9wdGlvbnMub25Eb25lXG4gIH0pO1xuICBjdHguc3RhcnQoc291cmNlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjdHguZGVzdHJveSgpO1xuICB9O1xufVxuZnVuY3Rpb24gdG9Dcm9zc0pTT05TdHJlYW0oc291cmNlLCBvcHRpb25zKSB7XG4gIGNvbnN0IHBsdWdpbnMgPSByZXNvbHZlUGx1Z2lucyhvcHRpb25zLnBsdWdpbnMpO1xuICBjb25zdCBjdHggPSBuZXcgQ3Jvc3NTdHJlYW1QYXJzZXJDb250ZXh0KHtcbiAgICBwbHVnaW5zLFxuICAgIHJlZnM6IG9wdGlvbnMucmVmcyxcbiAgICBkaXNhYmxlZEZlYXR1cmVzOiBvcHRpb25zLmRpc2FibGVkRmVhdHVyZXMsXG4gICAgb25QYXJzZTogb3B0aW9ucy5vblBhcnNlLFxuICAgIG9uRXJyb3I6IG9wdGlvbnMub25FcnJvcixcbiAgICBvbkRvbmU6IG9wdGlvbnMub25Eb25lXG4gIH0pO1xuICBjdHguc3RhcnQoc291cmNlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICBjdHguZGVzdHJveSgpO1xuICB9O1xufVxuZnVuY3Rpb24gZnJvbUNyb3NzSlNPTihzb3VyY2UsIG9wdGlvbnMpIHtcbiAgY29uc3QgcGx1Z2lucyA9IHJlc29sdmVQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG4gIGNvbnN0IGN0eCA9IG5ldyBDcm9zc0Rlc2VyaWFsaXplckNvbnRleHQoe1xuICAgIHBsdWdpbnMsXG4gICAgcmVmczogb3B0aW9ucy5yZWZzXG4gIH0pO1xuICByZXR1cm4gY3R4LmRlc2VyaWFsaXplKHNvdXJjZSk7XG59XG5cbi8vIHNyYy9jb3JlL1NlcmlhbGl6ZXIudHNcbnZhciBTZXJpYWxpemVyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLmFsaXZlID0gdHJ1ZTtcbiAgICB0aGlzLmZsdXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICAgIHRoaXMuY2xlYW51cHMgPSBbXTtcbiAgICB0aGlzLnJlZnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuICAgIHRoaXMua2V5cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gICAgdGhpcy5pZHMgPSAwO1xuICAgIHRoaXMucGx1Z2lucyA9IHJlc29sdmVQbHVnaW5zKG9wdGlvbnMucGx1Z2lucyk7XG4gIH1cbiAgd3JpdGUoa2V5LCB2YWx1ZSkge1xuICAgIGlmICh0aGlzLmFsaXZlICYmICF0aGlzLmZsdXNoZWQpIHtcbiAgICAgIHRoaXMucGVuZGluZysrO1xuICAgICAgdGhpcy5rZXlzLmFkZChrZXkpO1xuICAgICAgdGhpcy5jbGVhbnVwcy5wdXNoKFxuICAgICAgICBjcm9zc1NlcmlhbGl6ZVN0cmVhbSh2YWx1ZSwge1xuICAgICAgICAgIHBsdWdpbnM6IHRoaXMucGx1Z2lucyxcbiAgICAgICAgICBzY29wZUlkOiB0aGlzLm9wdGlvbnMuc2NvcGVJZCxcbiAgICAgICAgICByZWZzOiB0aGlzLnJlZnMsXG4gICAgICAgICAgZGlzYWJsZWRGZWF0dXJlczogdGhpcy5vcHRpb25zLmRpc2FibGVkRmVhdHVyZXMsXG4gICAgICAgICAgb25FcnJvcjogdGhpcy5vcHRpb25zLm9uRXJyb3IsXG4gICAgICAgICAgb25TZXJpYWxpemU6IChkYXRhLCBpbml0aWFsKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25EYXRhKFxuICAgICAgICAgICAgICAgIGluaXRpYWwgPyB0aGlzLm9wdGlvbnMuZ2xvYmFsSWRlbnRpZmllciArICdbXCInICsgc2VyaWFsaXplU3RyaW5nKGtleSkgKyAnXCJdPScgKyBkYXRhIDogZGF0YVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgb25Eb25lOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbGl2ZSkge1xuICAgICAgICAgICAgICB0aGlzLnBlbmRpbmctLTtcbiAgICAgICAgICAgICAgaWYgKHRoaXMucGVuZGluZyA8PSAwICYmIHRoaXMuZmx1c2hlZCAmJiAhdGhpcy5kb25lICYmIHRoaXMub3B0aW9ucy5vbkRvbmUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMub25Eb25lKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGdldE5leHRJRCgpIHtcbiAgICB3aGlsZSAodGhpcy5rZXlzLmhhcyhcIlwiICsgdGhpcy5pZHMpKSB7XG4gICAgICB0aGlzLmlkcysrO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIiArIHRoaXMuaWRzO1xuICB9XG4gIHB1c2godmFsdWUpIHtcbiAgICBjb25zdCBuZXdJRCA9IHRoaXMuZ2V0TmV4dElEKCk7XG4gICAgdGhpcy53cml0ZShuZXdJRCwgdmFsdWUpO1xuICAgIHJldHVybiBuZXdJRDtcbiAgfVxuICBmbHVzaCgpIHtcbiAgICBpZiAodGhpcy5hbGl2ZSkge1xuICAgICAgdGhpcy5mbHVzaGVkID0gdHJ1ZTtcbiAgICAgIGlmICh0aGlzLnBlbmRpbmcgPD0gMCAmJiAhdGhpcy5kb25lICYmIHRoaXMub3B0aW9ucy5vbkRvbmUpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm9uRG9uZSgpO1xuICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjbG9zZSgpIHtcbiAgICBpZiAodGhpcy5hbGl2ZSkge1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IHRoaXMuY2xlYW51cHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdGhpcy5jbGVhbnVwc1tpXSgpO1xuICAgICAgfVxuICAgICAgaWYgKCF0aGlzLmRvbmUgJiYgdGhpcy5vcHRpb25zLm9uRG9uZSkge1xuICAgICAgICB0aGlzLm9wdGlvbnMub25Eb25lKCk7XG4gICAgICAgIHRoaXMuZG9uZSA9IHRydWU7XG4gICAgICB9XG4gICAgICB0aGlzLmFsaXZlID0gZmFsc2U7XG4gICAgfVxuICB9XG59O1xuZXhwb3J0IHtcbiAgRmVhdHVyZSxcbiAgU2VyaWFsaXplcixcbiAgU2Vyb3ZhbERlc2VyaWFsaXphdGlvbkVycm9yLFxuICBTZXJvdmFsRXJyb3IsXG4gIFNlcm92YWxNaXNzaW5nSW5zdGFuY2VFcnJvcixcbiAgU2Vyb3ZhbE1pc3NpbmdQbHVnaW5FcnJvcixcbiAgU2Vyb3ZhbE1pc3NpbmdSZWZlcmVuY2VFcnJvcixcbiAgU2Vyb3ZhbE1pc3NpbmdSZWZlcmVuY2VGb3JJZEVycm9yLFxuICBTZXJvdmFsUGFyc2VyRXJyb3IsXG4gIFNlcm92YWxTZXJpYWxpemF0aW9uRXJyb3IsXG4gIFNlcm92YWxVbmtub3duVHlwZWRBcnJheUVycm9yLFxuICBTZXJvdmFsVW5zdXBwb3J0ZWROb2RlRXJyb3IsXG4gIFNlcm92YWxVbnN1cHBvcnRlZFR5cGVFcnJvcixcbiAgY29tcGlsZUpTT04sXG4gIGNyZWF0ZVBsdWdpbixcbiAgY3JlYXRlUmVmZXJlbmNlLFxuICBjcmVhdGVTdHJlYW0sXG4gIGNyb3NzU2VyaWFsaXplLFxuICBjcm9zc1NlcmlhbGl6ZUFzeW5jLFxuICBjcm9zc1NlcmlhbGl6ZVN0cmVhbSxcbiAgZGVzZXJpYWxpemUsXG4gIGZyb21Dcm9zc0pTT04sXG4gIGZyb21KU09OLFxuICBnZXRDcm9zc1JlZmVyZW5jZUhlYWRlcixcbiAgcmVzb2x2ZVBsdWdpbnMsXG4gIHNlcmlhbGl6ZSxcbiAgc2VyaWFsaXplQXN5bmMsXG4gIHRvQ3Jvc3NKU09OLFxuICB0b0Nyb3NzSlNPTkFzeW5jLFxuICB0b0Nyb3NzSlNPTlN0cmVhbSxcbiAgdG9KU09OLFxuICB0b0pTT05Bc3luY1xufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJGZWF0dXJlIiwiRmVhdHVyZTIiLCJBTExfRU5BQkxFRCIsImFzc2VydCIsImNvbmQiLCJlcnJvciIsInNlcmlhbGl6ZUNoYXIiLCJzdHIiLCJzZXJpYWxpemVTdHJpbmciLCJyZXN1bHQiLCJsYXN0UG9zIiwicmVwbGFjZW1lbnQiLCJpIiwibGVuIiwibGVuZ3RoIiwic2xpY2UiLCJkZXNlcmlhbGl6ZVJlcGxhY2VyIiwiZGVzZXJpYWxpemVTdHJpbmciLCJyZXBsYWNlIiwiUkVGRVJFTkNFU19LRVkiLCJHTE9CQUxfQ09OVEVYVF9SRUZFUkVOQ0VTIiwiR0xPQkFMX0NPTlRFWFRfUiIsImdldENyb3NzUmVmZXJlbmNlSGVhZGVyIiwiaWQiLCJSRUZFUkVOQ0UiLCJNYXAiLCJJTlZfUkVGRVJFTkNFIiwiY3JlYXRlUmVmZXJlbmNlIiwidmFsdWUiLCJzZXQiLCJoYXNSZWZlcmVuY2VJRCIsImhhcyIsImhhc1JlZmVyZW5jZSIsImdldFJlZmVyZW5jZUlEIiwiU2Vyb3ZhbE1pc3NpbmdSZWZlcmVuY2VFcnJvciIsImdldCIsImdldFJlZmVyZW5jZSIsIlNlcm92YWxNaXNzaW5nUmVmZXJlbmNlRm9ySWRFcnJvciIsImdsb2JhbFRoaXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsImNvbmZpZ3VyYWJsZSIsIndyaXRhYmxlIiwiZW51bWVyYWJsZSIsIndpbmRvdyIsInNlbGYiLCJnbG9iYWwiLCJjcmVhdGVQbHVnaW4iLCJwbHVnaW4iLCJkZWR1cGVQbHVnaW5zIiwiZGVkdXBlZCIsInBsdWdpbnMiLCJjdXJyZW50IiwiYWRkIiwiZXh0ZW5kcyIsInJlc29sdmVQbHVnaW5zIiwiU2V0IiwiU1lNQk9MX1NUUklORyIsIklOVl9TWU1CT0xfUkVGIiwiU3ltYm9sIiwiYXN5bmNJdGVyYXRvciIsImhhc0luc3RhbmNlIiwiaXNDb25jYXRTcHJlYWRhYmxlIiwiaXRlcmF0b3IiLCJtYXRjaCIsIm1hdGNoQWxsIiwic2VhcmNoIiwic3BlY2llcyIsInNwbGl0IiwidG9QcmltaXRpdmUiLCJ0b1N0cmluZ1RhZyIsInVuc2NvcGFibGVzIiwiU1lNQk9MX1JFRiIsIkNPTlNUQU5UX1NUUklORyIsIkNPTlNUQU5UX1ZBTCIsIkluZmluaXR5IiwiTmFOIiwiRVJST1JfQ09OU1RSVUNUT1JfU1RSSU5HIiwiRVJST1JfQ09OU1RSVUNUT1IiLCJFcnJvciIsIkV2YWxFcnJvciIsIlJhbmdlRXJyb3IiLCJSZWZlcmVuY2VFcnJvciIsIlN5bnRheEVycm9yIiwiVHlwZUVycm9yIiwiVVJJRXJyb3IiLCJjcmVhdGVDb25zdGFudE5vZGUiLCJ0IiwicyIsImwiLCJjIiwibSIsInAiLCJlIiwiYSIsImYiLCJiIiwibyIsIlRSVUVfTk9ERSIsIkZBTFNFX05PREUiLCJVTkRFRklORURfTk9ERSIsIk5VTExfTk9ERSIsIk5FR19aRVJPX05PREUiLCJJTkZJTklUWV9OT0RFIiwiTkVHX0lORklOSVRZX05PREUiLCJOQU5fTk9ERSIsImdldEVycm9yQ29uc3RydWN0b3IiLCJnZXRJbml0aWFsRXJyb3JPcHRpb25zIiwiY29uc3RydWN0IiwibmFtZSIsImNvbnN0cnVjdG9yIiwiZ2V0RXJyb3JPcHRpb25zIiwiZmVhdHVyZXMiLCJvcHRpb25zIiwibmFtZXMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiZ2V0T2JqZWN0RmxhZyIsIm9iaiIsImlzRnJvemVuIiwiaXNTZWFsZWQiLCJpc0V4dGVuc2libGUiLCJjcmVhdGVOdW1iZXJOb2RlIiwiaXMiLCJjcmVhdGVTdHJpbmdOb2RlIiwiY3JlYXRlQmlnSW50Tm9kZSIsImNyZWF0ZUluZGV4ZWRWYWx1ZU5vZGUiLCJjcmVhdGVEYXRlTm9kZSIsInRvSVNPU3RyaW5nIiwiY3JlYXRlUmVnRXhwTm9kZSIsInNvdXJjZSIsImZsYWdzIiwiY3JlYXRlQXJyYXlCdWZmZXJOb2RlIiwiYnl0ZXMiLCJVaW50OEFycmF5IiwidmFsdWVzIiwiQXJyYXkiLCJjcmVhdGVXS1N5bWJvbE5vZGUiLCJjcmVhdGVSZWZlcmVuY2VOb2RlIiwicmVmIiwiY3JlYXRlUGx1Z2luTm9kZSIsInRhZyIsImNyZWF0ZUFycmF5Tm9kZSIsInBhcnNlZEl0ZW1zIiwiY3JlYXRlQm94ZWROb2RlIiwiYm94ZWQiLCJjcmVhdGVUeXBlZEFycmF5Tm9kZSIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJjcmVhdGVCaWdJbnRUeXBlZEFycmF5Tm9kZSIsImNyZWF0ZURhdGFWaWV3Tm9kZSIsImJ5dGVMZW5ndGgiLCJjcmVhdGVFcnJvck5vZGUiLCJtZXNzYWdlIiwiY3JlYXRlQWdncmVnYXRlRXJyb3JOb2RlIiwiY3JlYXRlU2V0Tm9kZSIsInNpemUiLCJpdGVtcyIsImNyZWF0ZUl0ZXJhdG9yRmFjdG9yeUluc3RhbmNlTm9kZSIsImZhY3RvcnkiLCJjcmVhdGVBc3luY0l0ZXJhdG9yRmFjdG9yeUluc3RhbmNlTm9kZSIsImNyZWF0ZVN0cmVhbUNvbnN0cnVjdG9yTm9kZSIsInNlcXVlbmNlIiwiY3JlYXRlU3RyZWFtTmV4dE5vZGUiLCJwYXJzZWQiLCJjcmVhdGVTdHJlYW1UaHJvd05vZGUiLCJjcmVhdGVTdHJlYW1SZXR1cm5Ob2RlIiwiaXRlcmF0b3JUb1NlcXVlbmNlIiwidGhyb3dzQXQiLCJkb25lQXQiLCJuZXh0IiwicHVzaCIsImRvbmUiLCJ2IiwiZCIsInNlcXVlbmNlVG9JdGVyYXRvciIsImluZGV4IiwiY3VycmVudEluZGV4IiwiY3VycmVudEl0ZW0iLCJJVEVSQVRPUiIsIkFTWU5DX0lURVJBVE9SIiwiU1BFQ0lBTF9SRUZTIiwidG9TdHJpbmciLCJvYmplY3RUb1N0cmluZyIsInByb3RvdHlwZSIsImdldEVycm9yTWVzc2FnZSIsInR5cGUiLCJjYXVzZSIsImNhbGwiLCJTZXJvdmFsRXJyb3IiLCJTZXJvdmFsUGFyc2VyRXJyb3IiLCJTZXJvdmFsU2VyaWFsaXphdGlvbkVycm9yIiwiU2Vyb3ZhbERlc2VyaWFsaXphdGlvbkVycm9yIiwiU2Vyb3ZhbFVuc3VwcG9ydGVkVHlwZUVycm9yIiwiU2Vyb3ZhbFVuc3VwcG9ydGVkTm9kZUVycm9yIiwibm9kZSIsIlNlcm92YWxNaXNzaW5nUGx1Z2luRXJyb3IiLCJTZXJvdmFsTWlzc2luZ0luc3RhbmNlRXJyb3IiLCJTZXJvdmFsVW5rbm93blR5cGVkQXJyYXlFcnJvciIsIkJhc2VQYXJzZXJDb250ZXh0IiwibWFya2VkIiwiZGlzYWJsZWRGZWF0dXJlcyIsInJlZnMiLCJtYXJrUmVmIiwiaXNNYXJrZWQiLCJnZXRJbmRleGVkVmFsdWUiLCJyZWdpc3RlcmVkSWQiLCJpbmRleGVkIiwiZ2V0U3RyaWN0UmVmZXJlbmNlIiwicGFyc2VGdW5jdGlvbiIsInBhcnNlV2VsbEtub3duU3ltYm9sIiwicGFyc2VTcGVjaWFsUmVmZXJlbmNlIiwicGFyc2VJdGVyYXRvckZhY3RvcnkiLCJwYXJzZUFzeW5jSXRlcmF0b3JGYWN0b3J5IiwiY3JlYXRlT2JqZWN0Tm9kZSIsImVtcHR5IiwicmVjb3JkIiwiY3JlYXRlTWFwTm9kZSIsImsiLCJjcmVhdGVQcm9taXNlQ29uc3RydWN0b3JOb2RlIiwicHJvbWlzZVRvUmVzdWx0IiwiY3JlYXRlRGVmZXJyZWQiLCJyZXNvbHZlIiwicmVqZWN0IiwicHJvbWlzZSIsIlByb21pc2UiLCJyZXMiLCJyZWoiLCJpc1N0cmVhbSIsImNyZWF0ZVN0cmVhbSIsImxpc3RlbmVycyIsImFsaXZlIiwic3VjY2VzcyIsImZsdXNoTmV4dCIsImxpc3RlbmVyIiwia2V5cyIsImZsdXNoVGhyb3ciLCJ0aHJvdyIsImZsdXNoUmV0dXJuIiwicmV0dXJuIiwiX19TRVJPVkFMX1NUUkVBTV9fIiwib24iLCJkZWxldGUiLCJjbGVhciIsImNyZWF0ZVN0cmVhbUZyb21Bc3luY0l0ZXJhYmxlIiwiaXRlcmFibGUiLCJzdHJlYW0iLCJjYXRjaCIsInN0cmVhbVRvQXN5bmNJdGVyYWJsZSIsInBlbmRpbmciLCJjb3VudCIsImlzVGhyb3ciLCJyZXNvbHZlQWxsIiwic2hpZnQiLCJmaW5hbGl6ZSIsImRlZmVycmVkIiwiQmFzZUFzeW5jUGFyc2VyQ29udGV4dCIsInBhcnNlSXRlbXMiLCJub2RlcyIsInBhcnNlIiwicGFyc2VBcnJheSIsInBhcnNlUHJvcGVydGllcyIsInByb3BlcnRpZXMiLCJlbnRyaWVzIiwia2V5Tm9kZXMiLCJ2YWx1ZU5vZGVzIiwic3ltYm9sIiwicGFyc2VQbGFpbk9iamVjdCIsInBhcnNlQm94ZWQiLCJ2YWx1ZU9mIiwicGFyc2VUeXBlZEFycmF5IiwicGFyc2VCaWdJbnRUeXBlZEFycmF5IiwicGFyc2VEYXRhVmlldyIsInBhcnNlRXJyb3IiLCJwYXJzZUFnZ3JlZ2F0ZUVycm9yIiwicGFyc2VNYXAiLCJrZXkiLCJwYXJzZVNldCIsIml0ZW0iLCJwYXJzZVByb21pc2UiLCJzdGF0dXMiLCJwYXJzZVBsdWdpbiIsImN1cnJlbnRQbHVnaW5zIiwiYXN5bmMiLCJ0ZXN0IiwicGFyc2VTdHJlYW0iLCJjbGVhbnVwIiwidGhlbiIsImRhdGEiLCJwYXJzZU9iamVjdCIsImlzQXJyYXkiLCJjdXJyZW50Q2xhc3MiLCJEYXRlIiwiUmVnRXhwIiwiTnVtYmVyIiwiQm9vbGVhbiIsIlN0cmluZyIsIkJpZ0ludCIsIkFycmF5QnVmZmVyIiwiSW50OEFycmF5IiwiSW50MTZBcnJheSIsIkludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsIlVpbnQzMkFycmF5IiwiVWludDhDbGFtcGVkQXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJGbG9hdDY0QXJyYXkiLCJEYXRhVmlldyIsImN1cnJlbnRGZWF0dXJlcyIsIkJpZ0ludDY0QXJyYXkiLCJCaWdVaW50NjRBcnJheSIsIkFnZ3JlZ2F0ZUVycm9yIiwiQXN5bmNQYXJzZXJDb250ZXh0IiwiYXJndW1lbnRzIiwibW9kZSIsImdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciIsImFwcGx5T2JqZWN0RmxhZyIsImZsYWciLCJmcmVlemUiLCJwcmV2ZW50RXh0ZW5zaW9ucyIsInNlYWwiLCJCYXNlRGVzZXJpYWxpemVyQ29udGV4dCIsImRlc2VyaWFsaXplUmVmZXJlbmNlIiwiYXNzaWduSW5kZXhlZFZhbHVlIiwiZGVzZXJpYWxpemVBcnJheSIsImRlc2VyaWFsaXplIiwiZGVzZXJpYWxpemVQcm9wZXJ0aWVzIiwidmFscyIsImRlc2VyaWFsaXplT2JqZWN0IiwiY3JlYXRlIiwiZGVzZXJpYWxpemVEYXRlIiwiZGVzZXJpYWxpemVSZWdFeHAiLCJkZXNlcmlhbGl6ZVNldCIsImRlc2VyaWFsaXplTWFwIiwiZGVzZXJpYWxpemVBcnJheUJ1ZmZlciIsImRlc2VyaWFsaXplVHlwZWRBcnJheSIsImRlc2VyaWFsaXplRGF0YVZpZXciLCJkZXNlcmlhbGl6ZURpY3Rpb25hcnkiLCJmaWVsZHMiLCJhc3NpZ24iLCJkZXNlcmlhbGl6ZUFnZ3JlZ2F0ZUVycm9yIiwiZGVzZXJpYWxpemVFcnJvciIsImRlc2VyaWFsaXplUHJvbWlzZSIsImRlc2VyaWFsaXplZCIsImRlc2VyaWFsaXplQm94ZWQiLCJkZXNlcmlhbGl6ZVBsdWdpbiIsImRlc2VyaWFsaXplUHJvbWlzZUNvbnN0cnVjdG9yIiwiZGVzZXJpYWxpemVQcm9taXNlUmVzb2x2ZSIsImRlc2VyaWFsaXplUHJvbWlzZVJlamVjdCIsImRlc2VyaWFsaXplSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2UiLCJkZXNlcmlhbGl6ZUFzeW5jSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2UiLCJkZXNlcmlhbGl6ZVN0cmVhbUNvbnN0cnVjdG9yIiwiZGVzZXJpYWxpemVTdHJlYW1OZXh0IiwiZGVzZXJpYWxpemVTdHJlYW1UaHJvdyIsImRlc2VyaWFsaXplU3RyZWFtUmV0dXJuIiwiZGVzZXJpYWxpemVJdGVyYXRvckZhY3RvcnkiLCJkZXNlcmlhbGl6ZUFzeW5jSXRlcmF0b3JGYWN0b3J5IiwiVmFuaWxsYURlc2VyaWFsaXplckNvbnRleHQiLCJtYXJrZWRSZWZzIiwiSURFTlRJRklFUl9DSEVDSyIsImlzVmFsaWRJZGVudGlmaWVyIiwiY2hhciIsImdldEFzc2lnbm1lbnRFeHByZXNzaW9uIiwiYXNzaWdubWVudCIsIm1lcmdlQXNzaWdubWVudHMiLCJhc3NpZ25tZW50cyIsIm5ld0Fzc2lnbm1lbnRzIiwicHJldiIsInJlc29sdmVBc3NpZ25tZW50cyIsIm1lcmdlZCIsIk5VTExfQ09OU1RSVUNUT1IiLCJTRVRfQ09OU1RSVUNUT1IiLCJNQVBfQ09OU1RSVUNUT1IiLCJQUk9NSVNFX1JFU09MVkUiLCJQUk9NSVNFX1JFSkVDVCIsIk9CSkVDVF9GTEFHX0NPTlNUUlVDVE9SIiwiQmFzZVNlcmlhbGl6ZXJDb250ZXh0Iiwic3RhY2siLCJjcmVhdGVGdW5jdGlvbiIsInBhcmFtZXRlcnMiLCJib2R5Iiwiam9pbmVkIiwiam9pbiIsImNyZWF0ZUVmZmVjdGZ1bEZ1bmN0aW9uIiwicHVzaE9iamVjdEZsYWciLCJnZXRSZWZQYXJhbSIsInJlc29sdmVGbGFncyIsInJlc29sdmVQYXRjaGVzIiwiY3JlYXRlQXNzaWdubWVudCIsImNyZWF0ZUFkZEFzc2lnbm1lbnQiLCJjcmVhdGVTZXRBc3NpZ25tZW50IiwiY3JlYXRlRGVsZXRlQXNzaWdubWVudCIsImNyZWF0ZUFycmF5QXNzaWduIiwiY3JlYXRlT2JqZWN0QXNzaWduIiwiaXNJbmRleGVkVmFsdWVJblN0YWNrIiwiaW5jbHVkZXMiLCJzZXJpYWxpemVSZWZlcmVuY2UiLCJzZXJpYWxpemVBcnJheUl0ZW0iLCJzZXJpYWxpemUiLCJzZXJpYWxpemVBcnJheSIsImxpc3QiLCJpc0hvbGV5IiwicG9wIiwic2VyaWFsaXplUHJvcGVydHkiLCJ2YWwiLCJjaGVjayIsImlzSWRlbnRpZmllciIsInJlZlBhcmFtIiwic2VyaWFsaXplUHJvcGVydGllcyIsInNlcmlhbGl6ZU9iamVjdCIsInNlcmlhbGl6ZVdpdGhPYmplY3RBc3NpZ24iLCJzZXJpYWxpemVkIiwic2VyaWFsaXplU3RyaW5nS2V5QXNzaWdubWVudCIsIm1haW5Bc3NpZ25tZW50cyIsInBhcmVudEFzc2lnbm1lbnQiLCJzZXJpYWxpemVBc3NpZ25tZW50IiwicGFyZW50Iiwic2VyaWFsaXplQXNzaWdubWVudHMiLCJzZXJpYWxpemVEaWN0aW9uYXJ5IiwiaW5pdCIsInNlcmlhbGl6ZU51bGxDb25zdHJ1Y3RvciIsInNlcmlhbGl6ZURhdGUiLCJzZXJpYWxpemVSZWdFeHAiLCJzZXJpYWxpemVTZXRJdGVtIiwic2VyaWFsaXplU2V0Iiwic2VyaWFsaXplTWFwRW50cnkiLCJzZW50aW5lbCIsImtleVJlZiIsInZhbHVlUmVmIiwic2VyaWFsaXplTWFwIiwic2VudGluZWxJZCIsInNlcmlhbGl6ZUFycmF5QnVmZmVyIiwic2VyaWFsaXplVHlwZWRBcnJheSIsInNlcmlhbGl6ZURhdGFWaWV3Iiwic2VyaWFsaXplQWdncmVnYXRlRXJyb3IiLCJzZXJpYWxpemVFcnJvciIsInNlcmlhbGl6ZVByb21pc2UiLCJmdWxmaWxsZWQiLCJwcm9taXNlQ29uc3RydWN0b3IiLCJzZXJpYWxpemVXZWxsS25vd25TeW1ib2wiLCJzZXJpYWxpemVCb3hlZCIsInNlcmlhbGl6ZVBsdWdpbiIsImdldENvbnN0cnVjdG9yIiwic2VyaWFsaXplUHJvbWlzZUNvbnN0cnVjdG9yIiwic2VyaWFsaXplUHJvbWlzZVJlc29sdmUiLCJzZXJpYWxpemVQcm9taXNlUmVqZWN0Iiwic2VyaWFsaXplU3BlY2lhbFJlZmVyZW5jZVZhbHVlIiwic2VyaWFsaXplU3BlY2lhbFJlZmVyZW5jZSIsInNlcmlhbGl6ZUl0ZXJhdG9yRmFjdG9yeSIsImluaXRpYWxpemVkIiwic2VyaWFsaXplSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2UiLCJzZXJpYWxpemVBc3luY0l0ZXJhdG9yRmFjdG9yeSIsInNlcmlhbGl6ZUFzeW5jSXRlcmF0b3JGYWN0b3J5SW5zdGFuY2UiLCJzZXJpYWxpemVTdHJlYW1Db25zdHJ1Y3RvciIsInNlcmlhbGl6ZVN0cmVhbU5leHQiLCJzZXJpYWxpemVTdHJlYW1UaHJvdyIsInNlcmlhbGl6ZVN0cmVhbVJldHVybiIsIlJFRl9TVEFSVF9DSEFSUyIsIlJFRl9TVEFSVF9DSEFSU19MRU4iLCJSRUZfQ0hBUlMiLCJSRUZfQ0hBUlNfTEVOIiwiZ2V0SWRlbnRpZmllciIsIm1vZCIsIlZhbmlsbGFTZXJpYWxpemVyQ29udGV4dCIsInZhbGlkIiwidmFycyIsImFjdHVhbEluZGV4IiwiaWRlbnRpZmllciIsInNlcmlhbGl6ZVRvcCIsInRyZWUiLCJwYXRjaGVzIiwic3RhcnRzV2l0aCIsIkJhc2VTeW5jUGFyc2VyQ29udGV4dCIsInN5bmMiLCJfY3VycmVudCIsIlN5bmNQYXJzZXJDb250ZXh0IiwiY3R4Iiwic2VyaWFsIiwic2VyaWFsaXplQXN5bmMiLCJldmFsIiwidG9KU09OIiwiZnJvbSIsInRvSlNPTkFzeW5jIiwiY29tcGlsZUpTT04iLCJmcm9tSlNPTiIsIkNyb3NzQXN5bmNQYXJzZXJDb250ZXh0IiwiQ3Jvc3NEZXNlcmlhbGl6ZXJDb250ZXh0IiwiQ3Jvc3NTZXJpYWxpemVyQ29udGV4dCIsInNjb3BlSWQiLCJwYXJhbXMiLCJhcmdzIiwiQmFzZVN0cmVhbVBhcnNlckNvbnRleHQiLCJpbml0aWFsIiwib25QYXJzZUNhbGxiYWNrIiwib25QYXJzZSIsIm9uRXJyb3JDYWxsYmFjayIsIm9uRXJyb3IiLCJvbkRvbmVDYWxsYmFjayIsIm9uRG9uZSIsIm9uUGFyc2VJbnRlcm5hbCIsImZsdXNoIiwicHVzaFBlbmRpbmdTdGF0ZSIsInBvcFBlbmRpbmdTdGF0ZSIsInBhcnNlV2l0aEVycm9yIiwiZXJyIiwic3RhcnQiLCJkZXN0cm95IiwiaXNBbGl2ZSIsIkNyb3NzU3RyZWFtUGFyc2VyQ29udGV4dCIsIkNyb3NzU3luY1BhcnNlckNvbnRleHQiLCJjcm9zc1NlcmlhbGl6ZSIsImNyb3NzU2VyaWFsaXplQXN5bmMiLCJ0b0Nyb3NzSlNPTiIsInRvQ3Jvc3NKU09OQXN5bmMiLCJjcm9zc1NlcmlhbGl6ZVN0cmVhbSIsIm9uU2VyaWFsaXplIiwidG9Dcm9zc0pTT05TdHJlYW0iLCJmcm9tQ3Jvc3NKU09OIiwiU2VyaWFsaXplciIsImZsdXNoZWQiLCJjbGVhbnVwcyIsImlkcyIsIndyaXRlIiwib25EYXRhIiwiZ2xvYmFsSWRlbnRpZmllciIsImdldE5leHRJRCIsIm5ld0lEIiwiY2xvc2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/seroval/dist/esm/development/index.mjs\n");

/***/ })

};
;